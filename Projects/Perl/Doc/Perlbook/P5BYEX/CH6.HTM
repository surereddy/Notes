<html>

<head>

<title>Chapter 6 -- Statements</title>



<meta>

</head>

<body TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">

<h1><font SIZE="6" COLOR="#FF0000">Chapter&nbsp;6</font></h1>

<h1><font SIZE="6" COLOR="#FF0000">Statements</font></h1>

<hr>

<p>

<center><b><font SIZE="5">CONTENTS</font></b></center>

<ul>

<li><a HREF="#UnderstandingExpressions">

Understanding Expressions</a>

<li><a HREF="#StatementBlocks">

Statement Blocks</a>

<li><a HREF="#StatementBlocksandLocalVariables">

Statement Blocks and Local Variables</a>

<li><a HREF="#StatementTypes">

Statement Types</a>

<ul>

<li><a HREF="#ExampleUsingtheifModifier">

Example: Using the if Modifier</a>

<li><a HREF="#ExampleUsingtheunlessModifier">

Example: Using the unless Modifier</a>

<li><a HREF="#ExampleUsingtheuntilModifier">

Example: Using the until Modifier</a>

<li><a HREF="#ExampleUsingthewhileModifier">

Example: Using the while Modifier</a>

</ul>

<li><a HREF="#Summary">

Summary</a>

<li><a HREF="#ReviewQuestions">

Review Questions</a>

<li><a HREF="#ReviewExercises">

Review Exercises</a>

</ul>



<hr>

<p>

If you look at a Perl program from a very high level, it is made

of statements. <i>Statements</i> are a complete unit of instruction

for the computer to process. The computer executes each statement

it sees-in sequeNCe-until a jump or braNCh is processed.

<p>

Statements can be very simple or very complex. The simplest statement

is this

<blockquote>

<pre>

123;

</pre>

</blockquote>

<p>

which is a numeric literal followed by a semicolon. The semicolon

is very important. It tells Perl that the statement is complete.

A more complicated statement might be

<blockquote>

<pre>

$bookSize = ($numOfPages &gt;= 1200 ? &quot;Large&quot; : &quot;Normal&quot;);

</pre>

</blockquote>

<p>

which says if the number of pages is 1,200 or greater, then assign

<tt>&quot;Large&quot;</tt> to <tt>$bookSize;</tt>

otherwise, assign <tt>&quot;Normal&quot;</tt>

to <tt>$bookSize</tt>.

<p>

In Perl, every statement has a value. In the first example, the

value of the statement is <tt>123</tt>.

In the second example, the value of the statement could be either

<tt>&quot;Large&quot;</tt> or <tt>&quot;Normal&quot;</tt>

depending on the value of <tt>$numOfPages</tt>.

The last value that is evaluated becomes the value for the statement.

<p>

Like human language in which you put statements together from

parts of speech-nouns, verbs, and modifiers-you can also break

down Perl statements into parts. The parts are the literals, variables,

and fuNCtions you have already seen in the earlier chapters of

this book.

<p>

Human language phrases-like, &quot;walk the dog&quot;-also have

their counterparts in computer languages. The computer equivalent

is an expression. <i>Expressions</i> are a sequeNCe of literals,

variables, and fuNCtions connected by one or more operators that

evaluate to a single value-scalar or array. An expression can

be promoted to a statement by adding a semicolon. This was done

for the first example earlier. Simply adding a semicolon to the

literal made it into a statement that Perl could execute.

<p>

Expressions may have side effects, also. FuNCtions that are called

can do things that are not immediately obvious (like setting global

variables) or the pre- and post-iNCrement operators can be used

to change a variable's value.

<p>

Let's take a short diversion from our main discussion about statements

and look at expressions in isolation. Then we'll return to statements

to talk about statement blocks and statement modifiers.

<h2><a NAME="UnderstandingExpressions"><font SIZE="5" COLOR="#FF0000">

Understanding Expressions</font></a></h2>

<p>

You can break the universe of expressions up into four types:

<ul>

<li>Simple Expressions

<li>Simple Expressions with Side Effects

<li>Simple Expression with Operators

<li>Complex Expressions

</ul>

<p>

<i>Simple expressions </i>consist of a single literal or variable.

Table 6.1 shows some examples. Not much can be said about these

expressions because they are so basic. It might be a matter for

some debate whether or not an array or associative array variable

can be considered a simple expression. My vote is yes, they can.

The confusion might arise because of the notation used to describe

an array or associative array. For example, an array can be specified

as <tt>(12, 13, 14)</tt>. You can

see this specification as three literal values surrounded by parentheses

or one array. I choose to see one array which fits the definition

of a simple expression-a single variable.<br>

<p>

<center><b>Table 6.1&nbsp;&nbsp;The Simplest Perl Expressions</b></center>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td WIDTH="211"><i>Simple Expression</i></td><td WIDTH="192"><i>Description</i>

</td></tr>

<tr><td WIDTH="211"><tt>123</tt></td>

<td WIDTH="192">Integer literal</td></tr>

<tr><td WIDTH="211"><tt>Chocolate is great!</tt>

</td><td WIDTH="192">String literal</td></tr>

<tr><td WIDTH="211"><tt>(1, 2, 3)</tt>

</td><td WIDTH="192">Array literal</td></tr>

<tr><td WIDTH="211"><tt>$numPages</tt>

</td><td WIDTH="192">Variable</td></tr>

</table>

</center>

<p>

<i>Simple expressions with side effects </i>are the next type

of expression we'll examine. A side effect is when a variable's

value is changed by the expression. Side effects can be caused

using any of the unary operators: <tt>+</tt>,

-, <tt>++</tt>, --. These operators

have the effect of changing the value of a variable just by the

evaluation of the expression.No other Perl operators have this

effect-other than the assignment operators, of course. FuNCtion

calls can also have side effects- especially if local variables

were not used and changes were made to global variables. Table

6.2 shows examples of different side effects.<br>

<p>

<center><b>Table 6.2&nbsp;&nbsp;Perl Expressions with Side Effects</b></center>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td WIDTH="169"><i>Simple Expression</i></td><td WIDTH="306"><i>Description</i>

</td></tr>

<tr><td WIDTH="169"><tt>$numPages++</tt>

</td><td WIDTH="306">INCrements a variable</td></tr>

<tr><td WIDTH="169"><tt>++$numPages</tt>

</td><td WIDTH="306">INCrements a variable</td></tr>

<tr><td WIDTH="169"><tt>chop</tt>(<tt>$firstVar</tt>)

</td><td WIDTH="306">Changes the value of <tt>$firstVar</tt>-a global variable

</td></tr>

<tr><td WIDTH="169"><tt>sub</tt> <tt>firstsub</tt> {    <tt>$firstVar</tt> = 10; }

</td><td WIDTH="306">Also changes <tt>$firstVar</tt>

</td></tr>

</table>

</center>

<p>

<p>

Note that when the expressions <tt>$numPages++</tt>

and <tt>++$numPages</tt> are evaluated,

they have the same side effect even though they evaluate to different

values. The first evaluates to <tt>$numPages</tt>,

and the second evaluates to <tt>$numPages

+ 1</tt>. The side effect is to iNCrement <tt>$numPages</tt>

by 1.

<p>

The <tt>firstsub()</tt> fuNCtion shown

in Table 6.2 changes the value of the <tt>$firstVar</tt>

variable, which has a global scope. This can also be considered

a side effect, especially if <tt>$firstVar</tt>

should have been declared as a local variable.

<p>

<i>Simple expressions with operators</i> are expressions that

iNClude one operator and two operands. Any of Perl's binary operators

can be used in this type of expression. Table 6.3 shows a few

examples of this type of expression.<br>

<p>

<center><b>Table 6.3&nbsp;&nbsp;Perl Expressions with Operators</b></center>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td WIDTH="181"><i>Simple Expression</i></td><td WIDTH="294"><i>Description</i>

</td></tr>

<tr><td WIDTH="181"><tt>10 + $firstVar</tt>

</td><td WIDTH="294">Adds ten to <tt>$firstVar</tt>

</td></tr>

<tr><td WIDTH="181"><tt>$firstVar . &quot;AAA&quot;</tt>

</td><td WIDTH="294">CoNCatenates <tt>$firstVar</tt> and <tt>&quot;AAA&quot;</tt>

</td></tr>

<tr><td WIDTH="181"><tt>&quot;ABC&quot; x 5</tt>

</td><td WIDTH="294">Repeats <tt>&quot;ABC&quot;</tt> five times

</td></tr>

</table>

</center>

<p>

<p>

Another way of viewing <tt>10 +</tt>

<tt>$firstVar</tt> is as <i>simple

expression plus simple expression</i>. Thus, you can say that

a simple expression with an operator is defined as two simple

expressions connected by an operator. When computer programmers

define something in terms of itself, we call it <i>recursion</i>.

Each time a recursion is done, the expression is broken down into

simpler and simpler pieces until the computer can evaluate the

pieces properly.

<p>

A <i>complex expression</i> can use any number of literals, variables,

operators, and fuNCtions in any sequeNCe. Table 6.4 shows some

complex expressions.<br>

<p>

<center><b>Table 6.4&nbsp;&nbsp;Complex Perl Expressions</b></center><p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><i>Complex Expression</i></td></tr>

<tr><td>

<blockquote>

<tt>(10 + 2) + 20 / (5 ** 2)<br>

20 - (($numPages - 1) * 2)<br>

(($numPages++ / numChapters) * (1.5 / log(10)) + 6)</tt>

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

There is an infinite number of expressions you can form with the

Perl operator set. You can get extremely complicated in your use

of operators and fuNCtions if you are not careful. I prefer to

keep the expressions short, easy to document, and easy to maintain.

<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Tip</b></td></tr>

<tr><td>

<blockquote>

Sometimes it is difficult to tell whether you have enough closing parentheses for all of your opening parentheses. Starting at the left, count each open parenthesis, and when you find a closing parenthesis, subtract one from the total. If you reach zero 
at the end of the expression, the parentheses are balaNCed.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

Now we'll go back to looking at statements.

<h2><a NAME="StatementBlocks"><font SIZE="5" COLOR="#FF0000">

Statement Blocks</font></a></h2>

<p>

A <i>statement block </i>is a group of statements surrounded by

curly braces. Perl views a statement block as one statement. The

last statement executed becomes the value of the statement block.

This means that any place you can use a single statement-like

the <tt>map</tt> fuNCtion-you can

use a statement block. You can also create variables that are

local to a statement block. So, without going to the trouble of

creating a fuNCtion, you can still isolate one bit of code from

another.

<p>

Here is how I frequently use a statement block:

<blockquote>

<pre>

$firstVar = 10;

{

    $secondVar &gt;&gt;= 2;

    $secondVar++;

}

$thirdVar = 20;

</pre>

</blockquote>

<p>

The statement block serves to emphasize that the inner code is

set apart from the rest of the program. In this case, the initialization

of <tt>$secondVar</tt> is a bit more

complex than the other variables. Using a statement block does

not change the program execution in any way;  it simply is a visual

device to mark sections of code and a way to create local variables.

<h2><a NAME="StatementBlocksandLocalVariables"><font SIZE="5" COLOR="#FF0000">

Statement Blocks and Local Variables</font></a></h2>

<p>

Normally, it's a good idea to place all of your variable initialization

at the top of a program or fuNCtion. However, if you are maintaining

some existing code, you may want to use a statement block and

local variables to minimize the impact of your changes on the

rest of the code-especially if you have just been handed responsibility

for a program that someone else has written.

<p>

You can use the <tt>my()</tt> fuNCtion

to create variables whose scope is limited to the statement block.

This technique is very useful for temporary variables that won't

be needed elsewhere in your program. For example, you might have

a complex statement that you'd like to break into smaller ones

so that it's more understandable. Or you might want to insert

some <tt>print</tt> statements to

help debug a piece of code and need some temporary variables to

accommodate the <tt>print</tt> statement.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Assign ten to </i><tt><i>$firstVar</i></tt><i>.

<br>

Start the statement block.<br>

Create a local version of </i><tt><i>$firstVar</i></tt><i>

with a value of </i><tt><i>A</i></tt><i>.

<br>

Print </i><tt><i>$firstVar</i></tt><i>

repeated five times.<br>

End the statement block.<br>

Print the global </i><tt><i>$firstVar</i></tt><i>.</i>

</blockquote>

<blockquote>

<pre>

$firstVar = 10;

{

   my($firstVar) = &quot;A&quot;;

   print $firstVar x 5 . &quot;\n&quot;;



}

print(&quot;firstVar = $firstVar\n&quot;);

</pre>

</blockquote>

<p>

This program displays:

<blockquote>

<pre>

AAAAA

firstVar = 10

</pre>

</blockquote>

<p>

You can see that the value of <tt>$firstVar</tt>

has been uNChanged by the statement block even though a variable

called <tt>$firstVar</tt> is used

inside it. This shows that the variable used inside the statement

block does indeed have a local scope.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Tip</b></td></tr>

<tr><td>

<blockquote>

Statement blocks are also good to use when you temporarily need to send debugging output to a file. Then, when all the bugs have been found and the need for debugging is over, you can remove the statement block quickly and easily because all the code is 
in one spot.</blockquote>



</td></tr>

</table>

</center>

<p>

<h2><a NAME="StatementTypes"><font SIZE="5" COLOR="#FF0000">

Statement Types</font></a></h2>

<p>

Just as there were several types of expressions, there are also

several types of statements. Table 6.5 lists seven different types

of statements.<br>

<p>

<center><b>Table 6.5&nbsp;&nbsp;Perl Statement Types</b></center>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td WIDTH="183"><i>Statement Type</i></td><td WIDTH="407"><i>Description</i>

</td></tr>

<tr><td WIDTH="183">No-action statements</td><td WIDTH="407">These statements evaluate a value but perform no actions.

</td></tr>

<tr><td WIDTH="183">Action statements</td><td WIDTH="407">These statements perform some action.

</td></tr>

<tr><td WIDTH="183">Assignment statements</td><td WIDTH="407">These statements assign a value to one or more variables. They are discussed, along with the assignment operator, in <a HREF="ch4.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch4.htm">Chapter 4</a> &quot;Operators.&quot;

</td></tr>

<tr><td WIDTH="183">Decision statements</td><td WIDTH="407">These statements allow you to test a condition and choose among one or more actions. Decision statements are discussed in <a HREF="ch7.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch7.htm">Chapter 7</a> &quot;Control Statements.&quot;

</td></tr>

<tr><td WIDTH="183">Jump statements</td><td WIDTH="407">These statements let you uNConditionally change the program flow to another point in your code. For instaNCe, you could use the <tt>redo</tt> keyword to send your program flow back to the beginning of a 
statement block. Jump statements are discussed in <a HREF="ch7.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch7.htm">Chapter 7</a> &quot;Control Statements.&quot;

</td></tr>

<tr><td WIDTH="183">Loop statements</td><td WIDTH="407">These statements let you perform a series of statements repeatedly while some condition is true or until some condition is true. Loop statements are discussed in <a HREF="ch7.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch7.htm">Chapter 7</a> 
&quot;Control Statements.&quot;

</td></tr>

<tr><td WIDTH="183">Modified Statements</td><td WIDTH="407">These statements let you use the <tt>if</tt>, <tt>unless</tt>, <tt>until</tt>, and <tt>while</tt> keywords to change the behavior of a statement.

</td></tr>

</table>

</center>

<p>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

A <i>keyword</i> is a word that is reserved for use by Perl. These words (<tt>if</tt>, <tt>elsif</tt>, <tt>else</tt>, <tt>while</tt>, <tt>unless</tt>, <tt>until</tt>, <tt>for</tt>, <tt>foreach</tt>, <tt>last</tt>, <tt>next</tt>, <tt>redo</tt>, and 
<tt>continue</tt>) are integral to the language and provide you with the ability to control program flow.

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

<i>No-action statements</i> are evaluated by Perl and have a value

but perform no actions. For instaNCe, the Perl statement <tt>10

+ 20</tt>; has a value of 30, but because no variables

were changed, no work was done. The value of 20 is not stored

anywhere, and it is quickly forgotten when the next statement

is seen.

<p>

What good is a <i>no-action statement </i>if no work is done?

A lot of Perl programmers use these simple statements as return

values in fuNCtions. For instaNCe:

<blockquote>

<pre>

sub firstSub {

    doSomething();

    condition == true ? &quot;Success&quot; : &quot;Failure&quot;;

}

</pre>

</blockquote>

<p>

Because Perl returns the value of the last evaluated statement

when leaving a fuNCtion, you can use no-action statements to let

Perl know what value should be returned to the main program. Notice

that even though the ternary operator was used, because there

are no fuNCtion calls or unary operators, no work can be done.

<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

I still like to use the <tt>return()</tt> fuNCtion to explicitly identify the return values. The previous example looks like this when using the <tt>return()</tt> fuNCtion:

</blockquote>



</td></tr>

</table>

</center>

<p>

<blockquote>

<pre>

sub firstSub {

    doSomething();

    return(condition == true ? &quot;Success&quot; : &quot;Failure&quot;);

}

</pre>

</blockquote>

<p>

<i>Action statements</i> use expressions to perform some task.

They can iNCrement or decrement a variable and call a fuNCtion.

<p>

<i>Modified statements</i> use expressions in conjuNCtion with

a modifying keyword to perform some action. There are four modifying

keywords: <tt>if</tt>, <tt>unless</tt>,

<tt>until</tt>, and <tt>while</tt>.

The basic syntax of a modified statement is

<blockquote>

<pre>

EXPRESSION modifier (CONDITION);

</pre>

</blockquote>

<p>

Let's look at some examples of modified statements.

<h3><a NAME="ExampleUsingtheifModifier">

Example: Using the if Modifier</a></h3>

<p>

The <tt>if</tt> modifier tells Perl

that the expression should be evaluated only if a given condition

is true. The basic syntax of a modified statement with the <tt>if</tt>

modifier is

<blockquote>

<pre>

EXPRESSION if (CONDITION);

</pre>

</blockquote>

<p>

This is a compact way of saying

<blockquote>

<pre>

if (CONDITION) {

    EXPRESSION;

}

</pre>

</blockquote>

<p>

Let's prove that the <tt>if</tt> modifier

works. Here's an example showing that the <tt>if</tt>

modifier can prevent the evaluation of an expression.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Initialize the </i><tt><i>$firstVar</i></tt><i>

and </i><tt><i>$secondVar</i></tt><i>

variables to 20.<br>

INCrement </i><tt><i>$firstVar</i></tt><i>

if and only if </i><tt><i>$secondVar</i></tt><i>

is equal to 10.<br>

Print the values of </i><tt><i>$firstVar</i></tt><i>

and </i><tt><i>$secondVar</i></tt><i>.</i>

</blockquote>

<blockquote>

<pre>

$firstVar  = 20;

$secondVar = 20;



$firstVar++ if ($secondVar == 10);



print(&quot;firstVar  = $firstVar\n&quot;);

print(&quot;secondVar = $secondVar\n&quot;);

</pre>

</blockquote>

<p>

This program prints:

<blockquote>

<pre>

firstVar  = 20

secondVar = 20

</pre>

</blockquote>

<p>

The program doesn't iNCrement <tt>$firstVar</tt>

because the value of <tt>$secondVar</tt>

is 20 at the time the condition is evaluated. If you changed the

10 to a 20 in the condition, Perl would iNCrement <tt>$firstVar</tt>.

<p>

You can find out about the <tt>if</tt>

statement-as opposed to the <tt>if</tt>

modifier-in <a HREF="ch7.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch7.htm">Chapter 7</a> &quot;Control Statements.&quot;<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

The condition expression can be as complex as you'd like. However, I believe that one of the goals of statement modifiers is to make programs easier to read and understand. Therefore, I use modifiers only with simple conditions. If complex conditions need 
to be met before an expression should be evaluated, using the <tt>if</tt> keyword is probably a better idea.

</blockquote>



</td></tr>

</table>

</center>

<p>

<h3><a NAME="ExampleUsingtheunlessModifier">

Example: Using the unless Modifier</a></h3>

<p>

The <tt>unless</tt> modifier is the

opposite of the <tt>if</tt> modifier.

This modifier evaluates an expression unless a condition is true.

The basic syntax of a modified statement with the <tt>unless</tt>

modifier is

<blockquote>

<pre>

EXPRESSION unless (CONDITION);

</pre>

</blockquote>

<p>

This is a compact way of saying

<blockquote>

<pre>

if (! CONDITION) {

    EXPRESSION;

}

</pre>

</blockquote>

<p>

This modifier helps to keep program code clearly understandable

because you don't have to use the logical <tt>not</tt>

operator to change the value of a condition so you can evaluate

an expression. Let's look back at the example from a moment ago.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Initialize the </i><tt><i>$firstVar</i></tt><i>

and </i><tt><i>$secondVar</i></tt><i>

variables to 20.<br>

INCrement </i><tt><i>$firstVar</i></tt><i>

unless </i><tt><i>$secondVar</i></tt><i>

is equal to 10.<br>

Print the values of </i><tt><i>$firstVar</i></tt><i>

and </i><tt><i>$secondVar</i></tt><i>.</i>

</blockquote>

<blockquote>

<pre>

$firstVar  = 20;

$secondVar = 20;



$firstVar++ unless ($secondVar == 10);



print(&quot;firstVar  = $firstVar\n&quot;);

print(&quot;secondVar = $secondVar\n&quot;);

</pre>

</blockquote>

<p>

This program prints:

<blockquote>

<pre>

firstVar  = 21

secondVar = 20

</pre>

</blockquote>

<p>

If you were limited to using only the <tt>if</tt>

modifier, the modified statement would read

<blockquote>

<pre>

$firstVar++ if ($secondVar != 10);

</pre>

</blockquote>

<p>

The <tt>unless</tt> modifier is more

direct. All things being equal, the coNCept of <tt>$secondVar</tt>

being equal to 10 is easier to grasp than the coNCept of <tt>$secondVar</tt>

not being equal to 10. Of course, this is a trivial example. Let's

look at something more substantial before we move on.

<p>

One of the drawbacks of associative arrays is that they quietly

redefine the value of any key when that key is assigned a new

value, thereby losing the old value. If you are reading from a

list of key-value pairs, this might not be the behavior you need.

The <tt>unless</tt> modifier can be

used to prevent element assignment if the key has already been

used. Listing 6.1 shows the <tt>unless</tt>

modifier used in a program.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Call the </i><tt><i>assignElement()</i></tt><i>

fuNCtion to create two elements in the  </i><tt><i>@array</i></tt><i>

associative array.<br>

Call the </i><tt><i>printArray()</i></tt><i>

fuNCtion.<br>

Try to redefine the value associated with the &quot;A&quot; key

by calling </i><tt><i>assignElement()</i></tt><i>.

<br>

Print the array again to verify that no elements have changed.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 6.1&nbsp;&nbsp;06LST01.PL-Using the <font FACE="BI Helvetica BoldOblique">unless</font>

Modifier to Control Array Element Assignmen</b>t<br>

</blockquote>

<blockquote>

<pre>

assignElement(&quot;A&quot;, &quot;AAAA&quot;);

assignElement(&quot;B&quot;, &quot;BBBB&quot;);

printArray();

assignElement(&quot;A&quot;, &quot;ZZZZ&quot;);

printArray();





sub assignElement {

    my($key, $value) = @_;



    $array{$key} = $value unless defined($array{$key});

}



sub printArray {

    while (($key, $value) = each(%array)) {

        print(&quot;$key = $value\n&quot;);

    }

    print(&quot;\n&quot;);

}

</pre>

</blockquote>

<hr>

<p>

This program displays:

<blockquote>

<pre>

A = AAAA

B = BBBB



A = AAAA

B = BBBB

</pre>

</blockquote>

<p>

These lines of code should look a little familiar to you. The

<tt>while</tt> loop in the <tt>printArray()</tt>

fuNCtion was used in a <a HREF="ch5.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch5.htm">Chapter 5</a>example. The <tt>assignElement()</tt>

fuNCtion will make an assignment unless a key-value pair with

the same key already exists. In that case, the assignment statement

is bypassed.

<h3><a NAME="ExampleUsingtheuntilModifier">

Example: Using the until Modifier</a></h3>

<p>

The <tt>until</tt> modifier is a little

more complex than the <tt>if</tt>

or <tt>unless</tt> modifiers. It repeatedly

evaluates the expression until the condition becomes true. The

basic syntax of a modified statement with the <tt>until</tt>

modifier is

<blockquote>

<pre>

EXPRESSION until (CONDITION);

</pre>

</blockquote>

<p>

This is a compact way of saying

<blockquote>

<pre>

until (CONDITION) {

    EXPRESSION;

}

</pre>

</blockquote>

<p>

The expression is evaluated only while the condition is false.

If the condition is true when the statement is eNCountered, the

expression will never be evaluated. The following example proves

this:

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Initialize </i><tt><i>$firstVar</i></tt><i>

to 10.<br>

Repeatedly evaluate </i><tt><i>$firstVar++</i></tt><i>

until the condition </i><tt><i>$firstVar

&gt; 2</i></tt><i> is true.<br>

Print the value of </i><tt><i>$firstVar</i></tt><i>.</i>

</blockquote>

<blockquote>

<pre>

$firstVar = 10;

$firstVar++ until ($firstVar &gt; 2);



print(&quot;firstVar = $firstVar\n&quot;);

</pre>

</blockquote>

<p>

This program displays:

<blockquote>

<pre>

firstVar = 10

</pre>

</blockquote>

<p>

This shows that the expression <tt>$firstVar++</tt>

was never executed because the condition was true the first time

it was evaluated. If it had been executed, the value of <tt>$firstVar</tt>

would have been 11 when printed. In this case, the <tt>until</tt>

modifier worked exactly like the <tt>unless</tt>

modifier.

<p>

However, when the condition is false for the first evaluation,

Perl executes the expression repeatedly until the condition is

true. Here is an example:

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Initialize </i><tt><i>$firstVar</i></tt><i>

to 10.<br>

Repeatedly evaluate </i><tt><i>$firstVar++</i></tt><i>

until the condition </i><tt><i>$firstVar

&gt; 20</i></tt><i> is true.<br>

Print the value of </i><tt><i>$firstVar</i></tt><i>.</i>

</blockquote>

<blockquote>

<pre>

$firstVar = 10;

$firstVar++ until ($firstVar &gt; 20);



print(&quot;firstVar = $firstVar\n&quot;);

</pre>

</blockquote>

<p>

This program displays:

<blockquote>

<pre>

firstVar = 21

</pre>

</blockquote>

<p>

In this case, the <tt>$firstVar++</tt>

expression is executed 11 times. Each execution of the expression

iNCrements the value of <tt>$firstVar</tt>.

When <tt>$firstVar</tt> is equal to

21, the statement ends because 21 is greater than 20, which means

that the condition is true.

<p>

You can find out about the <tt>until</tt>

statement-as opposed to the <tt>until</tt>

modifier-in <a HREF="ch7.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch7.htm">Chapter 7</a> &quot;Control Statements.&quot;

<h3><a NAME="ExampleUsingthewhileModifier">

Example: Using the while Modifier</a></h3>

<p>

The <tt>while</tt> modifier is the

opposite of the <tt>until</tt> modifier.

It repeatedly evaluates the expression while the condition is

true. When the condition becomes false, the statement ends. The

basic syntax of a modified statement with the <tt>while</tt>

modifier is

<blockquote>

<pre>

EXPRESSION while (CONDITION);

</pre>

</blockquote>

<p>

This is a compact way of saying

<blockquote>

<pre>

while (CONDITION) {

    EXPRESSION;

}

</pre>

</blockquote>

<p>

The expression is evaluated only while the condition is true.

If the condition is false when the statement is eNCountered, the

expression will never be evaluated. Here is an example using the

<tt>while</tt> modifier.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Initialize </i><tt><i>$firstVar</i></tt><i>

to 10.<br>

Repeatedly evaluate </i><tt><i>$firstVar++</i></tt><i>

while the condition </i><tt><i>$firstVar

&lt; 20</i></tt><i> is true.<br>

Print the value of </i><tt><i>$firstVar</i></tt><i>.</i>

</blockquote>

<blockquote>

<pre>

$firstVar = 10;

$firstVar++ while ($firstVar &lt; 20);



print(&quot;firstVar = $firstVar\n&quot;);

</pre>

</blockquote>

<p>

This program displays:

<blockquote>

<pre>

firstVar = 21

</pre>

</blockquote>

<p>

You can compare this example directly to the last example given

for the <tt>until</tt> modifier. Because

the <tt>until</tt> modifier is the

opposite of the <tt>while</tt> modifier,

the operators in the conditions are also opposite in nature.

<p>

You can find out about the <tt>while</tt>

statement-as opposed to the <tt>while</tt>

modifier-in <a HREF="ch7.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch7.htm">Chapter 7</a> &quot;Control Statements.&quot;

<h2><a NAME="Summary"><font SIZE="5" COLOR="#FF0000">

Summary</font></a></h2>

<p>

This chapter discussed Perl statements and how they are built

from expressions. You read about four types of expressions: simple,

simple with side effects, simple with operators, and complex.

<p>

Next, you read about statement blocks. These program constructs

are good to logically isolate one block of statements from the

main program flow. You can also use statement blocks and the <tt>my()</tt>

fuNCtion to create local variables. This is mainly done for debugging

reasons or to make small program changes that are guaranteed not

to affect other portions of the program.

<p>

Then, seven types of statements were mentioned: no-action, action,

assignment, decision, jump, loop, and modified. This chapter described

no-action, action, and modified statements. Assignment statements

were mentioned in <a HREF="ch3.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch3.htm">Chapter 3</a>&quot;Variables&quot; and again in

<a HREF="ch4.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch4.htm">Chapter 4</a> &quot;Operators.&quot; Decision, jump, and loop statements

are covered in <a HREF="ch7.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch7.htm">Chapter 7</a> &quot;Control Statements.&quot;

<p>

Modified statements use the <tt>if</tt>,

<tt>unless</tt>, <tt>until</tt>,

and <tt>while</tt> keywords to affect

the evaluation of an expression. The <tt>if</tt>

keyword evaluates an expression if a given condition is true.

The <tt>unless</tt> keyword does the

opposite: the expression is evaluated if a given condition is

false. The <tt>until</tt> keyword

repeatedly evaluates an expression until the condition is true.

The <tt>while</tt> keyword is the

opposite of until so that it repeatedly evaluates an expression

until the condition is false.

<p>

The next chapter, &quot;Control Statements,&quot; explores the

<tt>decision</tt>, <tt>jump</tt>,

and <tt>loop</tt> statements in detail.

<h2><a NAME="ReviewQuestions"><font SIZE="5" COLOR="#FF0000">

Review Questions</font></a></h2>

<p>

Answers to Review Questions are in Appendix A.

<ol>

<li>What is an expression?

<li>What is a statement?

<li>What are the four statement modifiers?

<li>What are two uses for statement blocks?

<li>What can non-action statements be used for?

<li>How is the <tt>if</tt> modifier

different from the <tt>unless</tt>

modifier?

<li>What will the following code display?

</ol>

<blockquote>

<pre>

$firstVar = 10;

$secondVar = 20;



$firstVar += $secondVar++ if ($firstVar &gt; 10);



print(&quot;firstVar = $firstVar\n&quot;);

print(&quot;firstVar = $secondVar\n&quot;);

</pre>

</blockquote>

<h2><a NAME="ReviewExercises"><font SIZE="5" COLOR="#FF0000">

Review Exercises</font></a></h2>

<ol>

<li>Write a simple expression that uses the exponentiation operator.

<li>Write a complex expression that uses three operators and one

fuNCtion.

<li>Write a Perl program that uses a statement block inside a

fuNCtion call.

<li>Use the statement block from the previous exercise to create

local variables.

<li>Write a Perl program that shows if the expression clause of

a <tt>while</tt> modified statement

will be evaluated when the condition is false.

</ol>

<hr>



<center><p><a HREF="ch5.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch5.htm"><img SRC="pc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="#CONTENTS"><img SRC="cc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/cc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="index-1.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/index-1.htm"><img SRC="hb.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/hb.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="ch7.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch7.htm"><img SRC="nc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/nc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<hr WIDTH="100%"></p></center>

</body>

</html>

