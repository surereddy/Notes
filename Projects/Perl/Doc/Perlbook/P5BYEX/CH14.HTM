<html>

<head>

<title>Chapter 14  -- What Are Objects?</title>



<meta>

</head>

<body TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">

<h1><font SIZE="6" COLOR="#FF0000">Chapter&nbsp;14</font></h1>

<h1><font SIZE="6" COLOR="#FF0000">What Are Objects?</font></h1>

<hr>

<p>

<center><b><font SIZE="5">CONTENTS</font></b></center>

<ul>

<li><a HREF="#LearningaboutClasses">

Learning about Classes</a>

<li><a HREF="#AbstractThinking">

Abstract Thinking</a>

<li><a HREF="#OverridingMethodswithPolymorphism">

Overriding Methods with Polymorphism</a>

<li><a HREF="#KeepingCodeandDataTogetherwithENCapsulation">

Keeping Code and Data Together with ENCapsulation</a>

<li><a HREF="#HowPerlHandlesObjects">

How Perl Handles Objects</a>

<ul>

<li><a HREF="#ExampleBlesstheHashandPasstheRefereNCe">

Example: Bless the Hash and Pass the RefereNCe</a>

<li><a HREF="#ExampleInitializingProperties">

Example: Initializing Properties</a>

<li><a HREF="#ExampleUsingNamedParametersinConstructors">

Example: Using Named Parameters in Constructors</a>

<li><a HREF="#ExampleInheritaNCePerlStyle">

Example: InheritaNCe, Perl Style</a>

<li><a HREF="#ExamplePolymorphism">

Example: Polymorphism</a>

<li><a HREF="#ExampleHowOneClassCanContainAnother">

Example: How One Class Can Contain Another</a>

</ul>

<li><a HREF="#StaticVersusRegularMethodsandVariables">

Static Versus Regular Methods and Variables</a>

<li><a HREF="#Summary">

Summary</a>

<li><a HREF="#ReviewQuestions">

Review Questions</a>

<li><a HREF="#ReviewExercises">

Review Exercises</a>

</ul>



<hr>

<p>

Actually, &quot;What are objects?&quot; is a silly question because

you already know what an object is. Trust your instiNCts. The

book you are reading is an object. The knife and fork you eat

with are objects. In short, your life is filled with them.

<p>

The question that really needs to be asked is, &quot;What are

classes?&quot; You see, all object-oriented techniques use classes

to do the real work. A <i>class</i> is a combination of variables

and fuNCtions designed to emulate an object. However, when referring

to variables in a class, object-oriented folks use the term <i>properties</i>;

and when referring to fuNCtions in a class, the term <i>method</i>

is used.

<p>

I'm not sure why new terminology was developed for object-oriented

programming. Because the terms are now commonplace in the object-oriented

documentation and products, you need to learn and become comfortable

with them in order to work efficiently.

<p>

In this chapter, you see how to represent objects in Perl using

classes, methods, and properties. In addition, you look at the

definitions of some big words such as <i>abstraction</i>, <i>eNCapsulation</i>,

<i>inheritaNCe</i>, and <i>polymorphism</i>.

<p>

Following are short definitions for these words. The sections

that follow expand on these definitions and show some examples

of their use.

<blockquote>

<b>Abstraction:</b> Information about an object (its properties)

can be accessed in a manner that isolates how data is stored from

how it is accessed and used.

</blockquote>

<blockquote>

<b>ENCapsulation:</b> The information about an object and fuNCtions

that manipulate the information (its methods) are stored together.

</blockquote>

<blockquote>

<b>InheritaNCe:</b> Classes can inherit properties and methods

from one or more parent classes.

</blockquote>

<blockquote>

<b>Polymorphism:</b> A child class can redefine a method already

defined in the parent class.

</blockquote>

<h2><a NAME="LearningaboutClasses"><font SIZE="5" COLOR="#FF0000">

Learning about Classes</font></a></h2>

<p>

Before looking at specific examples of object-oriented Perl code,

you need to see some generic examples. Looking at generic examples

while learning the &quot;standard&quot; object-oriented terminology

will ensure that you have a firm grasp of the coNCepts. If you

had to learn new Perl coNCepts at the same time as the object

coNCepts, something might be lost because of information overload.

<p>

<i>Classes</i> are used to group and describe object types. Remember

the character classes from <a HREF="ch10.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch10.htm">Chapter 10</a>, &quot;Regular Expressions&quot;?

A class in the object-oriented world is essentially the same thing.

Let's create some classes for an inventory system for a pen and

peNCil vendor. Start with a pen object. How could you describe

a pen from an inventory point of view?

<p>

Well, the pen probably has a part number, and you need to know

how many of them there are. The color of the pen might also be

important. What about the level of ink in the cartridge-is that

important? Probably not to an inventory system because all the

pens will be new and therefore full.

<p>

The thought process embodied in the previous paragraph is called

<i>modeling</i>. Modeling is the process of deciding what will

go into your objects. In esseNCe, you create a model of the world

out of objects.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Tip</b></td></tr>

<tr><td>

<blockquote>

The terms <tt><i>object</i></tt> and <tt><i>class</i></tt> are pretty interchangeable. Except that a class might be considered an object described in computer language, whereas an object is just an object.

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

Objects are somewhat situationally dependent. The description

of an object, and the class, depends on what needs to be done.

If you were attempting to design a school course scheduling program,

your objects would be very different than if you were designing

a statistics program.

<p>

Now back to the inventory system. You were reading about pens

and how they had colors and other identifying features. In object

talk, these features are called <i>properties</i>. Figure 14.1

shows how the pen class looks at this stage of the discussion.

<p>

<a HREF="f14-1.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/f14-1.gif"><b>Figure 14.1 : </b><i>The Pen Class and its properties</i>.</a>

<p>

Now that you have a class, it's time to generalize. Some people

generalize first. I like to look at the details first and then

extract the common information. Of course, usually you'd need

several classes before any common features will appear. But because

I've already thought this example through, you can cheat a little.

<p>

It's pretty obvious that all inventory items will need a part

number and that each will have its own quantity-on-hand value.

Therefore, you can create a more general class than Pen. Let's

call it <tt>Inventory_item</tt>. Figure

14.2 shows this new class.

<p>

<a HREF="f14-2.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/f14-2.gif"><b>Figure 14.2 : </b><i>The Inventory_item class and its properties</i>.</a>

<p>

Because some of <tt>Pen's</tt> properties

are now also in <tt>Inventory_item</tt>,

you need some mechanism or technique to avoid repetition of information.

This is done by deriving the <tt>Pen</tt>

class from <tt>Inventory_item</tt>.

In other words, <tt>Inventory_item</tt>

becomes the <i>parent</i> of <tt>Pen</tt>.

Figure 14.3 shows how the two classes are now related.

<p>

<a HREF="f14-3.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/f14-3.gif"><b>Figure 14.3 : </b><i>The relationship between Inventory_item

and Pen</i>.</a>

<p>

You may not have noticed, but you have just used the coNCept of

<i>inheritaNCe</i>. The <tt>Pen</tt>

class inherits two of its properties from the <tt>Inventory_item</tt>

class. InheritaNCe is really no more complicated than that. The

child class has the properties of itself plus whatever the parent

class has.

<p>

You haven't seen methods or fuNCtions used in classes yet. This

was deliberate. Methods are inherited in the same way that data

is. However, there are a couple of tricky aspects of using methods

that are better left for later. Perhaps even until you start looking

at Perl code.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

Even though you won't read about methods at this point in the chapter, there is something important that you need to know about inheritaNCe and methods. First, methods are inherited just like properties. Second, using inherited methods helps to create 
your program more quickly because you are using fuNCtionality that is already working. Therefore-at least in theory-your programs should be easier to create.</blockquote>



</td></tr>

</table>

</center>

<p>

<h2><a NAME="AbstractThinking"><font SIZE="5" COLOR="#FF0000">

Abstract Thinking</font></a></h2>

<p>

Earlier, I mentioned the term <i>abstraction</i>. Let's examine

the idea a little further. In order to do this, you need a working

definition of the term <i>model</i>. How about, &quot;A model

is an approximation of something.&quot; If you build a model car,

some of the items in the original car will be missing, such as

spark plugs, for example. If you build a model house, you wouldn't

iNClude the plumbing. Thus, the models that you build are somewhat

abstract; the details don't matter, just the form.

<p>

Abstraction in object-oriented programming works in the same way.

As the programmer, you present the model of your objects to other

programmers in the form of an <i>interface</i>. Actually, the

interface is just some documentation that tells others how to

interact with any of your classes. However, nobody needs to know

what your classes really do. It is enough to say that the file

object stores the file name and size and presents the information

in English. Whether the internal format of the information is

compressed, Russian, or stored in memory or on the hard disk is

immaterial to the user of your classes.

<p>

I recommend that as you design an object or class, you occasionally

distaNCe yourself from the work. Try to view the resulting system

through the eyes of another to check for iNConsisteNCies and relationships

that aren't needed.

<p>

You've learned about abstraction in abstract terms so far. Now

let's use the <tt>Pen</tt> class that

you created earlier to see a coNCrete example of abstraction.

The <tt>Pen</tt> class had only one

property of its own, the ink color (the rest were inherited).

For the sake of argument, the ink color can be <tt>&quot;blue,&quot;</tt>

<tt>&quot;black,&quot;</tt> or <tt>&quot;red.&quot;</tt>

When a <tt>Pen</tt> object is created

(the mechanism of creation is unimportant at the moment), a specific

color is assigned to it. Use <tt>&quot;blue&quot;</tt>

for the moment. Here is a line of code to create the object:

<blockquote>

<pre>

$pen = Pen-&gt;new(&quot;blue&quot;);

</pre>

</blockquote>

<p>

Now the <tt>Pen</tt> object has been

created. Do you care if the internal format of the ink color is

the string <tt>&quot;blue&quot;</tt>

or the number 1? What if, because you expect to use thousands

of objects, the internal format changes from a string to a number

to save computer memory? As long as the interface does not change,

the program that uses the class does not need to change.

<p>

By keeping the external interface of the class fixed, an abstraction

is being used. This reduces the amount of time spent retrofitting

programs each time a change is made to a class the program is

using.

<h2><a NAME="OverridingMethodswithPolymorphism"><font SIZE="5" COLOR="#FF0000">

Overriding Methods with Polymorphism</font></a></h2>

<p>

<i>Polymorphism</i> is just a little more complicated than inheritaNCe

because it involves methods. Earlier, I said you might not learn

about methods before you look at a real object-oriented Perl program,

but I changed my mind. Let's make up some methods that belong

in an inventory program. How about a method to print the properties

for debugging purposes or a method to change the quantity-on-hand

amount? Figure 14.4 shows the <tt>Inventory_item</tt>

class with these two fuNCtions.

<p>

<a HREF="f14-4.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/f14-4.gif"><b>Figure 14.4 : </b><i>The Inventory_item class with methods</i>.</a>

<p>

This new fuNCtion is automatically inherited by the <tt>PEN</tt>

class. However, you will run into a problem because the <tt>printProperties()</tt>

fuNCtion won't print the ink color. You have three choices:

<ul>

<li>Change the fuNCtion in the <tt>Inventory_item</tt>

class-This is a bad choice because the generic inventory item

should not know any unique information about inventory objects-just

general or common information.

<li>Create a new fuNCtion in the <tt>Pen</tt>

class called <tt>printPenProperties()-</tt>This

is another bad choice. By solving the problem this way, every

class will soon have its own print fuNCtions, and keeping track

of the fuNCtion names would be a nightmare.

<li>Create a new fuNCtion in the <tt>Pen</tt>

class called <tt>printProperties()</tt>

to <i>override</i> the definition from <tt>Inventory_item</tt>.

This is a good solution. In fact, this is the way that polymorphism

works.

</ul>

<p>

Perl's take on polymorphism is that if you call a method in your

program, either the current class or a parent class should have

defined that method. If the current class has not defined the

method, Perl looks in the parent class. If the method is still

not found, Perl continues to search the class <i>hierarchy</i>.

<p>

I can hear you groaning at this point-another object-oriented

word! Yes, unfortunately. But at least this one uses the normal,

everyday definition of the word. A <i>hierarchy</i> is an organized

tree of information. In our examples so far, you have a two-level

hierarchy. It's possible to have class hierarchies many levels

deep. In fact, it's quite common. Figure 14.5 shows a class hierarchy

with more than one level.

<p>

<a HREF="f14-5.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/f14-5.gif"><b>Figure 14.5 : </b><i>A class hierarchy with many levels</i>.</a>

<p>

It's probably worth mentioning that some classes contain only

information and not methods. As far as I know, however, there

is no special terminology to reflect this. These information-only

classes may serve as adjuNCt or helper classes.

<h2><a NAME="KeepingCodeandDataTogetherwithENCapsulation"><font SIZE="5" COLOR="#FF0000">

Keeping Code and Data Together with ENCapsulation</font></a></h2>

<p>

There's not much that I need to say about eNCapsulation. Keeping

the methods in the same place as the information they affect seems

like common sense. It wasn't done using earlier languages mostly

because the programming tools were not available. The extra work

required to manually perform eNCapsulation outweighed the benefits

that would be gained.

<p>

One big advantage of eNCapsulation is that it makes using information

for unintended purposes more difficult, and this reduces logic

errors. For example, if pens were sold in lots of 100, the <tt>changeQuantityOnHand()</tt>

fuNCtion would reflect this. Changing the quantity by only one

would not be possible. This enforcement of business rules is one

of the biggest attractions of object-oriented programming.

<h2><a NAME="HowPerlHandlesObjects"><font SIZE="5" COLOR="#FF0000">

How Perl Handles Objects</font></a></h2>

<p>

Remember the coNCept of refereNCes that was discussed in <a HREF="ch8.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch8.htm">Chapter

8</a>, &quot;RefereNCes&quot;?  If not, please re-read it. RefereNCes

will play a large role in the rest of the chapter and are critical

to understanding how classes are used. You specifically need to

remember that the <tt>{ }</tt> notation

indicates an anonymous hash. Armed with this knowledge and the

object-oriented terminology from the first part of this chapter,

you are ready to look at real Perl objects. Listing 14.1 shows

you how the <tt>inventory_item</tt>

class could be defined in Perl.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Start a new class called </i><tt><i>Inventory_item</i></tt><i>.

The </i><tt><i>package</i></tt><i>

keyword is used to introduce new classes and namespaces.<br>

Define the </i><tt><i>new()</i></tt><i>

fuNCtion. This fuNCtion is responsible for constructing a new

object.<br>

The first parameter to the </i><tt><i>new()</i></tt><i>

fuNCtion is the class name (</i><tt><i>Inventory_item</i></tt><i>).

This is explained further in the sections &quot;Example: Initializing

Object Properties&quot; and &quot;Static Versus Regular Methods&quot;

later in the chapter.<br>

The </i><tt><i>bless()</i></tt><i>

fuNCtion is used to change the data type of the anonymous hash

to </i><tt><i>$class</i></tt><i> or

</i><tt><i>Inventory_item</i></tt><i>.

Because this is the last statement in the method, its value will

be returned as the value of the fuNCtion. I feel that using the

return statement to explicitly return a value would clutter the

code in this situation.<br>

An anonymous hash is used to hold the properties for the class.

For the moment, their values are undefined. Assigning values to

properties is discussed in the section &quot;Example: Initializing

Properties&quot; later in this chapter.<br>

Switch to the package called </i><tt><i>main</i></tt><i>.

This is the default place for variables and code to go (technically,

this is called a namespace). If no classes are defined in your

script, then this line is not needed.<br>

Assign an instaNCe of the </i><tt><i>Inventory_item</i></tt><i>

class to the </i><tt><i>$item variable</i></tt><i>.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 14.1&nbsp;&nbsp;14LST01.PL-Defining the </b><tt><b><font FACE="Courier">Inventory_item</font></b></tt><b>

Class<br>

</b>

</blockquote>

<blockquote>

<pre>

package Inventory_item;

    sub new {

        my($class) = shift;

    

        bless {

            &quot;PART_NUM&quot;    =&gt; undef,

            &quot;QTY_ON_HAND&quot; =&gt; undef

        }, $class;

    }



package main;

   $item = Inventory_item-&gt;new();

</pre>

</blockquote>

<hr>

<p>

There is a <i>lot</i> of new stuff in this small ten-line listing,

and you'll need to review it carefully to glean the information

needed to understand everything that is happening. You'll also

start to translate between the Perl keywords and the object-oriented

terminology.

<p>

The first line, <tt>package Inventory_item</tt>;

says two things, depending on if you are thinking in terms of

objects or in terms of Perl. When considering objects, it begins

the definition of a class. When considering Perl, it means that

a specific namespace will be used.

<p>

You read a little bit about namespace in <a HREF="ch3.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch3.htm">Chapter 3</a> &quot;Variables.&quot;

A <i>namespace</i> is used to keep one set of names from interfering

with another. For example, you can have a variable named bar and

a fuNCtion called <tt>bar</tt>, and

the names will not conflict because variables and fuNCtions each

have their own namespace.

<p>

The <tt>package</tt> keyword lets

you create your own namespace. This lets you create more than

one fuNCtion called <tt>new()</tt>

as long as each is in its own package or namespace. If you need

to refer to a specific fuNCtion in a specific namespace, you can

use <tt>Inventory_item&shy;&gt;new</tt>,

<tt>Inventory_item::new</tt>, or <tt>Inventory_item'new</tt>.

Which notation you use will probably depend on your background.

Object-oriented folks will probably want to use the -&gt; notation.

<p>

The second line, <tt>sub new</tt>,

starts the definition of a fuNCtion. It has become accepted practice

in the object-oriented world to construct new objects with the

<tt>new()</tt> method. This is called

the class <i>constructor</i>. This might be a good time to emphasize

that the class definition is a template. It's only when the <tt>new()</tt>

fuNCtion is called that an object is created or <i>instantiated</i>.

Instantiation means that memory is allocated from your computer's

memory pool and devoted to the use of this specific object. The

<tt>new()</tt> fuNCtion normally returns

a refereNCe to an anonymous hash. Therefore, the <tt>new()</tt>

fuNCtion should never be called unless you are assigning its return

value to a variable. If you don't store the refereNCe into a scalar

variable for later use, you'll never be able to access the anonymous

hash inside the object. For all intents and purposes, the anonymous

hash <i>is</i> the object.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

Not all objects are represented by hashes. If you need an object to emulate a gas tank, perhaps an anonymous scalar would be sufficient to hold the number of gallons of gas left in the tank. However, you'll see that working with hashes is quite easy oNCe 
you learn how. Hashes give you tremendous flexibility to solve programming problems.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

There is nothing magic about the new fuNCtion name. You could

call the fuNCtion that creates new objects <tt>create()</tt>

or <tt>build()</tt> or anything else,

but don't. The standard is <tt>new()</tt>,

and everyone who reads your program or uses your classes will

look for a <tt>new()</tt> fuNCtion.

If they don't find one, confusion might set in. There are so few

standards in the programming business. When they exist, it's usually

a good idea to follow them.

<p>

The <tt>bless()</tt> fuNCtion on the

third line changes the data type of its first parameter to the

string value of its second parameter. In the situation shown here,

the data type is changed to the name of the package, <tt>Inventory_item</tt>.

Using <tt>bless()</tt> to change the

data type of a refereNCe causes the <tt>ref()</tt>

fuNCtion to return the new data type. This potentially confusing

point is explained further in the section &quot;Example: Bless

the Hash and Pass the RefereNCe&quot; later in this chapter.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

I used the <tt>bless()</tt> fuNCtion without using parentheses to surround the parameters. While Perl lets you do this, I have been studiously using parentheses to avoid certain issues of precedeNCe that seem beyond the scope of this book. In this special 
instaNCe, where the anonymous hash is one of the parameters, I feel that using parentheses clutters the source code.

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

Embedded inside the <tt>bless()</tt>

fuNCtion call is the creation of an anonymous hash that holds

the properties of the class. The hash definition is repeated here

for your convenieNCe:

<blockquote>

<pre>

{

    &quot;PART_NUM&quot;    =&gt; undef,

    &quot;QTY_ON_HAND&quot; =&gt; undef

};

</pre>

</blockquote>

<p>

Nothing significant is happening here that you haven't seen before.

Each entry in the hash is a different property of the class. For

the moment, I have assigned the undefined value to the value part

of the entries. Soon you'll see how to properly initialize them.

<p>

After the <tt>new()</tt> fuNCtion

is defined, there is another package statement:

<blockquote>

<pre>

package main;

</pre>

</blockquote>

<p>

There is no object-oriented way to interpret this statement. It

simply tells Perl to switch back to using the <tt>main</tt>

namespace. Don't be fooled into thinking that there is a <tt>main</tt>

class somewhere. There isn't.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Caution</b></td></tr>

<tr><td>

<blockquote>

While you could create a <tt>main</tt> class by defining the <tt>new()</tt> fuNCtion after the <tt>package main;</tt> statement, things might get to be confusing, so don't do it!

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

The last statement in the file is really the first line that gets

executed. Everything else in the script has been class and method

definitions.

<blockquote>

<pre>

   $item = Inventory_item-&gt;new();

</pre>

</blockquote>

<p>

By now, you've probably guessed what this statement does. It assigns

a refereNCe to the anonymous hash to <tt>$item</tt>.

You can derefereNCe <tt>$item</tt>

in order to determine the value of the entries in the hash. If

you use the <tt>ref()</tt> fuNCtion

to determine the data type of <tt>$item</tt>,

you find that its value is <tt>Inventory_item</tt>.

<p>

Here are some key items to remember about objects in Perl:

<blockquote>

<b>All objects are anonymous hashes:</b> While not strictly true,

perhaps it should be. Also, most of the examples in this book

follow this rule. This means that most of the <tt>new()</tt>

methods you see return a refereNCe to a hash.

</blockquote>

<blockquote>

<tt><b><font FACE="Courier">bless()</font></b></tt><b> changes

the data type of the anonymous hash:</b> The data type is changed

to the name of the class.

</blockquote>

<blockquote>

<b>The anonymous hash itself is blessed:</b> This means that refereNCes

to the hash are not blessed. This coNCept is probably a little

uNClear. I had trouble figuring it out myself. The next section

clarifies this point and uses an example.

</blockquote>

<blockquote>

<b>Objects can belong to only one class at a time:</b> You can

use the <tt>bless()</tt> fuNCtion

to change the ownership at any time. However, don't do this unless

you have a good reason.

</blockquote>

<blockquote>

<b>The </b><tt><b><font FACE="Courier">-&gt;</font></b></tt><b>

operator is used to call a method associated with a class:</b>

There are two different ways to invoke or call class methods:

</blockquote>

<blockquote>

<pre>

$item = new Inventory_item;

</pre>

</blockquote>

<p>

or

<blockquote>

<pre>

$item = Inventory_item-&gt;new();

</pre>

</blockquote>

<p>

Both of these techniques are equivalent, but the <tt>-&gt;</tt>

style is preferred by object-oriented folks.

<h3><a NAME="ExampleBlesstheHashandPasstheRefereNCe">

Example: Bless the Hash and Pass the RefereNCe</a></h3>

<p>

If you recall from <a HREF="ch8.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch8.htm">Chapter 8</a> the <tt>ref()</tt>

fuNCtion returns either the undefined value or a string indicating

the parameter's data type (<tt>SCALAR</tt>,

<tt>ARRAY</tt>, <tt>HASH</tt>,

<tt>CODE</tt>, or <tt>REF</tt>).

When classes are used, these data types don't provide enough information.

<p>

This is why the <tt>bless()</tt> fuNCtion

was added to the language. It lets you change the data type of

any variable. You can change the data type to any string value

you like. Most often, the data type is changed to reflect the

class name.

<p>

It is important to understand that the variable itself will have

its data type changed. The following lines of code should make

this clear:

<blockquote>

<pre>

$foo    = { };

$fooRef = $foo;



print(&quot;data of \$foo is &quot;    . ref($foo)    . &quot;\n&quot;);

print(&quot;data of \$fooRef is &quot; . ref($fooRef) . &quot;\n&quot;);



bless($foo, &quot;Bar&quot;);



print(&quot;data of \$foo is &quot;    . ref($foo)    . &quot;\n&quot;);

print(&quot;data of \$fooRef is &quot; . ref($fooRef) . &quot;\n&quot;);

</pre>

</blockquote>

<p>

This program displays the following:

<blockquote>

<pre>

data of $foo is HASH

data of $fooRef is HASH

data of $foo is Bar

data of $fooRef is Bar

</pre>

</blockquote>

<p>

After the data type is changed, the <tt>ref($fooRef)</tt>

fuNCtion call returns <tt>Bar</tt>

instead of the old value of <tt>HASH</tt>.

This can happen only if the variable itself has been altered.

This example also shows that the <tt>bless()</tt>

fuNCtion works outside the object-oriented world.

<h3><a NAME="ExampleInitializingProperties">

Example: Initializing Properties</a></h3>

<p>

You now know how to instantiate a new class by using a <tt>new()</tt>

fuNCtion and how to create class properties (the class information)

with undefined values. Let's look at how to give those properties

some real values. You need to start by looking at the <tt>new()</tt>

fuNCtion from Listing 14.1. It's repeated here so you don't need

to flip back to look for it.

<blockquote>

<pre>

sub new {

        my($class) = shift;

        bless {

            &quot;PART_NUM&quot;    =&gt; undef,

            &quot;QTY_ON_HAND&quot; =&gt; undef

        }, $class;

}

</pre>

</blockquote>

<p>

The <tt>new()</tt> fuNCtion is a <i>static

</i>method. Static methods are not associated with any specific

object. This makes sense because the <tt>new()</tt>

fuNCtion is designed to create objects. It can't be associated

with an object that doesn't exist yet, can it?

<p>

The first argument to a static method is always the class name.

Perl takes the name of the class from in front of the -&gt; operator

and adds it to the beginning of the parameter array, which is

passed to the <tt>new()</tt> fuNCtion.

<p>

If you want to pass two values into the <tt>new()</tt>

fuNCtion to initialize the class properties, you can modify the

method to look for additional arguments as in the following:

<blockquote>

<pre>

sub new {

        my($class)   = shift;

        my($partNum) = shift;

        my($qty)     = shift;



        bless {

            &quot;PART_NUM&quot;    =&gt; $partNum,

            &quot;QTY_ON_HAND&quot; =&gt; $qty

        }, $class;

}

</pre>

</blockquote>

<p>

Each parameter you expect to see gets shifted out of the parameter

array into a scalar variable. Then the scalar variable is used

to initialize the anonymous hash.

<p>

You invoke this updated version of <tt>new()</tt>

by using this line of code:

<blockquote>

<pre>

$item = Inventory_item-&gt;new(&quot;AW-30&quot;, 1200);

</pre>

</blockquote>

<p>

While this style of parameter passing is very serviceable, Perl

provides for the use of another technique: passing named parameters.

<h3><a NAME="ExampleUsingNamedParametersinConstructors">

Example: Using Named Parameters in Constructors</a></h3>

<p>

The coNCept of using named parameters has been quickly accepted

in new computer languages. I was first introduced to it while

working with the scripting language for Microsoft Word. Rather

than explain the technique in words, let me show you an example

in code, as shown in Listing 14.2. I think you'll understand the

value of this technique very quickly.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Start a definition of the </i><tt><i>Inventory_item</i></tt><i>

class.<br>

Define the constructor for the class.<br>

Get the name of the class from the parameter array.<br>

Assign the rest of the parameters to the </i><tt><i>%params</i></tt><i>

hash.<br>

Bless the anonymous hash with the class name.<br>

Use </i><tt><i>%params</i></tt><i>

to initialize the class properties.<br>

Start the </i><tt><i>main</i></tt><i>

namespace.<br>

Call the constructor for the </i><tt><i>Inventory_item</i></tt><i>

class.<br>

Assign the object refereNCe to </i><tt><i>$item</i></tt><i>.

<br>

Print the two property values to verify that the property initialization

worked.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 14.2&nbsp;&nbsp;14LST02.PL-Setting Class Properties

Using the Class Constructor<br>

</b>

</blockquote>

<blockquote>

<pre>

package Inventory_item;

    sub new {

        my($class)  = shift;

        my(%params) = @_;



        bless {

            &quot;PART_NUM&quot;    =&gt; $params{&quot;PART_NUM&quot;},

            &quot;QTY_ON_HAND&quot; =&gt; $params{&quot;QTY_ON_HAND&quot;}

            }, $class;

    }



package main;



    $item = Inventory_item-&gt;new(

&quot;PART_NUM&quot;    =&gt; &quot;12A-34&quot;,

&quot;QTY_ON_HAND&quot; =&gt; 34);



    print(&quot;The part number is &quot; . %{$item}-&gt;{'PART_NUM'} . &quot;\n&quot;);

    print(&quot;The quantity is &quot; . %{$item}-&gt;{'QTY_ON_HAND'} . &quot;\n&quot;);

</pre>

</blockquote>

<hr>

<p>

One key statement to understand is the line in which the <tt>new()</tt>

fuNCtion is called:

<blockquote>

<pre>

$item = Inventory_item-&gt;new(

&quot;PART_NUM&quot;    =&gt; &quot;12A-34&quot;,

               &quot;QTY_ON_HAND&quot; =&gt; 34);

</pre>

</blockquote>

<p>

This looks like an associative array is being passed as the parameter

to <tt>new()</tt>, but looks are deceiving

in this case. The <tt>=&gt;</tt> operator

does exactly the same thing as the comma operator. Therefore,

the preceding statement is identical to the following:

<blockquote>

<pre>

$item = Inventory_item-&gt;new(&quot;PART_NUM&quot;, &quot;12A-34&quot;, &quot;QTY_ON_HAND&quot;, 34);

</pre>

</blockquote>

<p>

Also, a four-element array is being passed to<tt>

new()</tt>.

<p>

The second line of the <tt>new()</tt>

fuNCtion, <tt>my(%params) = @_;</tt>

does something very interesting. It takes the four-element array

and turns it into a hash with two entries. One entry is for <tt>PART_NUM</tt>,

and the other is for <tt>QTY_ON_HAND</tt>.

<p>

This conversion (array into hash) lets you access the parameters

by name using <tt>%params</tt>. The

initialization of the anonymous hash-inside the <tt>bless()</tt>

fuNCtion-takes advantage of this by using expressions such as

<tt>$params{&quot;PART_NUM&quot;}</tt>.

<p>

I feel that this technique helps to create self-documenting code.

When looking at the script, you always know which property is

being referred to. In addition, you can also use this technique

to partially initialize the anonymous hash. For example,

<blockquote>

<pre>

$item = Inventory_item-&gt;new(&quot;QTY_ON_HAND&quot; =&gt; 34);

</pre>

</blockquote>

<p>

gives a value only to the <tt>QTY_ON_HAND</tt>

property; the <tt>PART_NUM</tt> property

will remain undefined. You can use this technique with any type

of fuNCtion, not just constructors.

<h3><a NAME="ExampleInheritaNCePerlStyle">

Example: InheritaNCe, Perl Style</a></h3>

<p>

You already know that inheritaNCe means that properties and methods

of a parent class will be available to child classes. This section

shows you can use inheritaNCe in Perl.

<p>

First, a little diversion. You may not have realized it yet, but

each package can have its own set of variables that won't interfere

with another package's set. So if the variable <tt>$first</tt>

was defined in package A, you could also define <tt>$first</tt>

in package B without a conflict arising. For example,

<blockquote>

<pre>

package A;

    $first = &quot;package A&quot;;



package B;

    $first = &quot;package B&quot;;



package main;

    print(&quot;$A::first\n&quot;);

    print(&quot;$B::first\n&quot;);

</pre>

</blockquote>

<p>

displays

<blockquote>

<pre>

package A

package B

</pre>

</blockquote>

<p>

Notice that the <tt>::</tt> is being

used as a scope resolution operator in this example. The <tt>-&gt;</tt>

notation will not work; also, it's okay that <tt>-&gt;</tt>

can't be used because we're not really dealing with objects in

this example, just different namespaces.

<p>

You're probably wondering what this diversion has to do with inheritaNCe,

right? Well, inheritaNCe is accomplished by placing the names

of parent classes into a special array called <tt>@ISA</tt>.

The elements of <tt>@ISA</tt> are

searched left to right for any missing methods. In addition, the

<tt>UNIVERSAL</tt> class is invisibly

tacked on to the end of the search list. For example,

<blockquote>

<pre>

package UNIVERSAL;

    sub AUTOLOAD {

        die(&quot;[Error: Missing FuNCtion] $AUTOLOAD @_\n&quot;);

    }





package A;

    sub foo {

        print(&quot;Inside A::foo\n&quot;);

    }



package B;

    @ISA = (A);



package main;

    B-&gt;foo();

    B-&gt;bar();

</pre>

</blockquote>

<p>

displays

<blockquote>

<pre>

Inside A::foo

[Error: Missing FuNCtion] B::bar B

</pre>

</blockquote>

<p>

Let's start with the nearly empty class <tt>B</tt>.

This class has no properties or methods; it just has a parent:

the <tt>A</tt> class. When Perl executes

<tt>B-&gt;foo()</tt>, the first line

in the main package, it first looks in <tt>B</tt>.

When the <tt>foo()</tt> fuNCtion is

not found, it looks to the <tt>@ISA</tt>

array. The first element in the array is <tt>A</tt>,

so Perl looks at the <tt>A</tt> class.

Because <tt>A</tt> does have a <tt>foo()</tt>

method, that method is executed.

<p>

When a method can't be found by looking at each element of the

<tt>@ISA</tt> array, the <tt>UNIVERSAL</tt>

class is checked. The second line of the main package, <tt>B-&gt;bar()</tt>,

tries to use a fuNCtion that is not defined in either the base

class <tt>B</tt> or the parent class

<tt>A</tt>. Therefore,  as a last-ditch

effort, Perl looks in the <tt>UNIVERSAL</tt>

class. The <tt>bar()</tt> fuNCtion

is not there, but a special fuNCtion called <tt>AUTOLOAD()</tt>

is.

<p>

The <tt>AUTOLOAD()</tt> fuNCtion is

normally used to automatically load undefined fuNCtions. Its normal

use is a little beyond the scope of this book. However, in this

example, I have changed it into an error reporting tool. Instead

of loading undefined fuNCtions, it now causes the script to end

(via the <tt>die()</tt> fuNCtion)

and displays an error message indicating which method is undefined

and which class Perl was looking in. Notice that the message ends

with a newline to prevent Perl from printing the script name and

line number where the script death took place. In this case, the

information would be meaningless because the line number would

be inside the <tt>AUTOLOAD()</tt>

fuNCtion.

<p>

Listing 14.3 shows how to call the constructor of the parent class.

This example shows how to explicitly call the parent's constructor.

In the next section, you learn how to use the <tt>@ISA</tt>

array to generically call methods in the parent classes. However,

because constructors are frequently used to initialize properties,

I feel that they should always be called explicitly, which causes

less confusion when calling constructors from more than one parent.

<p>

This example also shows how to inherit the properties of a parent

class. By calling the parent class constructor fuNCtion, you can

initialize an anonymous hash that can be used by the base class

for adding additional properties.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Start a definition of the </i><tt><i>Inventory_item</i></tt><i>

class.<br>

Define the constructor for the class.<br>

Get the name of the class from the parameter array.<br>

Assign the rest of the parameters to the </i><tt><i>%params</i></tt><i>

hash.<br>

Bless the anonymous hash with the class name.<br>

Use </i><tt><i>%params</i></tt><i>

to initialize the class properties.<br>

Start a definition of the </i><tt><i>Pen</i></tt><i>

class.<br>

Initialize the </i><tt><i>@ISA</i></tt><i>

array to define the parent classes.<br>

Define the constructor for the class.<br>

Get the name of the class from the parameter array.<br>

Assign the rest of the parameters to the </i><tt><i>%params</i></tt><i>

hash.<br>

Call the constructor for the parent class, </i><tt><i>Inventory_item</i></tt><i>,

and assign the resulting object refereNCe to </i><tt><i>$self</i></tt><i>.

<br>

Create an entry in the anonymous hash for the </i><tt><i>INK_COLOR</i></tt><i>

key.<br>

Bless the anonymous hash so that </i><tt><i>ref()</i></tt><i>

will return </i><tt><i>Pen</i></tt><i>

and return a refereNCe to the anonymous hash.<br>

Start the </i><tt><i>main</i></tt><i>

namespace.<br>

Call the constructor for the </i><tt><i>Pen</i></tt><i>

class. Assign the object refereNCe to </i><tt><i>$item</i></tt><i>.

Note that an array with property-value pairs is passed to the

constructor.<br>

Print the three property values to verify that the property initialization

worked.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 14.3&nbsp;&nbsp;14LST03.PL-How to Call the Constructor

of a Parent Class<br>

</b>

</blockquote>

<blockquote>

<pre>

package Inventory_item;

    sub new {

        my($class)  = shift;

        my(%params) = @_;

        bless {

            &quot;PART_NUM&quot;    =&gt; $params{&quot;PART_NUM&quot;},

            &quot;QTY_ON_HAND&quot; =&gt; $params{&quot;QTY_ON_HAND&quot;}

            }, $class;

    }



package Pen;

    @ISA = (Inventory_item);





 sub new {

        my($class) = shift;

        my(%params) = @_;

        my($self) = Inventory_item-&gt;new(@_);



        $self-&gt;{&quot;INK_COLOR&quot;} = $params{&quot;INK_COLOR&quot;};



        return(bless($self, $class));

    }



package main;

    $pen = Pen-&gt;new(

        &quot;PART_NUM&quot;    =&gt; &quot;12A-34&quot;,

        &quot;QTY_ON_HAND&quot; =&gt; 34,

        &quot;INK_COLOR&quot;   =&gt; &quot;blue&quot;);



    print(&quot;The part number is &quot; . %{$pen}-&gt;{'PART_NUM'}    . &quot;\n&quot;);

    print(&quot;The quantity is &quot;    . %{$pen}-&gt;{'QTY_ON_HAND'} . &quot;\n&quot;);

    print(&quot;The ink color is &quot;   . %{$pen}-&gt;{'INK_COLOR'}   . &quot;\n&quot;);

</pre>

</blockquote>

<hr>

<p>

This program displays:

<blockquote>

<pre>

The part number is 12A-34

The quantity is 34

The ink color is blue

</pre>

</blockquote>

<p>

You should be familiar with all the aspects of this script by

now. The line <tt>my($self) = Inventory_item-&gt;new(@_);</tt>

is used to get a refereNCe to an anonymous hash. This hash becomes

the object for the base class.

<p>

To understand that calling the parent constructor creates the

object that becomes the object for the base class, you must remember

that an object <i>is</i> the anonymous hash. Because the parent

constructor creates the anonymous hash, the base class needs a

refereNCe only to that hash in order to add its own properties.

This refereNCe is stored in the <tt>$self</tt>

variable.

<p>

You may also see the variable name <tt>$this</tt>

used to hold the refereNCe in some scripts. Both <tt>$self</tt>

and <tt>$this</tt> are acceptable

in the object-oriented world.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

I would actually prefer the variable name <tt>$data</tt> because the hash <tt><i>is</i></tt> the object; therefore, the data <tt><i>is</i></tt> the object. But sometimes, it's good to follow conventional wisdom so that others can more easily understand 
your programs.

</blockquote>



</td></tr>

</table>

</center>

<p>

<h3><a NAME="ExamplePolymorphism">

Example: Polymorphism</a></h3>

<p>

<i>Polymorphism</i>, although a big word, is a simple coNCept.

It means that methods defined in the base class will override

methods defined in the parent classes. The following small example

clarifies this coNCept:

<blockquote>

<pre>

package A;

    sub foo {

        print(&quot;Inside A::foo\n&quot;);

    }



package B;

    @ISA = (A);



    sub foo {

        print(&quot;Inside B::foo\n&quot;);

    }



package main;

    B-&gt;foo();

</pre>

</blockquote>

<p>

This program displays

<blockquote>

<pre>

Inside B::foo

</pre>

</blockquote>

<p>

The <tt>foo()</tt> defined in class

<tt>B</tt> overrides the definition

that was inherited from class <tt>A</tt>.

<p>

Polymorphism is mainly used to add or extend the fuNCtionality

of an existing class without reprogramming the whole class. Listing

14.4 uses polymorphism to override the <tt>qtyChange()</tt>

fuNCtion inherited from <tt>Inventory_item</tt>.

In addition, it shows how to call a method in a parent class when

the specific parent class name (also known as the <tt><i>SUPER</i></tt>

class) is unknown.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Start a definition of the </i><tt><i>Inventory_item</i></tt><i>

class.<br>

Define the constructor for the class.<br>

Get the name of the class from the parameter array.<br>

Assign the rest of the parameters to the </i><tt><i>%params</i></tt><i>

hash.<br>

Bless the anonymous hash with the class name.<br>

Use </i><tt><i>%params</i></tt><i>

to initialize the class properties.<br>

Define the </i><tt><i>qtyChange()</i></tt><i>

method.<br>

Get the object refereNCe from the parameter array.<br>

Get the quantity to change from the parameter array. If there

are no more elements in the </i><tt><i>@_</i></tt><i>,

default to using the quantity 1.<br>

Use derefereNCing to change the </i><tt><i>QTY_ON_HAND</i></tt><i>

property.<br>

Start a definition of the </i><tt><i>Pen</i></tt><i>

class.<br>

Initialize the </i><tt><i>@ISA</i></tt><i>

array to define the parent classes.<br>

Initialize the </i><tt><i>@PARENT::ISA</i></tt><i>

array to let Perl search the </i><tt><i>@ISA</i></tt><i>

to look for method refereNCes.<br>

Define the constructor for the class.<br>

Get the name of the class from the parameter array.<br>

Assign the rest of the parameters to the </i><tt><i>%params</i></tt><i>

hash.<br>

Call the constructor for the parent class using the </i><tt><i>PARENT::</i></tt><i>

notation. This searches the classes listed in the </i><tt><i>@ISA</i></tt><i>

array looking for the </i><tt><i>new()</i></tt><i>

fuNCtion  and assigns the resulting object refereNCe to </i><tt><i>$self</i></tt><i>.

<br>

Create an entry in the anonymous hash for the </i><tt><i>INK_COLOR</i></tt><i>

key.<br>

Return a refereNCe to the anonymous hash.<br>

Define the </i><tt><i>qtyChange()</i></tt><i>

method.<br>

Get the object refereNCe from the parameter array.<br>

Get the quantity to change from the parameter array. If there

are no more elements in the </i><tt><i>@_</i></tt><i>,

default to using the quantity 100.<br>

Use derefereNCing to change the </i><tt><i>QTY_ON_HAND</i></tt><i>

property.<br>

Start the </i><tt><i>main</i></tt><i>

namespace.<br>

Call the constructor for the </i><tt><i>Pen</i></tt><i>

class. Assign the object refereNCe to </i><tt><i>$item</i></tt><i>.

<br>

Print the data type of </i><tt><i>$item</i></tt><i>

to show that it is now Pen.<br>

Print the three property values to verify that the property initialization

 worked.<br>

Change the quantity by the default amount.<br>

Print a newline to separate the previous values from the new value.

<br>

Print the quantity property value to verify that the change method

worked.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 14.4&nbsp;&nbsp;14LST04.PL-Accessing Methods in Parent

Classes<br>

</b>

</blockquote>

<blockquote>

<pre>

package Inventory_item;

    sub new {

        my($class)  = shift;

        my(%params) = @_;

        bless {

            &quot;PART_NUM&quot;    =&gt; $params{&quot;PART_NUM&quot;},

            &quot;QTY_ON_HAND&quot; =&gt; $params{&quot;QTY_ON_HAND&quot;}

        }, $class;

    }





    sub qtyChange {

        my($self)  = shift;

        my($delta)  = $_[0] ? $_[0] : 1;



        $self-&gt;{&quot;QTY_ON_HAND&quot;} += $delta;

    }



package Pen;

    @ISA = (&quot;Inventory_item&quot;);

    @PARENT::ISA = @ISA;



    sub new {

        my($class) = shift;

        my(%params) = @_;

        my($self) = $class-&gt;PARENT::new(@_);



        $self-&gt;{&quot;INK_COLOR&quot;} = $params{&quot;INK_COLOR&quot;};



        return($self);

    }



    sub qtyChange {

        my($self)  = shift;

        my($delta)  = $_[0] ? $_[0] : 100;



        $self-&gt;PARENT::qtyChange($delta);

    }

    



package main;



    $pen = Pen-&gt;new(

        &quot;PART_NUM&quot;=&gt;&quot;12A-34&quot;,

        &quot;QTY_ON_HAND&quot;=&gt;340,

        &quot;INK_COLOR&quot; =&gt; &quot;blue&quot;);



    print(&quot;The data type is &quot;   . ref($pen)                . &quot;\n&quot;);

    print(&quot;The part number is &quot; . %{$pen}-&gt;{'PART_NUM'}    . &quot;\n&quot;);

    print(&quot;The quantity is &quot;    . %{$pen}-&gt;{'QTY_ON_HAND'} . &quot;\n&quot;);

    print(&quot;The ink color is &quot;   . %{$pen}-&gt;{'INK_COLOR'}   . &quot;\n&quot;);



    $pen-&gt;qtyChange();

    print(&quot;\n&quot;);

    print(&quot;The quantity is &quot;    . %{$pen}-&gt;{'QTY_ON_HAND'} . &quot;\n&quot;);

</pre>

</blockquote>

<hr>

<p>

This program displays

<blockquote>

<pre>

The data type is Pen

The part number is 12A-34

The quantity is 340

The ink color is blue



The quantity is 440

</pre>

</blockquote>

<p>

The first interesting line in the preceding example is <tt>my($delta)

 = $_[0] ? $_[0] : 1;</tt>. This line checks to see if

a parameter was passed to <tt>Inventory_item::qtychange()</tt>

and if not, assigns a value of 1 to <tt>$delta</tt>.

This line of code uses the <tt>ternary</tt>

operator to determine if <tt>$_[0]</tt>

has a value or not. A zero is used as the subscript because the

class refereNCe was shifted out of the parameter array and into

<tt>$self</tt>.

<p>

The next interesting line is <tt>@PARENT::ISA

= @ISA;</tt>. This assignment lets you refer to a method

defined in the parent class. Perl searches the parent hierarchy

(the <tt>@ISA</tt> array) until a

definition is found for the requested fuNCtion.

<p>

The <tt>Pen::new()</tt> fuNCtion uses

the <tt>@PARENT::ISA</tt> to find

the parent constructor using this line: <tt>my($self)

= $class-&gt;PARENT::new(@_);</tt>. I don't really recommend

calling parent constructors in this manner because the constructor

that gets called will depend on the order of classes in the <tt>@ISA</tt>

array. Having code that is dependent on an array keeping a specific

order is a recipe for disaster; you might forget about the dependeNCy

and spend hours trying to find the problem. However, I thought

you should see how it works. Because the <tt>$class</tt>

variable (which is equal to <tt>Pen</tt>)

is used to locate the parent constructor, the hash will be blessed

with the name of the base <tt>Pen</tt>

class-one small advantage of this technique. This is shown by

the program's output. This technique avoids having to call the

<tt>bless()</tt> fuNCtion in the base

class constructor.

<p>

By now, you must be wondering where polymorphism fits into this

example. Well, the simple fact that both the <tt>Pen</tt>

and <tt>Inventory_item</tt> classes

have the <tt>qtyChange()</tt> method

means that polymorphism is being used. While the <tt>Inventory_item::qtyChange()</tt>

method defaults to changing the quantity by one, the <tt>Pen::qtyChange()</tt>

method defaults to changing the quantity by 100. Because the <tt>Pen::qtyChange()</tt>

method simply modifies the behavior of <tt>Inventory_item::qtyChange()</tt>,

it does not need to know any details about how the quantity is

actually changed. This capability to change fuNCtionality without

knowing the details is a sign that abstraction is taking place.

<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Tip</b></td></tr>

<tr><td>

<blockquote>

The <tt>Inventory_item::qtychange()</tt> notation refers to the <tt>qtyChange()</tt> fuNCtion in the <tt>Inventory_item</tt> class, and <tt>Pen::qtyChange()</tt> refers to the <tt>qtyChange()</tt> fuNCtion in the <tt>Pen</tt> class. This notation lets you 
uniquely identify any method in your script.

</blockquote>



</td></tr>

</table>

</center>

<p>

<h3><a NAME="ExampleHowOneClassCanContainAnother">

Example: How One Class Can Contain Another</a></h3>

<p>

Now that you have seen several objects in action, you probably

realize that some class properties will be objects themselves.

For example, you might have a billing object that contains an

inventory object, or you might use a car object inside a warehouse

object. The possibilities are endless.

<p>

Listing 14.5 shows how to add a color object to the inventory

system you've been building. It also shows you that Perl will

execute statements that are not part of a fuNCtion-even those

in packages other than main-as soon as they are seen by the interpreter.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Start a definition of the </i><tt><i>Inventory_item</i></tt><i>

class.<br>

Define the constructor for the class.<br>

Get the name of the class from the parameter array.<br>

Assign the rest of the parameters to the </i><tt><i>%params</i></tt><i>

hash.<br>

Bless the anonymous hash with the class name.<br>

Use </i><tt><i>%params</i></tt><i>

to initialize the class properties.<br>

Start a definition of the </i><tt><i>Pen</i></tt><i>

class.<br>

Initialize the </i><tt><i>@ISA</i></tt><i>

array to define the parent classes.<br>

Define the constructor for the class.<br>

Get the name of the class from the parameter array.<br>

Assign the rest of the parameters to the </i><tt><i>%params</i></tt><i>

hash.<br>

Call the constructor for the parent class and assign the resulting

object refereNCe to </i><tt><i>$self</i></tt><i>.

<br>

Create an entry in the anonymous hash for the </i><tt><i>INK_COLOR</i></tt><i>

key by calling the constructor for the </i><tt><i>Color</i></tt><i>

class.<br>

Return a refereNCe to the anonymous hash that has been blessed

into the </i><tt><i>Pen</i></tt><i>

class.<br>

Start a definition of the </i><tt><i>Color</i></tt><i>

class.<br>

Print a message on </i><tt><i>STDOUT</i></tt><i>.

<br>

Create two entries in the </i><tt><i>%Colors</i></tt><i>

hash.<br>

Define the constructor for the class.<br>

Get the name of the class from the parameter array.<br>

Assign the rest of the parameters to the </i><tt><i>%params</i></tt><i>

hash.<br>

Assign a refereNCe to one of the entries in the </i><tt><i>%Colors</i></tt><i>

hash to </i><tt><i>$self</i></tt><i>.

This will be used as the object refereNCe.<br>

Bless the hash entry into the </i><tt><i>Color</i></tt><i>

class and return </i><tt><i>$self</i></tt><i>

as the object refereNCe.<br>

Start the </i><tt><i>main</i></tt><i>

namespace.<br>

Print a message on </i><tt><i>STDOUT</i></tt><i>.

<br>

Call the constructor for the </i><tt><i>Pen</i></tt><i>

class. Assign the object refereNCe to </i><tt><i>$item</i></tt><i>.

<br>

Use </i><tt><i>%properties</i></tt><i>

as a temporary value to simplify the derefereNCing process.<br>

Print the three property values to verify that the property initialization

worked.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 14.5&nbsp;&nbsp;14LST05.PL-How One Class Can Use or

Contain Another Class<br>

</b>

</blockquote>

<blockquote>

<pre>

package Inventory_item;

    sub new {

        my($class)  = shift;

        my(%params) = @_;

        bless {

            &quot;PART_NUM&quot;    =&gt; $params{&quot;PART_NUM&quot;},

            &quot;QTY_ON_HAND&quot; =&gt; $params{&quot;QTY_ON_HAND&quot;}

        }, $class;

}



package Pen;

    @ISA = (Inventory_item);



    sub new {

        my($class) = shift;

        my(%params) = @_;

        my($self) = Inventory_item-&gt;new(@_);



        $self-&gt;{&quot;INK_COLOR&quot;} = Color-&gt;new($params{&quot;INK_COLOR&quot;});



        return(bless($self, $class));

    }



package Color;

    print(&quot;Executing Color statements\n&quot;);

    $colors{&quot;blue&quot;}  = &quot;Die Lot 13&quot;;

    $colors{&quot;red&quot;}   = &quot;Die Lot 5&quot;;



    sub new {

        my($class) = shift;

        my($param) = @_;

        my($self) = \$colors{$param};



        return(bless($self, $class));

    }





package main;

    print(&quot;Executing main statements\n&quot;);



    $pen = Pen-&gt;new(

        &quot;PART_NUM&quot;    =&gt; &quot;12A-34&quot;,

        &quot;QTY_ON_HAND&quot; =&gt; 34,

        &quot;INK_COLOR&quot;   =&gt; &quot;blue&quot;);



    %properties = %{$pen};

    print(&quot;The part number is &quot; . $properties{'PART_NUM'}     . &quot;\n&quot;);

    print(&quot;The quantity is &quot;    . $properties{'QTY_ON_HAND'}  . &quot;\n&quot;);

    print(&quot;The ink color is &quot;   . ${$properties{'INK_COLOR'}} . &quot;\n&quot;);

</pre>

</blockquote>

<hr>

<p>

This program displays

<blockquote>

<pre>

Executing Color statements

Executing main statements

The part number is 12A-34

The quantity is 34

The ink color is Die Lot 13

</pre>

</blockquote>

<p>

Where to start? You already know about the <tt>Inventory_item</tt>

class and the <tt>@ISA</tt> array.

Let's look at the assignment to the <tt>INK_COLOR</tt>

entry of the <tt>Pen</tt> class. This

line, <tt>$self-&gt;{&quot;INK_COLOR&quot;}

= Color-&gt;new($params{&quot;INK_COLOR&quot;});</tt>,

is used to call the constructor for the <tt>Color</tt>

class. The expression <tt>$params{&quot;INK_COLOR&quot;}</tt>

passes the value of <tt>&quot;blue&quot;</tt>

to the <tt>Color</tt> constructor,

which returns a refereNCe to one of the colors in the <tt>%colors</tt>

associative array.

<p>

You can tell that Perl executes all statements that are not inside

fuNCtions because the <tt>print</tt>

statement in the <tt>Color</tt> package

is executed before the <tt>print</tt>

statement in the <tt>main</tt> package.

This is why you can define hash entries inside the <tt>Color</tt>

class. When variables are defined inside a package but outside

a fuNCtion, they are called <i>static</i> variables. You can access

one of the hash entries in the <tt>Color</tt>

package like this: <tt>$Color::colors{&quot;blue&quot;}</tt>.

<h2><a NAME="StaticVersusRegularMethodsandVariables"><font SIZE="5" COLOR="#FF0000">

Static Versus Regular Methods and Variables</font></a></h2>

<p>

You already learned that a static method is one that can be called

without needing an instantiated object. Actually, you can also

have static variables as you saw in the last section. Static variables

can be used to emulate <i>constants</i>, values that don't change.

Constants are very useful. For example, you can use them for tax

rates, mathematical constants, and things such as state abbreviations.

Here is an example using a small Perl script:

<blockquote>

<pre>

package Math;

    $math{'PI'} = 3.1415;



package main;

    print(&quot;The value of PI is $Math::math{'PI'}.\n&quot;);

</pre>

</blockquote>

<p>

This program displays

<blockquote>

<pre>

The value of PI is 3.1415.

</pre>

</blockquote>

<p>

You can also do this:

<blockquote>

<pre>

package Math;

    $PI = 3.1415;

package main;

    print(&quot;The value of PI is $Math::PI.\n&quot;);

</pre>

</blockquote>

<p>

Because you have been using a static method all along-the <tt>new()</tt>

method-I'll take this opportunity to demonstrate a regular fuNCtion.

Listing 14.6 shows how to use the <tt>UNIVERSAL</tt>

package to define a utility fuNCtion that is available to all

classes. 

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Start a definition of the </i><tt><i>UNIVERSAL</i></tt><i>

class.<br>

Define the </i><tt><i>lookup()</i></tt><i>

method.<br>

DerefereNCe the object refereNCe (the first element of </i><tt><i>@_</i></tt><i>)

and use the second parameter as the key into the anonymous hash.

Return the value of the hash entry.<br>

Start a definition of the </i><tt><i>Inventory_item</i></tt><i>

class.<br>

Define the constructor for the class.<br>

Assign the rest of the parameters to the </i><tt><i>%params</i></tt><i>

hash.<br>

Bless the anonymous hash with the class name.<br>

Use </i><tt><i>%params</i></tt><i>

to initialize the class properties.<br>

Start the </i><tt><i>main</i></tt><i>

namespace.<br>

Call the constructor for the </i><tt><i>Inventory_item</i></tt><i>

class. Assign the object refereNCe to </i><tt><i>$item</i></tt><i>.

<br>

Print the two property values using the </i><tt><i>lookup()</i></tt><i>

method to verify that the property initialization worked.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 14.6&nbsp;&nbsp;14LST06.PL-Using a Static Method to

Retrieve Class Properties<br>

</b>

</blockquote>

<blockquote>

<pre>

package UNIVERSAL;

    sub lookup {

        return(%{$_[0]}-&gt;{$_[1]});

    }



package Inventory_item;

    sub new {

        my($class)  = shift;

        my(%params) = @_;

        my($self)   = { };

                             

        $self-&gt;{&quot;PART_NUM&quot;}    = $params{&quot;PART_NUM&quot;};

        $self-&gt;{&quot;QTY_ON_HAND&quot;} = $params{&quot;QTY_ON_HAND&quot;};



        return(bless($self, $class));

    }



package main;



    $item = Inventory_item-&gt;new(&quot;PART_NUM&quot;=&gt;&quot;12A-34&quot;, &quot;QTY_ON_HAND&quot;=&gt;34);



    print(&quot;The part number is &quot; . $item-&gt;lookup('PART_NUM')     . &quot;\n&quot;);

    print(&quot;The quantity is &quot;    . $item-&gt;lookup('QTY_ON_HAND')  . &quot;\n&quot;);

</pre>

</blockquote>

<hr>

<p>

I don't think this example needs any further explanation, so let's

use the space normally reserved to further discussion of the listing

and show you another utility fuNCtion instead. The <tt>printAll()</tt>

fuNCtion shown here displays all the properties of a class, or

you can specify one or more properties to display:

<blockquote>

<pre>

sub printAll {

    my($self) = shift;

    my(@keys) = @_ ? @_ : sort(keys(%{$self}));



    print(&quot;CLASS: $self\n&quot;);

    foreach $key (@keys) {

        printf(&quot;\t%10.10s =&gt; $self-&gt;{$key}\n&quot;, $key);

    }

}

</pre>

</blockquote>

<p>

If you put this fuNCtion into the <tt>UNIVERSAL</tt>

package, it will be available to any classes you define.

<p>

After constructing an inventory object, the statement <tt>$item-&gt;printAll();</tt>

might display

<blockquote>

<pre>

CLASS: Inventory_item=HASH(0x77ceac)

          PART_NUM =&gt; 12A-34

        QTY_ON_HAN =&gt; 34

</pre>

</blockquote>

<p>

and the statement <tt>$item-&gt;printAll('PART_NUM');</tt>

might display

<blockquote>

<pre>

CLASS: Inventory_item=HASH(0x77ceac)

          PART_NUM =&gt; 12A-34

</pre>

</blockquote>

<h2><a NAME="Summary"><font SIZE="5" COLOR="#FF0000">

Summary</font></a></h2>

<p>

This chapter served as an introduction to objects. It was not

intended to turn you into an overnight object guru. I hope that

enough information was presented so you have an understanding

of the object terminology and can read other people's programs.

You can also create your own methods and properties. However,

if you need to create more than a few small objects, consider

reading a book devoted specifically to object-oriented programming.

I give this advice because the relationships between objects can

become complex quickly when more than five objects are being used.

<p>

You learned earlier in the chapter that object-oriented programming

has its own terminology. This terminology lets you think of objects

in a computer language independent manner. After describing the

object or class as a set of properties (information) and methods

(fuNCtions), the class can be programmed using C++, Perl, or Delphi.

The programming language is relegated to the role of an implementation

detail.

<p>

The four big coNCepts in object-oriented programming are abstraction,

eNCapsulation, inheritaNCe, and polymorphism. Abstraction means

to isolate the access of a property from how it's stored. ENCapsulation

means that properties and the methods that act on them are defined

together. InheritaNCe means that one class (the child) can be

derived from another (the parent), and the child class will have

all the properties and methods defined in the parent. Polymorphism

means that the child class can override properties and methods

defined in the parent simply by using the same property or method

name.

<p>

After defining these words, you read about creating some classes

for an inventory system; the <tt>Inventory_item</tt>

and <tt>Pen</tt> classes were described.

The <tt>Pen</tt> class was derived

from the <tt>Inventory_item</tt> class.

These classes were used in examples to show how abstraction and

polymorphism work.

<p>

Next, you looked at object-oriented Perl scripts. You read that

it's good to keep all class property information in anonymous

hashes and that the <tt>bless()</tt>

fuNCtion is used to change the data type of a variable-even anonymous

ones.

<p>

You saw how to initialize properties by passing values to the

<tt>new()</tt> constructor fuNCtion.

With this technique, you can use named parameters and therefore

create partially initialized objects if needed. Child classes

in Perl will not automatically inherit properties from its parents.

However, using anonymous hashes totally avoids this issue because

the parent constructor can be explicitly called to create the

object. Then, the child can simply add entries to the anonymous

hash.

<p>

You saw an example of how one class can contain another. The <tt>Pen</tt>

class used this technique to hold an instaNCe of the <tt>Color</tt>

class.

<p>

Static variables and methods are independent of any specific object.

For example, the <tt>Color</tt> class

used a static hash to hold values for the colors blue and red.

Static variables can be accessed using the notation <tt>$Color::colors{&quot;blue&quot;}</tt>.

Of course, only static hash variables use this notation, but scalars

and arrays are accessed similarly. You can use static methods

like <tt>new()</tt> to create new

instaNCes of a class.

<p>

You also saw that the <tt>@ISA</tt>

array is used to hold a list of parent classes for the base class.

In addition, you learned that the <tt>UNIVERSAL</tt>

class is invisibly added to the end of the <tt>@ISA</tt>

array-making it the the last class searched for an undefined method.

The <tt>AUTOLOAD()</tt> method is

normally used to load undefined methods; however, in this chapter,

it was used instead to display an error message telling which

method is undefined and the base class in which it should be defined.

<p>

The next chapter discusses modules. You see that classes are a

specific use of the general module fuNCtionality and how to store

module (and class) definition in different script files. You also

see how to use some of the prewritten modules available in your

Perl distribution files and on the Internet.

<h2><a NAME="ReviewQuestions"><font SIZE="5" COLOR="#FF0000">

Review Questions</font></a></h2>

<p>

Answers to Review Questions are in Appendix A.

<ol>

<li>What is an object?

<li>What is a class?

<li>What is a property?

<li>What does the term <i>polymorphism</i> mean?

<li>Is the <tt>bless()</tt> fuNCtion

used to create classes?

<li>What does the <tt>package</tt>

keyword do?

<li>What can a static variable be used for?

<li>Why is it good to use anonymous hashes to represent objects

instead of regular arrays?

<li>How can you create a fuNCtion that is available to all classes

in your script?

</ol>

<h2><a NAME="ReviewExercises"><font SIZE="5" COLOR="#FF0000">

Review Exercises</font></a></h2>

<ol>

<li>Design an object model of a car. Create objects for the car,

tires, and doors.

<li>Extend the inventory model shown in Figure 14.3 to iNClude

three other objects.

<li>Extend the program in Listing 14.2 to add a third property

to the <tt>Pen</tt> class.

<li>Extend the car model from Exercise 1 to iNClude motorcycle

objects. Pay special attention to assumptions you may have made

in your original model. Are these still valid assumptions?

<li>By using the program in Listing 14.2, create a child of <tt>Pen</tt>

that can hold two different ink colors.

</ol>

<hr>



<center><p><a HREF="ch13.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch13.htm"><img SRC="pc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="#CONTENTS"><img SRC="cc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/cc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="index-1.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/index-1.htm"><img SRC="hb.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/hb.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="ch15.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch15.htm"><img SRC="nc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/nc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<hr WIDTH="100%"></p></center>

</body>

</html>

