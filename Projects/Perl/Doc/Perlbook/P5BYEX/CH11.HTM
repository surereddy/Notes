<html>

<head>

<title>Chapter 11  -- Creating Reports</title>



<meta>

</head>

<body TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">

<h1><font SIZE="6" COLOR="#FF0000">Chapter&nbsp;11</font></h1>

<h1><font SIZE="6" COLOR="#FF0000">Creating Reports</font></h1>

<hr>

<p>

<center><b><font SIZE="5">CONTENTS</font></b></center>

<ul>

<li><a HREF="#WhatsaFormatStatement">

What's a Format Statement?</a>

<ul>

<li><a HREF="#ExampleUsingFieldLines">

Example: Using Field Lines</a>

<li><a HREF="#ExampleReportHeadings">

Example: Report Headings</a>

<li><a HREF="#ExampleUsingFuNCtionsintheValueLine">

Example: Using FuNCtions in the Value Line</a>

<li><a HREF="#ExampleChangingFormats">

Example: Changing Formats</a>

<li><a HREF="#ExampleUsingLongPiecesofTextinReports">

Example: Using Long Pieces of Text in Reports</a>

<li><a HREF="#ExampleWritingtoaFileInsteadofISTDOUTI">

Example: Writing to a File Instead of <i>STDOUT</i></a>

</ul>

<li><a HREF="#Summary">

Summary</a>

<li><a HREF="#ReviewQuestions">

Review Questions</a>

<li><a HREF="#ReviewExercises">

Review Exercises</a>

</ul>



<hr>

<p>

Perl has a few special features that let you create simple reports.

The reports can have a header area where you can place a title,

page number, and other information that stays the same from one

page to the next. Perl will track how many lines have been used

in the report and automatically generate new pages as needed.

<p>

Compared to learning about regular expressions, learning how to

create reports will be a breeze. There are only a few tricky parts,

which I'll be sure to point out.

<p>

This chapter starts out by using the print() fuNCtion to display

a CD collection and then gradually moves from displaying the data

to a fully formatted report. The data file shown in Listing 11.1

is used for all of the examples in this chapter. The format is

pretty simple: the CD album's title, the artist's name, and the

album's price.

<hr>

<blockquote>

<b>Listing 11.1&nbsp;&nbsp;FORMAT.DAT-The Data File<br>

</b>

</blockquote>

<blockquote>

<pre>

The Lion King!

Tumbleweed Connection!Elton John!123.32

Photographs &amp; Memories!Jim Croce!4.95

Heads &amp; Tales!Harry Chapin!12.50

</pre>

</blockquote>

<hr>

<p>

You'll find that Perl is very handy for small text-based data

files like this. You can create them in any editor and use any

field delimiter you like. In this file, I used an exclamation

point to delimit the field. However, I could just as easily have

used a caret, a tilde, or any other character.

<p>

Now that we have some data, let's look at Listing 11.2, which

is a program that reads the data file and displays the information.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Open the </i><tt><i>FORMAT.DAT</i></tt><i>

file.<br>

<i>Read all the file's lines and place them in the </i></i><tt><i>@lines</i></tt><i>

array. Each line becomes a different element in the array.<br>

Close the file.<br>

Iterate over the </i><tt><i>@lines</i></tt><i>

array. </i><tt><i>$_</i></tt><i> is

set to a different array element each time through the loop.<br>

Remove the linefeed character from the end of the string.<br>

Split the string into three fields using the exclamation point

as the delimiter. Place each field into the </i><tt><i>$album</i></tt><i>,

</i><tt><i>$artist</i></tt><i>, and

</i><tt><i>$price</i></tt><i> variables.

<br>

Print the variables.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 11.2&nbsp;&nbsp;11LIST02.PL-A Program to Read and Display

the Data File<br>

</b>

</blockquote>

<blockquote>

<pre>

open(FILE, &quot;&lt;format.dat&quot;);

@lines = &lt;FILE&gt;;

close(FILE);



foreach (@lines) {

    chop;

    ($album, $artist, $price) = (split(/!/));

    print(&quot;Album=$album   Artist=$artist   Price=$price\n&quot;);

}

</pre>

</blockquote>

<hr>

<p>

This program displays:

<blockquote>

<pre>

Use of uninitialized value at 11lst02.pl line 8.

Album=The Lion King   Artist=   Price=

Album=Tumbleweed Connection   Artist=Elton John   Price=123.32

Album=Photographs &amp; Memories   Artist=Jim Croce   Price=4.95

Album=Heads &amp; Tales   Artist=Harry Chapin   Price=12.50

</pre>

</blockquote>

<p>

Why is an error being displayed on the first line of the output?

If you said that the split() fuNCtion was returning the undefined

value when there was no matching field in the input file, you

were correct. The first input line was the following:

<blockquote>

<pre>

The Lion King!

</pre>

</blockquote>

<p>

There are no entries for the <tt>Artist</tt>

or <tt>Price</tt> fields. Therefore,

the <tt>$artist </tt>and <tt>$price</tt>

variables were assigned the undefined value, which resulted in

Perl complaining about uninitialized values. You can avoid this

problem by assigning the empty string to any variable that has

the undefined value. Listing 11.3 shows a program that does this.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Open the </i><tt><i>FORMAT.DAT</i></tt><i>

file, read all the lines into </i><tt><i>@lines</i></tt><i>,

and then close the file.<br>

<i>Iterate over the </i></i><tt><i>@lines</i></tt><i>

array.<br>

Remove the linefeed character.<br>

Split the string into three fields.<br>

If any of the three fields is not present in the line, provide

a default value of an empty string.<br>

Print the variables.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 11.3&nbsp;&nbsp;11LST03.PL-How to Avoid the Uninitialized

Error When Using the <i>Split()</i> FuNCtion<br>

</b>

</blockquote>

<blockquote>

<pre>

open(FILE, &quot;&lt;format.dat&quot;);

@lines = &lt;FILE&gt;;

close(FILE);



foreach (@lines) {

    chop;

    ($album, $artist, $price) = (split(/!/));

    $album  = &quot;&quot; if !defined($album);  These lines assign null

    $artist = &quot;&quot; if !defined($artist); strings if no info is

    $price  = &quot;&quot; if !defined($price);  present in the record.

    print(&quot;Album=$album   Artist=$artist   Price=$price\n&quot;);

}

The first four lines this program displays are the following:



Album=The Lion King   Artist=   Price=

Album=Tumbleweed Connection   Artist=Elton John   Price=123.32

Album=Photographs &amp; Memories   Artist=Jim Croce   Price=4.95

Album=Heads &amp; Tales   Artist=Harry Chapin   Price=12.50

</pre>

</blockquote>

<hr>

<p>

The error has been eliminated, but it is still very hard to read

the output because the columns are not aligned. The rest of this

chapter is devoted to turning this jumbled output into a report.

<p>

Perl reports have <i>heading</i> and have <i>detail lines</i>.

A heading is used to identify the report title, the page number,

the date, and any other information that needs to appear at the

top of each page. Detail lines are used to show information about

each record in the report. In the data file being used for the

examples in this chapter (refer to Listing 11.1), each CD has

its own detail line.

<p>

Headings and detail lines are defined by using format statements,

which are discussed in the next section.

<h2><a NAME="WhatsaFormatStatement"><font SIZE="5" COLOR="#FF0000">

What's a Format Statement?</font></a></h2>

<p>

Perl uses <i>formats</i> as guidelines when writing report information.

A format is used to tell Perl what static text is needed and where

variable information should be placed. Formats are defined by

using the <tt>format</tt> statement.

The syntax for the <tt>format</tt>

statement is

<blockquote>

<pre>

format FORMATNAME =

    FIELD_LINE

    VALUE_LINE

</pre>

</blockquote>

<p>

The <tt>FORMATNAME</tt> is usually

the same name as the file handle that is used to accept the report

output. The section &quot;Example: Changing Formats,&quot; later

in this chapter, talks about using the <tt>format</tt>

statement where the <tt>FORMATNAME</tt>

is different from the file handle. If you don't specify a <tt>FORMATNAME</tt>,

Perl uses <tt>STDOUT</tt>. The <tt>FIELD_LINE</tt>

part of the format statement consists of text and field holders.

A <i>field holder</i> represents a given line width that Perl

will fill with the value of a variable. The <tt>VALUE_LINE</tt>

line consists of a comma-delimited list of expressions used to

fill the field holders in <tt>FIELD_LINE</tt>.

<p>

Report headings, which appear at the top of each page, have the

following format:

<blockquote>

<pre>

format FORMATNAME_TOP =

    FIELD_LINE

    VALUE_LINE

</pre>

</blockquote>

<p>

Yes, the only differeNCe between a detail line and a heading is

that <tt>_TOP</tt> is appended to

the <tt>FORMATNAME</tt>.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

The location of <tt>format</tt> statements is unimportant because they define only a format and never are executed. I feel that they should appear either at the beginning of a program or the end of a program, rarely in the middle. Placing <tt>format</tt> 
statements in the middle of your program might make them hard to find when they need to be changed. Of course, you should be consistent where you place them.

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

A typical <tt>format</tt> statement

might look like this:

<blockquote>

<pre>

format =

    The total amount is $@###.##

                         $total

</pre>

</blockquote>

<p>

The  at character @ is used to start a field holder. In this example,

the field holder is seven characters long (the at sign and decimal

point count, as well as the pound signs #). The next section,

&quot;Example: Using Field Lines,&quot; goes into more detail

about field lines and field holders.

<p>

<tt>Format</tt> statements are used

only when invoked by the write() fuNCtion. The write() fuNCtion

takes only one parameter: a file handle to send output to. Like

many things in Perl, if no parameter is specified, a default is

provided. In this case, STDOUT will be used when no FORMATNAME

is specified. In order to use the preceding format, you simply

assign a value to $total and then call the write() fuNCtion. For

example:

<blockquote>

<pre>

$total = 243.45

write();

$total = 50.00

write();

</pre>

</blockquote>

<p>

These lines will display:

<blockquote>

<pre>

    The total amount is $  243.45

    The total amount is $   50.50

</pre>

</blockquote>

<p>

The output will be sent to STDOUT. Notice that the decimal points

are automatically lined up when the lines are displayed.

<h3><a NAME="ExampleUsingFieldLines">

Example: Using Field Lines</a></h3>

<p>

The field lines of a <tt>format</tt>

statement control what is displayed and how. The simplest field

line contains only static text. You can use <i>static</i> or uNChanging

text as labels for variable information, dollar signs in front

of amounts, a separator character such as a comma between first

and last name, or whatever else is needed. However, you'll rarely

use just static text in your format statement. Most likely, you'll

use a mix of static text and field holders.

<p>

You saw a field holder in action in the last section in which

I demonstrated sending the report to STDOUT. I'll repeat the format

statement here so you can look at it in more detail:

<blockquote>

<pre>

format =

    The total amount is $@###.##

                         $total

</pre>

</blockquote>

<p>

The character sequeNCe <tt>The total amount

is $</tt> is static text. It will not change no matter

how many times the report is printed. The character sequeNCe @###.##,

however, is a field holder. It reserves seven spaces in the line

for a number to be inserted. The third line is the value line;

it tells Perl which variable to use with the field holder. Table

11.1 contains a list of the different format characters you can

use in field lines.<br>

<p>

<center><b>Table 11.1&nbsp;&nbsp;Field Holder Formats</b></center>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td WIDTH="133"><center><i>Format Character</i></center></td>

<td WIDTH="457"><center><i>Description</i></center></td></tr>

<tr><td WIDTH="133"><center><tt>@</tt></center>

</td><td WIDTH="457">This character represents the start of a field holder.

</td></tr>

<tr><td WIDTH="133"><center><tt>&lt;</tt></center>

</td><td WIDTH="457">This character indicates that the field should be left-justified.

</td></tr>

<tr><td WIDTH="133"><center><tt>&gt;</tt></center>

</td><td WIDTH="457">This character indicates that the field should be right-justified.

</td></tr>

<tr><td WIDTH="133"><center><tt>|</tt></center>

</td><td WIDTH="457">This character indicates that the field should be centered.

</td></tr>

<tr><td WIDTH="133"><center><tt>#</tt></center>

</td><td WIDTH="457">This character indicates that the field will be numeric. If used as the first character in the line, it indicates that the entire line is a comment.

</td></tr>

<tr><td WIDTH="133"><center><tt>.</tt></center>

</td><td WIDTH="457">This character indicates that a decimal point should be used with numeric fields.

</td></tr>

<tr><td WIDTH="133"><center><tt>^</tt></center>

</td><td WIDTH="457">This character also represents the start of a field holder. Moreover, it tells Perl to turn on word-wrap mode. See the section &quot;Example: Using Long Pieces of Text in Reports&quot; later in this chapter for more information about 
word-wrapping.

</td></tr>

<tr><td WIDTH="133"><center><tt>~</tt></center>

</td><td WIDTH="457">This character indicates that the line should not be written if it is blank.

</td></tr>

<tr><td WIDTH="133"><center><tt>~~</tt></center>

</td><td WIDTH="457">This sequeNCe indicates that lines should be written as needed until the value of a variable is completely written to the output file.

</td></tr>

<tr><td WIDTH="133"><center><tt>@*</tt></center>

</td><td WIDTH="457">This sequeNCe indicates that a multi-line field will be used.

</td></tr>

</table>

</center>

<p>

<p>

Let's start using some of these formatting characters by formatting

a report to display information about the <tt>FORMAT.DAT</tt>

file we used earlier. The program in Listing 11.4 displays the

information in nice, neat columns.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Declare a format for the STDOUT file handle.<br>

Open the </i><tt><i>FORMAT.DAT</i></tt><i>

file, read all the lines into </i><tt><i>@lines</i></tt><i>,

and then close the file.<br>

Iterate over the </i><tt><i>@lines</i></tt><i>

array.<br>

Remove the linefeed character.<br>

Split the string into three fields.<br>

If any of the three fields is not present in the line, provide

a default value of an empty string. Notice that a numeric value

must be given to </i><tt><i>$price</i></tt><i>

instead of the empty string.<br>

Invoke the </i><tt><i>format</i></tt><i>

statement by using the </i><tt><i>write()</i></tt><i>

fuNCtion.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 11.4&nbsp;&nbsp;11LST04.PL-Using a Format with <i>STDOUT

<br>

</i></b>

</blockquote>

<blockquote>

<pre>

format =

  Album=@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  Artist=@&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Price=$@##.##

        $album,                $artist,              $price

.



open(FILE, &quot;&lt;format.dat&quot;);

@lines = &lt;FILE&gt;;

close(FILE);



foreach (@lines) {

    chop;

    ($album, $artist, $price) = (split(/!/));

    $album  = &quot;&quot; if !defined($album);

    $artist = &quot;&quot; if !defined($artist);

    $price  = 0 if !defined($price);

    write();

}

</pre>

</blockquote>

<hr>

<p>

This program displays the following:

<blockquote>

<pre>

  Album=The Lion King   Artist=               Price=$  0.00

  Album=Tumbleweed Con  Artist=   Elton John  Price=$123.32

  Album=Photographs &amp;   Artist=    Jim Croce  Price=$  4.95

  Album=Heads &amp; Tales   Artist= Harry Chapin  Price=$ 12.50

</pre>

</blockquote>

<p>

You can see that the columns are now neatly aligned. This was

done with the format statement and the write() fuNCtion. The format

statement used in this example used three field holders. The first

field holder, @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;,

created a left-justified spot for a 14-character-wide field filled

by the value in $album. The second field holder, @&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;,

created a right-justified spot for a 12-character-wide field filled

by the value in $artist. The last field holder, @##.##, created

a six-character-wide field filled by the numeric value in $price.

<p>

You might think it's wasteful to have the field labels repeated

on each line, and I would agree with that. Instead of placing

field labels on the line, you can put them in the report heading.

The next section discusses how to do this.

<h3><a NAME="ExampleReportHeadings">

Example: Report Headings</a></h3>

<p>

<tt>Format</tt> statements for a report

heading use the same format as the detail line <tt>format</tt>

statement, except that <tt>_TOP</tt>

is appended to the file handle. In the case of <tt>STDOUT</tt>,

you must specify <tt>STDOUT_TOP</tt>.

Simply using <tt>_TOP</tt> will not

work.

<p>

To add a heading to the report about the CD collection, you might

use the following <tt>format</tt>

statement:

<blockquote>

<pre>

format STDOUT_TOP =

  @||||||||||||||||||||||||||||||||||||  Pg @&lt;

  &quot;CD Collection of David Medinets&quot;,        $%



  Album              Artist            Price

  -----------------  ----------------  -------

.

</pre>

</blockquote>

<p>

Adding this format statement to Listing 11.4 produces this output:

<blockquote>

<pre>

      CD Collection of David Medinets     Pg 1



  Album              Artist            Price

  -----------------  ----------------  -------

  The Lion King                        $  0.00

  Tumbleweed Connec  Elton John        $123.32

  Photographs &amp; Mem  Jim Croce         $  4.95

  Heads &amp; Tales      Harry Chapin      $ 12.50

</pre>

</blockquote>

<p>

Whenever a new page is generated, the heading format is automatically

invoked. Normally, a page is 60 lines long. However, you can change

this by setting the $= special variable.

<p>

Another special variable, $%, holds the current page number. It

will be initialized to zero when your program starts. Then, just

before invoking the heading format, it is iNCremented so its value

is one. You can change $% if you need to change the page number

for some reason.

<p>

You might notice that the | formatting character was used to center

the report title over the columns. You also might notice that

placing the field labels into the heading allows the columns to

be expanded in width.

<p>

Unfortunately, Perl does not truly have any facility for adding

footer detail lines. However, you can try a bit of &quot;magic&quot;

in order to fool Perl into creating footers with static text.

The <tt>$^L</tt> variable holds the

string that Perl writes before every report page except for the

first, and the <tt>$=</tt> variable

holds the number of lines per page. By changing <tt>$^L</tt>

to hold your footer and by reducing the value in <tt>$=</tt>

by the number of lines your footer will need, you can create primitive

footers. Listing 11.5 displays the CD collection report on two

pages by using this technique.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Declare a format for the </i><tt><i>STDOUT

</i></tt><i>file handle.<br>

Declare a heading format for the </i><tt><i>STDOUT

</i></tt><i>file handle.<br>

Open the </i><tt><i>FORMAT.DAT</i></tt><i>

file, read all the lines into </i><tt><i>@lines</i></tt><i>,

and then close the file.<br>

Assign a value of </i><tt><i>6</i></tt><i>

to </i><tt><i>$=</i></tt><i>. Normally,

it has a value of </i><tt><i>60</i></tt><i>.

Changing the value to </i><tt><i>6</i></tt><i>

will create very short pages-ideal for small example programs.

<br>

Assign a string to </i><tt><i>$^L</i></tt><i>,

which usually is equal to the form-feed character. The form-feed

character causes printers to eject a page.<br>

Iterate over the </i><tt><i>@lines</i></tt><i>

array.<br>

Remove the linefeed character.<br>

Split the string into three fields.<br>

If any of the three fields is not present in the line, provide

a default value of an empty string. Notice that a numeric value

must be given to </i><tt><i>$price</i></tt><i>

 instead of the empty string.<br>

Invoke the </i><tt><i>format</i></tt><i>

statement using the </i><tt><i>write()</i></tt><i>

fuNCtion.<br>

Print the footer on the last page. You need to explicitly do this

because the last page of the report probably will not be a full

page.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 11.5&nbsp;&nbsp;11LST05.PL-Tricking Perl into Creating

Primitive Footers<br>

</b>

</blockquote>

<blockquote>

<pre>

format =

  Album=@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  Artist=@&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Price=$@##.##

        $album,                $artist,              $price

.



format STDOUT_TOP =

  @||||||||||||||||||||||||||||||||||||  Pg @&lt;

  &quot;CD Collection of David Medinets&quot;,        $%



  Album              Artist            Price

  -----------------  ----------------  -------

.



open(FILE, &quot;&lt;format.dat&quot;);

@lines = &lt;FILE&gt;;

close(FILE);



$= = 6;



$^L = '-' x 60 . &quot;\n&quot; .

      &quot;Copyright, 1996, Eclectic Consulting\n&quot; .

      &quot;\n\n&quot;;



foreach (@lines) {

    chop();

    ($album, $artist, $price) = (split(/!/));

    $album  = &quot;&quot; if !defined($album);

    $artist = &quot;&quot; if !defined($artist);

    $price  = 0 if !defined($price);

    write();

}



print(&quot;$^L&quot;);

</pre>

</blockquote>

<hr>

<p>

This program displays the following:

<blockquote>

<pre>

     CD Collection of David Medinets     Pg 1



  Album              Artist            Price

  -----------------  ----------------  -------

  Album=The Lion King   Artist=               Price=$  0.00

  Album=Tumbleweed Con  Artist=   Elton John  Price=$123.32

------------------------------------------------------------

Copyright, 1996, Eclectic Consulting





     CD Collection of David Medinets     Pg 2



  Album              Artist            Price

  -----------------  ----------------  -------

  Album=Photographs &amp;   Artist=    Jim Croce  Price=$  4.95

  Album=Heads &amp; Tales   Artist= Harry Chapin  Price=$ 12.50

------------------------------------------------------------

Copyright, 1996, Eclectic Consulting

</pre>

</blockquote>

<p>

Let me explain the assignment to $^L in more detail. The assignment

is duplicated here for your convenieNCe:

<blockquote>

<pre>

$^L = '-' x 60 . &quot;\n&quot; .

      &quot;Copyright, 1996 by Eclectic Consulting\n&quot; .

      &quot;\n\n&quot;;

</pre>

</blockquote>

<p>

The first part of the assignment, '-' x 60, creates a line of

60 dash characters. Then a newline character is coNCatenated to

the line of dashes. Next, the copyright line is appended. Finally,

two more linefeeds are appended to separate the two pages of output.

Normally, you wouldn't add the ending linefeeds because the form-feed

character makes them unnecessary. Here's how the code would look

when designed to be sent to a printer:

<blockquote>

<pre>

$^L = '-' x 60 . &quot;\n&quot; .

      &quot;Copyright, 1996 by Eclectic Consulting&quot; .

      &quot;\014&quot;;

</pre>

</blockquote>

<p>

The &quot;\014&quot; string is the equivalent of a form-feed character

because the ASCII value for a form-feed is 12, which is 14 in

octal notation.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

I feel that it's important to say that the coding style in this example is not really recommended for &quot;real&quot; programming. I coNCatenated each footer element separately so I could discuss what each element did. The last three elements in the 
footer assignment probably should be placed inside one string literal for efficieNCy.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Tip</b></td></tr>

<tr><td>

<blockquote>

This example is somewhat iNComplete. If the last page of the report ends at line 20 and there are 55 lines per page, simply printing the <tt>$^L</tt> variable will not place the footer at the bottom of the page. Instead, the footer will appear after line 
20. This probably is not the behavior you would like. Try the following statement to fix this problem:

</blockquote>

<blockquote>

<tt>print(&quot;\n&quot; x $- . &quot;$^L&quot;);</tt>

</blockquote>

<blockquote>

This will coNCatenate enough linefeeds to the beginning of the <tt>footer</tt> variable to place the footer at the bottom of the page.

</blockquote>



</td></tr>

</table>

</center>

<p>

<h3><a NAME="ExampleUsingFuNCtionsintheValueLine">

Example: Using FuNCtions in the Value Line</a></h3>

<p>

You've already seen the value line in action. Most of the time,

its use will be very simple: create the field holder in the field

line and then put the variable name in the value line. But there

are some other value line capabilities you should know about.

In addition to simple scalar variables, you can specify array

variables and even fuNCtions on the value line. Listing 11.6 shows

a program that uses a fuNCtion to add ellipses to a string if

it is too wide for a column.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Declare a format for the </i><tt><i>STDOUT

</i></tt><i>file handle. In this example, the value line

calls the </i><tt><i>dotize()</i></tt><i>

fuNCtion.<br>

Declare a heading format for the </i><tt><i>STDOUT</i></tt><i>

file handle.<br>

Declare the </i><tt><i>dotize()</i></tt><i>

fuNCtion.<br>

Initialize local variables called </i><tt><i>$width</i></tt><i>

and </i><tt><i>$string</i></tt><i>.

<br>

If the width of </i><tt><i>$string</i></tt><i>

is greater than </i><tt><i>$width</i></tt><i>,

return a value that consists of </i><tt><i>$string</i></tt><i>

shortened to </i><tt><i>$width-3</i></tt><i>

with </i><tt><i>...</i></tt><i> appended

to the end; otherwise, return </i><tt><i>$string</i></tt><i>.

<br>

Open the </i><tt><i>FORMAT.DAT</i></tt><i>

file, read all the lines into </i><tt><i>@lines</i></tt><i>,

and then close the file.<br>

Iterate over the </i><tt><i>@lines</i></tt><i>

array.<br>

Remove the linefeed character.<br>

Split the string into three fields.<br>

If any of the three fields is not present in the line, provide

a default value of an empty string. Notice that a numeric value

must be given to </i><tt><i>$price</i></tt><i>

instead of the empty string.<br>

Invoke the </i><tt><i>format</i></tt><i>

statement by using the </i><tt><i>write()</i></tt><i>

fuNCtion.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 11.6&nbsp;&nbsp;11LIST05.PL-Using a FuNCtion with a

Value Line<br>

</b>

</blockquote>

<blockquote>

<pre>

format =

  @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  $@##.##

  dotize(17, $album), dotize(16, $artist), $price

.



format STDOUT_TOP =

  @||||||||||||||||||||||||||||||||||||  Pg @&lt;

  &quot;CD Collection of David Medinets&quot;,        $%



  Album              Artist            Price

  -----------------  ----------------  -------

.



sub dotize {

    my($width, $string) = @_;



    if (length($string) &gt; $width) {

        return(substr($string, 0, $width - 3) . &quot;...&quot;);

    }

    else {

        return($string);

    }

}



open(FILE, &quot;&lt;format.dat&quot;);

@lines = &lt;FILE&gt;;

close(FILE);



foreach (@lines) {

    chop();

    ($album, $artist, $price) = (split(/!/));

    $album  = &quot;&quot; if !defined($album);

    $artist = &quot;&quot; if !defined($artist);

    $price  = 0 if !defined($price);

    write();

}

</pre>

</blockquote>

<hr>

<p>

This program displays the following:

<blockquote>

<pre>

      CD Collection of David Medinets     Pg 1



  Album              Artist            Price

  -----------------  ----------------  -------

  The Lion King                        $  0.00

  Tumbleweed Con...  Elton John        $123.32

  Photographs &amp; ...  Jim Croce         $  4.95

  Heads &amp; Tales      Harry Chapin      $ 12.50

</pre>

</blockquote>

<p>

The second and third detail lines have benefited from the dotize()

fuNCtion. You can use a similar technique to invoke any fuNCtion

in the value line. You also can use expressions directly in the

value line, but it might be harder to maintain because the intent

of the expression might not be clear.

<h3><a NAME="ExampleChangingFormats">

Example: Changing Formats</a></h3>

<p>

So far, you've seen only how to use a single format statement

per report. If Perl could handle only one format per report, it

wouldn't have much utility as a reporting tool. Fortunately, by

using the <tt>$~</tt> special variable,

you can control which format is used for any given <tt>write()</tt>

fuNCtion call. Listing 11.7 shows a program that tracks the price

of the CDs in the collection and displays the total using an alternate

<tt>format</tt> statement.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Declare a format for the </i><tt><i>STDOUT</i></tt><i>

file handle.<br>

Declare a format for the total price information.<br>

Declare a heading format for the </i><tt><i>STDOUT</i></tt><i>

file handle.<br>

Declare the </i><tt><i>dotize()</i></tt><i>

fuNCtion.<br>

Initialize local variables called </i><tt><i>$width</i></tt><i>

and </i><tt><i>$string</i></tt><i>.

<br>

If the width of </i><tt><i>$string</i></tt><i>

is greater than </i><tt><i>$width</i></tt><i>,

return a value that consists of </i><tt><i>$string</i></tt><i>

shortened to </i><tt><i>$width-3</i></tt><i>

with </i><tt><i>...</i></tt><i> appended

to the end; otherwise, return </i><tt><i>$string</i></tt><i>.

<br>

Open the </i><tt><i>FORMAT.DAT</i></tt><i>

file, read all the lines into </i><tt><i>@lines</i></tt><i>,

and then close the file.<br>

Initialize the </i><tt><i>$total</i></tt><i>

variable to zero.<br>

Iterate over the </i><tt><i>@lines</i></tt><i>

array.<br>

Remove the linefeed character.<br>

Split the string into three fields.<br>

Provide a default value for any empty variables.<br>

Invoke the </i><tt><i>format</i></tt><i>

statement by using the </i><tt><i>write()</i></tt><i>

fuNCtion.<br>

Change the current format by assigning a value to the </i><tt><i>$~</i></tt><i>

special variable.<br>

Invoke the </i><tt><i>format</i></tt><i>

statement by using the </i><tt><i>write()</i></tt><i>

fuNCtion.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 11.7&nbsp;&nbsp;11LST07.PL-Using an Alternative <i>format</i>

Statement<br>

</b>

</blockquote>

<blockquote>

<pre>

format =

  @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  $@###.##

  dotize(17, $album), dotize(16, $artist), $price

.



format STDOUT_TOTAL =

  ---------------------------------------------

                                       $@###.##

                                        $total

.



format STDOUT_TOP =

  @||||||||||||||||||||||||||||||||||||  Pg @&lt;

  &quot;CD Collection of David Medinets&quot;,        $%



  Album              Artist            Price

  -----------------  ----------------  --------

.



sub dotize {

    my($width, $string) = @_;



    if (length($string) &gt; $width) {

        return(substr($string, 0, $width - 3) . &quot;...&quot;);

    }

    else {

        return($string);

    }

}



open(FILE, &quot;&lt;format.dat&quot;);

@lines = &lt;FILE&gt;;

close(FILE);



$total = 0;

foreach (@lines) {

    chop();

    ($album, $artist, $price) = (split(/!/));

    $album  = &quot;&quot; if !defined($album);

    $artist = &quot;&quot; if !defined($artist);

    $price  = 0 if !defined($price);

    write();

    $total += $price;

}



$~ = &quot;STDOUT_TOTAL&quot;;

write();

</pre>

</blockquote>

<hr>

<p>

This program displays the following:

<blockquote>

<pre>

    CD Collection of David Medinets     Pg 1



  Album              Artist            Price

  -----------------  ----------------  --------

  The Lion King                        $   0.00

  Tumbleweed Con...  Elton John        $ 123.32

  Photographs &amp; ...  Jim Croce         $   4.95

  Heads &amp; Tales      Harry Chapin      $  12.50

  ---------------------------------------------

                                       $ 140.77

</pre>

</blockquote>

<p>

This example shows you how to keep a running total and how to

switch to an alternative detail line format. If you need to switch

to an alternative heading format, assign the new header format

name to the <tt>$^</tt> special variable.

<h3><a NAME="ExampleUsingLongPiecesofTextinReports">

Example: Using Long Pieces of Text in Reports</a></h3>

<p>

By using the <tt>^</tt>, <tt>~</tt>,

and <tt>~~</tt> formatting characters

in your <tt>format</tt> statements,

you can use long pieces of text in a report: for example, the

first paragraph of a paper's abstract or some notes associated

with a database record. Listing 11.8 shows a program that prints

the definition of a word. The definition is too long to fit in

one column, so the <tt>^</tt> formatting

character is used to split the text onto multiple lines.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Declare a format for the </i><tt><i>STDOUT</i></tt><i>

file handle. The field and value lines are repeated enough times

to print the entire length of the expected output.<br>

Initialize the </i><tt><i>$word</i></tt><i>

and </i><tt><i>$definition</i></tt><i>

variables. The </i><tt><i>$definition</i></tt><i>

variable is initialized by using coNCatenated strings to avoid

line breaks caused by the book printing process.<br>

A line of asterisks is printed.<br>

The format is invoked.<br>

Another line of asterisks is printed.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 11.8&nbsp;&nbsp;11LST08.PL-Using the <i>^</i> Formatting

Character to Print Long Text Values<br>

</b>

</blockquote>

<blockquote>

<pre>

format =

  ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

  $word,    $definition

  ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

  $word,    $definition

  ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

  $word,    $definition

  ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

  $word,    $definition

  ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

  $word,    $definition

  ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

  $word,    $definition

.



$word = &quot;outlier&quot;;



$definition = &quot;1. someone sleeping outdoors. &quot; .

    &quot;2. someone whose office is not at home. &quot; .

    &quot;3. an animal who strays from the fold. &quot; .

    &quot;4. something that has been separated from the main body.&quot;;



print(&quot;****************\n&quot;);

write();

print(&quot;****************\n&quot;);

</pre>

</blockquote>

<hr>

<p>

This program displays the following:

<blockquote>

<pre>

****************

  outlier   1. someone sleeping outdoors. 2.

            someone whose office is not at

            home. 3. an animal who strays from

            the fold. 4. something that has

            been separated from the main body.



****************

</pre>

</blockquote>

<p>

The <tt>^</tt> formatting character

causes Perl to do word-wrapping on the specified variable. <i>Word-wrapping</i>

means that Perl will accumulate words into a temporary buffer,

stopping when the next word will cause the length of the accumulated

string to exceed the length of the field. The accumulated string

is iNCorporated into the report, and the accumulated words are

removed from the variable. Therefore, the next time Perl looks

at the variable, it can start accumulating words that have not

been used yet.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

Any linefeed characters in the variable are ignored when the <tt>^</tt> formatting character is used in the <tt>format</tt> statement.

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Caution</b></td></tr>

<tr><td>

<blockquote>

Because the value of the variable used in the value line changes when word-wrapping is being used, make sure to use only copies of variables in the <tt>format</tt> statement. By using copies of the variables, you'll still have the original value available 
for further processing.

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

The asterisks in the preceding example were printed to show that

a blank line was printed by the format. This was caused because

the <tt>$definition</tt> variable

ran out of words before the format ran out of space. Extra blank

lines can be eliminated by placing the ~ character somewhere-usually

at the beginning or end-of the field line. The format statement

then would look like this:

<blockquote>

<pre>

format =

  ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ~

  $word,    $definition

  ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ~

  $word,    $definition

  ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ~

  $word,    $definition

  ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ~

  $word,    $definition

  ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ~

  $word,    $definition

  ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ~

  $word,    $definition

.

</pre>

</blockquote>

<p>

The new report would not have a blank line.

<blockquote>

<pre>

****************

  outlier   1. someone sleeping outdoors. 2.

            someone whose office is not at

            home. 3. an animal who strays from

            the fold. 4. something that has

            been separated from the main body.

****************

</pre>

</blockquote>

<p>

It is rather wasteful to have to repeat the field lines often

enough to account for the longest possible length of <tt>$definition</tt>.

In fact, if you are reading the definitions from a file, you might

not know how long the definitions could be ahead of time. Perl

provides the ~~ character sequeNCe to handle situations like this.

By placing ~~ on the field line, Perl will repeat the field line

as often as needed until a blank line would be printed. Using

this technique would change the <tt>format</tt>

statement to this:

<blockquote>

<pre>

format =

  ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ~~

  $word,    $definition

</pre>

</blockquote>

<p>

You might be wondering how Perl decides when a word ends. This

behavior is controlled by the <tt>$:</tt>

variable. The default value for <tt>$:</tt>

is a string consisting of the space, newline, and dash characters.

<h3><a NAME="ExampleWritingtoaFileInsteadofISTDOUTI">

Example: Writing to a File Instead of <i>STDOUT</i></a></h3>

<p>

Up to this point in the chapter, we've only looked at writing

a report to the display or <tt>STDOUT</tt>.

This was done to simplify and shorten the examples. Writing a

report to a file requires that you open a file for output and

specify the file handle as a parameter to the <tt>write()</tt>

fuNCtion. All fuNCtionality you've seen so far can be used with

files.

<p>

Listing 11.9 shows how easy it is to convert an existing program

from using <tt>STDOUT</tt> to using

a file. The program shown is a reworking of the program in Listing

11.4. Four changes needed to be made for the conversion. The <tt>format</tt>

statement was changed to specify a format name identical to the

file handle used in the second <tt>open()</tt>

statement. A second <tt>open()</tt>

statement was added. The <tt>write()</tt>

fuNCtion was changed to specify the file handle to use, and a

second <tt>close()</tt> statement

was added.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Declare a format for the </i><tt><i>CD_REPORT</i></tt><i>

file handle.<br>

Open the </i><tt><i>FORMAT.DAT</i></tt><i>

file, read all the lines into </i><tt><i>@lines</i></tt><i>,

and then close the file.<br>

Open the </i><tt><i>FORMAT.RPT</i></tt><i>

file for output to hold the report.<br>

Iterate over the </i><tt><i>@lines</i></tt><i>

array.<br>

Remove the linefeed character.<br>

Split the string into three fields.<br>

If any of the three fields is not present in the line, provide

a default value of an empty string. Notice that a numeric value

must be given to </i><tt><i>$price</i></tt><i>

instead of the empty string.<br>

Invoke the </i><tt><i>format</i></tt><i>

statement by using the </i><tt><i>write()</i></tt><i>

fuNCtion specifying the file handle to use.<br>

Close the </i><tt><i>FORMAT.RPT</i></tt><i>

file.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 11.9&nbsp;&nbsp;11LST09.PL-Using a Format with <i>STDOUT

<br>

</i></b>

</blockquote>

<blockquote>

<pre>

format CD _REPORT =

  Album=@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  Artist=@&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Price=$@##.##

        $album,                $artist,              $price

.



open(FILE, &quot;&lt;format.dat&quot;);

@lines = &lt;FILE&gt;;

close(FILE);



open(CD_REPORT, &quot;&gt;format.rpt&quot;);



foreach (@lines) {

    chop;

    ($album, $artist, $price) = (split(/!/));

    $album  = &quot;&quot; if !defined($album);

    $artist = &quot;&quot; if !defined($artist);

    $price  = 0 if !defined($price);

    write(CD_REPORT);

}

</pre>

</blockquote>

<hr>

<blockquote>

<pre>

close(CD_REPORT);

</pre>

</blockquote>

<p>

This program creates a file called FORMAT.RPT that contains the

following:

<blockquote>

<pre>

  Album=The Lion King   Artist=               Price=$  0.00

  Album=Tumbleweed Con  Artist=   Elton John  Price=$123.32

  Album=Photographs &amp;   Artist=    Jim Croce  Price=$  4.95

  Album=Heads &amp; Tales   Artist= Harry Chapin  Price=$ 12.50

</pre>

</blockquote>

<p>

The contents of FORMAT.RPT are identical to the display created

by the program in Listing 11.4.

<p>

Using more than one format in reports destined for files is slightly

more complicated than it was when STDOUT was used. The process

is more involved because you need to make the output file handle

the default file handle before setting the <tt>$~</tt>

or <tt>$^</tt> special variables.

Listing 11.10 shows how to use an alternative format statement.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Declare a format for the </i><tt><i>CD_REPORT</i></tt><i>

file handle.<br>

Declare a format for the total price information using </i><tt><i>CD_REPORT_TOTAL</i></tt><i>

as the format name.<br>

Declare a heading format for the </i><tt><i>CD_REPORT</i></tt><i>

file handle using </i><tt><i>CD_REPORT_TOP</i></tt><i>

as the format name.<br>

Declare the </i><tt><i>dotize()</i></tt><i>

fuNCtion.<br>

Initialize local variables called </i><tt><i>$width</i></tt><i>

and </i><tt><i>$string</i></tt><i>.

<br>

If the width of </i><tt><i>$string</i></tt><i>

is greater than </i><tt><i>$width</i></tt><i>,

return a value that consists of </i><tt><i>$string</i></tt><i>

shortened to </i><tt><i>$width-3</i></tt><i>

with </i><tt><i>...</i></tt><i> appended

to the end; otherwise, return </i><tt><i>$string</i></tt><i>.

<br>

Open the </i><tt><i>FORMAT.DAT</i></tt><i>

file, read all the lines into </i><tt><i>@lines</i></tt><i>,

and then close the file.<br>

Open the </i><tt><i>FORMAT.RPT</i></tt><i>

file for output to hold the report.<br>

Initialize the </i><tt><i>$total</i></tt><i>

variable to zero.<br>

Iterate over the </i><tt><i>@lines</i></tt><i>

array.<br>

Remove the linefeed character.<br>

Split the string into three fields.<br>

Provide a default value for any empty variables.<br>

Invoke the </i><tt><i>format</i></tt><i>

statement by using the </i><tt><i>write()</i></tt><i>

fuNCtion specifying the </i><tt><i>CD_REPORT</i></tt><i>

file name.<br>

Change the current format by assigning a value to the </i><tt><i>$~</i></tt><i>

special variable. This statement uses some advaNCed coNCepts and

is explained further after the listing.<br>

Invoke the </i><tt><i>format</i></tt><i>

statement by using the </i><tt><i>write()</i></tt><i>

fuNCtion.<br>

Close the </i><tt><i>FORMAT.RPT</i></tt><i>

file.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 11.10&nbsp;&nbsp;11LST10.PL-Using an Alternative <i>format</i>

Statement<br>

</b>

</blockquote>

<blockquote>

<pre>

format CD_REPORT =

  @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  $@###.##

  dotize(17, $album), dotize(16, $artist), $price

.



format CD_REPORT_TOTAL =

  ---------------------------------------------

                                       $@###.##

                                        $total

.





format CD_REPORT_TOP =

  @||||||||||||||||||||||||||||||||||||  Pg @&lt;

  &quot;CD Collection of David Medinets&quot;,        $%



  Album              Artist            Price

  -----------------  ----------------  --------

.



sub dotize {

    my($width, $string) = @_;



    if (length($string) &gt; $width) {

        return(substr($string, 0, $width - 3) . &quot;...&quot;);

    }

    else {

        return($string);

    }

}



open(FILE, &quot;&lt;format.dat&quot;);

@lines = &lt;FILE&gt;;

close(FILE);



open(CD_REPORT, &quot;&gt;format.rpt&quot;);



$total = 0;

foreach (@lines) {

    chop();

    ($album, $artist, $price) = (split(/!/));

    $album  = &quot;&quot; if !defined($album);

    $artist = &quot;&quot; if !defined($artist);

    $price  = 0 if !defined($price);

    write(CD_REPORT);

    $total += $price;

}

</pre>

</blockquote>

<hr>

<blockquote>

<pre>

select((select(CD_REPORT), $~ = &quot;CD_REPORT_TOTAL&quot;)[0]);

write(CD_REPORT);

</font><font SIZE="2" FACE="Courier">close(CD_REPORT);

</pre>

</blockquote>

<p>

This program creates a file called <tt>FORMAT.RPT</tt>

that contains the following:

<blockquote>

<pre>

    CD Collection of David Medinets     Pg 1



  Album              Artist            Price

  -----------------  ----------------  --------

  The Lion King                        $   0.00

  Tumbleweed Con...  Elton John        $ 123.32

  Photographs &amp; ...  Jim Croce         $   4.95

  Heads &amp; Tales      Harry Chapin      $  12.50

  ---------------------------------------------

                                       $ 140.77

</pre>

</blockquote>

<p>

The contents of <tt>FORMAT.RPT</tt>

are identical to the display created by the program in Listing

11.7.

<p>

The statement that changes a default file handle and format name

is a little complicated. Let's take a closer look at it.

<blockquote>

<pre>

select((select(CD_REPORT), $~ = &quot;CD_REPORT_TOTAL&quot;)[0]);

</pre>

</blockquote>

<p>

In order to understand most statements, you need to look at the

innermost parenthesis first, and this one is no different. The

innermost expression to evaluate is

<blockquote>

<pre>

select(CD_REPORT), $~ = &quot;CD_REPORT_TOTAL&quot;

</pre>

</blockquote>

<p>

You might recall that the comma operator lets you place one or

more statements where normally you can place only one. That's

what is happening here. First, <tt>CD_REPORT</tt>

is selected as the default file handle for the <tt>print</tt>

and <tt>write</tt> statements, and

then the <tt>$~</tt> variable is changed

to the new format name. By eNClosing the two statements inside

parentheses, their return values are used in an array context.

You probably already have guessed that the <tt>[0]</tt>

notation then is used to retrieve the first element of the array:

the value returned from the <tt>select()</tt>

fuNCtion. Because the <tt>select()</tt>

fuNCtion returns the value of the previous default file handle,

after executing the second <tt>select()</tt>,

the default file handle is restored to its previous value.

<p>

This bit of code could have been written like this:

<blockquote>

<pre>

$oldhandle = select(CD_REPORT);

$~ = &quot;CD_REPORT_TOTAL&quot;;

select($oldhandle);

</pre>

</blockquote>

<h2><a NAME="Summary"><font SIZE="5" COLOR="#FF0000">

Summary</font></a></h2>

<p>

In this chapter, you learned how to create simple reports that

iNCorporate headers, footers, and detail lines. Headers are used

at the top of each page and can consist of both static text and

values from variables. Footers are used at the bottom of each

page and can consist only of static text. Detail lines make up

the body of a report.

<p>

Header and detail lines are defined by using <tt>format</tt>

statements that have alternating field and value lines. The field

lines hold the static text and field holders while the value lines

hold a comma-delimited list of expressions.

<p>

You can use several different format characters when creating

the field holder to have left-justified, right-justified, or centered

fields. You also can use word-wrapping to display long pieces

of text in your reports.

<p>

Directing a report to a file instead of to <tt>STDOUT</tt>

requires some simple steps. The output file needs to be opened;

the file handle needs to be specified as the format name in the

<tt>format</tt> statement; the format

name needs to be specified in the <tt>write</tt>

statement; and the output file needs to be closed.

<p>

The next chapter focuses on special variables. All the different

special variables you have seen so far-and more-are discussed

along with some examples of how to use them.

<h2><a NAME="ReviewQuestions"><font SIZE="5" COLOR="#FF0000">

Review Questions</font></a></h2>

<p>

Answers to Review Questions are in Appendix A.

<ol>

<li>What is the syntax of the <tt>format</tt>

statement?

<li>What is a footer?

<li>What fuNCtion is used to invoke the <tt>format</tt>

statement?

<li>How can you change a detail format line into a header format

line?

<li>What is the <tt>&gt;</tt> format

character used for?

<li>What is the <tt>$^L</tt> variable

used for?

<li>Can associative array variables be used in value lines?

<li>What will the following line of code do?<br>

<br>

<tt>select((select(ANNUAL_RPT), $^ = &quot;REGIONAL_SALES&quot;)[0]);</tt>

</ol>

<h2><a NAME="ReviewExercises"><font SIZE="5" COLOR="#FF0000">

Review Exercises</font></a></h2>

<ol>

<li>Modify the program in Listing 11.4 to display the second field

as left-justified instead of right-justified.

<li>Create a report that has both a price and a tax column. Use

a tax rate of seven percent.

<li>Modify the program in Listing 11.7 to display an average of

the CD prices instead of the total of the prices.

<li>Create a program that sends the report in the preceding exercise

to a file. Use the <tt>select</tt>

statement to change the default file handle so that a file handle

does not need to be passed to the <tt>write()</tt>

fuNCtion.

<li>Modify Listing 11.5 so that each pass through the loop checks

the value of <tt>$-</tt>. When the

value of <tt>$-</tt> is one less than

<tt>$=</tt>, change the value of <tt>$^L</tt>

to emulate a footer with variable text.

<li>Create a report that uses a detail line format with more than

one line. How would this affect the program written for Exercise

5?

</ol>

<hr>



<center><p><a HREF="ch10.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch10.htm"><img SRC="pc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="#CONTENTS"><img SRC="cc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/cc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="index-1.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/index-1.htm"><img SRC="hb.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/hb.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="ch12.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch12.htm"><img SRC="nc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/nc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<hr WIDTH="100%"></p></center>

</body>

</html>

