<HTML>

<HEAD>

<TITLE>Chapter 10  -- Regular Expressions</TITLE>



<META>

</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">

<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;10</FONT></H1>

<H1><FONT SIZE=6 COLOR=#FF0000>Regular Expressions</FONT></H1>

<HR>

<P>

<CENTER><B><FONT SIZE=5>CONTENTS</FONT></B></CENTER>

<UL>

<LI><A HREF="#PatternDelimiters">

Pattern Delimiters</A>

<LI><A HREF="#TheMatchingOperatorm">

The Matching Operator (m//)</A>

<UL>

<LI><A HREF="#TheMatchingOptions">

The Matching Options</A>

</UL>

<LI><A HREF="#TheSubstitutionOperators">

The Substitution Operator (s///)</A>

<UL>

<LI><A HREF="#TheSubstitutionOptions">

The Substitution Options</A>

</UL>

<LI><A HREF="#TheTranslationOperatortr">

The Translation Operator (tr///)</A>

<UL>

<LI><A HREF="#TheTranslationOptions">

The Translation Options</A>

</UL>

<LI><A HREF="#TheBindingOperatorsand">

The Binding Operators (=~ and !~)</A>

<LI><A HREF="#HowtoCreatePatterns">

How to Create Patterns</A>

<UL>

<LI><A HREF="#ExampleCharacterClasses">

Example: Character Classes</A>

<LI><A HREF="#ExampleQuantifiers">

Example: Quantifiers</A>

<LI><A HREF="#ExamplePatternMemory">

Example: Pattern Memory</A>

<LI><A HREF="#ExamplePatternPrecedeNCe">

Example: Pattern PrecedeNCe</A>

<LI><A HREF="#ExampleExtensionSyntax">

Example: Extension Syntax</A>

</UL>

<LI><A HREF="#PatternExamples">

Pattern Examples</A>

<UL>

<LI><A HREF="#ExampleUsingtheMatchOperator">

Example: Using the Match Operator</A>

<LI><A HREF="#ExampleUsingtheSubstitutionOperator">

Example: Using the Substitution Operator</A>

<LI><A HREF="#ExampleUsingtheTranslationOperator">

Example: Using the Translation Operator</A>

<LI><A HREF="#ExampleUsingtheISplitIFuNCtion">

Example: Using the <I>Split()</I> FuNCtion</A>

</UL>

<LI><A HREF="#Summary">

Summary</A>

<LI><A HREF="#ReviewQuestions">

Review Questions</A>

<LI><A HREF="#ReviewExercises">

Review Exercises</A>

</UL>



<HR>

<P>

You can use a <I>regular expression</I> to find patterns in strings:

for example, to look for a specific name in a phone list or all

of the names that start with the letter <I>a</I>. Pattern matching

is one of Perl's most powerful and probably least understood features.

But after you read this chapter, you'll be able to handle regular

expressions almost as well as a Perl guru. With a little practice,

you'll be able to do some iNCredibly handy things.

<P>

There are three main uses for regular expressions in Perl: matching,

substitution, and translation. The matching operation uses the

<TT>m//</TT> operator, which evaluates

to a true or false value. The substitution operation substitutes

one expression for another; it uses the <TT>s//</TT>

operator. The translation operation translates one set of characters

to another and uses the <TT>tr//</TT>

operator. These operators are summarized in Table 10.1.<BR>

<P>

<CENTER><B>Table 10.1&nbsp;&nbsp;Perl's Regular Expression Operators</B></CENTER>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD WIDTH=151><I>Operator</I></TD><TD WIDTH=438><I>Description</I>

</TD></TR>

<TR><TD WIDTH=151>m/PATTERN/</TD><TD WIDTH=438>This operator returns true if PATTERN is found in <TT>$_</TT>.

</TD></TR>

<TR><TD WIDTH=151>s/PATTERN/</TD><TD WIDTH=438>This operator replaces the sub-string matched by 

</TD></TR>

<TR><TD WIDTH=151>REPLACEMENT/</TD><TD WIDTH=438>PATTERN with REPLACEMENT.

</TD></TR>

<TR><TD WIDTH=151>tr/CHARACTERS/</TD><TD WIDTH=438>This operator replaces characters specified by 

</TD></TR>

<TR><TD WIDTH=151>REPLACEMENTS/</TD><TD WIDTH=438>CHARACTERS with the characters in REPLACEMENTS.

</TD></TR>

</TABLE>

</CENTER>

<P>

<P>

All three regular expression operators work with <TT>$_</TT>

as the string to search. You can use the binding operators (see

the section &quot;The Binding Operators&quot; later in this section)

to search a variable other than <TT>$_</TT>.

<P>

Both the matching (<TT>m//</TT>) and

the substitution (<TT>s///</TT>) operators

perform variable interpolation on the PATTERN and REPLACEMENT

strings. This comes in handy if you need to read the pattern from

the keyboard or a file.

<P>

If the match pattern evaluates to the empty string, the last valid

pattern is used. So, if you see a statement like print if <TT>//</TT>;

in a Perl program, look for the previous regular expression operator

to see what the pattern really is. The substitution operator also

uses this interpretation of the empty pattern.

<P>

In this chapter, you learn about pattern delimiters and then about

each type of regular expression operator. After that, you learn

how to create patterns in the section &quot;How to Create Patterns.&quot;

Then, the &quot;Pattern Examples&quot; section shows you some

situations and how regular expressions can be used to resolve

the situations.

<H2><A NAME="PatternDelimiters"><FONT SIZE=5 COLOR=#FF0000>

Pattern Delimiters</FONT></A></H2>

<P>

Every regular expression operator allows the use of alternative

<I>pattern delimiters</I>. A <I>delimiter </I>marks the beginning

and end of a given pattern. In the following statement,

<BLOCKQUOTE>

<PRE>

m//;

</PRE>

</BLOCKQUOTE>

<P>

you see two of the standard delimiters-the slashes (<TT>//</TT>).

However, you can use any character as the delimiter. This feature

is useful if you want to use the slash character inside your pattern.

For instaNCe, to match a file you would normally use:

<BLOCKQUOTE>

<PRE>

m/\/root\/home\/random.dat/

</PRE>

</BLOCKQUOTE>

<P>

This match statement is hard to read because all of the slashes

seem to run together (some programmers say they look like teepees).

If you use an alternate delimiter, if might look like this:

<BLOCKQUOTE>

<PRE>

m!/root/home/random.dat!

</PRE>

</BLOCKQUOTE>

<P>

or

<BLOCKQUOTE>

<PRE>

m{/root/home/random.dat}

</PRE>

</BLOCKQUOTE>

<P>

You can see that these examples are a little clearer. The last

example also shows that if a left bracket is used as the starting

delimiter, then the ending delimiter must be the right bracket.

<P>

Both the match and substitution operators let you use variable

interpolation. You can take advantage of this to use a single-quoted

string that does not require the slash to be escaped. For instaNCe:

<BLOCKQUOTE>

<PRE>

$file = '/root/home/random.dat';

m/$file/; 

</PRE>

</BLOCKQUOTE>

<P>

You might find that this technique yields clearer code than simply

changing the delimiters.

<P>

If you choose the single quote as your delimiter character, then

no variable interpolation is performed on the pattern. However,

you still need to use the backslash character to escape any of

the meta-characters discussed in the &quot;How to Create Patterns&quot;

section later in this chapter.<BR>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Tip</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

I tend to avoid delimiters that might be confused with characters in the pattern. For example, using the plus sign as a delimiter (<TT>m+abc+</TT>) does not help program readability. A casual reader might think that you intend to add two expressions 
instead of matching them.

</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Caution</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

The <TT>?</TT> has a special meaning when used as a match pattern delimiter. It works like the <TT>/</TT> delimiter except that it matches only oNCe between calls to the <TT>reset()</TT> fuNCtion. This feature may be removed in future versions of Perl, so 
avoid using it.

</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<P>

The next few sections look at the matching, substitution, and

translation operators in more detail.

<H2><A NAME="TheMatchingOperatorm"><FONT SIZE=5 COLOR=#FF0000>

The Matching Operator (m//)</FONT></A></H2>

<P>

The matching operator (<TT>m//</TT>)

is used to find patterns in strings. One of its more common uses

is to look for a specific string inside a data file. For instaNCe,

you might look for all customers whose last name is &quot;Johnson,&quot;

or you might need a list of all names starting with the letter

<I>s</I>.

<P>

The matching operator only searches the <TT>$_</TT>

variable. This makes the match statement shorter because you don't

need to specify where to search. Here is a quick example:

<BLOCKQUOTE>

<PRE>

$_ = &quot;AAA bbb AAA&quot;;

print &quot;Found bbb\n&quot; if  m/bbb/;

</PRE>

</BLOCKQUOTE>

<P>

The print statement is executed only if the <TT>bbb

</TT>character sequeNCe is found in the <TT>$_</TT>

variable. In this particular case, <TT>bbb</TT>

will be found, so the program will display the following:

<BLOCKQUOTE>

<PRE>

Found bbb

</PRE>

</BLOCKQUOTE>

<P>

The matching operator allows you to use variable interpolation

in order to create the pattern. For example:

<BLOCKQUOTE>

<PRE>

$needToFind = &quot;bbb&quot;;

$_ = &quot;AAA bbb AAA&quot;;

print &quot;Found bbb\n&quot; if  m/$needToFind/;

</PRE>

</BLOCKQUOTE>

<P>

Using the matching operator is so commonplace that Perl allows

you to leave off the <TT>m</TT> from

the matching operator as long as slashes are used as delimiters:

<BLOCKQUOTE>

<PRE>

$_ = &quot;AAA bbb AAA&quot;;

print &quot;Found bbb\n&quot; if  /bbb/;

</PRE>

</BLOCKQUOTE>

<P>

Using the matching operator to find a string inside a file is

very easy because the defaults are designed to facilitate this

activity. For example:

<BLOCKQUOTE>

<PRE>

$target = &quot;M&quot;;



open(INPUT, &quot;&lt;findstr.dat&quot;);



while (&lt;INPUT&gt;) {

     if (/$target/) {

         print &quot;Found $target on line $.&quot;;

     }

}

close(INPUT);<BR>



</PRE>

</BLOCKQUOTE>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Note</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

The <TT>$.</TT> special variable keeps track of the record number. Every time the diamond operators read a line, this variable is iNCremented.

</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<P>

This example reads every line in an input searching for the letter

<TT>M</TT>. When an <TT>M</TT>

is found, the print statement is executed. The print statement

prints the letter that is found and the line number it was found

on.

<H3><A NAME="TheMatchingOptions">

The Matching Options</A></H3>

<P>

The matching operator has several options that enhaNCe its utility.

The most useful option is probably the capability to ignore case

and to create an array of all matches in a string. Table 10.2

shows the options you can use with the matching operator.<BR>

<P>

<CENTER><B>Table 10.2&nbsp;&nbsp;Options for the Matching Operator</B></CENTER>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD WIDTH=73><CENTER><I>Option</I></CENTER></TD><TD WIDTH=517><I>Description</I>

</TD></TR>

<TR><TD WIDTH=73><CENTER>g</CENTER></TD><TD WIDTH=517>This option finds all occurreNCes of the pattern in the string. A list of matches is returned or you can iterate over the matches using a loop statement.

</TD></TR>

<TR><TD WIDTH=73><CENTER>i</CENTER></TD><TD WIDTH=517>This option ignores the case of characters in the string.

</TD></TR>

<TR><TD WIDTH=73><CENTER>m</CENTER></TD><TD WIDTH=517>This option treats the string as multiple lines. Perl does some optimization by assuming that <TT>$_</TT> contains a single line of input. If you know that it contains multiple newline characters, use 
this option to turn off the optimization.

</TD></TR>

<TR><TD WIDTH=73><CENTER>o</CENTER></TD><TD WIDTH=517>This option compiles the pattern only oNCe. You can achieve some small performaNCe gains with this option. It should be used with variable interpolation only when the value of the variable will not 
change during the lifetime of the program.

</TD></TR>

<TR><TD WIDTH=73><CENTER>s</CENTER></TD><TD WIDTH=517>This option treats the string as a single line.

</TD></TR>

<TR><TD WIDTH=73><CENTER>x</CENTER></TD><TD WIDTH=517>This option lets you use extended regular expressions. Basically, this means that Perl will ignore white space that's not escaped with a backslash or within a character class. I highly recommend this 
option so you can use spaces to make your regular expressions more readable. See the section, &quot;Example: Extension Syntax,&quot; later in this chapter for more information.

</TD></TR>

</TABLE>

</CENTER>

<P>

<P>

All options are specified after the last pattern delimiter. For

instaNCe, if you want the match to ignore the case of the characters

in the string, you can do this:

<BLOCKQUOTE>

<PRE>

$_ = &quot;AAA BBB AAA&quot;;

print &quot;Found bbb\n&quot; if  m/bbb/i;

</PRE>

</BLOCKQUOTE>

<P>

This program finds a match even though the pattern uses lowercase

and the string uses uppercase because the <TT>/i</TT>

option was used, telling Perl to ignore the case.

<P>

The result from a global pattern match can be assigned to an array

variable or used inside a loop. This feature comes in handy after

you learn about meta-characters in the section called &quot;How

to Create Patterns&quot; later in this chapter.

<P>

For more information about the matching options, see the section,

&quot;Pattern Examples&quot; later in this chapter.

<H2><A NAME="TheSubstitutionOperators"><FONT SIZE=5 COLOR=#FF0000>

The Substitution Operator (s///)</FONT></A></H2>

<P>

The substitution operator (<TT>s///</TT>)

is used to change strings. It requires two operands, like this:

<BLOCKQUOTE>

<PRE>

s/a/z/;

</PRE>

</BLOCKQUOTE>

<P>

This statement changes the first <TT>a</TT>

in <TT>$_</TT> into a <TT>z</TT>.

Not too complicated, huh? Things won't get complicated until we

start talking about regular expressions in earnest in the section,

&quot;How  to Create Patterns?&quot; later in the chapter.

<P>

You can use variable interpolation with the substitution operator

just as you can with the matching operator. For instaNCe:

<BLOCKQUOTE>

<PRE>

$needToReplace   = &quot;bbb&quot;;

$replacementText = &quot;1234567890&quot;;

$_ = &quot;AAA bbb AAA&quot;;

$result = s/$needToReplace/$replacementText/;<BR>



</PRE>

</BLOCKQUOTE>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Note</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

You can use variable interpolation in the replacement pattern as shown here, but none of the meta-characters described later in the chapter can be used in the replacement pattern.</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<P>

This program changes the <TT>$_</TT>

variable to hold <TT>&quot;AAA 1234567890

AAA&quot;</TT> instead of its original value, and the <TT>$result</TT>

variable will be equal to <TT>1-</TT>the

number of substitutions made.

<P>

Frequently, the substitution operator is used to remove substrings.

For instaNCe, if you want to remove the <TT>&quot;bbb&quot;</TT>

sequeNCe of characters from the <TT>$_</TT>

variable, you could do this:

<BLOCKQUOTE>

<PRE>

s/bbb//;

</PRE>

</BLOCKQUOTE>

<P>

By replacing the matched string with nothing, you have effectively

deleted it.

<P>

If brackets of any type are used as delimiters for the search

pattern, you need to use a second set of brackets to eNClose the

replacement pattern. For instaNCe:

<BLOCKQUOTE>

<PRE>

$_ = &quot;AAA bbb AAA&quot;;

$result = s{bbb}{1234567890};

</PRE>

</BLOCKQUOTE>

<H3><A NAME="TheSubstitutionOptions">

The Substitution Options</A></H3>

<P>

Like the matching operator, the substitution operator has several

options. One interesting option is the capability to evaluate

the replacement pattern as an expression instead of a string.

You could use this capability to find all numbers in a file and

multiply them by a given percentage, for instaNCe. Or, you could

repeat matched strings by using the string repetition operator.

Table 10.3 shows all of the options you can use with the substitution

operator.<BR>

<P>

<CENTER><B>Table 10.3&nbsp;&nbsp;Options for the Substitution

Operator</B></CENTER>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD WIDTH=115><CENTER><I>Option</I></CENTER></TD><TD WIDTH=475><I>Description</I>

</TD></TR>

<TR><TD WIDTH=115><CENTER>e</CENTER></TD><TD WIDTH=475>This option forces Perl to evaluate the replacement pattern as an expression.

</TD></TR>

<TR><TD WIDTH=115><CENTER>g</CENTER></TD><TD WIDTH=475>This option replaces all occurreNCes of the pattern in the string.

</TD></TR>

<TR><TD WIDTH=115><CENTER>i</CENTER></TD><TD WIDTH=475>This option ignores the case of characters in the string.

</TD></TR>

<TR><TD WIDTH=115><CENTER>m</CENTER></TD><TD WIDTH=475>This option treats the string as multiple lines. Perl does some optimization by assuming that <TT>$_</TT> contains a single line of input. If you know that it contains multiple newline characters, use 
this option to turn off the optimization.

</TD></TR>

<TR><TD WIDTH=115><CENTER>o</CENTER></TD><TD WIDTH=475>This option compiles the pattern only oNCe. You can achieve some small performaNCe gains with this option. It should be used with variable interpolation only when the value of the variable will not 
change during the lifetime of the program.

</TD></TR>

<TR><TD WIDTH=115><CENTER>s</CENTER></TD><TD WIDTH=475>This option treats the string as a single line.

</TD></TR>

<TR><TD WIDTH=115><CENTER>x</CENTER></TD><TD WIDTH=475>This option lets you use extended regular expressions. Basically, this means that Perl ignores white space that is not escaped with a backslash or within a character class. I highly recommend this 
option so you can use spaces to make your regular expressions more readable. See the section, &quot;Example: Extension Syntax,&quot; later in this chapter for more information.

</TD></TR>

</TABLE>

</CENTER>

<P>

<P>

The <TT>/e</TT> option changes the

interpretation of the pattern delimiters. If used, variable interpolation

is active even if single quotes are used. In addition, if back

quotes are used as delimiters, the replacement pattern is executed

as a DOS or UNIX command. The output of the command then is used

as the replacement text.

<H2><A NAME="TheTranslationOperatortr"><FONT SIZE=5 COLOR=#FF0000>

The Translation Operator (tr///)</FONT></A></H2>

<P>

The translation operator (<TT>tr///</TT>)

is used to change individual characters in the <TT>$_</TT>

variable. It requires two operands, like this:

<BLOCKQUOTE>

<PRE>

tr/a/z/;

</PRE>

</BLOCKQUOTE>

<P>

This statement translates all occurreNCes of <TT>a</TT>

into <TT>z</TT>. If you specify more

than one character in the match character list, you can translate

multiple characters at a time.

<P>

For instaNCe:

<BLOCKQUOTE>

<PRE>

tr/ab/z/;

</PRE>

</BLOCKQUOTE>

<P>

translates all <TT>a</TT> and all

<TT>b</TT> characters into the <TT>z</TT>

character. If the replacement list of characters is shorter than

the target list of characters, the last character in the replacement

list is repeated as often as needed. However, if more than one

replacement character is given for a matched character, only the

first is used. For instaNCe:

<BLOCKQUOTE>

<PRE>

tr/WWW/ABC/;

</PRE>

</BLOCKQUOTE>

<P>

results in all <TT>W</TT> characters

being converted to an <TT>A</TT> character.

The rest of the replacement list is ignored.

<P>

Unlike the matching and substitution operators, the translation

operator doesn't perform variable interpolation.<BR>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Note</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

The <TT>tr</TT> operator gets its name from the UNIX <TT>tr</TT> utility. If you are familiar with the <TT>tr</TT> utility, then you already know how to use the <TT>tr</TT> operator.

</BLOCKQUOTE>

<BLOCKQUOTE>

The UNIX <TT>sed</TT> utility uses a <TT>y</TT> to indicate translations. To make learning Perl easier for <TT>sed</TT> users, <TT>y</TT> is supported as a synonym for <TT>tr</TT>.

</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<H3><A NAME="TheTranslationOptions">

The Translation Options</A></H3>

<P>

The translation operator has options different from the matching

and substitution operators. You can delete matched characters,

replace repeated characters with a single character, and translate

only characters that don't match the character list. Table 10.4

shows the translation options.<BR>

<P>

<CENTER><B>Table 10.4&nbsp;&nbsp;Options for the Translation Operator</B></CENTER>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD WIDTH=79><CENTER><I>Option</I></CENTER></TD><TD WIDTH=511><I>Description</I>

</TD></TR>

<TR><TD WIDTH=79><CENTER>c</CENTER></TD><TD WIDTH=511>This option complements the match character list. In other words, the translation is done for every character that does not match the character list.

</TD></TR>

<TR><TD WIDTH=79><CENTER>d</CENTER></TD><TD WIDTH=511>This option deletes any character in the match list that does not have a corresponding character in the replacement list.

</TD></TR>

<TR><TD WIDTH=79><CENTER>s</CENTER></TD><TD WIDTH=511>This option reduces repeated instaNCes of matched characters to a single instaNCe of that character.

</TD></TR>

</TABLE>

</CENTER>

<P>

<P>

Normally, if the match list is longer than the replacement list,

the last character in the replacement list is used as the replacement

for the extra characters. However, when the d option is used,

the matched characters simply are deleted.

<P>

If the replacement list is empty, then no translation is done.

The operator still will return the number of characters that matched,

though. This is useful when you need to know how often a given

letter appears in a string. This feature also can compress repeated

characters using the <TT>s</TT> option.

<BR>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Tip</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

UNIX programmers may be familiar with using the <TT>tr</TT> utility to convert lowercase characters to uppercase characters, or vice versa. Perl now has the <TT>lc()</TT> and <TT>uc()</TT> fuNCtions that can do this much quicker.

</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<H2><A NAME="TheBindingOperatorsand"><FONT SIZE=5 COLOR=#FF0000>

The Binding Operators (=~ and !~)</FONT></A></H2>

<P>

The search, modify, and translation operations work on the <TT>$_</TT>

variable by default. What if the string to be searched is in some

other variable? That's where the binding operators come into play.

They let you bind the regular expression operators to a variable

other than <TT>$_</TT>. There are

two forms of the binding operator: the regular <TT>=~</TT>

and its complement <TT>!~</TT>. The

following small program shows the syntax of the <TT>=~</TT>

operator:

<BLOCKQUOTE>

<PRE>

$scalar       = &quot;The root has many leaves&quot;;

$match        = $scalar =~ m/root/;

$substitution = $scalar =~ s/root/tree/;

$translate    = $scalar =~ tr/h/H/;



print(&quot;\$match        = $match\n&quot;);

print(&quot;\$substitution = $substitution\n&quot;);

print(&quot;\$translate    = $translate\n&quot;);

print(&quot;\$scalar       = $scalar\n&quot;);

</PRE>

</BLOCKQUOTE>

<P>

This program displays the following:

<BLOCKQUOTE>

<PRE>

$match        = 1

$substitution = 1

$translate    = 2

$scalar       = The tree has many leaves

</PRE>

</BLOCKQUOTE>

<P>

This example uses all three of the regular expression operators

with the regular binding operator. Each of the regular expression

operators was bound to the <TT>$scalar</TT>

variable instead of <TT>$_</TT>. This

example also shows the return values of the regular expression

operators. If you don't need the return values, you could do this:

<BLOCKQUOTE>

<PRE>

$scalar = &quot;The root has many leaves&quot;;

print(&quot;String has root.\n&quot;) if $scalar =~ m/root/;

$scalar =~ s/root/tree/;

$scalar =~ tr/h/H/;

print(&quot;\$scalar = $scalar\n&quot;);

</PRE>

</BLOCKQUOTE>

<P>

This program displays the following:

<BLOCKQUOTE>

<PRE>

String has root.

$scalar = The tree has many leaves

</PRE>

</BLOCKQUOTE>

<P>

The left operand of the binding operator is the string to be searched,

modified, or transformed; the right operand is the regular expression

operator to be evaluated. The complementary binding operator is

valid only when used with the matching regular expression operator.

If you use it with the substitution or translation operator, you

get the following message if you're using the <TT>-w</TT>

command-line option to run Perl:

<BLOCKQUOTE>

<PRE>

Useless use of not in void context at test.pl line 4.

</PRE>

</BLOCKQUOTE>

<P>

You can see that the <TT>!~</TT> is

the opposite of <TT>=~</TT> by replacing

the <TT>=~</TT> in the previous example:

<BLOCKQUOTE>

<PRE>

$scalar = &quot;The root has many leaves&quot;;

print(&quot;String has root.\n&quot;) if $scalar !~ m/root/;

$scalar =~ s/root/tree/;

$scalar =~ tr/h/H/;

print(&quot;\$scalar = $scalar\n&quot;);

</PRE>

</BLOCKQUOTE>

<P>

This program displays the following:

<BLOCKQUOTE>

<PRE>

$scalar = The tree has many leaves

</PRE>

</BLOCKQUOTE>

<P>

The first print line does not get executed because the complementary

binding operator returns false.

<H2><A NAME="HowtoCreatePatterns"><FONT SIZE=5 COLOR=#FF0000>

How to Create Patterns</FONT></A></H2>

<P>

So far in this chapter, you've read about the different operators

used with regular expressions, and you've seen how to match simple

sequeNCes of characters. Now we'll look at the wide array of meta-characters

that are used to harness the full power of regular expressions.

<I>Meta-characters</I> are characters that have an additional

meaning above and beyond their literal meaning. For example, the

period character can have two meanings in a pattern. First, it

can be used to match a period character in the searched string-this

is its <I>literal meaning</I>. And second, it can be used to match

<I>any</I> character in the searched string except for the newline

character-this is its <I>meta-meaning</I>.

<P>

When creating patterns, the meta-meaning always will be the default.

If you really intend to match the literal character, you need

to prefix the meta-character with a backslash. You might recall

that the backslash is used to create an escape sequeNCe.

<P>

For more information about escape sequeNCes, see <A HREF="ch2.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch2.htm" >Chapter 2</A> &quot;Example:

Double Quoted Strings.&quot;

<P>

Patterns can have many different components. These components

all combine to provide you with the power to match any type of

string. The following list of components will give you a good

idea of the variety of ways that patterns can be created. The

section &quot;Pattern Examples&quot; later in this chapter shows

many examples of these rules in action.

<BLOCKQUOTE>

<B>Variable Interpolation:</B> Any variable is interpolated, and

the essentially new pattern then is evaluated as a regular expression.

Remember that only one level of interpolation is done. This means

that if the value of the variable iNCludes, for example, <TT>$scalar</TT>

as a string value, then <TT>$scalar</TT>

will not be interpolated. In addition, back-quotes do not interpolate

within double-quotes, and single-quotes do not stop interpolation

of variables when used within double-quotes.

</BLOCKQUOTE>

<BLOCKQUOTE>

<B>Self-Matching Characters:</B> Any character will match itself

unless it is a meta-character or one of <TT>$</TT>,

<TT>@</TT>, and <TT>&amp;</TT>.

The meta-characters are listed in Table 10.5, and the other characters

are used to begin variable names and fuNCtion calls. You can use

the backslash character to force Perl to match the literal meaning

of any character. For example, <TT>m/a/</TT>

will return true if the letter <TT>a</TT>

is in the <TT>$_</TT> variable. And

<TT>m/\$/</TT> will return true if

the character <TT>$</TT> is in the

<TT>$_</TT> variable.<BR>

</BLOCKQUOTE>

<P>

<CENTER><B>Table 10.5&nbsp;&nbsp;Regular Expression Meta-Characters,

Meta-Brackets, and Meta-SequeNCes</B></CENTER>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD WIDTH=133><CENTER><I>Meta-Character</I></CENTER></TD>

<TD WIDTH=457><I>Description</I></TD></TR>

<TR><TD WIDTH=133><CENTER>^</CENTER></TD><TD WIDTH=457>This meta-character-the caret-will match the beginning of a string or if the <TT>/m</TT> option is used, matches the beginning of a line. It is one of two pattern aNChors-the other aNChor is the 
<TT>$</TT>.

</TD></TR>

<TR><TD WIDTH=133><CENTER>.</CENTER></TD><TD WIDTH=457>This meta-character will match any character except for the new line unless the <TT>/s</TT> option is specified. If the <TT>/s</TT> option is specified, then the newline also will be matched.

</TD></TR>

<TR><TD WIDTH=133><CENTER>$</CENTER></TD><TD WIDTH=457>This meta-character will match the end of a string or if the <TT>/m</TT> option is used, matches the end of a line. It is one of two pattern aNChors-the other aNChor is the <TT>^</TT>.

</TD></TR>

<TR><TD WIDTH=133><CENTER>|</CENTER></TD><TD WIDTH=457>This meta-character-called <I>alternation</I>-lets you specify two values that can cause the match to succeed. For instaNCe, <TT>m/a|b/</TT> means that the <TT>$_</TT> variable must contain the 
<TT>&quot;a&quot;</TT> or <TT>&quot;b&quot;</TT> character for the match to succeed.

</TD></TR>

<TR><TD WIDTH=133><CENTER>*</CENTER></TD><TD WIDTH=457>This meta-character indicates that the &quot;thing&quot; immediately to the left should be matched 1 or more times in order to be evaluated as true.

</TD></TR>

<TR><TD WIDTH=133><CENTER>?</CENTER></TD><TD WIDTH=457>This meta-character indicates that the &quot;thing&quot; immediately to the left should be matched 0 or 1 times in order to be evaluated as true. When used in conjuNCtion with the <TT>+</TT>, 
<TT>_</TT>, <TT>?</TT>, or {<TT>n</TT>, <TT>m</TT>} meta-characters and brackets, it means that the regular expression should be non-greedy and match the smallest possible string.

</TD></TR>

<TR><TD WIDTH=133><CENTER><I>Meta-Brackets</I></CENTER></TD><TD WIDTH=457><I>Description</I>

</TD></TR>

<TR><TD WIDTH=133><CENTER>()</CENTER></TD><TD WIDTH=457>The parentheses let you affect the order of pattern evaluation and act as a form of pattern memory. See the section &quot;Pattern Memory&quot; later in this chapter for more information.

</TD></TR>

<TR><TD WIDTH=133><CENTER>(?...)</CENTER></TD><TD WIDTH=457>If a question mark immediately follows the left parentheses, it indicates that an extended mode component is being specified. See the section, &quot;Example: Extension Syntax,&quot; later in this 
chapter for more information.

</TD></TR>

<TR><TD WIDTH=133><CENTER>{n, m}</CENTER></TD><TD WIDTH=457>The curly braces specify how many times the &quot;thing&quot; immediately to the left should be matched. <TT>{n}</TT> means that it should be matched exactly n times. <TT>{n,}</TT> means it must 
be matched at least n times. <TT>{n, m}</TT> means that it must be matched at least n times and not more than m times.

</TD></TR>

<TR><TD WIDTH=133><CENTER>[]</CENTER></TD><TD WIDTH=457>The square brackets let you create a character class. For instaNCe, <TT>m/[abc]/</TT> will evaluate to true if any of <TT>&quot;a&quot;</TT>, <TT>&quot;b&quot;</TT>, or <TT>&quot;c&quot;</TT> is 
contained in <TT>$_</TT>. The square brackets are a more readable alternative to the alternation meta-character.

</TD></TR>

<TR><TD WIDTH=133><CENTER><I>Meta-SequeNCes</I></CENTER></TD>

<TD WIDTH=457><I>Description</I></TD></TR>

<TR><TD WIDTH=133><CENTER>\</CENTER></TD><TD WIDTH=457>This meta-character &quot;escapes&quot; the following character. This means that any special meaning normally attached to that character is ignored. For instaNCe, if you need to iNClude a dollar sign 
in a pattern, you must use <TT>\$</TT> to avoid Perl's variable interpolation. Use <TT>\\</TT> to specify the backslash character in your pattern.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\0nnn</CENTER></TD><TD WIDTH=457>Any Octal byte.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\a</CENTER></TD><TD WIDTH=457>Alarm.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\A</CENTER></TD><TD WIDTH=457>This meta-sequeNCe represents the beginning of the string. Its meaning is not affected by the <TT>/m</TT> option.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\b</CENTER></TD><TD WIDTH=457>This meta-sequeNCe represents the backspace character inside a character class; otherwise, it represents a <I>word boundary</I>. A word boundary is the spot between word (<TT>\w</TT>) and 
non-word(<TT>\W</TT>) characters. Perl thinks that the <TT>\W</TT> meta-sequeNCe matches the imaginary characters off the ends of the string.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\B</CENTER></TD><TD WIDTH=457>Match a non-word boundary.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\cn</CENTER></TD><TD WIDTH=457>Any control character.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\d</CENTER></TD><TD WIDTH=457>Match a single digit character.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\D</CENTER></TD><TD WIDTH=457>Match a single non-digit character.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\e</CENTER></TD><TD WIDTH=457>Escape.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\E</CENTER></TD><TD WIDTH=457>Terminate the <TT>\L</TT> or <TT>\U</TT> sequeNCe.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\f</CENTER></TD><TD WIDTH=457>Form Feed.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\G</CENTER></TD><TD WIDTH=457>Match only where the previous <TT>m//g</TT> left off.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\l</CENTER></TD><TD WIDTH=457>Change the next character to lowercase.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\L</CENTER></TD><TD WIDTH=457>Change the following characters to lowercase until a <TT>\E</TT> sequeNCe is eNCountered.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\n</CENTER></TD><TD WIDTH=457>Newline.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\Q</CENTER></TD><TD WIDTH=457>Quote Regular Expression meta-characters literally until the <TT>\E</TT> sequeNCe is eNCountered.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\r</CENTER></TD><TD WIDTH=457>Carriage Return.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\s</CENTER></TD><TD WIDTH=457>Match a single whitespace character.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\S</CENTER></TD><TD WIDTH=457>Match a single non-whitespace character.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\t</CENTER></TD><TD WIDTH=457>Tab.</TD>

</TR>

<TR><TD WIDTH=133><CENTER>\u</CENTER></TD><TD WIDTH=457>Change the next character to uppercase.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\U</CENTER></TD><TD WIDTH=457>Change the following characters to uppercase until a <TT>\E</TT> sequeNCe is eNCountered.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\v</CENTER></TD><TD WIDTH=457>Vertical Tab.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\w</CENTER></TD><TD WIDTH=457>Match a single word character. Word characters are the alphanumeric and underscore characters.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\W</CENTER></TD><TD WIDTH=457>Match a single non-word character.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\xnn</CENTER></TD><TD WIDTH=457>Any Hexadecimal byte.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\Z</CENTER></TD><TD WIDTH=457>This meta-sequeNCe represents the end of the string. Its meaning is not affected by the <TT>/m</TT> option.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\$</CENTER></TD><TD WIDTH=457>Dollar Sign.

</TD></TR>

<TR><TD WIDTH=133><CENTER>\@</CENTER></TD><TD WIDTH=457>Ampersand.

</TD></TR>

</TABLE>

</CENTER>

<P>

<BLOCKQUOTE>

<B>Character SequeNCes:</B> A sequeNCe of characters will match

the identical sequeNCe in the searched string. The characters

need to be in the same order in both the pattern and the searched

string for the match to be true. For example, <TT>m/abc/;</TT>

will match <TT>&quot;abc&quot;</TT>

but not <TT>&quot;cab&quot;</TT> or

<TT>&quot;bca&quot;</TT>. If any character

in the sequeNCe is a meta-character, you need to use the backslash

to match its literal value.

</BLOCKQUOTE>

<BLOCKQUOTE>

<B>Alternation:</B> The <I>alternation </I>meta-character (<TT>|</TT>)

will let you match more than one possible string. For example,

<TT>m/a|b/;</TT> will match if either

the <TT>&quot;a&quot;</TT> character

or the <TT>&quot;b&quot;</TT> character

is in the searched string. You can usesequeNCes of more than one

character with alternation. For example, <TT>m/dog|cat/;</TT>

will match if either of the strings <TT>&quot;dog&quot;</TT>

or <TT>&quot;cat&quot;</TT> is in

the searched string.<BR>

</BLOCKQUOTE>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Tip</B> </TD></TR>

<TR><TD>

<BLOCKQUOTE>

Some programmers like to eNClose the alternation sequeNCe inside parentheses to help indicate where the sequeNCe begins and ends.</BLOCKQUOTE>

<BLOCKQUOTE>

<TT>m/(dog|cat)/;</TT>

</BLOCKQUOTE>

<BLOCKQUOTE>

However, this will affect something called <I>pattern memory</I>, which you'll be learning about in the section, &quot;Example: Pattern Memory,&quot; later in the chapter.

</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<BLOCKQUOTE>

<B>Character Classes:</B> The square brackets are used to create

character classes. A <I>character class</I> is used to match a

specific type of character. For example, you can match any decimal

digit using <TT>m/[0123456789]/;</TT>.

This will match a single character in the range of zero to nine.

You can find more information about character classes in the section,

&quot;Example: Character Classes,&quot; later in this chapter.

</BLOCKQUOTE>

<BLOCKQUOTE>

<B>Symbolic Character Classes:</B> There are several character

classes that are used so frequently that they have a symbolic

representation. The period meta-character stands for a special

character class that matches all characters except for the newline.

The rest are <TT>\d</TT>, <TT>\D</TT>,

<TT>\s</TT>, <TT>\S</TT>,

<TT>\w</TT>, and <TT>\W</TT>.

These are mentioned in Table 10.5 earlier and are discussed in

the section, &quot;Example: Character Classes,&quot; later in

this chapter.

</BLOCKQUOTE>

<BLOCKQUOTE>

<B>ANChors:</B> The caret (<TT>^</TT>)

and the dollar sign meta-characters are used to aNChor a pattern

to the beginning and the end of the searched string. The caret

is always the first character in the pattern when used as an aNChor.

For example, <TT>m/^one/;</TT> will

only match if the searched string starts with a sequeNCe of characters,

<TT>one</TT>. The dollar sign is always

the last character in the pattern when used as an aNChor. For

example, <TT>m/(last|end)$/;</TT>

will match only if the searched string ends with either the character

sequeNCe <TT>last</TT> or the character

sequeNCe <TT>end</TT>. The <TT>\A</TT>

and <TT>\Z</TT> meta-sequeNCes also

are used as pattern aNChors for the beginning and end of strings.

</BLOCKQUOTE>

<BLOCKQUOTE>

<B>Quantifiers:</B> There are several meta-characters that are

devoted to controlling how many characters are matched. For example,

<TT>m/a{5}/;</TT> means that five

<TT>a</TT> characters must be found

before a true result can be returned. The <TT>*</TT>,

<TT>+</TT>, and <TT>?</TT>

meta-characters and the curly braces are all used as quantifiers.

See the section, &quot;Example: Quantifiers,&quot; later in this

chapter for more information.

</BLOCKQUOTE>

<BLOCKQUOTE>

<B>Pattern Memory:</B> Parentheses are used to store matched values

into buffers for later recall. I like to think of this as a form

of pattern memory. Some programmers call them back-refereNCes.

After you use <TT>m/(fish|fowl)/;</TT>

to match a string and a match is found, the variable <TT>$1</TT>

will hold either <TT>fish</TT> or

<TT>fowl</TT> depending on which sequeNCe

was matched. See the section, &quot;Example: Pattern Memory,&quot;

later in this chapter for more information.

</BLOCKQUOTE>

<BLOCKQUOTE>

<B>Word Boundaries:</B> The <TT>\b</TT>

meta-sequeNCe will match the spot between a space and the first

character of a word or between the last character of a word and

the space. The <TT>\b</TT> will match

at the beginning or end of a string if there are no leading or

trailing spaces. For example, <TT>m/\bfoo/;</TT>

will match <TT>foo</TT> even without

spaces surrounding the word. It also will match $<TT>foo</TT>

because the dollar sign is not considered a word character. The

statement <TT>m/foo\b/;</TT> will

match <TT>foo</TT> but not <TT>foobar</TT>,

and the statement <TT>m/\bwiz/;</TT>

will match <TT>wizard</TT> but not

<TT>geewiz</TT>. See the section,

&quot;Example: Character Classes,&quot; later in this chapter

for more information about word boundaries.

</BLOCKQUOTE>

<BLOCKQUOTE>

The <TT>\B</TT> meta-sequeNCe will

match everywhere except at a word boundary.

</BLOCKQUOTE>

<BLOCKQUOTE>

<B>Quoting Meta-Characters:</B> You can match meta-characters

literally by eNClosing them in a <TT>\Q..\E</TT>

sequeNCe. This will let you avoid using the backslash character

to escape all meta-characters, and your code will be easier to

read.

</BLOCKQUOTE>

<BLOCKQUOTE>

<B>Extended Syntax:</B> The (?...) sequeNCe lets you use an extended

version of the regular expression syntax. The different options

are discussed in the section, &quot;Example: Extension Syntax,&quot;

later in this chapter.

</BLOCKQUOTE>

<BLOCKQUOTE>

<B>Combinations:</B> Any of the preceding components can be combined

with any other to create simple or complex patterns.

</BLOCKQUOTE>

<P>

The power of patterns is that you don't always know in advaNCe

the value of the string that you will be searching. If you need

to match the first word in a string that was read in from a file,

you probably have no idea how long it might be; therefore, you

need to build a pattern. You might start with the <TT>\w</TT>

symbolic character class, which will match any single alphanumeric

or underscore character. So, assuming that the string is in the

<TT>$_</TT> variable, you can match

a one-character word like this:

<BLOCKQUOTE>

<PRE>

m/\w/;

</PRE>

</BLOCKQUOTE>

<P>

If you need to match both a one-character word and a two-character

word, you can do this:

<BLOCKQUOTE>

<PRE>

m/\w|\w\w/;

</PRE>

</BLOCKQUOTE>

<P>

This pattern says to match a single word character or two consecutive

word characters. You could continue to add alternation components

to match the different lengths of words that you might expect

to see, but there is a better way.

<P>

You can use the <TT>+</TT> quantifier

to say that the match should succeed only if the component is

matched one or more times. It is used this way:

<BLOCKQUOTE>

<PRE>

m/\w+/;

</PRE>

</BLOCKQUOTE>

<P>

If the value of <TT>$_</TT> was <TT>&quot;AAA

BBB&quot;</TT>, then <TT>m/\w+/;</TT>

would match the <TT>&quot;AAA&quot;</TT>

in the string. If <TT>$_</TT> was

blank, full of white space, or full of other non-word characters,

an undefined value would be returned.

<P>

The preceding pattern will let you determine if <TT>$_</TT>

contains a word but does not let you know what the word is. In

order to accomplish that, you need to eNClose the matching components

inside parentheses. For example:

<BLOCKQUOTE>

<PRE>

m/(\w+)/;

</PRE>

</BLOCKQUOTE>

<P>

By doing this, you force Perl to store the matched string into

the $1 variable. The $1 variable can be considered as pattern

memory.

<P>

This introduction to pattern components describes most of the

details you need to know in order to create your own patterns

or regular expressions. However, some of the components deserve

a bit more study. The next few sections look at character classes,

quantifiers, pattern memory, pattern precedeNCe, and the extension

syntax. Then the rest of the chapter is devoted to showing specific

examples of when to use the different components.

<H3><A NAME="ExampleCharacterClasses">

Example: Character Classes</A></H3>

<P>

A character class defines a type of character. The character class

<TT>[0123456789]</TT> defines the

class of decimal digits, and <TT>[0-9a-f]</TT>

defines the class of hexadecimal digits. Notice that you can use

a dash to define a range of consecutive characters. Character

classes let you match any of a range of characters; you don't

know in advaNCe which character will be matched. This capability

to match non-specific characters is what meta-characters are all

about.

<P>

You can use variable interpolation inside the character class,

but you must be careful when doing so. For example,

<BLOCKQUOTE>

<PRE>

$_ = &quot;AAABBBccC&quot;;

$charList = &quot;ADE&quot;;

print &quot;matched&quot; if m/[$charList]/;

</PRE>

</BLOCKQUOTE>

<P>

will display

<BLOCKQUOTE>

<PRE>

matched

</PRE>

</BLOCKQUOTE>

<P>

This is because the variable interpolation results in a character

class of <TT>[ADE]</TT>. If you use

the variable as one-half of a character range, you need to ensure

that you don't mix numbers and digits. For example,

<BLOCKQUOTE>

<PRE>

$_ = &quot;AAABBBccC&quot;;

$charList = &quot;ADE&quot;;

print &quot;matched&quot; if m/[$charList-9]/;

</PRE>

</BLOCKQUOTE>

<P>

will result in the following error message when executed:

<BLOCKQUOTE>

<PRE>

/[ADE-9]/: invalid [] range in regexp at test.pl line 4.

</PRE>

</BLOCKQUOTE>

<P>

At times, it's necessary to match on any character except for

a given character list. This is done by complementing the character

class with the caret. For example,

<BLOCKQUOTE>

<PRE>

$_ = &quot;AAABBBccC&quot;;

print &quot;matched&quot; if m/[^ABC]/;

</PRE>

</BLOCKQUOTE>

<P>

will display nothing. This match returns true only if a character

besides <TT>A</TT>, <TT>B</TT>,

or <TT>C</TT> is in the searched string.

If you complement a list with just the letter <TT>A</TT>,

<BLOCKQUOTE>

<PRE>

$_ = &quot;AAABBBccC&quot;;

print &quot;matched&quot; if m/[^A]/;

</PRE>

</BLOCKQUOTE>

<P>

then the string <TT>&quot;matched&quot;</TT>

will be displayed because <TT>B</TT>

and <TT>C</TT> are part of the string-in

other words, a character besides the letter <TT>A</TT>.

<P>

Perl has shortcuts for some character classes that are frequently

used. Here is a list of what I call symbolic character classes:

<BR>



<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD WIDTH=67><CENTER><TT><B><FONT FACE="Courier">\w</FONT></B></TT></CENTER>

</TD><TD WIDTH=523>This symbol matches any alphanumeric character or the underscore character. It is equivalent to the character class <TT>[a-zA-Z0-9_]</TT>.

</TD></TR>

<TR><TD WIDTH=67><CENTER><TT><B><FONT FACE="Courier">\W</FONT></B></TT></CENTER>

</TD><TD WIDTH=523>This symbol matches every character that the <TT>\w</TT> symbol does not. In other words, it is the complement of <TT>\w</TT>. It is equivalent to <TT>[^a-zA-Z0-9_]</TT>.

</TD></TR>

<TR><TD WIDTH=67><CENTER><TT><B><FONT FACE="Courier">\s</FONT></B></TT></CENTER>

</TD><TD WIDTH=523>This symbol matches any space, tab, or newline character. It is equivalent to <TT>[\t \n]</TT>.

</TD></TR>

<TR><TD WIDTH=67><CENTER><TT><B><FONT FACE="Courier">\S</FONT></B></TT></CENTER>

</TD><TD WIDTH=523>This symbol matches any non-whitespace character. It is equivalent to <TT>[^\t \n]</TT>.

</TD></TR>

<TR><TD WIDTH=67><CENTER><TT><B><FONT FACE="Courier">\d</FONT></B></TT></CENTER>

</TD><TD WIDTH=523>This symbol matches any digit. It is equivalent to <TT>[0-9]</TT>.

</TD></TR>

<TR><TD WIDTH=67><CENTER><TT><B><FONT FACE="Courier">\D</FONT></B></TT></CENTER>

</TD><TD WIDTH=523>This symbol matches any non-digit character. It is equivalent to <TT>[^0-9]</TT>.

</TD></TR>

</TABLE>

</CENTER>

<P>

<P>

You can use these symbols inside other character classes, but

not as endpoints of a range. For example, you can do the following:

<BLOCKQUOTE>

<PRE>

$_ = &quot;\tAAA&quot;;

print &quot;matched&quot; if m/[\d\s]/;

</PRE>

</BLOCKQUOTE>

<P>

which will display

<BLOCKQUOTE>

<PRE>

matched

</PRE>

</BLOCKQUOTE>

<P>

because the value of <TT>$_</TT> iNCludes

the tab character.<BR>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Tip</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

Meta-characters that appear inside the square brackets that define a character class are used in their literal sense. They lose their meta-meaning. This may be a little confusing at first. In fact, I have a tendeNCy to forget this when evaluating 
patterns.</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Note</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

I think that most of the confusion regarding regular expressions lies in the fact that each character of a pattern might have several possible meanings. The caret could be an aNChor, it could be a caret, or it could be used to complement a character 
class. Therefore, it is vital that you decide which context any given pattern character or symbol is in before assigning a meaning to it.</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<H3><A NAME="ExampleQuantifiers">

Example: Quantifiers</A></H3>

<P>

Perl provides several different quantifiers that let you specify

how many times a given component must be present before the match

is true. They are used when you don't know in advaNCe how many

characters need to be matched. Table 10.6 lists the different

quantifiers that can be used.<BR>

<P>

<CENTER><B>Table 10.6&nbsp;&nbsp;The Six Types of Quantifiers</B></CENTER>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD WIDTH=91><CENTER><I>Quantifier</I></CENTER></TD><TD WIDTH=492><I>Description</I>

</TD></TR>

<TR><TD WIDTH=91><CENTER>*</CENTER></TD><TD WIDTH=492>The component must be present zero or more times.

</TD></TR>

<TR><TD WIDTH=91><CENTER>+</CENTER></TD><TD WIDTH=492>The component must be present one or more times.

</TD></TR>

<TR><TD WIDTH=91><CENTER>?</CENTER></TD><TD WIDTH=492>The component must be present zero or one times.

</TD></TR>

<TR><TD WIDTH=91><CENTER>{n}</CENTER></TD><TD WIDTH=492>The component must be present n times.

</TD></TR>

<TR><TD WIDTH=91><CENTER>{n,}</CENTER></TD><TD WIDTH=492>The component must be present at least n times.

</TD></TR>

<TR><TD WIDTH=91><CENTER>{n,m}</CENTER></TD><TD WIDTH=492>The component must be present at least n times and no more than m times.

</TD></TR>

</TABLE>

</CENTER>

<P>

<P>

If you need to match a word whose length is unknown, you need

to use the <TT>+</TT> quantifier.

You can't use an <TT>*</TT> because

a zero length word makes no sense. So, the match statement might

look like this:

<BLOCKQUOTE>

<PRE>

m/\w+/;

</PRE>

</BLOCKQUOTE>

<P>

This pattern will match <TT>&quot;QQQ&quot;</TT>

and <TT>&quot;AAAAA&quot;</TT> but

not <TT>&quot;&quot;</TT> or <TT>&quot;

 BBB&quot;</TT>. In order to account for the leading white

space, which may or may not be at the beginning of a string, you

need to use the asterisk (<TT>*</TT>)

quantifier in conjuNCtion with the <TT>\s</TT>

symbolic character class in the following way:

<BLOCKQUOTE>

<PRE>

m/\s*\w+/; <BR>



</PRE>

</BLOCKQUOTE>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Tip</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

Be careful when using the <TT>*</TT> quantifier because it can match an empty string, which might not be your intention. The pattern <TT>/b*/</TT> will match any string-even one without any <TT>b</TT> characters.

</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<P>

At times, you may need to match an exact number of components.

The following match statement will be true only if five words

are present in the <TT>$_</TT> variable:

<BLOCKQUOTE>

<PRE>

$_ = &quot;AA AB AC AD AE&quot;;

m/(\w+\s+){5}/;

</PRE>

</BLOCKQUOTE>

<P>

In this example, we are matching at least one word character followed

by zero or more white space characters. The <TT>{5}</TT>

quantifier is used to ensure that that combination of components

is present five times.

<P>

The <TT>*</TT> and <TT>+</TT>

quantifiers are greedy. They match as many characters as possible.

This may not always be the behavior that you need. You can create

non-greedy components by following the quantifier with a <TT>?</TT>.

<P>

Use the following file specification in order to look at the <TT>*</TT>

and <TT>+</TT> quantifiers more closely:

<BLOCKQUOTE>

<PRE>

$_ = '/user/Jackie/temp/names.dat';

</PRE>

</BLOCKQUOTE>

<P>

The regular expression <TT>.*</TT>

will match the entire file specification. This can be seen in

the following small program:

<BLOCKQUOTE>

<PRE>

$_ = '/user/Jackie/temp/names.dat';

m/.*/;

print $&amp;;

</PRE>

</BLOCKQUOTE>

<P>

This program displays

<BLOCKQUOTE>

<PRE>

/user/Jackie/temp/names.dat

</PRE>

</BLOCKQUOTE>

<P>

You can see that the <TT>*</TT> quantifier

is greedy. It matched the whole string. If you add the ? modifier

to make the <TT>.*</TT> component

non-greedy, what do you think the program would display?

<BLOCKQUOTE>

<PRE>

$_ = '/user/Jackie/temp/names.dat';

m/.*?/;

print $&amp;;

</PRE>

</BLOCKQUOTE>

<P>

This program displays nothing because the least amount of characters

that the <TT>*</TT> matches is zero.

If we change the <TT>*</TT> to a <TT>+</TT>,

then the program will display

<BLOCKQUOTE>

<PRE>

/

</PRE>

</BLOCKQUOTE>

<P>

Next, let's look at the coNCept of pattern memory, which lets

you keep bits of matched string around after the match is complete.

<H3><A NAME="ExamplePatternMemory">

Example: Pattern Memory</A></H3>

<P>

Matching arbitrary numbers of characters is fine, but without

the capability to find out what was matched, patterns would not

be very useful. Perl lets you eNClose pattern components inside

parentheses in order to store the string that matched the components

into pattern memory. You also might hear <I>pattern memory </I>referred

to as <I>pattern buffers</I>. This memory persists after the match

statement is finished executing so that you can assign the matched

values to other variables.

<P>

You saw a simple example of this earlier right after the component

descriptions. That example looked for the first word in a string

and stored it into the first buffer, <TT>$1</TT>.

The following small program

<BLOCKQUOTE>

<PRE>

$_ =  &quot;AAA BBB ccC&quot;;

m/(\w+)/;

print(&quot;$1\n&quot;);

</PRE>

</BLOCKQUOTE>

<P>

will display

<BLOCKQUOTE>

<PRE>

AAA

</PRE>

</BLOCKQUOTE>

<P>

You can use as many buffers as you need. Each time you add a set

of parentheses, another buffer is used. If you want to find all

the words in the string, you need to use the /g match option.

In order to find all the words, you can use a loop statement that

loops until the match operator returns false.

<BLOCKQUOTE>

<PRE>

$_ =  &quot;AAA BBB ccC&quot;;



while (m/(\w+)/g) {

    print(&quot;$1\n&quot;);

}

</PRE>

</BLOCKQUOTE>

<P>

The program will display

<BLOCKQUOTE>

<PRE>

AAA

BBB

ccC

</PRE>

</BLOCKQUOTE>

<P>

If looping through the matches is not the right approach for your

needs, perhaps you need to create an array consisting of the matches.

<BLOCKQUOTE>

<PRE>

$_ =  &quot;AAA BBB ccC&quot;;

@matches = m/(\w+)/g;

print(&quot;@matches\n&quot;);

</PRE>

</BLOCKQUOTE>

<P>

The program will display

<BLOCKQUOTE>

<PRE>

AAA BBB ccC

</PRE>

</BLOCKQUOTE>

<P>

Perl also has a few special variables to help you know what matched

and what did not. These variables occasionally will save you from

having to add parentheses to find information.<BR>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD WIDTH=61><BLOCKQUOTE>

<CENTER><TT><B><FONT FACE="Courier">$+</FONT></B></TT></CENTER>

</BLOCKQUOTE>



</TD><TD WIDTH=529><BLOCKQUOTE>

This variable is assigned the value that the last bracket match matched.</BLOCKQUOTE>



</TD></TR>

<TR><TD WIDTH=61><BLOCKQUOTE>

<CENTER><TT><B><FONT FACE="Courier">$&amp;</FONT></B></TT></CENTER>

</BLOCKQUOTE>



</TD><TD WIDTH=529><BLOCKQUOTE>

This variable is assigned the value of the entire matched string. If the match is not successful, then <TT>$&amp;</TT> retains its value from the last successful match.

</BLOCKQUOTE>



</TD></TR>

<TR><TD WIDTH=61><BLOCKQUOTE>

<CENTER><TT><B><FONT FACE="Courier">$`</FONT></B></TT></CENTER>

</BLOCKQUOTE>



</TD><TD WIDTH=529><BLOCKQUOTE>

This variable is assigned everything in the searched string that is before the matched string.</BLOCKQUOTE>



</TD></TR>

<TR><TD WIDTH=61><BLOCKQUOTE>

<CENTER><TT><B><FONT FACE="Courier">$'</FONT></B></TT></CENTER>

</BLOCKQUOTE>



</TD><TD WIDTH=529><BLOCKQUOTE>

This variable is assigned everything in the search string that is after the matched string.</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Tip</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

If you need to save the value of the matched strings stored in the pattern memory, make sure to assign them to other variables. Pattern memory is local to the eNClosing block and lasts only until another match is done.</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<H3><A NAME="ExamplePatternPrecedeNCe">

Example: Pattern PrecedeNCe</A></H3>

<P>

Pattern components have an order of precedeNCe just as operators

do. If you see the following pattern:

<BLOCKQUOTE>

<PRE>

m/a|b+/

</PRE>

</BLOCKQUOTE>

<P>

it's hard to tell if the pattern should be

<BLOCKQUOTE>

<PRE>

m/(a|b)+/   # match either the &quot;a&quot; character repeated one 

            # or more times or the &quot;b&quot; character repeated one

            # or more times.

</PRE>

</BLOCKQUOTE>

<P>

or

<BLOCKQUOTE>

<PRE>

m/a|(b+)/   # match either the &quot;a&quot; character or the &quot;b&quot; character

            # repeated one or more times.

</PRE>

</BLOCKQUOTE>

<P>

The order of precedeNCe shown in Table 10.7 is designed to solve

problems like this. By looking at the table, you can see that

quantifiers have a higher precedeNCe than alternation. Therefore,

the second interpretation is correct.<BR>

<P>

<CENTER><B>Table 10.7&nbsp;&nbsp;The Pattern Component Order of

PrecedeNCe</B></CENTER>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD WIDTH=145><CENTER><I>PrecedeNCe Level</I></CENTER></TD>

<TD WIDTH=204><I>Component</I></TD></TR>

<TR><TD WIDTH=145><CENTER>1</CENTER></TD><TD WIDTH=204>Parentheses

</TD></TR>

<TR><TD WIDTH=145><CENTER>2</CENTER></TD><TD WIDTH=204>Quantifiers

</TD></TR>

<TR><TD WIDTH=145><CENTER>3</CENTER></TD><TD WIDTH=204>SequeNCes and ANChors

</TD></TR>

<TR><TD WIDTH=145><CENTER>4</CENTER></TD><TD WIDTH=204>Alternation

</TD></TR>

</TABLE>

</CENTER>

<P>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Tip</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

You can use parentheses to affect the order in which components are evaluated because they have the highest precedeNCe. However, unless you use the extended syntax, you will be affecting the pattern memory.</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<H3><A NAME="ExampleExtensionSyntax">

Example: Extension Syntax</A></H3>

<P>

The regular expression extensions are a way to significantly add

to the power of patterns without adding a lot of meta-characters

to the proliferation that already exists. By using the basic (<TT>?...</TT>)

notation, the regular expression capabilities can be greatly extended.

<P>

At this time, Perl recognizes five extensions. These vary widely

in fuNCtionality-from adding comments to setting options. Table

10.8 lists the extensions and gives a short description of each.

<BR>

<P>

<CENTER><B>Table 10.8&nbsp;&nbsp;Five Extension Components</B></CENTER>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD WIDTH=127><CENTER><I>Extension</I></CENTER></TD><TD WIDTH=463><I>Description</I>

</TD></TR>

<TR><TD WIDTH=127><CENTER>(?# TEXT)</CENTER></TD><TD WIDTH=463>This extension lets you add comments to your regular expression. The TEXT value is ignored.

</TD></TR>

<TR><TD WIDTH=127><CENTER>(?:...)</CENTER></TD><TD WIDTH=463>This extension lets you add parentheses to your regular expression without causing a pattern memory position to be used.

</TD></TR>

<TR><TD WIDTH=127><CENTER>(?=...)</CENTER></TD><TD WIDTH=463>This extension lets you match values without iNCluding them in the <TT>$&amp;</TT> variable.

</TD></TR>

<TR><TD WIDTH=127><CENTER>(?!...)</CENTER></TD><TD WIDTH=463>This extension lets you specify what should not follow your pattern. For instaNCe, <TT>/blue(?!bird)/</TT> means that <TT>&quot;bluebox&quot;</TT> and <TT>&quot;bluesy&quot;</TT> will be matched 
but not <TT>&quot;bluebird&quot;</TT>.

</TD></TR>

<TR><TD WIDTH=127><CENTER>(?sxi)</CENTER></TD><TD WIDTH=463>This extension lets you specify an embedded option in the pattern rather than adding it after the last delimiter. This is useful if you are storing patterns in variables and using variable 
interpolation to do the matching.

</TD></TR>

</TABLE>

</CENTER>

<P>

<P>

By far the most useful feature of extended mode, in my opinion,

is the ability to add comments directly inside your patterns.

For example, would you rather a see a pattern that looks like

this:

<BLOCKQUOTE>

<PRE>

# Match a string with two words. $1 will be the

# first word. $2 will be the second word.

m/^\s+(\w+)\W+(\w+)\s+$/;

</PRE>

</BLOCKQUOTE>

<P>

or one that looks like this:

<BLOCKQUOTE>

<PRE>

m/

    (?# This pattern will match any string with two)

    (?# and only two words in it. The matched words)

    (?# will be available in $1 and $2 if the match)

    (?# is successful.)



    ^      (?# ANChor this match to the beginning)

           (?# of the string)



    \s*    (?# skip over any whitespace characters)

           (?# use the * because there may be none)



    (\w+)  (?# Match the first word, we know it's)

           (?# the first word because of the aNChor)

           (?# above. Place the matched word into)

           (?# pattern memory.)



    \W+    (?# Match at least one non-word)

           (?# character, there may be more than one)



    (\w+)  (?# Match another word, put into pattern)

           (?# memory also.)



    \s*    (?# skip over any whitespace characters)

           (?# use the * because there may be none)



    $      (?# ANChor this match to the end of the)

           (?# string. Because both ^ and $ aNChors)

           (?# are present, the entire string will)

           (?# need to match the pattern. A)

           (?# sub-string that fits the pattern will)

           (?# not match.) 

/x;

</PRE>

</BLOCKQUOTE>

<P>

Of course, the commented pattern is much longer, but it takes

the same amount of time to execute. In addition, it will be much

easier to maintain the commented pattern because each component

is explained. When you know what each component is doing in relation

to the rest of the pattern, it becomes easy to modify its behavior

when the need arises.

<P>

Extensions also let you change the order of evaluation without

affecting pattern memory. For example,

<BLOCKQUOTE>

<PRE>

m/(?:a|b)+/;

</PRE>

</BLOCKQUOTE>

<P>

will match either the a character repeated one or more times or

the b character repeated one or more times. The pattern memory

will not be affected.

<P>

At times, you might like to iNClude a pattern component in your

pattern without iNCluding it in the <TT>$&amp;</TT>

variable that holds the matched string. The technical term for

this is a <I>zero-width positive look-ahead assertion</I>. You

can use this to ensure that the string following the matched component

is correct without affecting the matched value. For example, if

you have some data that looks like this:

<BLOCKQUOTE>

<PRE>

David    Veterinarian 56

Jackie  Orthopedist 34

Karen Veterinarian 28

</PRE>

</BLOCKQUOTE>

<P>

and you want to find all veterinarians and store the value of

the first column, you can use a look-ahead assertion. This will

do both tasks in one step. For example:

<BLOCKQUOTE>

<PRE>

while (&lt;&gt;) {

    push(@array, $&amp;) if m/^\w+(?=\s+Vet)/;

}



print(&quot;@array\n&quot;);

</PRE>

</BLOCKQUOTE>

<P>

This program will display:

<BLOCKQUOTE>

<PRE>

David Karen

</PRE>

</BLOCKQUOTE>

<P>

Let's look at the pattern with comments added using the extended

mode. In this case, it doesn't make sense to add comments directly

to the pattern because the pattern is part of the <TT>if</TT>

statement modifier. Adding comments in that location would make

the comments hard to format. So let's use a different tactic.

<BLOCKQUOTE>

<PRE>

$pattern = '^\w+     (?# Match the first word in the string)



            (?=\s+   (?# Use a look-ahead assertion to match)

                     (?# one or more whitespace characters)



               Vet)  (?# In addition to the whitespace, make)

                     (?# sure that the next column starts)

                     (?# with the character sequeNCe &quot;Vet&quot;)

           ';



while (&lt;&gt;) {

    push(@array, $&amp;) if m/$pattern/x;

}



print(&quot;@array\n&quot;);

</PRE>

</BLOCKQUOTE>

<P>

Here we used a variable to hold the pattern and then used variable

interpolation in the pattern with the match operator. You might

want to pick a more descriptive variable name than <TT>$pattern</TT>,

however.<BR>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Tip</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

Although the Perl documentation does not mention it, I believe you have only one look-ahead assertion per pattern, and it must be the last pattern component.</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<P>

The last extension that we'll discuss is the <I>zero-width negative

assertion</I>. This type of component is used to specify values

that shouldn't follow the matched string. For example, using the

same data as in the previous example, you can look for everyone

who is not a veterinarian. Your first iNClination might be to

simply replace the <TT>(?=...)</TT>

with the <TT>(?!...)</TT> in the previous

example.

<BLOCKQUOTE>

<PRE>

while (&lt;&gt;) {

    push(@array, $&amp;) if m/^\w+(?!\s+Vet)/;

}



print(&quot;@array\n&quot;);

</PRE>

</BLOCKQUOTE>

<P>

Unfortunately, this program displays

<BLOCKQUOTE>

<PRE>

Davi Jackie Kare

</PRE>

</BLOCKQUOTE>

<P>

which is not what you need. The problem is that Perl is looking

at the last character of the word to see if it matches the <TT>Vet</TT>

character sequeNCe. In order to correctly match the first word,

you need to explicitly tell Perl that the first word ends at a

word boundary, like this:

<BLOCKQUOTE>

<PRE>

while (&lt;&gt;) {

    push(@array, $&amp;) if m/^\w+\b(?!\s+Vet)/;

}



print(&quot;@array\n&quot;);

</PRE>

</BLOCKQUOTE>

<P>

This program displays

<BLOCKQUOTE>

<PRE>

Jackie

</PRE>

</BLOCKQUOTE>

<P>

which is correct.<BR>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Tip</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

There are many ways of matching any value. If the first method you try doesn't work, try breaking the value into smaller components and match each boundary. If all else fails, you can always ask for help on the <TT>comp.lang.perl.misc</TT> newsgroup.

</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<H2><A NAME="PatternExamples"><FONT SIZE=5 COLOR=#FF0000>

Pattern Examples</FONT></A></H2>

<P>

In order to demonstrate many different patterns, I will depart

from the standard example format in this section. Instead, I will

explain a matching situation and then a possible resolution will

immediately follow. After the resolution, I'll add some comments

to explain how the match is done. In all of these examples, the

string to search will be in the <TT>$_</TT>

variable.

<H3><A NAME="ExampleUsingtheMatchOperator">

Example: Using the Match Operator</A></H3>

<P>

If you need to find repeated characters in a string like the <TT>AA</TT>

in &quot;<TT>ABC AA ABC</TT>&quot;,

then do this:

<BLOCKQUOTE>

<PRE>

m/(.)\1/;

</PRE>

</BLOCKQUOTE>

<P>

This pattern uses pattern memory to store a single character.

Then a back-refereNCe (<TT>\1</TT>)

is used to repeat the first character. The back-refereNCe is used

to refereNCe the pattern memory while still inside the pattern.

Anywhere else in the program, use the <TT>$1</TT>

variable. After this statement, <TT>$1</TT>

will hold the repeated character. This pattern will match two

of any non-newline character.

<P>

If you need to find the first word in a string, then do this:

<BLOCKQUOTE>

<PRE>

m/^\s*(\w+)/;

</PRE>

</BLOCKQUOTE>

<P>

After this statement, <TT>$1</TT>

will hold the first word in the string. Any whitespace at the

beginning of the string will be skipped by the <TT>\s*</TT>

meta-character sequeNCe. Then the <TT>\w+</TT>

meta-character sequeNCe will match the next word. Note that the

<TT>*</TT>-which matches zero or more-is

used to match the whitespace because there may not be any. The

<TT>+</TT>-which matches one or more-is

used for the word.

<P>

If you need to find the last word in a string, then do this:

<BLOCKQUOTE>

<PRE>

m/

    (\w+)      (?# Match a word, store its value into pattern memory)



    [.!?]?     (?# Some strings might hold a senteNCe. If so, this)

               (?# component will match zero or one puNCtuation)

               (?# characters)



    \s*        (?# Match trailing whitespace using the * because there)

               (?# might not be any)



    $          (?# ANChor the match to the end of the string)

/x;

</PRE>

</BLOCKQUOTE>

<P>

After this statement, <TT>$1</TT>

will hold the last word in the string. You need to expand the

character class, [<TT>.!?</TT>], by

adding more puNCtuation.

<P>

If you need to know that there are only two words in a string,

you can do this:

<BLOCKQUOTE>

<PRE>

m/^(\w+)\W+(\w+)$/x;

</PRE>

</BLOCKQUOTE>

<P>

After this statement, <TT>$1</TT>

will hold the first word and <TT>$2</TT>

will hold the second word, assuming that the pattern matches.

The pattern starts with a caret and ends with a dollar sign, which

means that the entire string must match the pattern. The <TT>\w+</TT>

meta-character sequeNCe matches one word. The <TT>\W+</TT>

meta-character sequeNCe matches the whitespace between words.

You can test for additional words by adding one <TT>\W+</TT>(<TT>\w+</TT>)

meta-character sequeNCe for each additional word to match.

<P>

If you need to know that there are only two words in a string

while ignoring leading or trailing spaces, you can do this:

<BLOCKQUOTE>

<PRE>

m/^\s*(\w+)\W+(\w+)\s*$/;

</PRE>

</BLOCKQUOTE>

<P>

After this statement, <TT>$1</TT>

will hold the first word and <TT>$2</TT>

will hold the second word, assuming that the pattern matches.

The <TT>\s*</TT> meta-character sequeNCe

will match any leading or trailing whitespace.

<P>

If you need to assign the first two words in a string to <TT>$one</TT>

and <TT>$two</TT> and the rest of

the string to <TT>$rest</TT>, you

can do this:

<BLOCKQUOTE>

<PRE>

$_ = &quot;This is the way to San Jose.&quot;;



$word   = '\w+';    # match a whole word.



$space  = '\W+';    # match at least one character of whitespace



$string = '.*';     # match any number of anything except

                    # for the newline character.



($one, $two, $rest) = (m/^($word) $space ($word) $space ($string)/x);

</PRE>

</BLOCKQUOTE>

<P>

After this statement, <TT>$1</TT>

will hold the first word, <TT>$2</TT>

will hold the second word, and <TT>$rest</TT>

will hold everything else in the <TT>$_</TT>

variable. This example uses variable interpolation to, hopefully,

make the match pattern easier to read. This technique also emphasizes

which meta-sequeNCe is used to match words and whitespace. It

lets the reader focus on the whole of the pattern rather than

the individual pattern components by adding a level of abstraction.

<P>

If you need to see if <TT>$_</TT>

contains a legal Perl variable name, you can do this:

<BLOCKQUOTE>

<PRE>

$result = m/

            ^          (?# ANChor the pattern to the start of the string)



            [\$\@\%]   (?# Use a character class to match the first)

                       (?# character of a variable name)



            [a-z]      (?# Use a character class to ensure that the)

                       (?# character of the name is a letter)



            \w*        (?# Use a character class to ensure that the)

                       (?# rest of the variable name is either an)

                       (?# alphanumeric or an underscore character)



            $          (?# ANChor the pattern to the end of the)

                       (?# string. This means that for the pattern to)

                       (?# match, the variable name must be the only)

                       (?# value in $_.



          /ix;         # Use the /i option so that the search is

                       # case-insensitive and use the /x option to

                       # allow extensions.

</PRE>

</BLOCKQUOTE>

<P>

After this statement, <TT>$result</TT>

will be true if <TT>$_</TT> contains

a legal variable name and false if it does not.

<P>

If you need to see if <TT>$_</TT>

contains a legal integer literal, you can do this:

<BLOCKQUOTE>

<PRE>

$result = m/

            (?# First check for just numbers in $_)



            ^         (?# ANChor to the start of the string)

            \d+       (?# Match one or more digits)

            $         (?# ANChor to the end of the string)



            |         (?# or)



           (?# Now check for hexadecimal numbers)



            ^         (?# ANChor to the start of the string)

            0x        (?# The &quot;0x&quot; sequeNCe starts a hexadecimal number)

                        

            [\da-f]+  (?# Match one or more hexadecimal characters)

            $         (?# ANChor to the end of the string)

          /i;



</PRE>

</BLOCKQUOTE>

<P>

After this statement, <TT>$result</TT>

will be true if <TT>$_</TT> contains

an integer literal and false if it does not.

<P>

If you need to match all legal integers in <TT>$_</TT>,

you can do this:

<BLOCKQUOTE>

<PRE>

@results = m/^\d+$|^0[x][\da-f]+$/gi;

</PRE>

</BLOCKQUOTE>

<P>

After this statement, <TT>@result</TT>

will contain a list of all integer literals in <TT>$_</TT>.

<TT>@result</TT> will contain an empty

list if no literals are found.

<P>

If you need to match the end of the first word in a string, you

can do this:

<BLOCKQUOTE>

<PRE>

m/\w\W/;

</PRE>

</BLOCKQUOTE>

<P>

After this statement is executed, <TT>$&amp;</TT>

will hold the last character of the first word and the next character

that follows it. If you want only the last character, use pattern

memory, <TT>m/(\w)\W/</TT>;. Then

<TT>$1</TT> will be equal to the last

character of the first word. If you use the global option, <TT>@array

= m/\w\W/g</TT>;, then you can create an array that holds

the last character of each word in the string.

<P>

If you need to match the start of the second word in a string,

you can do this:

<BLOCKQUOTE>

<PRE>

m/\W\w/;

</PRE>

</BLOCKQUOTE>

<P>

After this statement, <TT>$&amp;</TT>

will hold the first character of the second word and the whitespace

character that immediately precedes it. While this pattern is

the opposite of the pattern that matches the end of words, it

will not match the beginning of the first word! This is because

of the <TT>\W</TT> meta-character.

Simply adding a <TT>*</TT> meta-character

to the pattern after the <TT>\W</TT>

does not help, because then it would match on zero non-word characters

and therefore match every word character in the string.

<P>

If you need to match the file name in a file specification, you

can do this:

<BLOCKQUOTE>

<PRE>

$_ = '/user/Jackie/temp/names.dat';

m!^.*/(.*)!;

</PRE>

</BLOCKQUOTE>

<P>

After this match statement, <TT>$1</TT>

will equal <TT>names.dat</TT>. The

match is aNChored to the beginning of the string, and the <TT>.*</TT>

component matches everything up to the last slash because regular

expressions are greedy. Then the next <TT>(.*)</TT>

matches the file name and stores it into pattern memory. You can

store the file path into pattern memory by placing parentheses

around the first <TT>.*</TT> component.

<P>

If you need to match two prefixes and one root word, like <TT>&quot;rockfish&quot;</TT>

and <TT>&quot;monkfish,&quot;</TT>

you can do this:

<BLOCKQUOTE>

<PRE>

m/(?:rock|monk)fish/x;

</PRE>

</BLOCKQUOTE>

<P>

The alternative meta-character is used to say that either <TT>rock</TT>

or <TT>monk</TT> followed by <TT>fish</TT>

needs to be found. If you need to know which alternative was found,

then use regular parentheses in the pattern. After the match,

<TT>$1</TT> will be equal to either

<TT>rock</TT> or <TT>monk</TT>.

<P>

If you want to search a file for a string and print some of the

surrounding lines, you can do this:

<BLOCKQUOTE>

<PRE>

# read the whole file into memory.

open(FILE, &quot;&lt;fndstr.dat&quot;);

@array = &lt;FILE&gt;;

close(FILE);



# specify which string to find.

$stringToFind = &quot;A&quot;;



# iterate over the array looking for the

# string.

for ($index = 0; $index &lt;= $#array; $index++) {

    last if $array[$index] =~ /$stringToFind/;

}



# Use $index to print two lines before

# and two lines after the line that contains

# the match.

foreach (@array[$index-2..$index+2]) {

    print(&quot;$index: $_&quot;);

    $index++;

}

</PRE>

</BLOCKQUOTE>

<P>

There are many ways to perform this type of search, and this is

just one of them. This technique is only good for relatively small

files because the entire file is read into memory at oNCe. In

addition, the program assumes that the input file always contains

the string that you are looking for.

<H3><A NAME="ExampleUsingtheSubstitutionOperator">

Example: Using the Substitution Operator</A></H3>

<P>

If you need to remove white space from the beginning of a string,

you can do this:

<BLOCKQUOTE>

<PRE>

s/^\s+//;

</PRE>

</BLOCKQUOTE>

<P>

This pattern uses the <TT>\s</TT>

predefined character class to match any whitespace character.

The plus sign means to match zero or more white space characters,

and the caret means match only at the beginning of the string.

<P>

If you need to remove whitespace from the end of a string, you

can do this:

<BLOCKQUOTE>

<PRE>

s/\s+$//;

</PRE>

</BLOCKQUOTE>

<P>

This pattern uses the <TT>\s</TT>

predefined character class to match any whitespace character.

The plus sign means to match zero or more white space characters,

and the dollar sign means match only at the end of the string.

<P>

If you need to add a prefix to a string, you can do this:

<BLOCKQUOTE>

<PRE>

$prefix = &quot;A&quot;;

</FONT><FONT SIZE=2 FACE="Courier">s/^(.*)/$prefix$1/;

</PRE>

</BLOCKQUOTE>

<P>

When the substitution is done, the value in the <TT>$prefix</TT>

variable will be added to the beginning of the <TT>$_</TT>

variable. This is done by using variable interpolation and pattern

memory. Of course, you also might consider using the string coNCatenation

operator; for instaNCe, <TT>$_ = &quot;A&quot;

. $_;</TT>, which is probably faster.

<P>

If you need to add a suffix to a string, you can do this:

<BLOCKQUOTE>

<PRE>

$suffix = &quot;Z&quot;;

s/^(.*)/$1$suffix/;

</PRE>

</BLOCKQUOTE>

<P>

When the substitution is done, the value in the <TT>$suffix</TT>

variable will be added to the end of the $_ variable. This is

done by using variable interpolation and pattern memory. Of course,

you also might consider using the string coNCatenation operator;

for instaNCe, <TT>$_ .= &quot;Z&quot;;</TT>,

which is probably faster.

<P>

If you need to reverse the first two words in a string, you can

do this:

<BLOCKQUOTE>

<PRE>

s/^\s*(\w+)\W+(\w+)/$2 $1/;

</PRE>

</BLOCKQUOTE>

<P>

This substitution statement uses the pattern memory variables

<TT>$1</TT> and <TT>$2</TT>

to reverse the first two words in a string. You can use a similar

technique to manipulate columns of information, the last two words,

or even to change the order of more than two matches.

<P>

If you need to duplicate each character in a string, you can do

this:

<BLOCKQUOTE>

<PRE>

s/\w/$&amp; x 2/eg;

</PRE>

</BLOCKQUOTE>

<P>

When the substitution is done, each character in <TT>$_</TT>

will be repeated. If the original string was <TT>&quot;123abc&quot;</TT>,

the new string would be <TT>&quot;112233aabbcc&quot;</TT>.

The e option is used to force evaluation of the replacement string.

The <TT>$&amp;</TT> special variable

is used in the replacement pattern to refereNCe the matched string,

which then is repeated by the string repetition operator.

<P>

If you need to capitalize all the words in a senteNCe, you can

do this:

<BLOCKQUOTE>

<PRE>

s/(\w+)/\u$1/g;

</PRE>

</BLOCKQUOTE>

<P>

When the substitution is done, each character in <TT>$_</TT>

will have its first letter capitalized. The <TT>/g</TT>

option means that each word-the <TT>\w+</TT>

meta-sequeNCe-will be matched and placed in <TT>$1</TT>.

Then it will be replaced by <TT>\u$1</TT>.

The <TT>\u</TT> will capitalize whatever

follows it; in this case, it's the matched word.

<P>

If you need to insert a string between two repeated characters,

you can do this:

<BLOCKQUOTE>

<PRE>

$_      = &quot;!!!!&quot;;

$char   = &quot;!&quot;;

$insert = &quot;AAA&quot;;



s{

    ($char)             # look for the specified character.



    (?=$char)           # look for it again, but don't iNClude

                        # it in the matched string, so the next

}                       # search also will find it.

{

    $char . $insert     # coNCatenate the specified character

                        # with the string to insert.



}xeg;                   # use extended mode, evaluate the

                        # replacement pattern, and match all

                        # possible strings.



print(&quot;$_\n&quot;);

</PRE>

</BLOCKQUOTE>

<P>

This example uses the extended mode to add comments directly inside

the regular expression. This makes it easy to relate the comment

directly to a specific pattern element. The match pattern does

not directly reflect the originally stated goal of inserting a

string between two repeated characters. Instead, the example was

quietly restated. The new goal is to substitute all instaNCes

of <TT>$char</TT> with <TT>$char</TT>

<TT>. $insert</TT>, if <TT>$char</TT>

is followed by <TT>$char</TT>. As

you can see, the end result is the same. Remember that sometimes

you need to think outside the box.

<P>

If you need to do a second level of variable interpolation in

the replacement pattern, you can do this:

<BLOCKQUOTE>

<PRE>

s/(\$\w+)/$1/eeg;

</PRE>

</BLOCKQUOTE>

<P>

This is a simple example of secondary variable interpolation.

If <TT>$firstVar =</TT> <TT>&quot;AAA&quot;</TT>

and <TT>$_ = '$firstVar'</TT>, then

<TT>$_</TT> would be equal to <TT>&quot;AAA&quot;</TT>

after the substitution was made. The key is that the replacement

pattern is evaluated twice. This technique is very powerful. It

can be used to develop error messages used with variable interpolation.

<BLOCKQUOTE>

<PRE>

$errMsg = &quot;File too large&quot;;

$fileName = &quot;DATA.OUT&quot;;

$_ = 'Error: $errMsg for the file named $fileName';

s/(\$\w+)/$1/eeg;

print;

</PRE>

</BLOCKQUOTE>

<P>

When this program is run, it will display

<BLOCKQUOTE>

<PRE>

Error: File too large for the file named DATA.OUT

</PRE>

</BLOCKQUOTE>

<P>

The values of the <TT>$errMsg</TT>

and <TT>$fileName</TT> variables were

interpolated into the replacement pattern as needed.

<H3><A NAME="ExampleUsingtheTranslationOperator">

Example: Using the Translation Operator</A></H3>

<P>

If you need to count the number of times a given letter appears

in a string, you can do this:

<BLOCKQUOTE>

<PRE>

$cnt = tr/Aa//;

</PRE>

</BLOCKQUOTE>

<P>

After this statement executes, <TT>$cnt</TT>

will hold the number of times the letter a appears in <TT>$_</TT>.

The <TT>tr</TT> operator does not

have an option to ignore the case of the string, so both upper-

and lowercase need to be specified.

<P>

If you need to turn the high bit off for every character in <TT>$_</TT>,

you can do this:

<BLOCKQUOTE>

<PRE>

tr [\200-\377] [\000-\177];

</PRE>

</BLOCKQUOTE>

<P>

This statement uses the square brackets to delimit the character

lists. Notice that spaces can be used between the pairs of brackets

to enhaNCe readability of the lists. The octal values are used

to specify the character ranges. The translation operator is more

efficient-in this instaNCe-than using logical operators and a

loop statement. This is because the translation can be done by

creating a simple lookup table.

<H3><A NAME="ExampleUsingtheISplitIFuNCtion">

Example: Using the <I>Split()</I> FuNCtion</A></H3>

<P>

If you need to split a string into words, you can do this:

<BLOCKQUOTE>

<PRE>

s/^\s+//;

@array = split;

</PRE>

</BLOCKQUOTE>

<P>

After this statement executes, <TT>@array</TT>

will be an array of words. Before splitting the string, you need

to remove any beginning white space. If this is not done, split

will create an array element with the white space as the first

element in the array, and this is probably not what you want.

<P>

If you need to split a string contained in <TT>$line</TT>

instead of <TT>$_</TT> into words,

you can do this:

<BLOCKQUOTE>

<PRE>

$line =~ s/^\s+//;

@array = split(/\W/, $line);

</PRE>

</BLOCKQUOTE>

<P>

After this statement executes, <TT>@array</TT>

will be an array of words.

<P>

If you need to split a string into characters, you can do this:

<BLOCKQUOTE>

<PRE>

@array = split(//);

</PRE>

</BLOCKQUOTE>

<P>

After this statement executes, <TT>@array</TT>

will be an array of characters. <TT>split</TT>

recognizes the empty pattern as a request to make every character

into a separate array element.

<P>

If you need to split a string into fields based on a delimiter

sequeNCe of characters, you can do this:

<BLOCKQUOTE>

<PRE>

@array = split(/:/);

</PRE>

</BLOCKQUOTE>

<P>

<TT>@array</TT> will be an array of

strings consisting of the values between the delimiters. If there

are repeated delimiters-<TT>::</TT>

in this example-then an empty array element will be created. Use

<TT>/:+/</TT> as the delimiter to

match in order to eliminate the empty array elements.

<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>

Summary</FONT></A></H2>

<P>

This chapter introduced you to regular expressions or patterns,

regular expression operators, and the binding operators. There

are three regular expression operators-<TT>m//</TT>,

<TT>s///</TT>, and <TT>tr///</TT>-which

are used to match, substitute, and translate and use the <TT>$_</TT>

variable as the default operand. The binding operators, <TT>=~</TT>

and <TT>!~</TT>, are used to bind

the regular expression operators to a variable other than <TT>$_</TT>.

<P>

While the slash character is the default pattern delimiter, you

can use any character in its place. This feature is useful if

the pattern contains the slash character. If you use an opening

bracket or parenthesis as the beginning delimiter, use the closing

bracket or parenthesis as the ending delimiter. Using the single-quote

as the delimiter will turn off variable interpolation for the

pattern.

<P>

The matching operator has six options: <TT>/g</TT>,

<TT>/i</TT>, <TT>/m</TT>,

<TT>/o</TT>, <TT>/s</TT>,

and <TT>/x</TT>. These options were

described in Table 10.2. I've found that the <TT>/x</TT>

option is very helpful for creating maintainable, commented programs.

The <TT>/g</TT> option, used to find

all matches in a string, also is useful. And, of course, the capability

to create case-insensitive patterns using the <TT>/i</TT>

option is crucial in many cases.

<P>

The substitution operator has the same options as the matching

operator and one more-the <TT>/e</TT>

option. The <TT>/e</TT> option lets

you evaluate the replacement pattern and use the new value as

the replacement string. If you use back-quotes as delimiters,

the replacement pattern will be executed as a DOS or UNIX command,

and the resulting output will become the replacement string.

<P>

The translation operator has three options: <TT>/c</TT>,

<TT>/d</TT>, and <TT>/s</TT>.

These options are used to complement the match character list,

delete characters not in the match character list, and eliminate

repeated characters in a string. If no replacement list is specified,

the number of matched characters will be returned. This is handy

if you need to know how many times a given character appears in

a string.

<P>

The binding operators are used to force the matching, substitution,

and translation operators to search a variable other than <TT>$_</TT>.

The <TT>=~</TT> operator can be used

with all three of the regular expression operators, while the

<TT>!~</TT> operator can be used only

with the matching operator.

<P>

Quite a bit of space was devoted to creating patterns, and the

topic deserves even more space. This is easily one of the more

involved features of the Perl language. One key coNCept is that

a character can have multiple meanings. For example, the plus

sign can mean a plus sign in one instaNCe (its literal meaning),

and in another it means match something one or more times (its

meta-meaning).

<P>

You learned about regular expression components and that they

can be combined in an infinite number of ways. Table 10.5 listed

most of the meta-meanings for different characters. You read about

character classes, alternation, quantifiers, aNChors, pattern

memory, word boundaries, and extended components.

<P>

The last section of the chapter was devoted to presenting numerous

examples of how to use regular expressions to accomplish specific

goals. Each situation was described, and a pattern that matched

that situation was shown. Some commentary was given for each example.

<P>

In the next chapter, you'll read about how to present information

by using formats. Formats are used to help relieve some of the

programming burden from the task of creating reports.

<H2><A NAME="ReviewQuestions"><FONT SIZE=5 COLOR=#FF0000>

Review Questions</FONT></A></H2>

<P>

Answers to Review Questions are in Appendix A.

<OL>

<LI>Can you use variable interpolation with the translation operator?

<LI>What happens if the pattern is empty?

<LI>What variable does the substitution operator use as its default?

<LI>Will the following line of code work?<BR>

<BR>

<TT> m{.*];</TT>

<LI>What is the <TT>/g</TT> option

of the substitution operator used for?

<LI>What does the <TT>\d</TT> meta-character

sequeNCe mean?

<LI>What is the meaning of the dollar sign in the following pattern?

<BR>

<BR>

<TT>/AA[.&lt;]$]ER/</TT>

<LI>What is a word boundary?

<LI>What will be displayed by the following program?<BR>

<BR>

<TT>$_ = 'AB AB AC';<BR>

print m/c$/i;</TT>

</OL>

<H2><A NAME="ReviewExercises"><FONT SIZE=5 COLOR=#FF0000>

Review Exercises</FONT></A></H2>

<OL>

<LI>Write a pattern that matches either <TT>&quot;top&quot;</TT>

or <TT>&quot;topgun&quot;</TT>.

<LI>Write a program that accepts input from <TT>STDIN</TT>

and changes all instaNCes of the letter <TT>a</TT>

into the letter <TT>b</TT>.

<LI>Write a pattern that stores the first character to follow

a tab into pattern memory.

<LI>Write a pattern that matches the letter <TT><I>g</I></TT>

between three and seven times.

<LI>Write a program that finds repeated words in an input file

and prints the repeated word and the line number on which it was

found.

<LI>Create a character class for octal numbers.

<LI>Write a program that uses the translation operator to remove

repeated instaNCes of the tab character and then replaces the

tab character with a space character.

<LI>Write a pattern that matches either <TT>&quot;top&quot;</TT>

or <TT>&quot;topgun&quot;</TT> using

a zero-width positive look-ahead assertion.

</OL>

<HR>



<CENTER><P><A HREF="ch9.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch9.htm"><IMG SRC="pc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="index-1.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/index-1.htm"><IMG SRC="hb.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="ch11.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch11.htm"><IMG SRC="nc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<HR WIDTH="100%"></P></CENTER>

</BODY>

</HTML>

