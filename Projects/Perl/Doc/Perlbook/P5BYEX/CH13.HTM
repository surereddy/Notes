<html>

<head>

<title>Chapter 13  -- Handling Errors and Signals</title>



<meta>

</head>

<body TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">

<h1><font SIZE="6" COLOR="#FF0000">Chapter&nbsp;13</font></h1>

<h1><font SIZE="6" COLOR="#FF0000">Handling Errors and Signals</font>

</h1>

<hr>

<p>

<center><b><font SIZE="5">CONTENTS</font></b></center>

<ul>

<li><a HREF="#CheckingforErrors">

Checking for Errors</a>

<li><a HREF="#ExampleUsingtheTTFONTSIZEFACECouriererrnoFONTTTFONTSIZEVariableFONT">

Example: Using the <tt>errno</tt>

Variable</font></a>

<ul>

<li><a HREF="#ExampleUsingtheTTFONTSIZEFACECourierorFONTTTFONTSIZELogicalOperatorFONT">

Example: Using the <tt>or</tt>

Logical Operator</font></a>

<li><a HREF="#ExampleUsingtheTTFONTSIZEFACECourierdieFONTTTFONTSIZEFuNCtionFONT">

Example: Using the <tt>die()</tt>

FuNCtion</font></a>

<li><a HREF="#ExampleUsingtheTTFONTSIZEFACECourierwarnFONTTTFONTSIZEFuNCtionFONT">

Example: Using the <tt>warn()</tt>

FuNCtion</font></a>

</ul>

<li><a HREF="#TrappingFatalErrors">

Trapping Fatal Errors</a>

<ul>

<li><a HREF="#ExampleUsingtheTTFONTSIZEFACECourierevalFONTTTFONTSIZEFuNCtionFONT">

Example: Using the <tt>eval()</tt>

FuNCtion</font></a>

</ul>

<li><a HREF="#WhatIsaSignal">

What Is a Signal?</a>

<ul>

<li><a HREF="#ExampleHowtoHandleaSignal">

Example: How to Handle a Signal</a>

</ul>

<li><a HREF="#Summary">

Summary</a>

<li><a HREF="#ReviewQuestions">

Review Questions</a>

<li><a HREF="#ReviewExercises">

Review Exercises</a>

</ul>



<hr>

<p>

Most of the examples in this book have been ignoring the fact

that errors can and probably will occur. An error can occur because

the directory you are trying to use does not exist, the disk is

full, or any of a thousand other reasons. Quite often, you won't

be able to do anything to recover from an error, and your program

should exit. However, exiting after displaying a user-friendly

error message is much preferable than waiting until the operating

system or Perl's own error handling takes over.

<p>

After looking at errors generated by fuNCtion calls, we'll look

at a way to prevent certain normally fatal activities-like dividing

by zero-from stopping the execution of your script; this is by

using the <tt>eval()</tt> fuNCtion.

<p>

Then, you'll see what a signal is and how to use the <tt>%SIG</tt>

associative array to create a signal handling fuNCtion.

<h2><a NAME="CheckingforErrors"><font SIZE="5" COLOR="#FF0000">

Checking for Errors</font></a></h2>

<p>

There is only one way to check for errors in any programming language.

You need to test the return values of the fuNCtions that you call.

Most fuNCtions return zero or false when something goes wrong.

So when using a critical fuNCtion like <tt>open()</tt>

or <tt>sysread()</tt>, checking the

return value helps to ensure that your program will work properly.

<p>

Perl has two special variables-<tt>$?</tt>

and <tt>$!</tt>-that help in finding

out what happened after an error has occurred. The <tt>$?</tt>

variable holds the status of the last pipe close, back-quote string,

or <tt>system()</tt> fuNCtion. The

<tt>$!</tt> variable can be used in

either a numeric or a string context. In a numeric context it

holds the current value of <tt>errno</tt>.

If used in a string context, it holds the error string associated

with <tt>errno</tt>. The variable,

<i>errno</i>, is pre-defined variable that can sometimes be used

to determine the last error that took place. <br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Caution</b></td></tr>

<tr><td>

<blockquote>

You can't rely on these variables to check the status of pipes, back-quoted strings, or the <tt>system()</tt> fuNCtion when executing scripts under the Windows operating system. My recommendation is to capture the output of the back-quoted string and 
check it directly for error messages. Of course, the command writes its errors to <tt>STDERR</tt> and then can't trap them, and you're out of luck.

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

ONCe you detect an error and you can't correct the problem without

outside intervention, you need to communicate the problem to the

user. This is usually done with the <tt>die()</tt>

and <tt>warn()</tt> fuNCtions.

<h2><a NAME="ExampleUsingtheTTFONTSIZEFACECouriererrnoFONTTTFONTSIZEVariableFONT"><font SIZE="5" COLOR="#FF0000">

Example: Using the <tt>errno</tt>

Variable</font></font></a></h2>

<p>

When an error occurs, it is common practice for UNIX-based fuNCtions

and programs to set a variable called <tt>errno</tt>

to reflect which error has occurred. If <tt>errno=2</tt>,

then your script tried to access a directory or file that did

not exist. Table 13.1 lists 10 possible values the <tt>errno</tt>

variable can take, but there are hundreds more. If you are interested

in seeing all the possible error values, run the program in Listing

13.1.<br>

<p>

<center><b>Table 13.1&nbsp;&nbsp;Ten Possible Values for </b><tt><b><font FACE="Courier">errno</font></b></tt></center>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td WIDTH="59"><center><i>Value</i></center></td><td WIDTH="356"><i>Description</i>

</td></tr>

<tr><td WIDTH="59"><center>1</center></td><td WIDTH="356">Operation not permitted

</td></tr>

<tr><td WIDTH="59"><center>2</center></td><td WIDTH="356">No such file or directory

</td></tr>

<tr><td WIDTH="59"><center>3</center></td><td WIDTH="356">No such process

</td></tr>

<tr><td WIDTH="59"><center>4</center></td><td WIDTH="356">Interrupted fuNCtion call

</td></tr>

<tr><td WIDTH="59"><center>5</center></td><td WIDTH="356">Input/output error

</td></tr>

<tr><td WIDTH="59"><center>6</center></td><td WIDTH="356">No such device or address

</td></tr>

<tr><td WIDTH="59"><center>7</center></td><td WIDTH="356">Arg list too long

</td></tr>

<tr><td WIDTH="59"><center>8</center></td><td WIDTH="356">Exec format error

</td></tr>

<tr><td WIDTH="59"><center>9</center></td><td WIDTH="356">Bad file descriptor

</td></tr>

<tr><td WIDTH="59"><center>10</center></td><td WIDTH="356">No child processes

</td></tr>

</table>

</center>

<p>

<p>



<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Loop from 1 to 10,000 using </i><tt><i>$!</i></tt><i>

as the loop variable.<br>

Evaluate the </i><tt><i>$!</i></tt><i>

variable in a string context so that </i><tt><i>$errText</i></tt><i>

is assigned the error message associated with the value of </i><tt><i>$!</i></tt><i>.

<br>

Use </i><tt><i>chomp()</i></tt><i>

to eliminate possible newlines at the end of an error message.

Some of the messages have newlines, and some don't.<br>

Print the error message if the message is not </i><tt><i>Unknown

Error</i></tt><i>. Any error value not used by the system

defaults to </i><tt><i>Unknown Error</i></tt><i>.

Using the if statement modifier ensures that only valid error

messages are displayed.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 13.1&nbsp;&nbsp;13LST01.PL-A Program to List All Possible

Values for </b><tt><i><b><font FACE="Courier">errno<br>

</font></b></i></tt>

</blockquote>

<blockquote>

<pre>

for ($! = 1; $! &lt;= 10000; $!++) {

    $errText = $!;

    chomp($errText);

    printf(&quot;%04d: %s\n&quot;, $!, $errText) if $! ne &quot;Unknown Error&quot;;

}

</pre>

</blockquote>

<hr>

<p>

Under Windows 95, this program prints 787 error messages. Most

of them are totally unrelated to Perl.

<h3><a NAME="ExampleUsingtheTTFONTSIZEFACECourierorFONTTTFONTSIZELogicalOperatorFONT">

Example: Using the <tt>or</tt>

Logical Operator</font></a></h3>

<p>

Perl provides a special logical operator that is ideal for testing

the return values from fuNCtions. You may recall that the <tt>or</tt>

operator will evaluate only the right operand if the left operand

is false. Because most fuNCtions return false when an error occurs,

you can use the <tt>or</tt> operator

to control the display of error messages. For example:

<blockquote>

<pre>

chdir('/user/printer') or print(&quot;Can't connect to Printer dir.\n&quot;);

</pre>

</blockquote>

<p>

This code prints only the error message if the program can't change

to the <tt>/user/printer</tt> directory.

Unfortunately, simply telling the user what the problem is, frequently,

is not good enough. The program must also exit to avoid compounding

the problems. You could use the comma operator to add a second

statement to the right operand of the <tt>or</tt>

operator. Adding an <tt>exit()</tt>

statement to the previous line of code looks like this:

<blockquote>

<pre>

chdir('/usr/printer') or print(&quot;failure\n&quot;), exit(1);

print(&quot;success\n&quot;);

</pre>

</blockquote>

<p>

I added the extra <tt>print</tt> statement

to prove that the script really exits. If the printer directory

does not exist, the second <tt>print</tt>

statement is not executed.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

At the shell or DOS, a zero return value means that the program ended successfully. While inside a Perl script, a zero return value frequently means an error has occurred. Be careful when dealing with return values; you should always check your 
documentation. </blockquote>



</td></tr>

</table>

</center>

<p>

<p>

Using the comma operator to execute two statements instead of

one is awkward and prone to misinterpretation when other programmers

look at the script. Fortunately, you can use the <tt>die()</tt>

fuNCtion to get the same fuNCtionality.

<h3><a NAME="ExampleUsingtheTTFONTSIZEFACECourierdieFONTTTFONTSIZEFuNCtionFONT">

Example: Using the <tt>die()</tt>

FuNCtion</font></a></h3>

<p>

The <tt>die()</tt> fuNCtion is used

to quit your script and display a message for the user to read.

Its syntax is

<blockquote>

<pre>

die(LIST);

</pre>

</blockquote>

<p>

The elements of <tt>LIST</tt> are

printed to <tt>STDERR</tt>, and then

the script will exit, setting the script's return value to <tt>$!</tt>

(<tt>errno</tt>). If you were running

the Perl script from inside a C program or UNIX script, you could

then check the return value to see what went wrong.

<p>

The simplest way to use the <tt>die()</tt>

fuNCtion is to place it on the right side of the <tt>or</tt>

operator

<blockquote>

<pre>

chdir('/user/printer') or die();

</pre>

</blockquote>

<p>

which displays

<blockquote>

<pre>

Died at test.pl line 2.

</pre>

</blockquote>

<p>

if the /user/printer directory does not exist. The message is

not too informative, so you should always iNClude a message telling

the user what happened. If you don't know what the error might

be, you can always display the error text associated with errno.

For example:

<blockquote>

<pre>

chdir('/user/printer') or die(&quot;$!&quot;);

</pre>

</blockquote>

<p>

This line of code displays

<blockquote>

<pre>

No such file or directory at test.pl line 2.

</pre>

</blockquote>

<p>

This error message is a bit more informative. It's even better

if you append the text , <tt>stopped</tt>

to the error message like this:

<blockquote>

<pre>

chdir('/user/printer') or die(&quot;$!, stopped&quot;);

</pre>

</blockquote>

<p>

which displays

<blockquote>

<pre>

No such file or directory, stopped at test.pl line 2.

</pre>

</blockquote>

<p>

Appending the extra string makes the error message look a little

more professional. If you are really looking for informative error

messages, try this:

<blockquote>

<pre>

$code = &quot;chdir('/user/printer')&quot;;

eval($code) or die(&quot;PROBLEM WITH LINE: $code\n$! , stopped&quot;);

</pre>

</blockquote>

<p>

which displays the following:

<blockquote>

<pre>

PROBLEM WITH LINE: chdir('/user/printer')

No such file or directory , stopped at test.pl line 3.

</pre>

</blockquote>

<p>

The <tt>eval()</tt> fuNCtion is discussed

in the section, &quot;Example: Using the <tt>eval()</tt>

FuNCtion,&quot; later in this chapter. Therefore, I won't explain

what this code is doing other than to say that the <tt>eval()</tt>

fuNCtion executes its arguments as semi-isolated Perl code. First,

the Perl code in <tt>$code</tt> is

executed and then, if an error arises, the Perl code in <tt>$code</tt>

is displayed as text by the <tt>die()</tt>

fuNCtion.

<p>

If you don't want <tt>die()</tt> to

add the script name and line number to the error, add a newline

to the end of the error message. For example:

<blockquote>

<pre>

chdir('/user/printer') or die(&quot;$!\n&quot;);

</pre>

</blockquote>

<p>

displays the following

<blockquote>

<pre>

No such file or directory

</pre>

</blockquote>

<h3><a NAME="ExampleUsingtheTTFONTSIZEFACECourierwarnFONTTTFONTSIZEFuNCtionFONT">

Example: Using the <tt>warn()</tt>

FuNCtion</font></a></h3>

<p>

The <tt>warn()</tt> fuNCtion has the

same fuNCtionality that <tt>die()</tt>

does except the script is not exited. This fuNCtion is better

suited for nonfatal messages like low memory or disk space conditions.

The next example tries to change to the <tt>/text</tt>

directory. If the connect fails, the consequeNCes are not fatal

because the files can still be written to the current directory.

<blockquote>

<pre>

chdir('/text') or warn(&quot;Using current directory instead of /text, 

</font><font SIZE="2" FACE="ZapfDingbats">&Acirc;</font><font SIZE="2" FACE="Courier">warning&quot;);

</pre>

</blockquote>

<p>

This line of code displays

<blockquote>

<pre>

Using current directory instead of /text, warning at test.pl line 2.

</pre>

</blockquote>

<p>

if the <tt>/text</tt> directory does

not exist. As with <tt>die()</tt>,

you can eliminate the script name and line number by ending your

error message with a newline. You could also use the <tt>$!</tt>

variable to display the system error message.

<h2><a NAME="TrappingFatalErrors"><font SIZE="5" COLOR="#FF0000">

Trapping Fatal Errors</font></a></h2>

<p>

There are times when reporting fatal errors and then exiting the

script are not appropriate responses to a problem. For example,

your script might try to use the <tt>alarm()</tt>

fuNCtion, which is not supported in some versions of Perl. Normally,

using an unsupported fuNCtion causes your problem to exit, but

you can use the <tt>eval()</tt> fuNCtion

to trap the error and avoid ending the script.

<p>

The <tt>eval()</tt> fuNCtion accepts

an expression and then executes it. Any errors generated by the

execution will be isolated and not affect the main program. However,

all fuNCtion definitions and variable modifications do affect

the main program.

<h3><a NAME="ExampleUsingtheTTFONTSIZEFACECourierevalFONTTTFONTSIZEFuNCtionFONT">

Example: Using the <tt>eval()</tt>

FuNCtion</font></a></h3>

<p>

You can use the <tt>eval()</tt> fuNCtion

to trap a normally fatal error:

<blockquote>

<pre>

eval { alarm(15) };

warn() if $@;



eval { print(&quot;The print fuNCtion worked.\n&quot;); };

warn() if $@;

</pre>

</blockquote>

<p>

This program displays the following:

<blockquote>

<pre>

The Unsupported fuNCtion alarm fuNCtion is unimplemented at test.pl line 

&nbsp;2.

        ...caught at test.pl line 3.

The print fuNCtion worked.

</pre>

</blockquote>

<p>

The <tt>$@</tt> special variable holds

the error message, if any, returned by the execution of the expression

passed to the <tt>eval()</tt> fuNCtion.

If the expression is evaluated correctly, then <tt>$@</tt>

is an empty string. You probably remember that an empty string

is evaluated as false when used as a conditional expression.

<p>

In an earlier section, &quot;Example: Using the <tt>die()</tt>

FuNCtion,&quot; you saw the following code snippet being used:

<blockquote>

<pre>

$code = &quot;chdir('/user/printer')&quot;;

eval($code) or die(&quot;PROBLEM WITH LINE: $code\n$! , stopped&quot;);

</pre>

</blockquote>

<p>

This program shows that <tt>eval()</tt>

will execute a line of code that is inside a variable. You can

use this capability in many different ways besides simply trapping

fatal errors. The program in Listing 13.2 presents a prompt and

executes Perl code as you type it. Another way of looking at this

program is that it is an interactive Perl interpreter.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Loop until the user enters </i><tt><i>exit</i></tt><i>.

<br>

Print the prompt.<br>

Get a line of input from </i><tt><i>STDIN</i></tt><i>

and remove the ending linefeed.<br>

Execute the line.<br>

If the executed code set the </i><tt><i>$@</i></tt><i>

error message variable, display the error message as a warning.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 13.2&nbsp;&nbsp;13LST02.PL-Using Perl Interactively

<br>

</b>

</blockquote>

<blockquote>

<pre>

do {

    print(&quot;&gt; &quot;);

    chop($_ = &lt;&gt;);

    eval($_);

    warn() if $@;

} while ($_ ne &quot;exit&quot;);

</pre>

</blockquote>

<hr>

<p>

When you run this program, you will see a <tt>&gt;</tt>

prompt. At the prompt, you can type in any Perl code. When you

press Enter, the line is executed. You can even define fuNCtions

you can use later in the interactive session. The program can

be stopped by typing <tt>exit</tt>

at the command line.

<p>

If you like powerful command-line environments, you can build

on this small program to create a personalized system. For example,

you might need to perform a backup operation before leaving work.

Instead of creating a batch file (under DOS) or a shell file (under

UNIX), you can add a new command to the Perl interactive program,

as in Listing 13.3.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Loop until the user enters </i><tt><i>exit</i></tt><i>.

<br>

Print the prompt.<br>

Get a line of input from </i><tt><i>STDIN</i></tt><i>

and remove the ending linefeed.<br>

If the inputted line begins with </i><tt><i>do#</i></tt><i>,

then a custom command has been  entered.<br>

Process the </i><tt><i>do#backup</i></tt><i>

custom command.<br>

See if the user needs help.<br>

Otherwise, use the </i><tt><i>eval()</i></tt><i>

fuNCtion to execute the inputted line.<br>

If the executed code set the </i><tt><i>$@</i></tt><i>

error message variable, display the error message as a warning.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 13.3&nbsp;&nbsp;13LST03.PL-An Interactive Perl Interpreter

that Understands Custom Commands<br>

</b>

</blockquote>

<blockquote>

<pre>

sub backItUp {

    '\backup /user/*';

    'delete /user/*.bak'

}



sub help {

    print(&quot;do#backup will perform the nightly backup\n&quot;);

    print(&quot;help will display this message.\n\n&quot;);

}



do {

    print(&quot;&gt; &quot;);

    chop($_ = &lt;&gt;);

    if (/^do#/) {

        backItUp)() if /backup/;

    }

    elsif (/^\s*help/) {

        help();

    }

    else {

        eval($_);

        warn() if $@;

    }

} while ($_ ne &quot;exit&quot;);

</pre>

</blockquote>

<hr>

<p>

This program invokes the backup program and deletes the backup

files if you enter <tt>do#backup</tt>

at the <tt>&gt;</tt> prompt. Of course,

you need to modify this program to perform the customized commands

you'd like to have. This technique also enables you to centralize

your administrative tasks, which will make them easier to document

and maintain.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Tip</b></td></tr>

<tr><td>

<blockquote>

If you are running Perl on a DOS or Windows machine, consider replacing your small batch utility programs with one Perl interpreter and some customized commands. This saves on hard disk space if you use a lot of batch files because each file may take up 
to 4,096 bytes, regardless of its actual size.</blockquote>



</td></tr>

</table>

</center>

<p>

<h2><a NAME="WhatIsaSignal"><font SIZE="5" COLOR="#FF0000">

What Is a Signal?</font></a></h2>

<p>

<i>Signals</i> are messages sent by the operating system to the

process running your Perl script. At any time, a signal that must

be answered can be sent to your process. Normally, a default handler

is used to take care of a signal. For example, under Windows 95,

when you press the Ctrl+C key combination, your process is sent

an <tt>INT</tt> or interrupt signal.

The default handler responds by ending the process and displays

the following message:

<blockquote>

<pre>

^C at test.pl line 22

</pre>

</blockquote>

<p>

Of course, the filename and line number change to match the particulars

of whatever script happens to be running when Ctrl+C was pressed.

The <tt>^C</tt> notation refers to

the Ctrl+C key sequeNCe.

<h3><a NAME="ExampleHowtoHandleaSignal">

Example: How to Handle a Signal</a></h3>

<p>

You can cause Perl to ignore the Ctrl+C key sequeNCe by placing

the following line of code near the beginning of your program:

<blockquote>

<pre>

$SIG{'INT'} = 'IGNORE';

</pre>

</blockquote>

<p>

You can restore the default handler like this:

<blockquote>

<pre>

$SIG{'INT'} = 'DEFAULT';

</pre>

</blockquote>

<p>

If you need to ensure that files are closed, error messages are

written, or other cleanup chores are completed, you need to create

a custom <tt>INT</tt> handle fuNCtion.

For example:

<blockquote>

<pre>

sub INT_handler {

    # close all files.

    # send error message to log file.

    exit(0);

}



$SIG{'INT'} = 'INT_handler';

</pre>

</blockquote>

<p>

If the Ctrl+C key sequeNCe is pressed anytime after the hash assignment

is made, the <tt>INT_handler</tt>

fuNCtion is called instead of the default handler.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

In theory, you could remove the <tt>exit()</tt> call from the signal handler fuNCtion, and the script should start executing from wherever it left off. However, this feature is not working on several platforms. If you want to test your platform, run the 
following small program:

</blockquote>

<blockquote>

<tt>sub INT_handler {<br>

&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Don't Interrupt!\n&quot;);<br>

}<br>

<br>

$SIG{'INT'} = 'INT_handler';<br>

for ($x = 0; $x &lt; 10; $x++) {<br>

&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;$x\n&quot;);<br>

&nbsp;&nbsp;&nbsp;&nbsp;sleep 1;<br>

}</tt>

</blockquote>

<blockquote>

You should be able to press Ctrl+C while the script is counting without forcing the script to end.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

The <tt>%SIG</tt> associative array

holds only entries you have created for your custom signal handler

fuNCtions. So, unfortunately, you can't find out which signals

are supported by looking at the array returned by <tt><i>keys</font></i><font FACE="Courier">(%SIG)</tt>.

<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Tip</b></td></tr>

<tr><td>

<blockquote>

If you are running Perl on a UNIX machine, you can run the <tt>kill -l</tt> command. This command displays a list of possible signals.

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

I looked directly into the perl.exe file supplied with my Perl

distribution to find out that the hip port of Perl for Win32 supports

the following signals:

<blockquote>

<tt>ABRT2</tt>-This signal means that

another process is trying to abort your process.

</blockquote>

<blockquote>

<tt>BREAK2</tt>-This signal indicates

that a Ctrl+Break key sequeNCe was pressed under Windows.

</blockquote>

<blockquote>

<tt>TERM2</tt>-This signal means that

another process is trying to terminate your process.

</blockquote>

<blockquote>

<tt>SEGV2</tt>-This signal indicates

that a segment violation has taken place.

</blockquote>

<blockquote>

<tt>FPE2</tt>-This signal catches

floating point exceptions.

</blockquote>

<blockquote>

<tt>ILL2</tt>-This signal indicates

that an illegal instruction has been attempted.

</blockquote>

<blockquote>

<tt>INT2</tt>-This signal indicates

that a Ctrl+C key sequeNCe was pressed under Windows.

</blockquote>

<p>

You can also use the <tt>%SIG</tt>

hash to trap a call to the <tt>warn()</tt>

and <tt>die()</tt> fuNCtions. This

comes in handy if you're working with someone else's code and

want to keep a log of whenever these fuNCtions are called. Rather

than finding every place the fuNCtions are used, you can define

a handler fuNCtion as in Listing 13.4.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Define a handler for the </i><tt><i>warn()</i></tt><i>

fuNCtion. The error message is passed to the handler as the first

element of the </i><tt><i>@_ array</i></tt><i>.

<br>

Define a handler for the </i><tt><i>die()</i></tt><i>

fuNCtion.<br>

Define the </i><tt><i>sendToLogfile()</i></tt><i>

utility fuNCtion.<br>

Start the signal catching by creating two entries in the </i><tt><i>%SIG</i></tt><i>

hash.<br>

Invoke the </i><tt><i>warn()</i></tt><i>

and </i><tt><i>die()</i></tt><i> fuNCtions.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 13.4&nbsp;&nbsp;13LST04.PL-How to Define Signal Handler

FuNCtions for the </b><tt><i><b><font FACE="Courier">warn()</font></b></i></tt><b>

and </b><tt><i><b><font FACE="Courier">die() </font></b></i></tt><b>FuNCtions

<br>

</b>

</blockquote>

<blockquote>

<pre>

sub WARN_handler {

    my($signal) = @_;

    sendToLogfile(&quot;WARN: $signal&quot;);

}



sub DIE_handler {

    my($signal) = @_;

    sendToLogfile(&quot;DIE: $signal&quot;);

}



sub sendToLogfile {

    my(@array) = @_;

    open(LOGFILE, &quot;&gt;&gt;program.log&quot;);

    print LOGFILE (@array);

    close(LOGFILE);

}



$SIG{__WARN__} = 'WARN_handler';

$SIG{__DIE__}  = 'DIE_handler';



chdir('/printer') or warn($!);

chdir('/printer') or die($!);

</pre>

</blockquote>

<hr>

<p>

When this program is done executing, the <tt>PROGRAM.LOG</tt>

file contains these lines:

<blockquote>

<pre>

WARN: No such file or directory at 13lst02.pl line 22.

DIE: No such file or directory at 13lst02.pl line 23.

</pre>

</blockquote>

<h2><a NAME="Summary"><font SIZE="5" COLOR="#FF0000">

Summary</font></a></h2>

<p>

Your program's capability to handle error conditions that may

arise will determine, to a certain extent, how usable your program

is. If a user of your program finds that it stops working with

no error messages and, therefore, no way to solve whatever problem

has arisen, then your program won't be used for long.

<p>

Displaying error messages is also valuable during the programming

and debugging stage. If you mistakenly type a directory name,

it may take you an hour to look through the script and find the

problem. Handling the <tt>No such directory</tt>

error correctly in the first place will tell you what the problem

is and which line of the script has the problem.

<p>

In this chapter, you saw that checking for errors usually means

looking at the return value of the fuNCtions that are called.

Some fuNCtions set the <tt>errno</tt>

variable while others simply return true or false. While the <tt>errno</tt>

variable does have a core set of values that are system independent,

it also has system-dependent values. Listing 13.1 showed you how

to display the error values applicable to your system.

<p>

Next, you read about the <tt>or</tt>

logical operator. This operator evaluates only the right operand

if the left is false. Therefore, it is useful when testing for

unsuccessful fuNCtions that return false upon failure.

<p>

The <tt>die()</tt> and <tt>warn()</tt>

fuNCtions are both used to display an error message. In addition,

the <tt>die()</tt> fuNCtion causes

the script to end.

<p>

Then, the <tt>eval()</tt> fuNCtion

was covered. It is used to execute Perl code in a protected environment

so that fatal errors will not end the script. Any error messages

that do arise will be placed into the <tt>$@</tt>

special variable. All variable value changes and fuNCtion definitions

affect the main program.

<p>

Lastly, the signals were covered. Signals are messages sent to

a process by the operating system. There is a wide range of signals,

and they differ depending on which operating system you are using.

The <tt>%SIG</tt> associative array

is used to set up your own signal handling fuNCtion.

<p>

The next chapter discusses object orientation. You learn the definition

of an object, how to create one, and how to derive new objects

from existing objects.

<h2><a NAME="ReviewQuestions"><font SIZE="5" COLOR="#FF0000">

Review Questions</font></a></h2>

<p>

Answers to Review Questions are in Appendix A.

<ol>

<li>Why is it important to check for errors?

<li>How is the <tt>die()</tt> fuNCtion

different from the <tt>warn()</tt>

fuNCtion?

<li>What is the meaning of the <tt>$!</tt>

special variable?

<li>What does the <tt>eval()</tt>

fuNCtion do?

<li>What is a signal?

<li>What will the statement <tt>$SIG{'ABRT'}

= 'IGNORE'</tt> do?

<li>Which signal is used to trap floating point exceptions?

</ol>

<h2><a NAME="ReviewExercises"><font SIZE="5" COLOR="#FF0000">

Review Exercises</font></a></h2>

<ol>

<li>Write a program that opens a file and uses the <tt>die()</tt>

fuNCtion if an error occurs.

<li>Write a program that uses the <tt>warn()</tt>

fuNCtion if an existing file will be overwritten by an <tt>open()</tt>

statement.

<li>List three situations where the <tt>warn()</tt>

fuNCtion could be used.

<li>List three situations where the <tt>die()</tt>

fuNCtion could be used.

<li>Modify the interactive Perl interpreter to print a version

number when the <tt>version</tt> custom

command is used.

<li>Modify the interactive Perl interpreter to save all commands

entered into a log file. Add a timestamp to each log entry.

</ol>

<hr>



<center><p><a HREF="ch12.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch12.htm"><img SRC="pc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="#CONTENTS"><img SRC="cc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/cc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="index-1.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/index-1.htm"><img SRC="hb.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/hb.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="ch14.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch14.htm"><img SRC="nc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/nc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<hr WIDTH="100%"></p></center>

</body>

</html>

