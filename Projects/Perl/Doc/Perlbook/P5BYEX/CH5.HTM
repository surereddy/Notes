<html>

<head>

<title>Chapter 5 -- FuNCtions</title>



<meta>

</head>

<body TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">

<h1><font SIZE="6" COLOR="#FF0000">Chapter&nbsp;5</font></h1>

<h1><font SIZE="6" COLOR="#FF0000">FuNCtions</font></h1>

<hr>

<p>

<center><b><font SIZE="5">CONTENTS</font></b></center>

<ul>

<ul>

<li><a HREF="#ExampleUsingtheParameterArray">

Example: Using the Parameter Array (@_)</a>

<li><a HREF="#ExamplePassingParametersbyRefereNCe">

Example: Passing Parameters by RefereNCe</a>

<li><a HREF="#ExampleScopeofVariables">

Example: Scope of Variables</a>

<li><a HREF="#ExampleUsingaListasaFuNCtionParameter">

Example: Using a List as a FuNCtion Parameter</a>

<li><a HREF="#ExampleNestingFuNCtionCalls">

Example: Nesting FuNCtion Calls</a>

<li><a HREF="#ExampleUsingaPrivateFuNCtion">

Example: Using a Private FuNCtion</a>

</ul>

<li><a HREF="#StringFuNCtions">

String FuNCtions</a>

<ul>

<li><a HREF="#ExampleChangingaStringsValue">

Example: Changing a String's Value</a>

<li><a HREF="#ExampleSearchingaString">

Example: Searching a String</a>

</ul>

<li><a HREF="#ArrayFuNCtions">

Array FuNCtions</a>

<ul>

<li><a HREF="#ExamplePrintinganAssociativeArray">

Example: Printing an Associative Array</a>

<li><a HREF="#ExampleCheckingtheExisteNCeofanElement">

Example: Checking the ExisteNCe of an Element</a>

</ul>

<li><a HREF="#Summary">

Summary</a>

<li><a HREF="#ReviewQuestions">

Review Questions</a>

<li><a HREF="#ReviewExercises">

Review Exercises</a>

</ul>



<hr>

<p>

This chapter takes a look at <i>fuNCtions</i>. FuNCtions are blocks

of codes that are given names so that you can use them as needed.

FuNCtions help you to organize your code into pieces that are

easy to understand and work with. They let you build your program

step by step, testing the code along the way.

<p>

After you get the idea for a program, you need to develop a program

outline-either in your head or on paper. Each step in the outline

might be one fuNCtion in your program. This is called <i>modular

programming</i>. Modular programming is very good at allowing

you to hide the details so that readers of your source code can

understand the overall aim of your program.

<p>

For instaNCe, if your program has a fuNCtion that calculates the

area of a circle, the following line of code might be used to

call it:

<blockquote>

<pre>

$areaOfFirstCircle = areaOfCircle($firstRadius);

</pre>

</blockquote>

<p>

By looking at the fuNCtion call, the reader knows what the program

is doing. Detailed understanding of the actual fuNCtion is not

needed.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Tip</b></td></tr>

<tr><td>

<blockquote>

Well thought out fuNCtion and variable names help people to understand your program. If the line of code was</blockquote>

<blockquote>

<tt>$areaFC = areaCirc($fRad);</tt>

</blockquote>

<blockquote>

its meaning would not be as clear.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

Calling a fuNCtion means that Perl stops executing the current series of program lines. Program flow jumps into the program code inside the fuNCtion. When the fuNCtion is finished, Perl jumps back to the point at which the fuNCtion call was made. Program 
execution continues from that point onward.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

Let's look at the fuNCtion call a little closer. The first thing

on the line is a scalar variable and an assignment operator. You

already know this means Perl assigns the value on the right of

the assignment operator to <tt>$areaOfFirstCircle</tt>.

But, what exactly is on the right?

<p>

The first thing you see is the fuNCtion name <tt>areaOfCircle()</tt>.

The parentheses directly to the right and no <tt>$</tt>,

<tt>@</tt>, or <tt>%</tt>

beginning the name indicates that this is a fuNCtion call. Inside

the parentheses is a list of parameters or values that get passed

to the fuNCtion. You can think of a parameter just like a football.

When passed, the receiver (for example, the fuNCtion) has several

options: run (modify it in some way), pass (call other routines),

fumble (call the error handler).<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

Perl enables you to use the <tt>&amp;</tt> character to start fuNCtion names, and in a few cases it is needed. Those few situations that the <tt>&amp;</tt> character is needed are beyond the scope of this book.

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

Listing 5.1 shows a short program that calls and defines the <tt>areaOfCircle()</tt>

fuNCtion.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Assign </i><tt><i>$areaOfFirstCircle</i></tt><i>

the value that is returned by the fuNCtionareaOfCircle().<br>

Print </i><tt><i>$areaOfFirstCircle</i></tt><i>.

<br>

Define the areaOfCircle() fuNCtion.<br>

Get the first parameter from the </i><tt><i>@_</i></tt><i>

 parameter array.<br>

Calculate the area and return the new value.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 5.1&nbsp;&nbsp;05LST01.PL-Calculating the Area of a

Circle<br>

</b>

</blockquote>

<blockquote>

<pre>

$areaOfFirstCircle = areaOfCircle(5);

print(&quot;$areaOfFirstCircle\n&quot;);



sub areaOfCircle {

    $radius = $_[0];

    return(3.1415 * ($radius ** 2));

}

</pre>

</blockquote>

<hr>

<p>

This program prints:

<blockquote>

<pre>

78.7375

</pre>

</blockquote>

<p>

The fact that something prints tells you that the program flow

returned to the print line after calling the <tt>areaOfCircle()</tt>

fuNCtion.

<p>

A fuNCtion definition is very simple. It consists of:

<blockquote>

<pre>

sub fuNCtionName {

}

</pre>

</blockquote>

<p>

That's it. Perl fuNCtion definitions never get any more complex.

<p>

The complicated part comes when dealing with parameters. <i>Parameters

</i>are values passed to the fuNCtion (remember the football?).

The parameters are specified inside the parentheses that immediately

follow the fuNCtion name. In Listing 5.1, the fuNCtion call was

<tt>areaOfCircle(5)</tt>. There was

only one parameter, the number 5. Even though there is only one

parameter, Perl creates a parameter array for the fuNCtion to

use.

<p>

Inside the <tt>areaOfCircle()</tt>

fuNCtion, the parameter array is named <tt>@_</tt>.

All parameters specified during the fuNCtion call are stored in

the <tt>@_ </tt>array so that the

fuNCtion can retrieve them. Our small fuNCtion did this with the

line:

<blockquote>

<pre>

$radius = $_[0];

</pre>

</blockquote>

<p>

This line of code assigns the first element of the <tt>@_

</tt>array to the <tt>$radius</tt>

scalar.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

Because parameters always are passed as lists, Perl fuNCtions also are referred to as list operators. And, if only one parameter is used, they are sometimes referred to as unary operators. However, I'll continue to call them fuNCtions and leave the finer 
points of distiNCtion to others.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

The next line of the fuNCtion:

<blockquote>

<pre>

return(3.1415 * ($radius ** 2));

</pre>

</blockquote>

<p>

calculates the circle's area and returns the newly calculated

value. In this case, the returning value is assigned to the <tt>$areaOfFirstCircle</tt>

scalar variable.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

If you prefer, you don't need to use the <tt>return()</tt> fuNCtion to return a value because Perl automatically returns the value of the last expression evaluated. I prefer to use the <tt>return()</tt> fuNCtion and be explicit so that there is no 
mistaking my intention.

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

You may have used programming languages that distinguish between

a fuNCtion and a subroutine, the differeNCe being that a fuNCtion

returns a value and a subroutine does not. Perl makes no such

distiNCtions. Everything is a fuNCtion-whether or not it returns

a value.

<h3><a NAME="ExampleUsingtheParameterArray">

Example: Using the Parameter Array (@_)</a></h3>

<p>

All parameters to a fuNCtion are stored in an array called <tt>@_</tt>.

One side effect of this is that you can find out how many parameters

were passed by evaluating <tt>@</tt>

in a scalar context.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Call the </i><tt><i>firstSub()</i></tt><i>

fuNCtion with a variety of parameters.<br>

Define the </i><tt><i>firstSub()</i></tt><i>

fuNCtion<br>

Assign </i><tt><i>$numParameters</i></tt><i>

the number of elements in the array @_.<br>

Print out how any parameters were passed.</i>

</blockquote>

<blockquote>

<pre>

firstSub(1, 2, 3, 4, 5, 6);

firstSub(1..3);

firstSub(&quot;A&quot;..&quot;Z&quot;);



sub firstSub {

    $numParameters = @_ ;

    print(&quot;The number of parameters is $numParameters\n&quot;);

}

</pre>

</blockquote>

<p>

This program prints out:

<blockquote>

<pre>

The number of parameters is 6

The number of parameters is 3

The number of parameters is 26

</pre>

</blockquote>

<p>

Perl lets you pass any number of parameters to a fuNCtion. The

fuNCtion decides which parameters to use and in what order. The

<tt>@_</tt> array is used like any

other array.

<p>

Let's say that you want to use scalar variables to refereNCe the

parameters so you don't have to use the clumsy and uninformative

<tt>$_ [0]</tt> array element notation.

By using the assignment operator, you can assign array elements

to scalars in one easy step.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Call the </i><tt><i>areaOfRectangle()</i></tt><i>

fuNCtion with varying parameters.<br>

Define the </i><tt><i>areaOfRectangle()</i></tt><i>

fuNCtion.<br>

Assign the first two elements of </i><tt><i>@_</i></tt><i>

to </i><tt><i>$height</i></tt><i>

and </i><tt><i>$width</i></tt><i>

respectively.<br>

Calculate the area.<br>

Print the three variables: </i><tt><i>$height</i></tt><i>,

</i><tt><i>$width</i></tt><i>, and

</i><tt><i>$area</i></tt><i>.</i>

</blockquote>

<blockquote>

<pre>

areaOfRectangle(2, 3);

areaOfRectangle(5, 6);



sub areaOfRectangle {

    ($height, $width) = @_ ;



    $area = $height * $width;



    print(&quot;The height is $height. The width is $width.

        The area is $area.\n\n&quot;);

}

</pre>

</blockquote>

<p>

This program prints out:

<blockquote>

<pre>

The height is 2. The width is 3.

        The area is 6.



The height is 5. The width is 6.

        The area is 30.

</pre>

</blockquote>

<p>

The statement <tt>($height,$width) = @_;</tt>

does the array element to scalar assignment. The first element

is assigned to <tt>$height</tt>, and

the second element is assigned to <tt>$width</tt>.

After the assignment is made, you can use the scalar variables

to represent the parameters.

<h3><a NAME="ExamplePassingParametersbyRefereNCe">

Example: Passing Parameters by RefereNCe</a></h3>

<p>

Using scalar variables inside your fuNCtions is a good idea for

another reason-besides simple readability coNCerns. When you change

the value of the elements of the <tt>@ </tt>

array, you also change the value of the parameters in the rest

of the program. This is because Perl parameters are called by

refereNCe. When parameters are called by refereNCe, changing their

value in the fuNCtion also changes their value in the main program.

Listing 5.2 shows how this happens.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Create an array with 6 elements.<br>

Print the elements of the array.<br>

Call the </i><tt><i>firstSub()</i></tt><i>

fuNCtion.<br>

Print the elements of the array.<br>

Define the </i><tt><i>firstSub()</i></tt><i>

fuNCtion.<br>

Change the values of the first two elements of </i><tt><i>@_</i></tt><i>.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 5.2&nbsp;&nbsp;05LST02.PL-Using the @Array to Show

Call by RefereNCe<br>

</b>

</blockquote>

<blockquote>

<pre>

@array = (0..5);

print(&quot;Before fuNCtion call, array = @array\n&quot;);

firstSub(@array);

print(&quot;After fuNCtion call, array =  @array\n&quot;);



sub firstSub{

    $_[0] = &quot;A&quot;;

    $_[1] = &quot;B&quot;;

}

</pre>

</blockquote>

<hr>

<p>

This program prints:

<blockquote>

<pre>

Before fuNCtion call, array =  0 1 2 3 4 5

After fuNCtion call, array =   A B 2 3 4 5

</pre>

</blockquote>

<p>

You can see that the fuNCtion was able to affect the <tt>@array</tt>

variable in the main program. Generally, this is considered bad

programming practice because it does not isolate what the fuNCtion

does from the rest of the program. If you change the fuNCtion

so that scalars are used inside the fuNCtion, this problem goes

away. List-ing 5.3 shows how to redo the program in Listing 5.2

so scalars are used inside the fuNCtion.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Create an array with 6 elements.<br>

Print the elements of the array.<br>

Call the </i><tt><i>firstSub()</i></tt><i>

fuNCtion.<br>

Print the elements of the array.<br>

Define the </i><tt><i>firstSub()</i></tt><i>

fuNCtion.<br>

Assign the first two elements of </i><tt><i>@_</i></tt><i>

to </i><tt><i>$firstVar</i></tt><i>

and </i><tt><i>$secondVar</i></tt><i>.

<br>

Change the values of the scalar variables.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 5.3&nbsp;&nbsp;05LST03.PL-Using Scalars Instead of

the @_ Array Inside FuNCtions<br>

</b>

</blockquote>

<blockquote>

<pre>

@array = (0..5);

print(&quot;Before fuNCtion call, array = @array\n&quot;);

firstSub(@array);

print(&quot;After fuNCtion call, array =  @array\n&quot;);



sub firstSub{

    ($firstVar, $secondVar) = @_ ;



    $firstVar = &quot;A&quot;;

    $secondVar = &quot;B&quot;;

}

</pre>

</blockquote>

<hr>

<p>

This program prints:

<blockquote>

<pre>

Before fuNCtion call, array =  0 1 2 3 4 5

After fuNCtion call, array =   0 1 2 3 4 5

</pre>

</blockquote>

<p>

This example shows that the original <tt>@array</tt>

variable is left untouched. However, another problem has quietly

arisen. Let's change the program a little so the values of <tt>$firstVar</tt>

are printed before and after the fuNCtion call. Listing 5.4 shows

how changing a variable in the fuNCtion affects the main program.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Assign a value to </i><tt><i>$firstVar</i></tt><i>.

<br>

Create an array with 6 elements.<br>

Print the elements of the array.<br>

Call the </i><tt><i>firstSub()</i></tt><i>

fuNCtion.<br>

Print the elements of the array.<br>

Define the </i><tt><i>firstSub()</i></tt><i>

fuNCtion.<br>

Assign the first two elements of </i><tt><i>@_</i></tt><i>

to </i><tt><i>$firstVar</i></tt><i>

and </i><tt><i>$secondVar</i></tt><i>.

<br>

Change the values of the scalar variables.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 5.4&nbsp;&nbsp;05LST04.PL-Using Variables in FuNCtions

Can Cause Unexpected Results<br>

</b>

</blockquote>

<blockquote>

<pre>

$firstVar = 10;

@array    = (0..5);



print(&quot;Before fuNCtion call\n&quot;);

print(&quot;\tfirstVar = $firstVar\n&quot;);

print(&quot;\tarray    = @array\n&quot;);



firstSub(@array);



print(&quot;After fuNCtion call\n&quot;);

print(&quot;\tfirstVar = $firstVar\n&quot;);

print(&quot;\tarray    = @array\n&quot;);



sub firstSub{

    ($firstVar, $secondVar) = @_ ;



    $firstVar = &quot;A&quot;;

    $secondVar = &quot;B&quot;;

}

</pre>

</blockquote>

<hr>

<p>

This program prints:

<blockquote>

<pre>

Before fuNCtion call

        firstVar = 10

        array    = 0 1 2 3 4 5



After fuNCtion call

        firstVar = A

        array    = 0 1 2 3 4 5

</pre>

</blockquote>

<p>

By using the <tt>$firstVar</tt> variable

in the fuNCtion you also change its value in the main program.

By default, all Perl variables are accessible everywhere inside

a program. This ability to globally access variables can be a

good thing at times. It does help when trying to isolate a fuNCtion

from the rest of your program. The next section shows you how

to create variables that can only be used inside fuNCtions.

<h3><a NAME="ExampleScopeofVariables">

Example: Scope of Variables</a></h3>

<p>

<i>Scope</i> refers to the visibility of variables. In other words,

which parts of your program can see or use it. Normally, every

variable has a global scope. ONCe defined, every part of your

program can access a variable.

<p>

It is very useful to be able to limit a variable's scope to a

single fuNCtion. In other words, the variable wil have a limited

scope. This way, changes inside the fuNCtion can't affect the

main program in unexpected ways. Listing 5.5 introduces two of

Perl's built-in fuNCtions that create variables of limited scope.

The <tt>my()</tt> fuNCtion creates

a variable that only the current fuNCtion can see. The <tt>local()</tt>

fuNCtion creates a variable that fuNCtions the current fuNCtion

calls can see. If that sounds confusing, don't worry. It is confusing;

but, Listing 5.5 should clear things up. In this case, it's a

listing that is worth a thousand words, not a picture!

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Call </i><tt><i>firstSub()</i></tt><i>

with a two parameters.<br>

Define the </i><tt><i>firstSub()</i></tt><i>

fuNCtion.<br>

Assign the first parameter to local variable </i><tt><i>$firstVar</i></tt><i>.

<br>

Assign the second parameter to my variable </i><tt><i>$secondVar</i></tt><i>.

<br>

Print the variables.<br>

Call the second fuNCtion without any parameters.<br>

Print the variables to see what changed.<br>

Define the </i><tt><i>secondSub()</i></tt><i>

fuNCtion.<br>

Print the variables.<br>

Assign new values to the variables.<br>

Print the variables to see that the new values were assigned correctly.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 5.5&nbsp;&nbsp;05LST05.PL-Using the Local and My FuNCtions

to Create Local Variables<br>

</b>

</blockquote>

<blockquote>

<pre>

firstSub(&quot;AAAAA&quot;, &quot;BBBBB&quot;);



sub firstSub{

    local ($firstVar) = $_[0];

    my($secondVar)    = $_[1];



    print(&quot;firstSub: firstVar  = $firstVar\n&quot;);

    print(&quot;firstSub: secondVar = $secondVar\n\n&quot;);



    secondSub();



    print(&quot;firstSub: firstVar  = $firstVar\n&quot;);

    print(&quot;firstSub: secondVar = $secondVar\n\n&quot;);

}



sub secondSub{

    print(&quot;secondSub: firstVar  = $firstVar\n&quot;);

    print(&quot;secondSub: secondVar = $secondVar\n\n&quot;);



    $firstVar  = &quot;ccccC&quot;;

    $secondVar = &quot;DDDDD&quot;;



    print(&quot;secondSub: firstVar  = $firstVar\n&quot;);

    print(&quot;secondSub: secondVar = $secondVar\n\n&quot;);

}

</pre>

</blockquote>

<hr>

<p>

This program prints:

<blockquote>

<pre>

firstSub: firstVar = AAAAA

firstSub: secondVar = BBBBB



secondSub: firstVar  = AAAAA

Use of uninitialized value at test.pl line 19.

secondSub: secondVar =



secondSub: firstVar  = ccccC

secondSub: secondVar = DDDDD



firstSub: firstVar  = ccccC

firstSub: secondVar = BBBBB

</pre>

</blockquote>

<p>

The output from this example shows that <tt>secondSub()</tt>

could not access the <tt>$secondVar</tt>

variable that was created with <tt>my()</tt>

inside <tt>firstSub()</tt>. Perl even

prints out an error message that warns about the uninitialized

value. The <tt>$firstVar</tt> variable,

however, can be accessed and valued by <tt>secondSub()</tt>.

<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Tip</b></td></tr>

<tr><td>

<blockquote>

It's generally a better idea to use <tt>my()</tt> instead of <tt>local()</tt> so that you can tightly control the scope of local variables. Think about it this way-it's 4:00 in the morning and the project is due. Is that the time to be checking variable 
scope? No. Using <tt>my()</tt>enforces good programming practices and reduces headaches.

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

Actually, the <tt>my()</tt> fuNCtion

is even more complex than I've said. The easy definition is that

it creates variables that only the current fuNCtion can see. The

true definition is that it creates variables with lexical scope.

This distiNCtion is only important when creating modules or objects,

so let's ignore the complicated definition for now. You'll hear

more about it in <a HREF="ch15.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch15.htm">Chapter 15</a>, &quot;Perl Modules.&quot;

<p>

If you remember, I mentioned calling parameters by refereNCe.

Passing parameters by refereNCe means that fuNCtions can change

the variable's value, and the main program sees the change. When

<tt>local()</tt> is used in conjuNCtion

with assigning the <tt>@_ </tt>array

elements to scalars, then the parameters are essentially being

called by value. The fuNCtion can change the value of the variable,

but only the fuNCtion is affected. The rest of the program sees

the old value.

<h3><a NAME="ExampleUsingaListasaFuNCtionParameter">

Example: Using a List as a FuNCtion Parameter</a></h3>

<p>

Now that you understand about the scope of variables, let's take

another look at parameters. Because all parameters are passed

to a fuNCtion in one array, what if you need to pass both a scalar

and an array to the same fuNCtion? This next example shows you

what happens.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Call the </i><tt><i>firstSub()</i></tt><i>

fuNCtion with two parameters: a list and a scalar.<br>

Define the </i><tt><i>firstSub()</i></tt><i>

fuNCtion.<br>

Assign the elements of the </i><tt><i>@_</i></tt><i>

array to </i><tt><i>@</i></tt><i>array

and </i><tt><i>$firstVar</i></tt><i>.

<br>

Print </i><tt><i>@array</i></tt><i>

and </i><tt><i>$firstVar</i></tt><i>.</i>

</blockquote>

<blockquote>

<pre>

firstSub((0..10), &quot;AAAA&quot;);



sub firstSub{

    local(@array, $firstVar) = @_ ;



    print(&quot;firstSub: array    = @array\n&quot;);

    print(&quot;firstSub: firstVar = $firstVar\n&quot;);

}

</pre>

</blockquote>

<p>

This program prints:

<blockquote>

<pre>

firstSub: array    = 0 1 2 3 4 5 6 7 8 9 10 AAAA

Use of uninitialized value at test.pl line 8.

firstSub: firstVar =

</pre>

</blockquote>

<p>

When the local variables are initialized, the <tt>@array</tt>

variables grab all of the elements in the <tt>@</tt>

array, leaving none for the scalar variable. This results in the

uninitialized value message displayed in the output. You can fix

this by merely reversing the order of parameters. If the scalar

value comes first, then the fuNCtion processes the parameters

without a problem.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Call the </i><tt><i>firstSub()</i></tt><i>

fuNCtion with two parameters: a scalar and a list.<br>

Define the </i><tt><i>firstSub()</i></tt><i>

fuNCtion.<br>

Assign the elements of the </i><tt><i>@_</i></tt><i>

array to </i><tt><i>$firstVar</i></tt><i>

and </i><tt><i>@array</i></tt><i>.

<br>

Print </i><tt><i>@array</i></tt><i>

and </i><tt><i>$firstVar</i></tt><i>.</i>

</blockquote>

<blockquote>

<pre>

firstSub(&quot;AAAA&quot;, (0..10));



sub firstSub{

    local($firstVar, @array) = @_ ;



    print(&quot;firstSub: array    = @array\n&quot;);

    print(&quot;firstSub: firstVar = $firstVar\n&quot;);

}

</pre>

</blockquote>

<p>

This program prints:

<blockquote>

<pre>

firstSub: array    = 0 1 2 3 4 5 6 7 8 9 10

firstSub: firstVar = AAAA<br>



</pre>

</blockquote>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

You can pass as many scalar values as you want to a fuNCtion, but only one array. If you try to pass more than one array, the array elements become joined together and passed as one array to the fuNCtion. Your fuNCtion won't be able to tell when one array 
starts and another ends.</blockquote>



</td></tr>

</table>

</center>

<p>

<h3><a NAME="ExampleNestingFuNCtionCalls">

Example: Nesting FuNCtion Calls</a></h3>

<p>

FuNCtion calls can be nested many levels deep. Nested fuNCtion

calls simply means that one fuNCtion can call another which in

turn can call another. Exactly how many levels you can nest depends

on which version of Perl you are running and how your machine

is configured. Normally, you don't have to worry about it. If

you want to see how many levels your system can recurse, try the

following small program:

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Call the </i><tt><i>firstSub()</i></tt><i>

fuNCtion.<br>

Define the </i><tt><i>firstSub()</i></tt><i>

fuNCtion.<br>

Print </i><tt><i>$count<br>

</i></tt><i>INCrement </i><tt><i>$count</i></tt><i>

by one.<br>

Call the </i><tt><i>firstSub()</i></tt><i>

fuNCtion recursively.</i>

</blockquote>

<blockquote>

<pre>

firstSub();



sub firstSub{

    print(&quot;$count\n&quot;);

    $count++;

    firstSub();

}

</pre>

</blockquote>

<p>

My system counts up to 127 before displaying the following message:

<blockquote>

<pre>

Error: Runtime exception

</pre>

</blockquote>

<p>

While it is important to realize that there is a limit to the

number of times your program can nest fuNCtions, you should never

run into this limitation unless you are working with recursive

mathematical fuNCtions.

<h3><a NAME="ExampleUsingaPrivateFuNCtion">

Example: Using a Private FuNCtion</a></h3>

<p>

Occasionally, you might want to create a private fuNCtion. A private

fuNCtion is one that is only available inside the scope where

it was defined.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Assign the return value from </i><tt><i>performCalc()</i></tt><i>

to </i><tt><i>$temp</i></tt><i>.<br>

Print </i><tt><i>$temp</i></tt><i>.

<br>

Define the </i><tt><i>performCalc()</i></tt><i>

fuNCtion.<br>

Assign my scalar variables values from the </i><tt><i>@_</i></tt><i>

parameter array.<br>

Define the private fuNCtion referred to by </i><tt><i>$square</i></tt><i>.

<br>

Return the first element of the </i><tt><i>@_</i></tt><i>

parameter array raised to the 2nd power.<br>

Return the value of </i><tt><i>$firstVar</i></tt><i>

raised to the 2nd power and<br>

</i><tt><i>$secondVar</i></tt><i>

raised to the 2nd power.</i>

</blockquote>

<blockquote>

<pre>

$temp = performCalc(10, 10);

print(&quot;temp = $temp\n&quot;);



sub performCalc {

    my ($firstVar, $secondVar) = @_;



    my $square = sub {

        return($_[0] ** 2);

    };



    return(&amp;$square($firstVar) + &amp;$square($secondVar));

};

</pre>

</blockquote>

<p>

This program prints:

<blockquote>

<pre>

temp = 200

</pre>

</blockquote>

<p>

This example is rather trivial, but it serves to show that in

Perl it pays to create little helper routines. A fine line needs

to be drawn between what should be iNCluded as a private fuNCtion

and what shouldn't. I would draw the line at 5 or 6 lines of code.

Anything longer probably should be made into its own fuNCtion.

I would also say that a private fuNCtion should have only one

purpose for existeNCe. Performing a calculation and then opening

a file is too much fuNCtionality for a single private fuNCtion

to have.

<p>

The rest of the chapter is devoted to showing you some of the

built-in fuNCtions of Perl. These little nuggets of fuNCtionality

will become part of your arsenal of programming weapons.

<h2><a NAME="StringFuNCtions"><font SIZE="5" COLOR="#FF0000">

String FuNCtions</font></a></h2>

<p>

The first set of fuNCtions that we'll look at are those that deal

with strings. These fuNCtions let you determine a string's length,

search for a sub-string, and change the case of the characters

in the string, among other things. Table 5.1 shows Perl's string

fuNCtions.<br>

<p>

<center><b>Table 5.1&nbsp;&nbsp;String FuNCtions</b></center>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td WIDTH="211"><i>FuNCtion</i></td><td WIDTH="379"><i>Description</i>

</td></tr>

<tr><td WIDTH="211"><tt>chomp(STRING) OR chomp(ARRAY)</tt>

</td><td WIDTH="379">Uses the value of the <tt>$/</tt> special variable to remove endings from <tt>STRING</tt> or each element of <tt>ARRAY</tt>. The line ending is only removed if it matches the current value of <tt>$/</tt>.

</td></tr>

<tr><td WIDTH="211"><tt>chop(STRING) OR chop(ARRAY)</tt>

</td><td WIDTH="379">Removes the last character from a string or the last character from every element in an array. The last character chopped is returned.

</td></tr>

<tr><td WIDTH="211"><tt>chr(NUMBER)</tt>

</td><td WIDTH="379">Returns the character represented by <tt>NUMBER</tt> in the ASCII table. For instaNCe, <tt>chr(65)</tt> returns the letter <tt>A</tt>. For more information about the ASCII table see Appendix E, &quot;ASCII Table.&quot;

</td></tr>

<tr><td WIDTH="211"><tt>crypt(STRING1, STRING2)</tt>

</td><td WIDTH="379">ENCrypts <tt>STRING1</tt>. Unfortunately, Perl does not provide a decrypt fuNCtion. 

</td></tr>

<tr><td WIDTH="211"><tt>index(STRING, SUBSTRING, POSITION)</tt>

</td><td WIDTH="379">Returns the position of the first occurreNCe of <tt>SUBSTRING</tt> in <tt>STRING</tt> at or after <tt>POSITION</tt>. If you don't specify <tt>POSITION</tt>, the search starts at the beginning of <tt>STRING</tt>.

</td></tr>

<tr><td WIDTH="211"><tt>join(STRING, ARRAY)</tt>

</td><td WIDTH="379">Returns a string that consists of all of the elements of <tt>ARRAY</tt> joined together by <tt>STRING</tt>. For instaNCe, <tt>join(&quot;&gt;&gt;&quot;, (&quot;AA&quot;, &quot;BB&quot;, &quot;cc&quot;))</tt> returns 
<tt>&quot;AA&gt;&gt;BB&gt;&gt;cc&quot;</tt>.

</td></tr>

<tr><td WIDTH="211"><tt>lc(STRING)</tt>

</td><td WIDTH="379">Returns a string with every letter of <tt>STRING</tt> in lowercase. For instaNCe, <tt>lc(&quot;ABCD&quot;)</tt> returns <tt>&quot;abcd&quot;</tt>.

</td></tr>

<tr><td WIDTH="211"><tt>lcfirst(STRING)</tt>

</td><td WIDTH="379">Returns a string with the first letter of <tt>STRING</tt> in lowercase. For instaNCe, <tt>lcfirst(&quot;ABCD&quot;)</tt> returns <tt>&quot;aBCD&quot;</tt>.

</td></tr>

<tr><td WIDTH="211"><tt>length(STRING)</tt>

</td><td WIDTH="379">Returns the length of <tt>STRING</tt>.

</td></tr>

<tr><td WIDTH="211"><tt>rindex(STRING, SUBSTRING, POSITION)</tt>

</td><td WIDTH="379">Returns the position of the last occurreNCe of <tt>SUBSTRING</tt> in <tt>STRING</tt> at or after <tt>POSITION</tt>. If you don't specify <tt>POSITION</tt>, the search starts at the end of <tt>STRING</tt>.

</td></tr>

<tr><td WIDTH="211"><tt>split(PATTERN, STRING, LIMIT)</tt>

</td><td WIDTH="379">Breaks up a string based on some delimiter. In an array context, it returns a list of the things that were found. In a scalar context, it returns the number of things found.

</td></tr>

<tr><td WIDTH="211"><tt>substr(STRING, OFFSET, LENGTH)</tt>

</td><td WIDTH="379">Returns a portion of <tt>STRING</tt> as determined by the <tt>OFFSET</tt> and <tt>LENGTH</tt> parameters. If <tt>LENGTH</tt> is not specified, then everything from <tt>OFFSET</tt> to the end of <tt>STRING</tt> is returned. A negative 
<tt>OFFSET</tt> can be used to start from the right side of <tt>STRING</tt>.

</td></tr>

<tr><td WIDTH="211"><tt>uc(STRING)</tt>

</td><td WIDTH="379">Returns a string with every letter of <tt>STRING</tt> in uppercase. For instaNCe, <tt>uc(&quot;abcd&quot;)</tt> returns <tt>&quot;ABCD&quot;</tt>.

</td></tr>

<tr><td WIDTH="211"><tt>Ucfirst(STRING)</tt>

</td><td WIDTH="379">Returns a string with the first letter of <tt>STRING</tt> in uppercase. For instaNCe, <tt>ucfirst(&quot;abcd&quot;)</tt> returns <tt>&quot;Abcd&quot;</tt>.

</td></tr>

</table>

</center>

<p>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

As a general rule, if Perl sees a number where it expects a string, the number is quietly converted to a string without your needing to do anything.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

Some of these fuNCtions use the special variable <tt>$_ </tt>as the default string to work with. More information about <tt>$_ </tt>can be found in <a HREF="ch9.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch9.htm">Chapter 9</a> &quot;Using Files,&quot; and <a HREF="ch12.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch12.htm">Chapter 12</a>, 
&quot;Using Special Variables.&quot;

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

The next few sections demonstrate some of these fuNCtions. After

seeing some of them work, you'll be able to use the rest of them.

<h3><a NAME="ExampleChangingaStringsValue">

Example: Changing a String's Value</a></h3>

<p>

Frequently, I find that I need to change part of a string's value,

usually somewhere in the middle of the string. When this need

arises, I turn to the <tt>substr()</tt>

fuNCtion. Normally, the <tt>substr()</tt>

fuNCtion returns a sub-string based on three parameters: the string

to use, the position to start at, and the length of the string

to return.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Assign </i><tt><i>$firstVar</i></tt><i>

the return value from substr().<br>

Print </i><tt><i>$firstVar</i></tt><i>.</i>

</blockquote>

<blockquote>

<pre>

$firstVar = substr(&quot;0123BBB789&quot;, 4, 3);

print(&quot;firstVar  = $firstVar\n&quot;);

</pre>

</blockquote>

<p>

This program prints:

<blockquote>

<pre>

firstVar = BBB

</pre>

</blockquote>

<p>

The <tt>substr()</tt> fuNCtion starts

at the fifth position and returns the next three characters. The

returned string can be printed like in the above example, as an

array element, for string coNCatention, or any of a hundred other

options.

<p>

Things become more interesting when you put the <tt>substr()</tt>

fuNCtion on the left-hand side of the assignment statement. Then,

you actually can assign a value to the string that <tt>substr()</tt>

returns.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Initialize </i><tt><i>$firstVar</i></tt><i>

with a string literal.<br>

Replace the string returned by the </i><tt><i>substr()</i></tt><i>

fuNCtion with &quot;AAA&quot;.<br>

Print </i><tt><i>$firstVar</i></tt><i>.</i>

</blockquote>

<blockquote>

<pre>

$firstVar = &quot;0123BBB789&quot;;

substr($firstVar, 4, 3) = &quot;AAA&quot;;

print(&quot;firstVar  = $firstVar\n&quot;);

</pre>

</blockquote>

<p>

This program prints:

<blockquote>

<pre>

firstVar = 0123AAA789

</pre>

</blockquote>

<h3><a NAME="ExampleSearchingaString">

Example: Searching a String</a></h3>

<p>

Another useful thing you can do with strings is search them to

see if they have a given sub-string. For example if you have a

full path name such as <tt>&quot;C:\\WINDOWS

\\TEMP\\WSREWE.DAT&quot;</tt>, you might need to extract

the file name at the end of the path. You might do this by searching

for the last backslash and then using <tt>substr()</tt>

to return the sub-string.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

The path name string has double backslashes to indicate to Perl that we really want a backslash in the string and not some other escape sequeNCe. You can read more about escape sequeNCes in <a HREF="ch2.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch2.htm">Chapter 2</a> &quot;Numeric and String  
Literals.&quot;</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Assign a string literal to </i><tt><i>$pathName</i></tt><i>.

<br>

Find the location of the last backslash by starting at the end

of the string and working backward using the </i><tt><i>rindex()</i></tt><i>

fuNCtion. When the position of the last backslash is found, add

one to it so that<br>

</i><tt><i>$position</i></tt><i> points

at the first character (&quot;W&quot;) of the file name.<br>

Use the </i><tt><i>substr()</i></tt><i>

fuNCtion to extract the file name and assign it<br>

to </i><tt><i>$fileName</i></tt><i>.

<br>

Print </i><tt><i>$fileName</i></tt><i>.</i>

</blockquote>

<blockquote>

<pre>

$pathName = &quot;C:\\WINDOWS\\TEMP\\WSREWE.DAT&quot;;

$position = rindex($pathName, &quot;\\&quot;) + 1;

$fileName = substr($pathName, $position);

print(&quot;$fileName\n&quot;);

</pre>

</blockquote>

<p>

This program prints:

<blockquote>

<pre>

WSREWE.DAT

</pre>

</blockquote>

<p>

If the third parameter-the length-is not supplied to <tt>substr()</tt>,

it simply returns the sub-string that starts at the position specified

by the second parameter and continues until the end of the string

specified by the first parameter.

<h2><a NAME="ArrayFuNCtions"><font SIZE="5" COLOR="#FF0000">

Array FuNCtions</font></a></h2>

<p>

Arrays are a big part of the Perl language and Perl has a lot

of fuNCtions to help you work with them. Some of the actions arrays

perform iNClude deleting elements, checking for the existeNCe

of an element, reversing all of the the elements in an array,

and sorting the elements. Table 5.2 lists the fuNCtions you can

use with arrays.<br>

<p>

<center><b>Table 5.2&nbsp;&nbsp;Array FuNCtions</b></center>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td WIDTH="205"><i>FuNCtion</i></td><td WIDTH="385"><i>Description</i>

</td></tr>

<tr><td WIDTH="205"><tt>defined(VARIABLE)</tt>

</td><td WIDTH="385">Returns true if <tt>VARIABLE</tt> has a real value and if the variable has not yet been assigned a value. This is not limited to arrays; any data type can be checked. Also see the <tt>exists</tt> fuNCtion for information about 
associative array keys.

</td></tr>

<tr><td WIDTH="205"><tt>delete(KEY)</tt>

</td><td WIDTH="385">Removes the key-value pair from the given associative array. If you delete a value from the <tt>%ENV</tt> array, the environment of the current process is changed, not that of the parent.

</td></tr>

<tr><td WIDTH="205"><tt>each(ASSOC_ARRAY)</tt>

</td><td WIDTH="385">Returns a two-element list that contains a key and value pair from the given associative array. The fuNCtion is mainly used so  you can iterate over the associate array elements. A null list is returned when the last element has been 
read.

</td></tr>

<tr><td WIDTH="205"><tt>exists(KEY)</tt>

</td><td WIDTH="385">Returns true if the <tt>KEY</tt> is part of the specified associative array. For instaNCe, <tt>exists($array{&quot;Orange&quot;})</tt> returns true if the <tt>%array</tt> associative array has a key with the value of &quot;Orange.&quot;


</td></tr>

<tr><td WIDTH="205"><tt>join(STRING, ARRAY)</tt>

</td><td WIDTH="385">Returns a string that consists of all of the elements of <tt>ARRAY</tt> joined together by <tt>STRING</tt>. For instaNCe, <tt>join(&quot;&gt;&gt;&quot;, (&quot;AA&quot;, &quot;BB&quot;, &quot;cc&quot;))</tt> returns 
<tt>&quot;AA&gt;&gt;BB&gt;&gt;cc&quot;</tt>.

</td></tr>

<tr><td WIDTH="205"><tt>keys(ASSOC_ARRAY)</tt>

</td><td WIDTH="385">Returns a list that holds all of the keys in a given associative array. The list is not in any particular order.

</td></tr>

<tr><td WIDTH="205"><tt>map(EXPRESSION, ARRAY)</tt>

</td><td WIDTH="385">Evaluates <tt>EXPRESSION</tt> for every element of <tt>ARRAY</tt>. The special variable <tt>$ </tt>is assigned each element of <tt>ARRAY</tt> immediately before <tt>EXPRESSION</tt> is evaluated.

</td></tr>

<tr><td WIDTH="205"><tt>pack(STRING, ARRAY)</tt>

</td><td WIDTH="385">Creates a binary structure, using <tt>STRING</tt> as a guide, of the elements of <tt>ARRAY</tt>. You can look in <a HREF="ch8.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch8.htm">Chapter 8</a> &quot;RefereNCes,&quot; for more information.

</td></tr>

<tr><td WIDTH="205"><tt>pop(ARRAY)</tt>

</td><td WIDTH="385">Returns the last value of an array. It also reduces the size of the array by one.

</td></tr>

<tr><td WIDTH="205"><tt>push(ARRAY1, ARRAY2)</tt>

</td><td WIDTH="385">Appends the contents of <tt>ARRAY2</tt> to <tt>ARRAY1</tt>. This iNCreases the size of <tt>ARRAY1</tt> as needed.

</td></tr>

<tr><td WIDTH="205"><tt>reverse(ARRAY)</tt>

</td><td WIDTH="385">Reverses the elements of a given array when used in an array context. When used in a scalar context, the array is converted to a string, and the string is reversed.

</td></tr>

<tr><td WIDTH="205"><tt>scalar(ARRAY)</tt>

</td><td WIDTH="385">Evaluates the array in a scalar context and returns the number of elements in the array.

</td></tr>

<tr><td WIDTH="205"><tt>shift(ARRAY)</tt>

</td><td WIDTH="385">Returns the first value of an array. It also reduces the size of the array by one.

</td></tr>

<tr><td WIDTH="205"><tt>sort(ARRAY)</tt>

</td><td WIDTH="385">Returns a list containing the elements of <tt>ARRAY</tt> in sorted order. See <a HREF="ch8.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch8.htm">Chapter 8</a> &quot;RefereNCes,&quot; for more information.

</td></tr>

<tr><td WIDTH="205"><tt>splice(ARRAY1, OFFSET, </tt>

</td><td WIDTH="385">Replaces elements of <tt>ARRAY1</tt> with elements 

</td></tr>

<tr><td WIDTH="205"><tt>LENGTH, ARRAY2)</tt>

</td><td WIDTH="385">in <tt>ARRAY2</tt>. It returns a list holding any elements that were removed. Remember that the <tt>$[</tt> variable may change the base array subscript when determining the <tt>OFFSET</tt> value.

</td></tr>

<tr><td WIDTH="205"><tt>split(PATTERN, STRING, LIMIT)</tt>

</td><td WIDTH="385">Breaks up a string based on some delimiter. In an array context, it returns a list of the things that were found. In a scalar context, it returns the number of things found.

</td></tr>

<tr><td WIDTH="205"><tt>undef(VARIABLE)</tt>

</td><td WIDTH="385">Always returns the undefined value. In addition, it undefines <tt>VARIABLE</tt>, which must be a scalar, an entire array, or a subroutine name.

</td></tr>

<tr><td WIDTH="205"><tt>unpack(STRING, ARRAY)</tt>

</td><td WIDTH="385">Does the opposite of <tt>pack()</tt>. 

</td></tr>

<tr><td WIDTH="205"><tt>unshift(ARRAY1, ARRAY2)</tt>

</td><td WIDTH="385">Adds the elements of <tt>ARRAY2</tt> to the front of <tt>ARRAY1</tt>. Note that the added elements retain their original order. The size of the new <tt>ARRAY1</tt> is returned.

</td></tr>

<tr><td WIDTH="205"><tt>values(ASSOC_ARRAY)</tt>

</td><td WIDTH="385">Returns a list that holds all of the values in a given associative array. The list is not in any particular order.

</td></tr>

</table>

</center>

<p>

<p>

As with the string fuNCtions, only a few of these fuNCtions will

be explored. ONCe you see the examples, you'll be able to handle

the rest with no trouble.

<h3><a NAME="ExamplePrintinganAssociativeArray">

Example: Printing an Associative Array</a></h3>

<p>

The <tt>each()</tt> fuNCtion returns

key, value pairs of an associative array one-by-one in a list.

This is called <i>iterating</i> over the elements of the array.

Iteration is a synonym for looping. So, you also could say that

the <tt>each()</tt> fuNCtion starts

at the beginning of an array and loops through each element until

the end of the array is reached. This ability lets you work with

key, value pairs in a quick easy manner.

<p>

The <tt>each()</tt> fuNCtion does

not loop by itself. It needs a little help from some Perl control

statements. For this example, we'll use the <i>while</i> loop

to print an associative array. The <tt>while

(CONDITION) {}</tt> control statement continues to execute

any program code surrounded by the curly braces until the <tt>CONDITION</tt>

turns false.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Create an associative with number, color pairs.<br>

Using a while loop, iterate over the array elements.<br>

Print the key, value pair.</i>

</blockquote>

<blockquote>

<pre>

%array = ( &quot;100&quot;, &quot;Green&quot;, &quot;200&quot;, &quot;Orange&quot;);



while (($key, $value) = each(%array)) {

      print(&quot;$key = $value\n&quot;);

}

</pre>

</blockquote>

<p>

This program prints:

<blockquote>

<pre>

100 = Green

200 = Orange

</pre>

</blockquote>

<p>

The <tt>each()</tt> fuNCtion returns

false when the end of the array is reached. Therefore, you can

use it as the basis of the <tt>while</tt>'s

condition. When the end of the array is reached, the program continues

execution after the closing curly brace. In this example, the

program simply ends.

<h3><a NAME="ExampleCheckingtheExisteNCeofanElement">

Example: Checking the ExisteNCe of an Element</a></h3>

<p>

You can use the <tt>defined()</tt>

fuNCtion to check if an array element exists before you assign

a value to it. This ability is very handy if you are reading values

from a disk file and don't want to overlay values already in memory.

For instaNCe, suppose you have a disk file of customers' addresses

and you would like to know if any of them are duplicates. You

check for duplicates by reading the information one address at

a time and assigning the address to an associative array using

the customer name as the key value. If the customer name already

exists as a key value, then that address should be flagged for

follow up.

<p>

Because we haven't talked about disk files yet, we'll need to

emulate a disk file with an associative array. And, instead of

using customer's address, we'll use customer number and customer

name pairs. First, we see what happens when an associative array

is created and two values have the same keys.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Call the </i><tt><i>createPair()</i></tt><i>

fuNCtion three times to create three key, value pairs in the </i><tt><i>%array</i></tt><i>

associative array.<br>

Loop through </i><tt><i>%array</i></tt><i>,

printing each key, value pair.<br>

Define the </i><tt><i>createPair()</i></tt><i>

fuNCtion.<br>

Create local variables to hold the key, value pair passed as parameters.

<br>

Create an array element to hold the key, value pair.</i>

</blockquote>

<blockquote>

<pre>

createPair(&quot;100&quot;,  &quot;Kathy Jones&quot;);

createPair(&quot;200&quot;,  &quot;Grace Kelly&quot;);

createPair(&quot;100&quot;, &quot;George Orwell&quot;);



while (($key, $value) = each %array) {

    print(&quot;$key, $value\n&quot;);

};



sub createPair{

    my($key, $value) = @_ ;



    $array{$key} = $value;

};

</pre>

</blockquote>

<p>

This program prints:

<blockquote>

<pre>

100, George Orwell

200, Grace Kelly

</pre>

</blockquote>

<p>

This example takes advantages of the global nature of variables.

Even though the <tt>%array</tt> element

is set in the <tt>createPair()</tt>

fuNCtion, the array is still accessible by the main program. Notice

that the first key, value pair (100 and Kathy Jones) are overwritten

when the third key, value pair is eNCountered. You can see that

it is a good idea to be able to determine when an associative

array element is already defined so that duplicate entries can

be handled. The next program does this.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Call the </i><tt><i>createPair()</i></tt><i>

fuNCtion three times to create three key,  value pairs in the

</i><tt><i>%array</i></tt><i> associative

array.<br>

Loop through </i><tt><i>%array</i></tt><i>,

printing each key, value pair.<br>

Define the </i><tt><i>createPair()</i></tt><i>

fuNCtion.<br>

Create local variables to hold the key, value pair passed as parameters.

<br>

If the key, value pair already exists in </i><tt><i>%array</i></tt><i>,

then iNCrement<br>

 the customer number by one. Check to see if the new key, value

<br>

pair exists. If so, keep iNCrementing until a nonexistent<br>

key, value pair is found.<br>

Create an array element to hold the key, value pair.</i>

</blockquote>

<blockquote>

<pre>

createPair(&quot;100&quot;,  &quot;Kathy Jones&quot;);

createPair(&quot;200&quot;,  &quot;Grace Kelly&quot;);

createPair(&quot;100&quot;, &quot;George Orwell&quot;);



while (($key, $value) = each %array) {

    print(&quot;$key, $value\n&quot;);

};



sub createPair{

    my($key, $value) = @_ ;



    while (defined($array{$key})) {

        $key++;

    }



    $array{$key} = $value;

};

</pre>

</blockquote>

<p>

This program prints:

<blockquote>

<pre>

100, George Orwell

101, Kathy Jones

200, Grace Kelly

</pre>

</blockquote>

<p>

You can see that the customer number for Kathy Jones has been

changed to 101. If the array had already had an entry for 101,

the Kathy Jones' new customer number would be 102.

<h2><a NAME="Summary"><font SIZE="5" COLOR="#FF0000">

Summary</font></a></h2>

<p>

In this chapter you've learned about fuNCtions-what they are and

how to call them. You saw that you can create your own fuNCtion

or use one of Perl's many built-in fuNCtions. Each fuNCtion can

accept any number of parameters which get delivered to the fuNCtion

in the form of the <tt>@ </tt>array.

This array, like any other array in Perl, can be accessed using

the array element to access an individual element. ( For instaNCe,

<tt>$_ [0]</tt> accesses the first

element in the <tt>@ </tt>array.)

Because Perl parameters are passed by refereNCe, changing the

<tt>@</tt> array changes the values

in the main program as well as the fuNCtion.

<p>

You learned about the scope of variables and how all variables

are global by default. Then, you saw how to create variable with

local scope using <tt>local()</tt>

and <tt>my()</tt>. <tt>My()</tt>

is the better choice in almost all situations because it enforces

local scope and limits side effects from fuNCtion to inside the

fuNCtions.

<p>

Then you saw that it was possible to nest fuNCtion calls, which

means that one fuNCtion can call another, which in turn can call

another. You  also might call this a chain of fuNCtion calls.

Private fuNCtions were introduced next. A private fuNCtion is

one that only can be used inside the fuNCtion that defines it.

<p>

A list of string fuNCtions then was presented. These iNCluded

fuNCtions to remove the last character, eNCrypt a string, find

a sub-string, convert array elements into a string, change the

case of a string character, and find the length of a string. Examples

were shown about how to change a string's characters and how to

search a string.

<p>

The section on array fuNCtions showed that Perl has a large number

of fuNCtions that deal specifically with arrays. The list of fuNCtions

iNCluded the ability to delete elements, return key, value pairs

from associative arrays, reverse an array's elements, and sort

an array. Examples were shown for printing an associative array

and checking for the existeNCe of an element.

<p>

The next chapter, &quot;Statements,&quot; goes into detail about

what statements are and how you create them. The information that

you learned about variables and fuNCtions will come into play.

You'll see how to link variables and fuNCtions together to form

expressions and statements.

<h2><a NAME="ReviewQuestions"><font SIZE="5" COLOR="#FF0000">

Review Questions</font></a></h2>

<p>

Answers to Review Questions are in Appendix A.

<ol>

<li>What is a parameter?

<li>What two fuNCtions are used to create variables with local

scope?

<li>What does parameter passing by refereNCe mean?

<li>What is the <tt>@_ </tt>array

used for?

<li>Do Perl variables have global or local scope by default?

<li>Why is it hard to pass two arrays to a fuNCtion?

<li>What is the differeNCe between variables created with <tt>local()</tt>

and variables created with <tt>my()</tt>?

<li>What does the <tt>map()</tt> fuNCtion

do?

</ol>

<h2><a NAME="ReviewExercises"><font SIZE="5" COLOR="#FF0000">

Review Exercises</font></a></h2>

<ol>

<li>Create a fuNCtion that prints its own parameter list.

<li>Create a program that uses three fuNCtions to demonstrate

fuNCtion call nesting.

<li>Use the <tt>chop()</tt> fuNCtion

in a program. Print both the returned character and the string

that was passed as a parameter.

<li>Run the following program to see how many levels of recursion

your system configuration supports:<br>

<br>

<tt>firstSub();<br>

<br>

sub firstSub{<br>

  print(&quot;$count\n&quot;);<br>

        $count++;<br>

        firstSub();<br>

}</tt>

<li>Write a fuNCtion that uses the <tt>substr()</tt>

and <tt>uc()</tt> fuNCtions to change

the tenth through twentieth characters to uppercase.

<li>Write a fuNCtion that uses the <tt>keys()</tt>

fuNCtion to print out the values of an associative array.

<li>Create a program that uses a private fuNCtion to subtract

two numbers and multiply the result by four.

<li>Write a program that shows what the <tt>shift()</tt>

and <tt>unshift()</tt> fuNCtions do.

<li>Write a program that shows what the <tt>push()</tt>

and <tt>pop()</tt> fuNCtions do.

</ol>

<hr>



<center><p><a HREF="ch4.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch4.htm"><img SRC="pc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="#CONTENTS"><img SRC="cc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/cc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="index-1.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/index-1.htm"><img SRC="hb.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/hb.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="ch6.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch6.htm"><img SRC="nc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/nc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<hr WIDTH="100%"></p></center>

</body>

</html>

