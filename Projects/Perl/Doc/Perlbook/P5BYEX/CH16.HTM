<HTML>

<HEAD>

<TITLE>Chapter 16  -- Debugging Perl</TITLE>



<META>

</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">

<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;16</FONT></H1>

<H1><FONT SIZE=6 COLOR=#FF0000>Debugging Perl</FONT></H1>

<HR>

<P>

<CENTER><B><FONT SIZE=5>CONTENTS</FONT></B></CENTER>

<UL>

<LI><A HREF="#SyntaxErrors">

Syntax Errors</A>

<LI><A HREF="#CommonSyntaxErrors">

Common Syntax Errors</A>

<LI><A HREF="#LogicErrors">

Logic Errors</A>

<UL>

<LI><A HREF="#UsingtheTTFONTSIZEFACECourierwFONTTTFONTSIZECommandLineOptionFONT">

Using the <TT>-w</TT>

Command-Line Option</FONT></A>

<LI><A HREF="#BeingStrictwithYourVariables">

Being Strict with Your Variables</A>

<LI><A HREF="#SteppingThroughYourScript">

Stepping Through Your Script</A>

<LI><A HREF="#ExamplesDisplayingInformation">

Examples: Displaying Information</A>

<LI><A HREF="#ExamplesUsingtheFONTSIZEFACELBIHelveticaBlackObliquenFONTFONTSIZECommandFONT">

Examples: Using the n

Command</A>

<LI><A HREF="#ExamplesUsingBreakpoints">

Examples: Using Breakpoints</A>

<LI><A HREF="#ExamplesCreatingCommandAliases">

Examples: Creating Command Aliases</A>

<LI><A HREF="#ExamplesUsingtheDebuggerasanInteractiveInterpreter">

Examples: Using the Debugger as an Interactive Interpreter

</A>

</UL>

<LI><A HREF="#Summary">

Summary</A>

<LI><A HREF="#ReviewQuestions">

Review Questions</A>

<LI><A HREF="#ReviewExercises">

Review Exercises</A>

</UL>



<HR>

<P>

This chapter is about errors: how to find them and how to fix

them. No programmer I've ever known of is able to consistently

create perfect programs. So don't feel bad if you also have some

problems you need to solve. I've spent many hours looking for

a missing closing bracket or a misspelled variable name.

<P>

There are two different types of errors: syntax errors and logic

errors. <I>Syntax</I> errors are made as you type your script

into an editor. For example, you might not add a closing quote

or might misspell a filename. <I>Logic</I> errors are more insidious

and difficult to find. For example, you might place an assignment

statement inside an <TT>if</TT> statement

block that belongs outside the block. Or you might have a loop

that runs from 0 to 100 when it should run from 10 to 100. Accidentally

deleting the 1 or not entering it in the first place is very easy.

<P>

Syntax errors are usually easy to fix. The section &quot;Common

Syntax Errors&quot; discusses some common syntax errors. You'll

see how to decipher some of Perl's error messages.

<P>

Logic errors can be very hard to fix. They are discussed in the

section &quot;Logic Errors.&quot; While there is no magic wand

to wave over a program that will identify logic errors, there

are some tools that can help-like the debugger. A <I>debugger</I>

is an environment that lets you execute your program line by line.

This is also called <I>single-stepping</I> through your program.

You can also display or modify the value of variables. The debugger

is discussed in the section &quot;Stepping Through Your Script.&quot;

<H2><A NAME="SyntaxErrors"><FONT SIZE=5 COLOR=#FF0000>

Syntax Errors</FONT></A></H2>

<P>

Perl is generally considered an interpreted language. However,

this is not truly accurate. Before being executed, your script

is compiled into an internal format-just like Java's byte-codes

or Pascal's p-code. While Perl is compiling your program, it also

checks for syntax errors. This is why syntax errors are also called

<I>compile-time</I> errors.

<P>

Fixing syntax errors is a matter of reading the error message

displayed by the compiler and then trying to understand which

line of code generated the message and why. The next section,

&quot;Common Syntax Errors,&quot; might help. If you are uNCertain

which line of code really generated the error, try commenting

out the likely culprits. Then, re-execute your program and look

at the error messages that are produced to see if they have changed.

<H2><A NAME="CommonSyntaxErrors"><FONT SIZE=5 COLOR=#FF0000>

Common Syntax Errors</FONT></A></H2>

<P>

One very common error is to use <TT>elseif</TT>

instead of the correct <TT>elsif</TT>

keyword. As you program, you'll find that you consistently make

certain kinds of errors. This is okay. Everyone has his or her

own little quirks. Mine is that I keep using the assignment operator

instead of the equality operator. Just remember what your particular

blind spot is. When errors occur, check for your personal common

errors first.

<P>

This section shows some common syntax errors and the error messages

that are generated as a result. First, the error message are shown

and then the script that generated it. After the script, I'll

cast some light as to why that particular message was generated.

<BLOCKQUOTE>

<PRE>

Scalar found where operator expected at test.pl line 2, near &quot;$bar&quot;

        (Missing semicolon on previous line?)

$foo = { }    # this line is missing a semi-colon.

$bar = 5;

</PRE>

</BLOCKQUOTE>

<P>

Perl sees the anonymous hash on the first line and is expecting

either an operator or the semicolon to follow it. The scalar variable

that it finds, <TT>$bar</TT>, does

not fit the syntax of an expression because two variables can't

be right after each other. In this case, even though the error

message indicates line 2, the problem is in line 1.

<BLOCKQUOTE>

<PRE>

Bare word found where operator expected at 

    test.pl line 2, near &quot;print(&quot;This&quot;

  (Might be a runaway multi-line &quot;&quot; string starting on line 1)

syntax error at test.pl line 2, near &quot;print(&quot;This is &quot;

String found where operator expected at test.pl line 3, near 

&quot;print(&quot;&quot;

  (Might be a runaway multi-line &quot;&quot; string starting on line 2)

        (Missing semicolon on previous line?)

Bare word found where operator expected at 

    test.pl line 3, near &quot;print(&quot;This&quot;

String found where operator expected at test.pl line 3, at end of 

line

        (Missing operator before &quot;);

?)

Can't find string terminator '&quot;' anywhere before EOF at test.pl 

line 3.



print(&quot;This is a test.\n);    # this line is missing a ending 



quote.

print(&quot;This is a test.\n&quot;);

print(&quot;This is a test.\n&quot;);

</PRE>

</BLOCKQUOTE>

<P>

In this example, a missing end quote has generated 12 lines of

error messages! You really need to look only at the last one in

order to find out that the problem is a missing string terminator.

While the last error message describes the problem, it does not

tell you where the problem is. For that piece of information,

you need to look at the first line where it tells you to look

at line two. Of course, by this time you already know that if

the error message says line 2, the error is probably in line 1.

<BLOCKQUOTE>

<PRE>

Can't call method &quot;a&quot; in empty package &quot;test&quot; at test.pl line 1.



print(This is a test.\n);    # this line is missing a beginning quote.

</PRE>

</BLOCKQUOTE>

<P>

The error being generated here is very cryptic and has little

to do with the actual problem. In order to understand why the

message mentions methods and packages, you need to understand

the different, arcane ways you can invoke methods when programming

with objects. You probably need to add a beginning quote if you

ever see this error message.<BR>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Tip</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

As long as you follow the object calling guidelines used in <A HREF="ch14.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch14.htm" >Chapter 14</A>, &quot;What Are Objects?,&quot; you will never have to worry about the more advaNCed ways to call object methods.</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<P>

This list of syntax errors could go on for quite a while, but

you probably understand the basic coNCepts:

<BLOCKQUOTE>

Errors are not always located on the line mentioned in the error

message.<BR>

Errors frequently have nothing to do with the error message displayed.

</BLOCKQUOTE>

<H2><A NAME="LogicErrors"><FONT SIZE=5 COLOR=#FF0000>

Logic Errors</FONT></A></H2>

<P>

These are the programming problems-sometimes called bugs-that

you can stare at for hours without having a clue about why your

script doesn't work. If you find yourself in this position, take

a walk or eat some chocolate. In other words, take a break from

staring at the computer screen. You can also find another programmer

to walk through the code with you. Quite often while explaining

the code to someone else, the problem becomes obvious.

<P>

Besides these two options, you can do the following:

<BLOCKQUOTE>

<B>Use the </B><TT><B><FONT FACE="Courier">-w</FONT></B></TT><B>

Command-line Option</B>-This option will produce warning messages

about questionable code.

</BLOCKQUOTE>

<BLOCKQUOTE>

<B>Use the </B><TT><B><FONT FACE="Courier">strict</FONT></B></TT><B>

pragma</B>-This pragma will force you to declare all variables

before using them.

</BLOCKQUOTE>

<BLOCKQUOTE>

<B>Use the built-in debugger</B>-The built-in debugger will let

you single-step through your script, examining or changing variable

values as needed.

</BLOCKQUOTE>

<P>

Each of these options is discussed in separate sections later.

<P>

As a general rule, when debugging logic errors it helps to break

complex expressions and statements into simpler ones: the simpler,

the better. Use temporary variables if you need to. If you use

the <TT>++</TT> or <TT>-</TT>

operators inside fuNCtion calls or complex expressions, don't.

Move the decrement or iNCrement operation to a separate line.

After the program is debugged, you can always recombine the simple

statements into complex ones.<BR>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Tip</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

One of the most common logic problem is using the assignment operator (<TT>=</TT>) when you should use the equality operator (<TT>==</TT>). If you are creating a conditional expression, you'll almost always use the equality operator (<TT>==</TT>).

</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<H3><A NAME="UsingtheTTFONTSIZEFACECourierwFONTTTFONTSIZECommandLineOptionFONT">

Using the <TT>-w</TT>

Command-Line Option</FONT></A></H3>

<P>

One of the most important features to combat logic errors is the

<TT>&#173;w</TT> command-line option,

which causes warning messages to be displayed indicating questionable

Perl code. Questionable code iNCludes identifiers that are mentioned

only oNCe, scalar variables that are used before being set, redefined

subroutines, refereNCes to undefined filehandles, and filehandles

opened read-only that you are attempting to write on.

<P>

For example, can you find anything wrong with the following lines

of code?

<BLOCKQUOTE>

<PRE>

$foo = { };

$bar = 5;



print(&quot;$foa\n&quot;);

print(&quot;$bar\n&quot;);

</PRE>

</BLOCKQUOTE>

<P>

You probably can't see anything wrong at first glaNCe. In fact,

this program compiles and runs without complaint. However, running

this program with the <TT>&#173;w</TT>

option (<TT>perl &#173;w test.pl</TT>)

results in these error messages:

<BLOCKQUOTE>

<PRE>

Identifier &quot;main::foa&quot; used only oNCe: possible typo at test.pl line 4.

Identifier &quot;main::foo&quot; used only oNCe: possible typo at test.pl line 1.

Use of uninitialized value at test.pl line 4.

</PRE>

</BLOCKQUOTE>

<P>

With these error messages, the problem becomes obvious. Either

the variable name <TT>$foo</TT> is

misspelled in the assignment statement or the variable name <TT>$foa</TT>

was misspelled in the print statement.<BR>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Tip</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

Always use the <TT>-w</TT> command-line option! Let me repeat this: Always use the <TT>-w</TT> command-line option! Okay? It will save you lots of headaches tracking down bugs that Perl can catch automatically.

</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<P>

The <TT>-w</TT> option is so useful

that you should <I>always</I> use it. If you know that a specific

line of code is going to generate an error message and you want

to ignore it, use the <TT>$^W</TT>

special variable. For example,

<BLOCKQUOTE>

<PRE>

$foo = { };

$bar = 5;



$^W = 0;

print(&quot;$foa\n&quot;);

print(&quot;$bar\n&quot;);

$^W = 1;

</PRE>

</BLOCKQUOTE>

<P>

eliminates the display of the <TT>Use of

uninitialized value at test.pl line 4.</TT> error message.

Unfortunately, this technique will not stop all messages, and

the placement of the <TT>$^W</TT>

<TT>=</TT> <TT>0;</TT>

statement seems to affect whether the message will be suppressed.

<BR>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Caution</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

This feature did not seem to be too stable in my version of Perl. If you can't get it to work in your version, don't spend too much time trying to find the problem. It simply may not work properly in your version of Perl, either.</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<H3><A NAME="BeingStrictwithYourVariables">

Being Strict with Your Variables</A></H3>

<P>

In the last chapter, &quot;Modules,&quot; the use of modules to

implement pragmas was discussed. One very useful pragma to aid

in debugging is <TT>use strict;</TT>.

This statement does two things:

<UL>

<LI>Forces you to use the <TT>my()</TT>

fuNCtion to declare all variables. When all variables have a local

scope, you avoid problems associated with unintentionally changing

the value of a variable in a fuNCtion.

<LI>Ensures that you can't use accidental symbolic derefereNCing.

This topic was not covered in <A HREF="ch8.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch8.htm" >Chapter 8</A> &quot;RefereNCes,&quot;

because it is relatively advaNCed. If you use the derefereNCing

techniques shown in <A HREF="ch8.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch8.htm" >Chapter 8</A> you won't need to worry about this

requirement.

</UL>

<P>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Tip</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

The strict directory on the CD holds all listings from <A HREF="ch8.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch8.htm" >Chapter 8</A>converted so they work with the <TT>use strict;</TT> pragma: essentially, all the variables needed to be declared local using the <TT>my()</TT> fuNCtion.

</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<P>

When the <TT>strict</TT> pragma is

used, your script will not compile if the preceding two rules

are violated. For example, if you tried to run the following lines

of code,

<BLOCKQUOTE>

<PRE>

use strict;



$foo = { };

$bar = 5;



print(&quot;$foo\n&quot;);

print(&quot;$bar\n&quot;);

</PRE>

</BLOCKQUOTE>

<P>

you would receive these error messages:

<BLOCKQUOTE>

<PRE>

Global symbol &quot;foo&quot; requires explicit package name at test.pl line 3.

Global symbol &quot;bar&quot; requires explicit package name at test.pl line 4.

Global symbol &quot;foo&quot; requires explicit package name at test.pl line 6.

Global symbol &quot;bar&quot; requires explicit package name at test.pl line 7.

Execution of test.pl aborted due to compilation errors.

</PRE>

</BLOCKQUOTE>

<P>

In order to eliminate the messages, you need to declare <TT>$foo</TT>

and <TT>$bar</TT> as local variables,

like this:

<BLOCKQUOTE>

<PRE>

use strict;



my($foo) = { };

my($bar) = 5;



print(&quot;$foo\n&quot;);

print(&quot;$bar\n&quot;);

</PRE>

</BLOCKQUOTE>

<P>

I bet you already have guessed that the <TT>my()</TT>

fuNCtion makes the variables local to the <TT>main</TT>

package.

<P>

In the next section, you see how to use the debugger to step through

your programs.

<H3><A NAME="SteppingThroughYourScript">

Stepping Through Your Script</A></H3>

<P>

So far, you've read about how to limit the possibility of errors

appearing in your programs. If, after using the <TT>-w</TT>

and the <TT>strict</TT> pragma, you

still have a problem, it's time to use the <I>debugger</I>.

<P>

What is the debugger? Quite simply, it is an interactive environment

that allows you to execute your script's statements one at a time.

If necessary, you can display the lines of your script, view or

alter variables, and even execute entirely new statements.

<P>

You start the debugger by using the <TT>-d</TT>

command-line option. The following line

<BLOCKQUOTE>

<PRE>

perl -w -d 08lst08.pl

</PRE>

</BLOCKQUOTE>

<P>

starts the debugger and loads the script called <TT>08lst08.pl</TT>.

If you want to invoke the debugger with no script, you need to

perform a small bit of magic, like this

<BLOCKQUOTE>

<PRE>

perl -d -e &quot;1;&quot;

</PRE>

</BLOCKQUOTE>

<P>

to start debugger without any program. I say that this is a bit

of magic because you haven't read about all the different command-line

options available for the Perl interpreter. You see them all in

<A HREF="ch17.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch17.htm" >Chapter 17</A>, &quot;Using the Command-Line Options.&quot; The -e

option tells Perl to execute a single Perl statement. In this

case the statement is 1;, which basically means do nothing. It

does, however, stop the interpreter from looking for the name

of a script file on the command line.

<P>

When the debugger starts, your screen will look something like

this:

<BLOCKQUOTE>

<PRE>

Loading DB routines from $RCSfile: perl5db.pl,v $$Revision: 4.1

$$Date: 92/08/07 18:24:07 $

Emacs support available.



Enter h for help.



main::(08lst08.pl:3):   my($codeRef);

  DB&lt;1&gt;

</PRE>

</BLOCKQUOTE>

<P>

This message tells you that the debugger (<TT>DB</TT>)

routines have been loaded. The <TT>DB&lt;1&gt;</TT>

is a prompt that indicates that the debugger is waiting for input.

The line number inside the angle brackets is the current execution

line<I>.</I> The <I>current execution line</I> is that line that

the debugger waits to execute.

<P>

One of the features of the debugger is the capability to insert

breakpoints into your script. A <I>breakpoint</I> is an instruction

that tells the debugger to stop, to display a prompt, and to wait

for input. When the debugger first starts, there are no breakpoints

defined for your program. See the section &quot;Examples: Using

Breakpoints&quot; later in the chapter for more information.

<P>

You can use any of the commands listed in Table 16.11 while using

the debugger. While some of the commands are demonstrated in the

sections that follow the table, you can't hurt anything by experimenting

with any or all of the commands on your own.<BR>

<P>

<CENTER><B>Table 16.1&nbsp;&nbsp;The Debugger Commands</B></CENTER>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD WIDTH=133><I>Command</I></TD><TD WIDTH=457><I>Description</I>

</TD></TR>

<TR><TD COLSPAN=2 WIDTH=590><B>Commands That Control Actions</B>

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>a ACTION</TT></CENTER>

</TD><TD WIDTH=457>This command tells the debugger to perform <TT>ACTION</TT> just before the current execution line is executed. Optionally, you can specify a line number. For example, <TT>a 10 print(&quot;$numFiles&quot;);</TT> executes the 
<TT>print</TT> statement before line 10 is executed. If line 10 is inside a loop, the action is performed each time through the loop.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>A</TT></CENTER>

</TD><TD WIDTH=457>Deletes all actions.</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>L</TT></CENTER>

</TD><TD WIDTH=457>Lists all breakpoints and actions.</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>&lt; ACTION</TT></CENTER>

</TD><TD WIDTH=457>Forces the debugger to execute <TT>ACTION</TT> each time the debugger prompt is displayed. This command is great if you need to print the value of certain values each time you are prompted by the debugger.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>&gt; ACTION</TT></CENTER>

</TD><TD WIDTH=457>Forces the debugger to execute <TT>ACTION</TT> after every debugger command you issue.

</TD></TR>

<TR><TD COLSPAN=2 WIDTH=590><B>Commands That Involve Breakpoints</B>

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>b</TT></CENTER>

</TD><TD WIDTH=457>Sets a breakpoint at the current execution line. You can specify a line where the breakpoint should be set. For example, <TT>b 35</TT> sets a breakpoint at line 35. You can also create a conditional breakpoint. For example, <TT>b 35 
$numLines == 0</TT>  causes the debugger to stop at line 35 only if <TT>$numLines</TT> is equal to zero. Watch conditions can also be attached to fuNCtions; just use the fuNCtion name instead of a line number.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>D</TT></CENTER>

</TD><TD WIDTH=457>Deletes the breakpoint from the current execution line. If you specify a line number, the breakpoint is deleted from that line.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>D</TT></CENTER>

</TD><TD WIDTH=457>Deletes all breakpoints.</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>L</TT></CENTER>

</TD><TD WIDTH=457>Lists all breakpoints and actions.</TD></TR>

<TR><TD COLSPAN=2 WIDTH=590><B>Commands That Display Information</B>

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>l</TT></CENTER>

</TD><TD WIDTH=457>Lets you print out parts of your script. There are several flavors of this command that you can use:

<P>

Using a plain <TT>l</TT> displays about 10 lines of your script.<BR>

Using <TT>l 5+4</TT> displays 4 lines of your script starting with line 5.<BR>

Using <TT>l 4-7</TT> displays lines 4 through 7 of your script.<BR>

Using <TT>l 34</TT> displays line 34 of your script.<BR>

Using <TT>l foo</TT> displays roughly the first 10 lines of the <TT>foo()</TT> fuNCtion.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>L</TT></CENTER>

</TD><TD WIDTH=457>Lists all breakpoints and actions.</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>p EXPR</TT></CENTER>

</TD><TD WIDTH=457>Prints the result of evaluating <TT>EXPR</TT> to the display. It is a shorthand way of saying <TT>print DB::OUT (EXPR)</TT>.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>S</TT></CENTER>

</TD><TD WIDTH=457>Lists all fuNCtion names that are defined. The list will iNClude any fuNCtion defined in modules as well as those in your script.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>T</TT></CENTER>

</TD><TD WIDTH=457>Prints a stack trace. A <I>stack trace</I> displays a list of fuNCtion calls and the line number where the calls were made.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>V</TT></CENTER>

</TD><TD WIDTH=457>Lists all variables that are currently defined from all packages and modules that are loaded. A better form of this command is <TT>V PACKAGE</TT> or <TT>V PACKAGE VARLIST</TT> where <TT>PACKAGE</TT> is the name of a loaded package or 
module, and <TT>VARLIST</TT> is a currently defined variable in <TT>PACKAGE</TT>. When specifying variable names, don't use the <TT>$</TT>, <TT>@</TT>, or <TT>%</TT> type specifiers.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>w LINE</TT></CENTER>

</TD><TD WIDTH=457>Displays about 10 lines centered around <TT>LINE</TT>. For example, if you use <TT>w 10</TT>, lines 7 to 16 might display.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>X</TT></CENTER>

</TD><TD WIDTH=457>Lists all variables in the current package. If you have stepped into a fuNCtion that is in package <TT>foo</TT>, the variables in package <TT>foo</TT> are displayed, not those in <TT>main</TT>. You can also specify exactly which 
variables to display if needed. When specifying variable names, don't use the <TT>$</TT>, <TT>@</TT>, or <TT>%</TT> type specifiers.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>-</TT></CENTER>

</TD><TD WIDTH=457>Displays about 10 lines of your script that are before the current line. For example, if the current display line is 30, this command might display lines 19 to 29.

</TD></TR>

<TR><TD COLSPAN=2 WIDTH=590><B>Commands That Control Execution</B>

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>s</TT></CENTER>

</TD><TD WIDTH=457>Steps through the lines in your script one at a time. It steps into any user-defined fuNCtion that is called. While single-stepping is slow, you see exactly how your code is being executed.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>N</TT></CENTER>

</TD><TD WIDTH=457>Executes the next statement in your script. Although all fuNCtion calls are executed, it does not follow the execution path inside a fuNCtion. This command enables you to move quicker through the execution of your script than simply 
using the <TT>s</TT> command. An example of this is shown in the &quot;Examples: Using the <TT>n</TT> Command&quot; section later in this chapter.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>R</TT></CENTER>

</TD><TD WIDTH=457>Executes the rest of the statements in the current fuNCtion. The debugger pauses for input on the line following the line that made the fuNCtion call.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>C LINE</TT></CENTER>

</TD><TD WIDTH=457>Executes the rest of the statements in your script unless a breakpoint is found before the script ends. You can optionally use this command to create a temporary break by specifying a line number after the <TT>c</TT>. I think of this 
command as continue until <TT>LINE</TT>.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>No Command</TT></CENTER>

</TD><TD WIDTH=457>Pressing the Enter key without specifying a command will make the debugger repeat the last <TT>n</TT> or <TT>s</TT> command that was used. This feature makes it a little easier to single-step through your script.

</TD></TR>

<TR><TD COLSPAN=2 WIDTH=590><B>Commands That Work with the Debugger Command History</B>

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>!</TT></CENTER>

</TD><TD WIDTH=457>Re-executes the previous command. You can also specify the number of the previous command to execute. Use the <TT>H</TT> command to get a list of the previous commands. If you specify a negative number, like <TT>! -2</TT>, the debugger 
counts backwards from the last executed command.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>H</TT></CENTER>

</TD><TD WIDTH=457>Lists all the debugger commands you have issued. Only commands that cause action are saved in the command history. This means that the <TT>l</TT> and <TT>T</TT> commands are not saved. You can limit the history viewed by specifying a 
negative number. For example, <TT>H -5</TT> displays the last five commands  you have issued.

</TD></TR>

<TR><TD COLSPAN=2 WIDTH=590><B>Miscellaneous Commands</B></TD>

</TR>

<TR><TD WIDTH=133><CENTER><TT>f FILENAME</TT></CENTER>

</TD><TD WIDTH=457>Causes the debugger to switch to <TT>FILENAME</TT>. The file specified must have already been loaded via the <TT>use</TT> or <TT>require</TT> statements. Please note that some of the documentation that accompanies the Perl interpreter 
may indicate that <TT>f</TT> is the <TT>finish</TT> command. It used to be; however, the finish fuNCtionality is now accomplished by the <TT>r</TT> command.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>Q</TT></CENTER>

</TD><TD WIDTH=457>Quits the debugger. You can also use the Ctrl+D key sequeNCe under UNIX and the Ctrl+Z key sequeNCe under DOS and Windows.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>T</TT></CENTER>

</TD><TD WIDTH=457>Toggles trace mode on and off. <I>Trace</I> mode, when on, displays each script line as it is being executed. I don't recommend this option except for very short programs because the lines are displayed so quickly that you won't be able 
to read them.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>/pattern/</TT></CENTER>

</TD><TD WIDTH=457>Searches for <TT>pattern</TT> in the currently loaded file. If <TT>pattern</TT> is found, the current display line is changed to the line where <TT>pattern</TT> was found.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>?pattern?</TT></CENTER>

</TD><TD WIDTH=457>Searches backward for <TT>pattern</TT> in the currently loaded file. If <TT>pattern</TT> is found, the current display line is changed to the line where <TT>pattern</TT> was found.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>=</TT></CENTER>

</TD><TD WIDTH=457>Displays any aliases that are currently defined. You can also use it to create aliases. See the section &quot;Examples: Creating Command Aliases&quot; later in this chapter for more information about aliases and the <TT>=</TT> command.

</TD></TR>

<TR><TD WIDTH=133><CENTER><TT>COMMAND</TT></CENTER>

</TD><TD WIDTH=457>Any text that is not recognized as an alias or a debugger command is executed as a Perl statement. See the section &quot;Examples: Using the Debugger as an Interactive Interpreter&quot; later in this chapter for more information about 
executing Perl statements inside the debugger.

</TD></TR>

</TABLE>

</CENTER>

<P>

<P>

As you can see, the debugger has quite a few commands to choose

from, and it is very powerful. Most programmers will not need

all of the fuNCtionality that the debugger has. If you learn to

display script lines, to use breakpoints, and to display variables,

you'll be well on your way to solving any logic problem that may

arise.

<H3><A NAME="ExamplesDisplayingInformation">

Examples: Displaying Information</A></H3>

<P>

The debugger uses the coNCept of a current display line. The <I>current

display line</I> is simply the last line that has been displayed

by the <TT>l</TT> command. When the

debugger first starts, the current display line is the first executable

line. See Listing 16.1 for some examples.

<HR>

<BLOCKQUOTE>

<B>Listing 16.1&nbsp;&nbsp;16LST01.PL-Using the Debugger List

Commands<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

01: package Inventory_item;

02:    sub new {

03:    }

04:

05: package Pen;

06:     @ISA = (Inventory_item);

07:

08:     sub new {

09:     }

10:

11: package Color;

12:     print(&quot;Executing Color statements\n&quot;);

13:     $colors{&quot;blue&quot;}  = &quot;Die Lot 13&quot;;

14:     $colors{&quot;red&quot;}   = &quot;Die Lot 5&quot;;

15:

16:     sub new {

17:     }

18:

19: package main;

20:     print(&quot;Executing main statements\n&quot;);

</PRE>

</BLOCKQUOTE>

<HR>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Note</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

This listing is identical to Listing 14.5 except that the guts of the fuNCtions have been removed. This was done simply to shorten the listing.</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<P>

If you load this script into the debugger (<TT>perl

-d 16lst01.pl</TT>), you will see that the first displayed

line is line 6. The lines before line 6 are <TT>package</TT>

and <TT>fuNCtion</TT> statements.

Line 6 will also be the current execution line.

<P>

If you issue the <TT>l</TT> debugger

command, lines 6 to 15 are displayed:

<BLOCKQUOTE>

<PRE>

6:          @ISA = (Inventory_item);

7:

8:          sub new {

9:          }

10:

11:     package Color;

12:         print(&quot;Executing Color statements\n&quot;);

13:         $colors{&quot;blue&quot;}  = &quot;Die Lot 13&quot;;

14:         $colors{&quot;red&quot;}   = &quot;Die Lot 5&quot;;

15:

</PRE>

</BLOCKQUOTE>

<P>

After this display, the current display line is changed to 15,

but the current execution line is still line 6. If you issue the

<TT>l</TT> debugger command again,

lines 16 to 20 are displayed.

<P>

You can display the first line of your script by using the <TT>l

1</TT> debugger command. This command displays the first

line of the script and changes the current display line:

<BLOCKQUOTE>

<PRE>

1:      package Inventory_item;

</PRE>

</BLOCKQUOTE>

<P>

Because this script uses package names to change the namespace

in which the fuNCtions are defined, simply issuing <TT>l

new</TT> does not display a <TT>new()</TT>

fuNCtion. Instead, you need to use the double-colon (<TT>::</TT>)

notation to specify which namespace to use. For example, <TT>l

Color::new</TT> displays

<BLOCKQUOTE>

<PRE>

16:         sub new {

17:         }

</PRE>

</BLOCKQUOTE>

<P>

While inside the debugger, you can use the <TT>X</TT>

and <TT>V</TT> commands to view variables.

These commands are very good for simple variables, but I have

not found them to be useful for complex data structures. For example,

Listing 16.2 shows a small program that creates an array within

an array data structure.

<HR>

<BLOCKQUOTE>

<B>Listing 16.2&nbsp;&nbsp;16LST02.PL-Using the </B><TT><B><FONT FACE="Courier">X</FONT></B></TT><B>

Command to View Arrays<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

sub prtArray {

    my(@array)      = @_;

    my($index)      = 0;



    foreach (@array) {

        if (ref($_) eq 'ARRAY') {

            my($innerIndex) = 0;



            foreach (@{$array[3]}) {

                print(&quot;\t$innerIndex\t'$_'\n&quot;);

                $innerIndex++;

            }

        }

        else {

            print(&quot;$index\t'$array[$index]'\n&quot;);

        }

        $index++;

    }

}



@array = (1, 2, 3, [1, 2, 3], 4);    # an array inside an array.

1;

</PRE>

</BLOCKQUOTE>

<HR>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Note</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

This listing is for illustrative purposes only. The crude method used to print the data structure is not recommended for practical use. I suggest that you invest time creating a general-use routine that can print more than one type of complex structure. 
You might also look at the dumpvars module that comes with most, if not all, Perl distributions.</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<P>

Load this script into the debugger (<TT>perl

-d 16lst01.pl</TT>), use the <TT>s</TT>

command to execute the array assignment, and then display <TT>@array</TT>

with the <TT>X array</TT> command.

Your display should look like this:

<BLOCKQUOTE>

<PRE>

@array = (

  0     '1'

  1     '2'

  2     '3'

  3     'ARRAY(0x7c693c)'

  4     '4'

)

</PRE>

</BLOCKQUOTE>

<P>

You can see that the displayed values are not as informative as

you might hope for because of the array refereNCe in element 3.

However, because the <TT>prtArray()</TT>

fuNCtion is designed to print this type of data structure, call

it from the debugger using the <TT>prtArray(@array);</TT>

command. This should result in a display like this:

<BLOCKQUOTE>

<PRE>

0       '1'

1       '2'

2       '3'

        0       '1'

        1       '2'

        2       '3'

4       '4'

</PRE>

</BLOCKQUOTE>

<P>

The <TT>1;</TT> line of code is used

to let you execute the array assignment without the debugger ending.

Just ignore it.

<H3><A NAME="ExamplesUsingtheFONTSIZEFACELBIHelveticaBlackObliquenFONTFONTSIZECommandFONT">

Examples: Using the <FONT SIZE=4 FACE="LBI Helvetica Black Oblique">n</FONT><FONT SIZE=4>

Command</FONT></A></H3>

<P>

The <TT>n</TT> command lets you step

over fuNCtion calls in your scripts. This command saves you time

because you won't need to single-step through every line of every

fuNCtion. The program in Listing 16.3 has three fuNCtions defined

and three fuNCtion calls and is used to demonstrate the <TT>n</TT>

command.

<HR>

<BLOCKQUOTE>

<B>Listing 16.3&nbsp;&nbsp;16LST03.PL-Using the </B><TT><B><FONT FACE="Courier">n</FONT></B></TT><B>

Command to Step Over FuNCtion Calls<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

1:      sub a {

2:          print(&quot;This is fuNCtion a\n&quot;);

3:      }

4:

5:      sub b {

6:          print(&quot;This is fuNCtion b\n&quot;);

7:      }

8:

9:      sub c {

10:         print(&quot;This is fuNCtion c\n&quot;);

11:     }

12:

13:     a();

14:     b();

15:     c();

</PRE>

</BLOCKQUOTE>

<HR>

<P>

First, let's see the regular path of execution that takes place

using the <TT>s</TT> command:

<BLOCKQUOTE>

<PRE>

13:     a();

2:          print(&quot;This is fuNCtion a\n&quot;);

This is fuNCtion a

14:     b();

6:          print(&quot;This is fuNCtion b\n&quot;);

This is fuNCtion b

15:     c();

10:         print(&quot;This is fuNCtion c\n&quot;);

This is fuNCtion c

</PRE>

</BLOCKQUOTE>

<P>

If the <TT>n</TT> command is used

instead of the <TT>s</TT> command,

the path of execution stays the same. However, you are prompted

after each fuNCtion call. The lines inside the fuNCtion are still

executed, however.

<BLOCKQUOTE>

<PRE>

13:     a();

This is fuNCtion a

14:     b();

This is fuNCtion b

15:     c();

This is fuNCtion c

</PRE>

</BLOCKQUOTE>

<P>

By switching between the <TT>s</TT>

and <TT>n</TT> commands, you can decide

which fuNCtions to step into and which to step over.

<H3><A NAME="ExamplesUsingBreakpoints">

Examples: Using Breakpoints</A></H3>

<P>

Breakpoints are used to tell the debugger where to stop execution

of your script. After the execution is stopped, the debugger prompts

you to enter a debugger command. For example, you might want to

set a breakpoint on a line that assigns a complicated expression

to a variable. This allows you to check any variables used in

the expression before it is executed.

<P>

Listing 16.4 demonstrates the different breakpoint commands you

can use.

<HR>

<BLOCKQUOTE>

<B>Listing 16.4&nbsp;&nbsp;16LST05.PL-Sample Program to Test Breakpoints

<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

1:      sub a {

2:          my($foo) = @_;

3:

4:          print(&quot;This is fuNCtion a. Foo is $foo.\n&quot;);

5:      }

6:

7:      a(10);

8:      a(5);

</PRE>

</BLOCKQUOTE>

<HR>

<P>

When the script is first loaded into the debugger, the current

execution line is 7. Using the <TT>c</TT>

command causes the entire program to be executed. A transcript

of the debugging session might look like this:

<BLOCKQUOTE>

<PRE>

main::(16lst04.pl:7):   a(10);

  DB&lt;1&gt; <B>c

</B>This is fuNCtion a. Foo is 10.

This is fuNCtion a. Foo is 5.

</PRE>

</BLOCKQUOTE>

<P>

You can force the debugger to stop each time that <TT>a()</TT>

is invoked by using the <TT>b a</TT>

command. This lets you examine the <TT>@_</TT>

parameter array before the fuNCtion is started. For example:

<BLOCKQUOTE>

<PRE>

main::(16lst04.pl:7):   a(10);

  DB&lt;1&gt; <B>b a

</B>  DB&lt;2&gt; <B>c

</B>main::a(16lst04.pl:2):      my($foo) = @_;

  DB&lt;3&gt; <B>p @_

</B>10

  DB&lt;4&gt; <B>c

</B>This is fuNCtion a. Foo is 10.

main::a(16lst04.pl:2):      my($foo) = @_;

  DB&lt;4&gt; <B>p @_

</B>5

  DB&lt;5&gt; <B>c

</B>This is fuNCtion a. Foo is 5.<BR>



</PRE>

</BLOCKQUOTE>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Tip</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

The <TT>p</TT> command, used in this example, is shorthand for the statement <TT>print(&quot;@_\n&quot;);</TT>. You can use the <TT>p</TT> command to print any variable.

</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<P>

You can also create conditional breakpoints. For example, you

could tell the debugger to stop inside <TT>a()</TT>

only if <TT>$foo</TT> is equal to

<TT>5</TT> using the command <TT>b

4 $foo == 5</TT>. In this instaNCe, you can't use <TT>b

a $foo == 5</TT> because <TT>$foo</TT>

is a local variable. When the debugger stops just before executing

a fuNCtion, the parameter array is initialized but not any of

the local variables. A debugging session using conditional breakpoints

might look like this:

<BLOCKQUOTE>

<PRE>

main::(16lst04.pl:7):   a(10);

  DB&lt;1&gt; <B>b 4 $foo == 5

</B>  DB&lt;2&gt; <B>L

</B>4:          print(&quot;This is fuNCtion a. Foo is $foo.\n&quot;);

  break if ($foo == 5)

  DB&lt;2&gt; <B>c

</B>This is fuNCtion a. Foo is 10.

main::a(16lst04.pl:4):      print(&quot;This is fuNCtion a. Foo is $foo.\n&quot;);

  DB&lt;2&gt; <B>c

</B>This is fuNCtion a. Foo is 5.

</PRE>

</BLOCKQUOTE>

<P>

The debugger did not stop during the first call to <TT>a()</TT>

because <TT>$foo</TT> was equal to

<TT>10</TT>. On the second call, <TT>$foo</TT>

is set to <TT>5</TT> which causes

the debugger to stop.

<P>

The <TT>L</TT> debugger command is

used to display all breakpoints and their conditions. If you don't

specify any conditions, a default condition of 1 is supplied.

Because 1 is always true, this creates an uNConditional breakpoint.

If you had created an uNConditional breakpoint on line 7, the

<TT>L</TT> command would display the

following:

<BLOCKQUOTE>

<PRE>

4:          print(&quot;This is fuNCtion a. Foo is $foo.\n&quot;);

  break if ($foo == 10)

7:      a(10);

  break if (1)

</PRE>

</BLOCKQUOTE>

<P>

The <TT>d</TT> command is used to

delete or remove breakpoints. Issuing the commands <TT>d

4</TT> and then <TT>L</TT>

would result in this display:

<BLOCKQUOTE>

<PRE>

7:      a(10);

  break if (1)

</PRE>

</BLOCKQUOTE>

<P>

If you want to delete <I>all</I> the breakpoints at oNCe, use

the <TT>D</TT> command.

<H3><A NAME="ExamplesCreatingCommandAliases">

Examples: Creating Command Aliases</A></H3>

<P>

The <TT>=</TT> command is used to

create command aliases. If you find yourself issuing the same

long command over and over again, you can create an alias for

that command. For example, the debugger command

<BLOCKQUOTE>

<PRE>

= pFoo print(&quot;foo=$foo\n&quot;);

</PRE>

</BLOCKQUOTE>

<P>

creates an alias called <TT>pFoo</TT>.

After this command is issued, typing <TT>pFoo</TT>

at the debugger prompt produces the same results as typing <TT>print(&quot;foo=$foo\n&quot;);</TT>.

<P>

You use the <TT>=</TT> command without

any arguments when you want a list of the current aliases.

<P>

If you want to set up some aliases that will always be defined,

create a file called <TT>.perldb</TT>

and fill it with your alias definitions. Use the following line

as a template:

<BLOCKQUOTE>

<PRE>

$DB::alias{'pFoo'} = 'print(&quot;foo=$foo\n&quot;);';

</PRE>

</BLOCKQUOTE>

<P>

After you create this file and its alias definitions, the aliases

will be available in every debugging session.

<H3><A NAME="ExamplesUsingtheDebuggerasanInteractiveInterpreter">

Examples: Using the Debugger as an Interactive Interpreter

</A></H3>

<P>

In <A HREF="ch13.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch13.htm" >Chapter 13</A>, &quot;Handling Errors and Signals,&quot; you learned

how to create an interactive Perl interpreter that could replace

shell and batch files. The program was shown in Listing 13.3.

You can also use the debugger as an interactive interpreter. In

fact, it does an even better job in some cases.

<P>

If you create a script with fuNCtions that perform individual

system tasks, you can run that script inside the debugger. Then

you can call the fuNCtions from the debugger command lines as

needed. Listing 16.5 shows what one possible script might look

like.

<HR>

<BLOCKQUOTE>

<B>Listing 16.5&nbsp;&nbsp;16LST05.PL-A Script with Some System

MaintenaNCe FuNCtions<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

sub printUserReport {

    # read list of users

    # determine usage statistics

    # display report

}



sub backupUsers {

    # remove backup file.

    #'delete /user/*.bak'



    # backup user files to tape.

    #'\backup /user/*';

}



sub help {

    print(&quot;\n&quot;);

    print(&quot;backupUsers will perform the nightly backup.\n&quot;);

    print(&quot;printUserReport will display user usage statistics.\n&quot;);

    print(&quot;\n&quot;);

}



1;

</PRE>

</BLOCKQUOTE>

<HR>

<p>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR><TD><B>Note</B></TD></TR>

<TR><TD>

<BLOCKQUOTE>

This script is really nothing but a skeleton. You should be able to flesh it out with fuNCtions that are useful to you.</BLOCKQUOTE>



</TD></TR>

</TABLE>

</CENTER>

<P>

<P>

You load this script into the debugger with the command <TT>perl

-d 16lst05.pl</TT>. After the script loads, you can run

any of the fuNCtions by typing their name at the debugger prompt.

Here is a sample debugger session:

<BLOCKQUOTE>

<PRE>

main::(16lst05.pl:22):  1;

  DB&lt;1&gt; help



backupUsers will perform the nightly backup.

printUserReport will display user usage statistics.





  DB&lt;2&gt; backupUsers



  DB&lt;3&gt; q

</PRE>

</BLOCKQUOTE>

<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>

Summary</FONT></A></H2>

<P>

I think there is a certain art to debugging that only experieNCe

can teach. There are so many different places where things can

go wrong that it's impossible to remember which bug is most likely

to appear in a given scenario. If you have lived through the frustration

of tracking a bug for hours only to have someone look at your

program for three minutes and say, &quot;Look, that minus sign

should be a multiplication sign!&quot; you are much more likely

to find the bug the next time. There is no substitute for real-life

debugging.

<P>

Let's recap what you <I>did</I> learn in this chapter. You started

out by reading about syntax or compile-time errors. This class

of error involved a misplaced parenthesis, a missing quote, or

some other slip of the fingers while entering your program into

an editor. Syntax errors are found when Perl compiles your program

into an internal format prior to actually executing it. The only

way to track down a syntax error is to read the error messages

and look at your program.

<P>

Logic errors, on the other hand, can be harder to find. They involve

some logical flaw in your program. Using the index into an array

or specifying the wrong variable as a parameter to a fuNCtion

both qualify as logic errors.

<P>

The first step to combating logic errors is to use the <TT>-w</TT>

command-line option. The <TT>-w</TT>

command tells Perl to display warning messages for various dangerous

coding practices.

<P>

The next step is to use the <TT>strict</TT>

pragma in your programs. This requires that you declare every

variable you use. Creating only local variables minimizes the

possibility of inadvertently changing the wrong variable or causing

side effects in your program.

<P>

If you still have logic errors after these two options have been

used, you might use the debugger. The debugger lets you single-step

through your program and print or modify variables. You can also

set breakpoints or actions, and you can interactively call any

fuNCtion directly from the debugger command line.

<P>

The next chapter discusses all the Perl command-line options.

You'll also read more about the <TT>-e</TT>

option mentioned earlier.

<H2><A NAME="ReviewQuestions"><FONT SIZE=5 COLOR=#FF0000>

Review Questions</FONT></A></H2>

<P>

Answers to Review Questions are in Appendix A.

<OL>

<LI>What is a logic error?

<LI>What is a compile-time error?

<LI>What will the <TT>D</TT> debugger

command do?

<LI>What is a conditional breakpoint?

<LI>What is an action?

<LI>What will the <TT>c</TT> debugger

command do?

<LI>Can you invoke any fuNCtion directly from the debugger command

line?

<LI>What is an alias?

<LI>What is a common error associated with conditional expressions?

</OL>

<H2><A NAME="ReviewExercises"><FONT SIZE=5 COLOR=#FF0000>

Review Exercises</FONT></A></H2>

<OL>

<LI>Name three common syntax errors.

<LI>Use the <TT>s</TT> debugger command

to determine the execution path for the program in Listing 16.1.

<LI>Set a breakpoint on line 14 of Listing 16.1. If you use the

<TT>c</TT> command to execute the

program, how many times will the debugger stop and display a prompt?

<LI>Modify the program in Listing 16.1 to use the <TT>strict</TT>

pragma.

<LI>Create a useful system maintenaNCe fuNCtion and modify Listing

16.5 to support it.

</OL>

<HR>



<CENTER><P><A HREF="ch15.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch15.htm"><IMG SRC="pc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="index-1.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/index-1.htm"><IMG SRC="hb.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="ch17.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch17.htm"><IMG SRC="nc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<HR WIDTH="100%"></P></CENTER>

</BODY>

</HTML>

