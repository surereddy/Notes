<html>

<head>

<title>Chapter 21  -- Using Perl with Web Servers</title>



<meta>

</head>

<body TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">

<h1><font SIZE="6" COLOR="#FF0000">Chapter&nbsp;21</font></h1>

<h1><font SIZE="6" COLOR="#FF0000">Using Perl with Web Servers</font>

</h1>

<hr>

<p>

<center><b><font SIZE="5">CONTENTS</font></b></center>

<ul>

<li><a HREF="#ServerLogFiles">

Server Log Files 

<ul>

<li><a HREF="#ExampleReadingaLogFile">

Example: Reading a Log File</a>

<li><a HREF="#ExampleListingAccessbyDocument">

Example: Listing Access by Document</a>

<li><a HREF="#ExampleLookingattheStatusCode">

Example: Looking at the Status Code</a>

<li><a HREF="#ExampleConvertingtheReporttoaWebPage">

Example: Converting the Report to a Web Page</a>

<li><a HREF="#ExistingLogFileAnalyzingPrograms">

Existing Log File Analyzing Programs</a>

<li><a HREF="#CreatingYourOwnCGILogFile">

Creating Your Own CGI Log File</a>

</ul>

<li><a HREF="#CommunicatingwithUsers">

Communicating with Users</a>

<ul>

<li><a HREF="#ExampleGeneratingaWhatsNewPage">

Example: Generating a What's New Page</a>

<li><a HREF="#ExampleGettingUserFeedback">

Example: Getting User Feedback</a>

</ul>

<li><a HREF="#Summary">

Summary</a>

<li><a HREF="#ReviewExercises">

Review Exercises</a>

</ul>



<hr>

<p>

Web servers frequently need some type of maintenaNCe in order

to operate at peak efficieNCy. This chapter will look at some

maintenaNCe tasks that can be performed by Perl programs. You

will see some ways that your server keeps track of who visits

and what Web pages are accessed on your site. You will also see

some ways to automatically generate a site index, a what's new

document, and user feedback about a Web page.

<h2><a NAME="ServerLogFiles"><font SIZE="5" COLOR="#FF0000">

Server Log Files</font></a></h2>

<p>

The most useful tool to assist in understanding how and when your

Web site pages and applications are being accessed is the log

file generated by your Web server. This log file contains, among

other things, which pages are being accessed, by whom, and when.

<p>

Each Web server will provide some form of log file that records

who and what accesses a specific HTML page or graphic. A terrific

site to get an overall comparison of the major Web servers can

be found at <b>http://www.webcompare.com/</b>. From this site

one can see which Web servers follow the CERN/NCSA common log

format that is detailed below. In addition, you can also find

out which sites can customize log files, or write to multiple

log files. You might also be surprised at the number of Web servers

there are on the market.

<p>

Understanding the contents of the server log files is a worthwhile

endeavor. And in this section, you'll see several ways that the

information in the log files can be manipulated. However, if you're

like most people, you'll use one of the log file analyzers that

you'll read about in the section &quot;Existing Log File Analyzing

Programs&quot; to do most of your work. After all, you don't want

to create a program that others are giving away for free.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note </b></td></tr>

<tr><td>

<blockquote>

This section about server log files is one that you can read when the need arises. If you are not actively running a Web server now, you won't be able to get full value from the examples. The CD-ROM that accompanies this book has a sample log file to you 
to experiment on but it is very limited in size and scope.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

Nearly all of the major Web servers use a common format for their

log files. These log files contain information such as the IP

address of the remote host, the document that was requested, and

a timestamp. The syntax for each line of a log file is:

<pre>

site logName fullName [date:time GMToffset] &quot;req file proto&quot; status length

</pre>

</blockquote>

<p>

Because that line of syntax is relatively meaningless, here is

a line from a real log file:

<blockquote>

<pre>

204.31.113.138 - - [03/Jul/1996:06:56:12 -0800]

    &quot;GET /PowerBuilder/Compny3.htm HTTP/1.0&quot; 200 5593

</pre>

</blockquote>



<p>

Even though I have split the line into two, you need to remember

that inside the log file it really is only one line.

<p>

Each of the eleven items listed in the above syntax and example

are described in the following list.

<ul>

<li><b>site</b>-either an IP address or the symbolic name of the

site making the HTTP request. In the example line the remotehost

is <tt>204.31.113.138</tt>.

<li><b>logName</b>-login name of the user who owns the account

that is making the HTTP request. Most remote sites don't give

out this information for security reasons. If this field is disabled

by the host, you see a dash (<tt>-</tt>)

instead of the login name.

<li><b>fullName</b>-full name of the user who owns the account

that is making the HTTP request. Most remote sites don't give

out this information for security reasons. If this field is disabled

by the host, you see a dash (<tt>-</tt>)

instead of the full name. If your server requires a user id in

order to fulfill an HTTP request, the user id will be placed in

this field.

<li><b>date</b>-date of the HTTP request. In the example line

the date is <tt>03/Jul/1996</tt>.

<li><b>time</b>-time of the HTTP request. The time will be presented

in 24-hour format. In the example line the time is <tt>06:56:12</tt>.

<li><b>GMToffset</b>-signed offset from Greenwich Mean Time. GMT

is the international time refereNCe. In the example line the offset

is -0800, eight hours earlier than GMT.

<li><b>req</b>-HTTP command. For WWW page requests, this field

will always start with the GET command. In the example line the

request is <tt>GET</tt>.

<li><b>file</b>-path and filename of the requested file. In the

example line the file is <tt>/PowerBuilder/Compny3.htm</tt>.

There are three types of path/filename combinations:

</ul>

<blockquote>

<b>Implied Path and Filename</b>-accesses a file in a user's home

direc-tory. For example, <tt>/~foo/</tt>

could be expanded into <tt>/user/foo/homepage.html</tt>.

The <tt>/user/foo</tt> directory is

the home directory for the user <tt>foo</tt>.

And <tt>homepage.html</tt> is the

default file name for any user's home page. Implied paths are

hard to analyze because you need to know how the server is set

up and because the server's set up may change.

</blockquote>

<blockquote>

<b>Relative Path and Filename</b>-accesses a file in a directory

that is specified relative to a user's home directory. For example,

<tt>/~foo/cooking.html</tt> will be

expanded into <tt>/user/foo/cooking.html</tt>.

</blockquote>

<blockquote>

<b>Full Path and Filename</b>-accesses a file by explicitly stating

the full directory and filename. For example, <tt>/user/foo/biking/mountain/index.html</tt>.

</blockquote>

<ul>

<li><b>proto</b>-type of protocol used for the request. In the

example line, proto <tt>HTTP 1.0</tt>

is used.

<li><b>status</b>-status code generated by the request. In the

example line the status is <tt>200</tt>.

See section &quot;Example: Looking at the Status Code&quot; later

in the chapter for more information.

<li><b>length</b>-length of requested document. In the example

line the byte is <tt>5593</tt>.

</ul>

<p>

Web servers can have many different types of log files. For example,

you might see a proxy access log, or an error log. In this chapter,

we'll focus on the access log-where the Web server tracks every

access to your Web site.

<h3><a NAME="ExampleReadingaLogFile">

Example: Reading a Log File</a></h3>

<p>

In this section you see a Perl script that can open a log file

and iterate over the lines of the log file. It is usually unwise

to read entire log files into memory because they can get quite

large. A friend of mine has a log file that is over 113 Megabytes!

<p>

Regardless of the way that you'd like to process the data, you

must open a log file and read it. You can read the entry into

one variable for processing, or you can split the entry into it's

components. To read each line into a single variable, use the

following code sample:

<blockquote>

<pre>$LOGFILE = &quot;access.log&quot;;

open(LOGFILE) or die(&quot;Could not open log file.&quot;);

foreach $line (&lt;LOGFILE&gt;) {

    chomp($line);              # remove the newline from $line.

    # do line-by-line processing.

}<br>

</pre>

</blockquote>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

If you don't have your own server logs, you can use the file <tt>server.log</tt> that is iNCluded on the CD-ROM that accompanies this book.

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

The code snippet will open the log file for reading and will access

the file one line at a time, loading the line into the <tt>$line</tt>

variable. This type of processing is pretty limiting because you

need to deal with the entire log entry at oNCe.

<p>

A more popular way to read the log file is to split the contents

of the entry into different variables. For example, Listing 21.1

uses the <tt>split()</tt> command

and some processing to value 11 variables:

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Turn on the </i><tt><i>warning</i></tt><i>

option.<br>

</i>Initialize <tt>$LOGFILE</tt> with

the full path and name of the access log.<br>

Open the log file.<br>

Iterate over the lines of the log file. Each line gets placed,

<br>

in turn, into <tt>$line</tt>.<br>

Split <tt>$line</tt> using the space

character as the delimiter.<br>

Get the time value from the <tt>$date</tt>

variable.<br>

Remove the date value from the <tt>$date</tt>

variable avoiding the time<br>

value and the '[' character.<br>

Remove the '&quot;' character from the beginning of the request

value.<br>

Remove the end square bracket from the <tt>gmt</tt>

offset value.<br>

Remove the end quote from the protocol value.<br>

Close the log file.

</blockquote>

<hr>

<p>

<b>Listing 21.1&nbsp;&nbsp;21LST01.PL-Read the Access Log and

Parse Each Entry<br>

</b>

<blockquote>

<pre>#!/usr/bin/perl -w



$LOGFILE = &quot;access.log&quot;;

open(LOGFILE) or die(&quot;Could not open log file.&quot;);

foreach $line (&lt;LOGFILE&gt;) {

    

    ($site, $logName, $fullName, $date, $gmt,

         $req, $file, $proto, $status, $length) = split(' ',$line);

    $time = substr($date, 13);

    $date = substr($date, 1, 11);

    $req  = substr($req, 1);

    chop($gmt);

    chop($proto);

    # do line-by-line processing.

}

close(LOGFILE);

</pre>

</blockquote>

<hr>

<p>

If you print out the variables, you might get a display like this:

<br>

<blockquote>

<pre>$site     = ros.algonet.se

$logName  = -

$fullName = -

$date     = 09/Aug/1996

$time     = 08:30:52

$gmt      = -0500

$req      = GET

$file     = /~jltiNChe/songs/rib_supp.gif

$proto    = HTTP/1.0

$status   = 200

$length   = 1543

</pre>

</blockquote>

<p>

You can see that after the split is done, further manipulation

is needed in order to &quot;clean up&quot; the values inside the

variable. At the very least, the square brackets and the double-quotes

needed to be removed.

<p>

I prefer to use a regular expression to extract the information

from the log file entries. I feel that this approach is more straightforward-assuming

that you are comfortable with regular expressions-than the others.

Listing 21.2 shows a program that uses a regular expression to

determine the 11 items in the log entries.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Turn on the </i><tt><i>warning</i></tt><i>

option.<br>

</i>Initialize <tt>$LOGFILE</tt> with

the full path and name of the access log.<br>

Open the log file.<br>

Iterate over the lines of the log file. Each line gets placed,in

turn, into <tt>$line</tt>.<br>

Define a temporary variable to hold a pattern that recognizesa

single item.<br>

Use the matching operator to store the 11 items into pattern memory.

<br>

Store the pattern memories into individual variables.<br>

Close the log file.

</blockquote>

<hr>

<p>

<b>Listing 21.2&nbsp;&nbsp;21LST02.PL-Using a Regular Expression

to Parse the Log File Entry<br>

</b>

<blockquote>

<pre>#!/usr/bin/perl -w



$LOGFILE = &quot;access.log&quot;;

open(LOGFILE) or die(&quot;Could not open log file.&quot;);

foreach $line (&lt;LOGFILE&gt;) {

    $w = &quot;(.+?)&quot;;

    $line =~ m/^$w $w $w \[$w:$w $w\] &quot;$w $w $w&quot; $w $w/;



    $site     = $1;

    $logName  = $2;

    $fullName = $3;

    $date     = $4;

    $time     = $5;

    $gmt      = $6;

    $req      = $7;

    $file     = $8;

    $proto    = $9;

    $status   = $10;

    $length   = $11;



    # do line-by-line processing.

}

close(LOGFILE);

</pre>

</blockquote>

<hr>

<p>

The main advantage to using regular expressions to extract information

is the ease with which you can adjust the pattern to account for

different log file formats. If you use a server that delimits

the date/time item with curly brackets, you only need to change

the line with the matching operator to accommodate the different

format.

<h3><a NAME="ExampleListingAccessbyDocument">

Example: Listing Access by Document</a></h3>

<p>

One easy and useful analysis that you can do is to find out how

many times each document at your site has been visited. Listing

21.3 contains a program that reports on the access counts of documents

beginning with the letter s.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

The <tt>parseLogEntry()</tt> fuNCtion uses <tt>$_</tt> as the pattern space. This eliminates the need to pass parameters but is generally considered bad programming practice. But this is a small program, so perhaps it's okay.

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Turn on the </i><tt><i>warning</i></tt><i>

option.<br>

</i>Define a format for the report's detail line.<br>

Define a format for the report's header line.<br>

Define the <tt>parseLogEntry()</tt>

fuNCtion.<br>

Declare a local variable to hold the pattern that matches a single

item.<br>

Use the matching operator to extract information into pattern

memory.<br>

Return a list that contains the 11 items extracted from the log

entry.<br>

Open the logfile.<br>

Iterate over each line of the logfile.<br>

Parse the entry to extract the 11 items but only keep the file

specification that was requested.<br>

Put the filename into pattern memory.<br>

Store the filename into <tt>$fileName</tt>.

<br>

Test to see if <tt>$fileName</tt>

is defined.<br>

INCrement the file specification's value in the <tt>%docList</tt>

hash.<br>

Close the log file.<br>

Iterate over the hash that holds the file specifications.<br>

Write out each hash entry in a report.

</blockquote>

<hr>

<p>

<b>Listing 21.3&nbsp;&nbsp;21LST03.PL-Creating a Report of the

Access Counts for Documents that Start with the Letter S<br>

</b>

<blockquote>

<pre>#!/usr/bin/perl -w



format =

  @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @&gt;&gt;&gt;&gt;&gt;&gt;&gt;

  $document,                              $count

.



format STDOUT_TOP =

  @||||||||||||||||||||||||||||||||||||  Pg @&lt;



  &quot;Access Counts for S* Documents&quot;,,        $%

  Document                                Access Count

  --------------------------------------- ------------

.



sub parseLogEntry {

    my($w) = &quot;(.+?)&quot;;

    m/^$w $w $w \[$w:$w $w\] &quot;$w $w $w&quot; $w $w/;

    return($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11);

}





$LOGFILE = &quot;access.log&quot;;

open(LOGFILE) or die(&quot;Could not open log file.&quot;);

foreach (&lt;LOGFILE&gt;) {

    $fileSpec = (parseLogEntry())[7];

    $fileSpec =~ m!.+/(.+)!;

    $fileName = $1;

    # some requests don't specify a filename, just a directory.

    if (defined($fileName)) {

        $docList{$fileSpec}++ if $fileName =~ m/^s/i;

    }

}

close(LOGFILE);



foreach $document (sort(keys(%docList))) {

    $count = $docList{$document};

    write;

}

</pre>

</blockquote>

<hr>

<p>

This program displays:<br>

<blockquote>

<pre>Access Counts for S* Documents      Pg 1



  Document                                Access Count

  -------------------------------------- ------------

  /~bamohr/scapenow.gif                          1

  /~jltiNChe/songs/song2.gif                     5

  /~mtmortoj/mortoja_html/song.html              1

  /~scmccubb/pics/shock.gif                      1

</pre>

</blockquote>

<p>

This program has a couple of points that deserve a comment or

two. First, notice that the program takes advantage of the fact

that Perl's variables default to a global scope. The main program

values <tt>$_</tt> with each log file

entry and <tt>parseLogEntry()</tt>

also directly accesses <tt>$_</tt>.

This is okay for a small program but for larger programs, you

need to use local variables. Second, notice that it takes two

steps to specify files that start with a letter. The filename

needs to be extracted from <tt>$fileSpec</tt>

and then the filename can be filtered inside the <tt>if</tt>

statement. If the file that was requested has no filename, the

server will probably default to <tt>index.html</tt>.

However, this program doesn't take this into account. It simply

ignores the log file entry if no file was explicitly requested.

<p>

You can use this same counting technique to display the most frequent

remote sites that contact your server. You can also check the

status code to see how many requests have been rejected. The next

section looks at status codes.

<h3><a NAME="ExampleLookingattheStatusCode">

Example: Looking at the Status Code</a></h3>

<p>

It is important for you to periodically check the server's log

file in order to determine if unauthorized people are trying to

access secured documents. This is done by checking the status

code in the log file entries.

<p>

Every status code is a three digit number. The first digit defines

how your server responded to the request. The last two digits

do not have any categorization role. There are five values for

the first digit:

<ul>

<li><b>1xx: </b>Informational-Not used, but reserved for future

use

<li><b>2xx</b>: Success-The action was successfully received,

understood, and accepted.

<li><b>3xx</b>: Redirection - Further action must be taken in

order to complete the request.

<li><b>4xx</b>: Client Error - The request contains bad syntax

or cannot be fulfilled.

<li><b>5xx</b>: Server Error - The server failed to fulfill an

apparently valid request.

</ul>

<p>

Table 21.1 contains a list of the most common status codes that

can appear in your log file. You can find a complete list on the

<b>http://www.w3.org/pub/WWW/Protocols/HTTP/1.0/spec.html</b>

Web page.<br>

<p>

<center><b>Table 21.1&nbsp;&nbsp;The Most Common Server Status

Codes</b></center>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td WIDTH="97"><center><i>Status</i></center></td><td WIDTH="234"><i>Description Code</i>

</td></tr>

<tr><td WIDTH="97"><center>200</center></td><td WIDTH="234">OK</td>

</tr>

<tr><td WIDTH="97"><center>204</center></td><td WIDTH="234">No content

</td></tr>

<tr><td WIDTH="97"><center>301</center></td><td WIDTH="234">Moved permanently

</td></tr>

<tr><td WIDTH="97"><center>302</center></td><td WIDTH="234">Moved temporarily

</td></tr>

<tr><td WIDTH="97"><center>400</center></td><td WIDTH="234">Bad Request

</td></tr>

<tr><td WIDTH="97"><center>401</center></td><td WIDTH="234">Unauthorized

</td></tr>

<tr><td WIDTH="97"><center>403</center></td><td WIDTH="234">Forbidden

</td></tr>

<tr><td WIDTH="97"><center>404</center></td><td WIDTH="234">Not found

</td></tr>

<tr><td WIDTH="97"><center>500</center></td><td WIDTH="234">Internal server error

</td></tr>

<tr><td WIDTH="97"><center>501</center></td><td WIDTH="234">Not implemented

</td></tr>

<tr><td WIDTH="97"><center>503</center></td><td WIDTH="234">Service unavailable

</td></tr>

</table>

</center>

<p>

<p>

Status code 401 is logged when a user attempts to access a secured

document and enters an iNCorrect password. By searching the log

file for this code, you can create a report of the failed attempts

to gain entry into your site. Listing 21.4 shows how the log file

could be searched for a specific error code-in this case, 401.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Turn on the warning option.<br>

Define a format for the report's detail line.<br>

Define a format for the report's header line.<br>

Define the </i><tt><i>parseLogEntry()</i></tt><i>

fuNCtion.<br>

Declare a local variable to hold the pattern that matches a single

item.<br>

Use the matching operator to extract information into pattern

memory.<br>

Return a list that contains the 11 items extracted from the log

entry.<br>

Open the logfile.<br>

Iterate over each line of the logfile.<br>

Parse the entry to extract the 11 items but only keep the site

information and the status code that was requested.<br>

If the status code is 401 then save the iNCrement the counter

for that site.<br>

Close the log file.<br>

Check the site name to see if it has any entries. If not, display

a message that says no unauthorized accesses took place.<br>

Iterate over the hash that holds the site names.<br>

Write out each hash entry in a report.</i>

</blockquote>

<hr>

<p>

<b>Listing 21.4&nbsp;&nbsp;21LST04.PL-Checking for Unauthorized

Access Attempts<br>

</b>

<blockquote>

<pre>#!/usr/bin/perl -w



format =

  @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @&gt;&gt;&gt;&gt;&gt;&gt;&gt;

  $site,                                  $count

.



format STDOUT_TOP =

  @||||||||||||||||||||||||||||||||||||  Pg @&lt;

  &quot;Unauthorized Access Report&quot;,             $%



  Remote Site Name                        Access Count

  --------------------------------------- ------------

.



sub parseLogEntry {

    my($w) = &quot;(.+?)&quot;;

    m/^$w $w $w \[$w:$w $w\] &quot;$w $w $w&quot; $w $w/;

    return($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11);

}





$LOGFILE = &quot;access.log&quot;;

open(LOGFILE) or die(&quot;Could not open log file.&quot;);

foreach (&lt;LOGFILE&gt;) {

    ($site, $status) = (parseLogEntry())[0, 9];



    if ($status eq '401') {

        $siteList{$site}++;

    }

}

close(LOGFILE);



@sortedSites = sort(keys(%siteList));



if (scalar(@sortedSites) == 0) {

    print(&quot;There were no unauthorized access attempts.\n&quot;);

}

else {

    foreach $site (@sortedSites) {

        $count = $siteList{$site};

        write;

    }

}

</pre>

</blockquote>

<p>

This program displays:

<blockquote>

<pre>       

Unauthorized Access Report        Pg 1



  Remote Site Name                        Access Count

  --------------------------------------- ------------

  ip48-max1-fitch.zipnet.net                     1

  kairos.algonet.se                              4

</pre>

</blockquote>

<p>

You can expand this program's usefulness by also displaying the

logName and fullName items from the log file.

<h3><a NAME="ExampleConvertingtheReporttoaWebPage">

Example: Converting the Report to a Web Page</a></h3>

<p>

Creating nice reports for your own use is all well and good. But

suppose your boss wants the statistics updated hourly and available

on demand? Printing the report and faxing to the head office is

probably a bad idea. One solution is to convert the report into

a Web page. Listing 21.5 contains a program that does just that.

The program will create a Web page that displays the access counts

for the documents that start with a 's.' Figure 21.1 shows the

Web page that displayed the access counts.

<p>

<a HREF="f21-1.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/f21-1.gif"><b>Figure 21.1 : </b><i>The Web page that displayed the Access

Counts</i>.</a>

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Turn on the warning option.<br>

<i>Define the </i></i><tt><i>parseLogEntry()</i></tt><i>

fuNCtion.<br>

Declare a local variable to hold the pattern that matches a single

item.<br>

Use the matching operator to extract information into pattern

memory.<br>

Return a list that contains the 11 items extracted from the log

entry.<br>

Initialize some variables to be used later. The file name of the

accesslog, the web page file name, and the email address of the

web page maintainer.<br>

Open the logfile.<br>

Iterate over each line of the logfile.<br>

Parse the entry to extract the 11 items but only keep the file

specification that was requested.<br>

Put the filename into pattern memory.<br>

Store the filename into </i><tt><i>$fileName</i></tt><i>.

<br>

Test to see if </i><tt><i>$fileName</i></tt><i>

is defined.<br>

INCrement the file specification's value in the </i><tt><i>%docList</i></tt><i>

hash.Close the log file.<br>

Open the output file that will become the web page.<br>

Output the HTML header.<br>

Start the body of the HTML page.<br>

Output current time.<br>

Start an unorder list so the subsequent table is indented.<br>

Start a HTML table.<br>

Output the heading for the two columns the table will use.<br>

Iterate over hash that holds the document list.<br>

Output a table row for each hash entry.<br>

End the HTML table.<br>

End the unordered list.<br>

Output a message about who to contact if questions arise.<br>

End the body of the page.<br>

End the HTML.<br>

Close the web page file.</i>

</blockquote>

<hr>

<p>

<b>Listing 21.5&nbsp;&nbsp;21LST05.PL-Creating a Web Page to View

Access Counts<br>

</b>

<blockquote>

<pre>#!/usr/bin/perl -w



sub parseLogEntry {

    my($w) = &quot;(.+?)&quot;;

    m/^$w $w $w \[$w:$w $w\] &quot;$w $w $w&quot; $w $w/;

    return($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11);

}



$LOGFILE  = &quot;access.log&quot;;

$webPage  = &quot;acescnt.htm&quot;;

$mailAddr = 'medined@planet.net';



open(LOGFILE) or die(&quot;Could not open log file.&quot;);

foreach (&lt;LOGFILE&gt;) {

    $fileSpec = (parseLogEntry())[7];

    $fileSpec =~ m!.+/(.+)!;

    $fileName = $1;

    # some requests don't specify a filename, just a directory.

    

if (defined($fileName)) {

        $docList{$fileSpec}++ if $fileName =~ m/^s/i;

    }

}

close(LOGFILE);



open(WEBPAGE, &quot;&gt;$webPage&quot;);

print WEBPAGE (&quot;&lt;HEAD&gt;&lt;TITLE&gt;Access Counts&lt;/TITLE&gt;&lt;/HEAD&gt;&quot;);

print WEBPAGE (&quot;&lt;BODY&gt;&quot;);

print WEBPAGE (&quot;&lt;H1&gt;&quot;, scalar(localtime), &quot;&lt;/H1&gt;&quot;);

print WEBPAGE (&quot;&lt;UL&gt;&quot;);

print WEBPAGE (&quot;&lt;TABLE BORDER=1 CELLPADDING=10&gt;&quot;);

print WEBPAGE (&quot;&lt;TR&gt;&lt;TH&gt;Document&lt;/TH&gt;&lt;TH&gt;Access&lt;BR&gt;Count&lt;/TH&gt;&lt;/TR&gt;&quot;);



foreach $document (sort(keys(%docList))) {

    $count = $docList{$document};

    print WEBPAGE (&quot;&lt;TR&gt;&quot;);

    print WEBPAGE (&quot;&lt;TD&gt;&lt;FONT SIZE=2&gt;&lt;TT&gt;$document&lt;/TT&gt;&lt;/FONT&gt;&lt;/TD&gt;&quot;);

    print WEBPAGE (&quot;&lt;TD ALIGN=right&gt;$count&lt;/TD&gt;&quot;);

    print WEBPAGE (&quot;&lt;/TR&gt;&quot;);

}



print WEBPAGE (&quot;&lt;/TABLE&gt;&lt;P&gt;&quot;);

print WEBPAGE (&quot;&lt;/UL&gt;&quot;);

print WEBPAGE (&quot;Have questions? Contact &lt;A HREF=\&quot;mailto:$mailAddr\ &quot;&gt;$mailAddr&lt;/A&gt;&quot;);

print WEBPAGE (&quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;);

close(WEBPAGE);

</pre>

</blockquote>



<hr>

<h3><a NAME="ExistingLogFileAnalyzingPrograms">

Existing Log File Analyzing Programs</a></h3>

<p>

Now that you've learned some of the basics of log file statistics,

you should check out a program called Statbot, which can be used

to automatically generate statistics and graphs. You can find

it at:

<blockquote>

<pre>http://www.xmission.com:80/~dtubbs/

</pre>

</blockquote>

<p>

Statbot is a WWW log analyzer, statistics generator, and database

program. It works by &quot;snooping&quot; on the logfiles generated

by most WWW servers and  creating a database that contains information

about the WWW server. This  database is then used to create a

statistics page and GIF charts that can be  &quot;linked to&quot;

by other WWW resources.

<p>

Because Statbot &quot;snoops&quot; on the server logfiles, it

does not require the use  of the server's cgi-bin capability.

It simply runs from the user's own directory, automatically updating

statistics. Statbot uses a text-based configuration file for setup,

so it is very easy to install and operate, even for  people with

no programming experieNCe. Most importantly, Statbot is fast.

ONCe it is up and running, updating the database and creating

the new  HTML page can take as little as 10 seconds. Because of

this, many Statbot users run Statbot oNCe every 5-10 minutes,

which provides them with the very latest statistical information

about their site.

<p>

Another fine log analysis program is AccessWatch, written by Dave

Maher. AccessWatch is a World Wide Web utility that provides a

comprehensive view of daily accesses for individual users. It

is equally capable of gathering statistics for an entire server.

It provides a regularly updated summary of WWW server hits and

accesses, and gives a graphical representation of available statistics.

It generates statistics for hourly server load, page demand, accesses

by domain, and accesses by host. AccessWatch parses the WWW server

log and searches for a common set of documents, usually specified

by a user's root directory, such as /~username/ or /users/username.

AccessWatch displays results in a graphical, compact format.

<p>

If you'd like to look at <i>all</i> of the available log file

analyzers, go to Yahoo's Log Analysis Tools page:

<blockquote>

<pre>http://www.yahoo.com/Computers_and_Internet/Internet/

    World_Wide_Web/HTTP/Servers/Log_Analysis_Tools/

</pre>

</blockquote>

<p>

This page lists all types of log file analyzers-from simple Perl

scripts to full-blown graphical applications.

<h3><a NAME="CreatingYourOwnCGILogFile">

Creating Your Own CGI Log File</a></h3>

<p>

It is generally a good idea to keep track of who executes your

CGI scripts. You've already been introduced to the environment

variables that are available within your CGI script. Using the

information provided by those environment variables, you can create

your own log file.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Turn on the warning option.<br>

<i>Define the </i></i><tt><i>writeCgiEntry()</i></tt><i>

fuNCtion.<br>

Initialize the log file name.<br>

Initialize the name of the current script.<br>

Create local versions of environment variables.<br>

Open the log file in append mode.<br>

Output the variables using ! as a field delimiter.<br>

Close the log file.<br>

Call the </i><tt><i>writeCgiEntry()</i></tt><i>

fuNCtion.<br>

Create a test HTML page.</i>

</blockquote>

<p>

Listing 21.6 shows how to create your own CGI log file based on

environment variables.

<hr>

<p>

<b>Listing 21.6&nbsp;&nbsp;21LST06.PL-Creating Your Own CGI Log

File Based on Environment Variables<br>

</b>

<blockquote>

<pre>#!/usr/bin/perl -w



sub writeCgiEntry {

    my($logFile) = &quot;cgi.log&quot;;

    my($script)  = __FILE__;

    my($name)    = $ENV{'REMOTE_HOST'};

    my($addr)    = $ENV{'REMOTE_ADDR'};

    my($browser) = $ENV{'HTTP_USER_AGENT'};

    my($time)    = time;



    open(LOGFILE,&quot;&gt;&gt;$logFile&quot;) or die(&quot;Can't open cgi log file.\n&quot;);

    print LOGFILE (&quot;$script!$name!$addr!$browser!$time\n&quot;);

    close(LOGFILE);

}



writeCgiEntry();



# do some CGI activity here.



print &quot;Content-type: text/html\n\n&quot;;

print &quot;&lt;HTML&gt;&quot;;

print &quot;&lt;TITLE&gt;CGI Test&lt;/TITLE&gt;&quot;;

print &quot;&lt;BODY&gt;&lt;H1&gt;Testing!&lt;/H1&gt;&lt;/BODY&gt;&quot;;

print &quot;&lt;/HTML&gt;&quot;;

</pre>

</blockquote>

<hr>

<p>

Every time this script is called, an entry will be made in the

CGI log file. If you place a call to the <tt>writeCgiEntry()</tt>

fuNCtion in all of your CGI scripts, after a while you will be

able perform some statistical analysis on who uses your CGI scripts.

<h2><a NAME="CommunicatingwithUsers"><font SIZE="5" COLOR="#FF0000">

Communicating with Users</font></a></h2>

<p>

So far we've been looking at examining the server log files in

this chapter. Perl is also very useful for creating the Web pages

that the user will view.

<h3><a NAME="ExampleGeneratingaWhatsNewPage">

Example: Generating a What's New Page</a></h3>

<p>

One of the most common features of a Web site is a What's New

page. This page typically lists all of the files modified in the

last week or month along with a short description of the document.

<p>

A What's New page is usually automatically generated using a scheduler

program, like <tt>cron</tt>. If you

try to generate the What's New page via a CGI script, your server

will quickly be overrun by the large number of disk accesses that

will be required and your users will be upset that a simple What's

New page takes so long to load.

<p>

Perl is an excellent tool for creating a What's New page. It has

good directory access fuNCtions and regular expressions that can

be used to search for titles or descriptions in HTML pages. Listing

21.7 contains a Perl program that will start at a specified base

directory and search for files that have been modified siNCe the

last time that the script was run. When the search is complete,

an HTML page is generated. You can have your home page point to

the automatically generated What's New page.

<p>

This program uses a small data file-called <tt>new.log</tt>-to

keep track of the last time that the program was run. Any files

that have changed siNCe that date are displayed on the HTML page.

<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

This program contains the first significant use of recursion in this book. Recursion happens when a fuNCtion calls itself and will be fully explained after the program listing.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Turn on the warning option.<br>

Turn on the strict pragma.<br>

Declare some variables.<br>

Call the </i><tt><i>checkFiles()</i></tt><i>

fuNCtion to find modified files.<br>

Call the </i><tt><i>setLastTime()</i></tt><i>

fuNCtion to update the log file.<br>

Call the </i><tt><i>createHTML()</i></tt><i>

fuNCtion to create the web page.<br>

<br>

Define the </i><tt><i>getLastTime()</i></tt><i>

fuNCtion.<br>

Declare local variables to hold the parameters.<br>

If the data file can't be opened, use the current time as the

default.<br>

Read in the time of the last running of the program.<br>

Close the data file.<br>

Return the time.<br>

Define the </i><tt><i>setLastTime()</i></tt><i>

fuNCtion.<br>

Declare local variables to hold the parameters.<br>

Open the data file for writing.<br>

Output </i><tt><i>$time</i></tt><i>

which is the current time this program is running.  <br>

Close the data file.<br>

Define the </i><tt><i>checkFiles()</i></tt><i>

fuNCtion.<br>

Declare local variables to hold the parameters.<br>

Declare more local variables.<br>

Create an array containing the files in the </i><tt><i>$path</i></tt><i>

directory.<br>

Iterate over the list of files.<br>

If current file is current dir or parent dir, move on to next

file.<br>

Create full filename by joining dir (</i><tt><i>$path</i></tt><i>)

with filename (</i><tt><i>$_</i></tt><i>).

<br>

If current file is a directory, then recurse and move to next

file.<br>

Get last modification time of current file.<br>

Provide a default value for the file's title.<br>

If the file has been changed siNCe the last running of this program,open

the file, look for a title HTML tag, and close the file.<br>

Create an anonymous array and assign it to a hash entry.<br>

Define the </i><tt><i>createHTML()</i></tt><i>

fuNCtion.<br>

Declare local variables to hold the parameters.<br>

Declare more local variables.<br>

Open the HTML file for output.<br>

Output the HTML header and title tags.<br>

Output an H1 header tag.<br>

If no files have changed, output a message.<br>

Otherwise output the HTML tags to begin a table.<br>

Iterate the list of modified files.<br>

Output info about modified file as an HTML table row.<br>

Output the HTML tags to end a table.<br>

Output the HTML tags to end the document.<br>

Close the HTML file.</i>

</blockquote>

<hr>

<p>

<b>Listing 21.7&nbsp;&nbsp;21LST07.PL-Generating a Primitive What's

New Page<br>

</b>

<blockquote>

<pre>#!/usr/bin/perl -w

use strict;



my($root)     = &quot;/website/root&quot;;          # root of server

my($newLog)   = &quot;new.log&quot;;                # file w/time of last run.

my($htmlFile) = &quot;$root/whatnew.htm&quot;;      # output file.

my($lastTime) = getLastTime($newLog);     # time of last run.

my(%modList);                             # hash of modified files.



checkFiles($root, $root, $lastTime, \%modList);

setLastTime($newLog, time());

createHTML($htmlFile, $lastTime, \%modList);



sub getLastTime {

    my($newLog) = shift;        # filename of log file.

    my($time)   = time();       # the current time is the default.



    if (open(NEWLOG, &quot;&lt;$newLog&quot;)) {

        chomp($time = &lt;NEWLOG&gt;);

        close(NEWLOG);

    }

    return($time);

}



sub setLastTime {

    my($newLog) = shift;        # filename of log file.

    my($time)   = shift;        # the time of this run.



    open(NEWLOG, &quot;&gt;$newLog&quot;) or die(&quot;Can't write What's New log file.&quot;);

    print NEWLOG (&quot;$time\n&quot;);

    close(NEWLOG);

}



sub checkFiles {

    my($base)    = shift;   # the root of the dir tree to search

    my($path)    = shift;   # the current dir as we recurse

    my($time)    = shift;   # the time of the last run of this script

    my($hashRef) = shift;   # the hash where modified files are listed.

    my($fullFilename);      # a combo of $path and the current filename.

    my(@files);             # holds a list of files in current dir.

    my($title);             # the HTML title of a modified doc.

    my($modTime);           # the modification time of a modfied doc.



    opendir(ROOT, $path);

    @files = readdir(ROOT);

    closedir(ROOT);



    foreach (@files) {

        next if /^\.|\.\.$/;



        

        $fullFilename    = &quot;$path/$_&quot;;



        if (-d $fullFilename) {

            checkFiles($base, $fullFilename, $time, $hashRef);

            next;

        }



        $modTime = (stat($fullFilename))[9]; # only need the mod time.

        $title   = 'Untitled';               # provide a default value



        if ($modTime &gt; $time) {

            open(FILE, $fullFilename);

                while (&lt;FILE&gt;) {

                    if (m!&lt;title&gt;(.+)&lt;/title&gt;!i) {

                        $title = $1;

                        last;

                    }

                }

            close(FILE);



            %{$hashRef}-&gt;{substr($fullFilename, length($base))} =

                [ $modTime, $title ];

        }

    }

}





sub createHTML {

    my($htmlFile)   = shift;

    my($lastTime)   = shift;

    my($hashRef)    = shift;

    my($htmlTitle)  = &quot;What's New SiNCe &quot; . scalar(localtime($lastTime)). &quot;!&quot;;

    my(@sortedList) = sort(keys(%{$hashRef}));



    open(HTML, &quot;&gt;$htmlFile&quot;);



    print HTML (&quot;&lt;TITLE&gt;$htmlTitle&lt;/TITLE&gt;\n&quot;);

    print HTML (&quot;&lt;HTML&gt;\n&quot;);

    print HTML (&quot;&lt;HEAD&gt;&lt;TITLE&gt;$htmlTitle&lt;/TITLE&gt;&lt;/HEAD&gt;\n&quot;);

    print HTML (&quot;&lt;BODY&gt;\n&quot;);

    print HTML (&quot;&lt;H1&gt;$htmlTitle&lt;/H1&gt;&lt;P&gt;\n&quot;);



    if (scalar(@sortedList) == 0) {

        print HTML (&quot;There are no new files.\n&quot;);

    }

    else {

        print HTML (&quot;&lt;TABLE BORDER=1 CELLPADDING=10&gt;\n&quot;);

        print HTML (&quot;&lt;TR&gt;\n&quot;);

        print HTML (&quot;  &lt;TH&gt;Filename&lt;/TH&gt;\n&quot;);

        print HTML (&quot;  &lt;TH&gt;Modification&lt;BR&gt;Date&lt;/TH&gt;\n&quot;);

        print HTML (&quot;  &lt;TH&gt;Title&lt;/TH&gt;\n&quot;);

        print HTML (&quot;&lt;/TR&gt;\n&quot;);

        foreach (sort(keys(%{$hashRef}))) {

            my($modTime, $title) = @{%{$hashRef}-&gt;{$_}};



            $modTime = scalar(localtime($modTime));

            print HTML (&quot;&lt;TR&gt;\n&quot;);

            print HTML (&quot;  &lt;TD&gt;&lt;FONT SIZE=2&gt;&lt;A HREF=\&quot;$_\&quot;&gt;$_&lt;/A&gt;&lt;/FONT&gt;&lt;/TD&gt;\n&quot;);

            print HTML (&quot;  &lt;TD&gt;&lt;FONT SIZE=2&gt;$modTime&lt;/FONT&gt;&lt;/TD&gt;\n&quot;);

            print HTML (&quot;  &lt;TD&gt;&lt;FONT SIZE=2&gt;$title&lt;/FONT&gt;&lt;/TD&gt;\n&quot;);

            print HTML (&quot;&lt;/TR&gt;\n&quot;);

        }

        print HTML (&quot;&lt;/TABLE&gt;\n&quot;);

    }



    print HTML (&quot;&lt;/BODY&gt;\n&quot;);

    print HTML (&quot;&lt;/HTML&gt;\n&quot;);

    close(HTML);

}

</pre>

</blockquote>

<hr>

<p>

The program from Listing 21.7 will generate an HTML file that

can be displayed in any browser capable of handling HTML tables.

Figure 21.2 shows how the page looks in Netscape Navigator.

<p>

<a HREF="f21-2.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/f21-2.gif"><b>Figure 21.2 : </b><i>A What's New page</i>.</a>

<p>

You might wonder why I end the HTML lines with newline characters

when newlines are ignored by Web browsers. The newline characters

will help you to edit the resulting HTML file with a standard

text editor if you need to make an emergeNCy change. For example,

a document might change status from <tt>visible</tt>

to <tt>for internal use only</tt>

and you'd like to remove it from the What's New page. It is much

easier to fire up a text editor and remove the refereNCe then

to rerun the What's New script.

<p>

I think the only tricky code in Listing 22.7 is where it creates

an anonymous array that is stored into the hash that holds the

changed files. Look at that line of code closely.

<blockquote>

<pre>%{$hashRef}-&gt;{substr($fullFilename, length($base))} = [ $modTime, $title 

</pre>

</blockquote>

<p>

The <tt>$hashRef</tt> variable holds

a refereNCe to <tt>%modList</tt> that

was passed from the main program. The key part of the key-value

pair for this hash is the relative path and file name. The value

part is an anonymous array that holds the modification time and

the document title.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Tip</b></td></tr>

<tr><td>

<blockquote>

An array was used to store the information about the modified file so that you can easily change the program to display additional information. You might also want to display the file size or perhaps some category information.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

Using the relative path in the key becomes important when the

HTML file is created. In order to create hypertext links to the

changed documents, the links need to have the document's directory

relative to the server's root directory. For example, my WebSite

server has a base directory of <tt>/website/root</tt>.

If a document changes in <tt>/website/root/apache</tt>,

then the hypertext link must use <tt>/apache</tt>

as the relative path in order for the user's Web browser to find

the file. To arrive at the relative path, the program simply takes

the full path and filename and removes the beginning of the string

value using the <tt>substr()</tt>

fuNCtion.

<p>

You might also want to know a bit about the recursive nature of

the <tt>checkFiles()</tt> fuNCtion.

This book really hasn't mentioned recursive fuNCtions in any detail

yet. So, I'll take this opportunity to explain them.

<p>

A <i>recursive fuNCtion</i> calls itself in order to get work

done. One classic example of recursiveness is the <tt>factorial()</tt>

fuNCtion from the math world. 3! (five factorial) is the same

as 1*2*3 or 6. The <tt>factorial()</tt>

fuNCtion looks like this:

<blockquote>

<pre>sub factorial {

    my($n) = shift;



    return(1) if $n == 1;

    return($n * factorial($n-1));

}

</pre>

</blockquote>

<p>

Now track the value of the return statements when factorial(3)

is called:

<ol>

<li><b>factorial(3)</b>-return(3 * factorial(2));

<li><b>factorial(2)</b>-return(2 * factorial(1));

<li><b>factorial(1)</b>-return(1);

<li><b>factorial(2)</b>-return(2 * 1);

<li><b>factorial(3)</b>-return(3 * 2);

<li>A value of 6 is returned.

</ol>

<p>

First, the fuNCtion repeated calls itself (recurses) until an

end condition is reached. When the end condition is reached ($n

== 1) then the stack of fuNCtion calls is followed backwards to

read the final value of 6.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Caution</b></td></tr>

<tr><td>

<blockquote>

It is very important for a recursive fuNCtion to have an end condition. If not, the fuNCtion recurses until your system runs out of memory.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

If you look back at the <tt>checkFiles()</tt>

fuNCtion, you see that the end condition is not explicitly stated.

When a directory has no subdirectories, the fuNCtion will stop

recursing. And instead of returning a value that is used in a

mathematical expression, a hash refereNCe is continually passed

where the information about changed files is stored.

<p>

While the topic is the information about the changed files, let

me mention the two directories that are used as parameters for

<tt>checkFiles()</tt>. The first directory

is the path to the Web server root-it will not change as the recursion

happens. The second directory is the directory that the fuNCtion

is currently looking at. It will change with each recursion.

<h3><a NAME="ExampleGettingUserFeedback">

Example: Getting User Feedback</a></h3>

<p>

One of the hallmarks of a professional Web site, at least in my

opinion, is that every page has a section that identifies the

organization that created the page and a way to provide feedback.

Most Web sites simply place a little hypertext link that contains

the Webmaster's e-mail address. However, this places a large burden

on the user to adequately describe the Web page so that the Webmaster

knows which one they are referring to. Wouldn't it be nice if

you could automate this? Picture this scenario: the user clicks

a button and a user feedback form appears that automatically knows

which page the user was on when the button was pressed. Perhaps

the feedback form looks like Figure 21.3.

<p>

<a HREF="f21-3.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/f21-3.gif"><b>Figure 21.3 : </b><i>A sample user feedback form</i>.</a>

<p>

You can have this nice feature at your site with a little work

by following these steps:

<ol>

<li>INClude a small HTML form at the end of every Web page at

your site. This footer contains the button that summons the feedback

form.

<li>Create a CGI Perl script that generates a feedback form on-the-fly.

This form will be customized to each Web page.

</ol>

<p>

In step one, you need to add a small HTML form to each Web page

at your site. This form does not have to be very complex; just

one button will do. You can get started by adding the following

form to the bottom of your home page just before the <tt>&lt;/BODY&gt;</tt>

tag.

<blockquote>

<pre>&lt;FORM METHOD=POST Action=&quot;cgi-bin/feedback.pl&quot;&gt;

  &lt;INPUT TYPE=hidden NAME=&quot;to&quot; VALUE=&quot;xxxxxxxxxxxxxxxxxx&quot;&gt;

  &lt;INPUT TYPE=hidden NAME=&quot;subject&quot; VALUE=&quot;Home Page&quot;&gt;

  &lt;CENTER&gt;

    &lt;INPUT TYPE=submit VALUE=&quot;Send a comment to the webmaster&quot;&gt;

  &lt;/CENTER&gt;

&lt;/FORM&gt;<br>

</pre>

</blockquote>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

You might need to change directory locations in the action clause to correspond to the requirements of your own server.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

The first field, <tt>to</tt>, is the

destination of the feedback information. Change the xs to your

personal e-mail address. The second field, <tt>subject</tt>,

is used to describe the Web page that the HTML form is contained

on. This is the only field that will change from Web page to Web

page. The last item in the form is a submit button. When this

button is clicked, the feedback.pl Perl script will be invoked.

<p>

This HTML form will place a submit button onto your home page

like the one shown in Figure 21.4.

<p>

<a HREF="f21-4.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/f21-4.gif"><b>Figure 21.4 : </b><i>The customized submit button</i>.</a><br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

In the course of researching the best way to create a customized feedback form, I  pulled information from a CGI script (<tt>mailer.cgi</tt>) by Matt Kruse (mkruse@saunix.sau.edu) and <font FACE="LI Helvetica Light Oblique">Serving the Web</font>, a book 
by Robert Jon Mudry.

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

Step Two requires you to create the feedback Perl script. Listing

21.8 contains a bare-bones script that will help you get started.

This script will generate the HTML that created the Web page in

Figure 21.3.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Turn on the warning option.<br>

Turn on the strict pragma.<br>

Declare a hash variable to hold the form's data.<br>

Call the </i><tt><i>getFormData()</i></tt><i>

fuNCtion.<br>

Output the web page's MIME type.<br>

Output the start of the web page.<br>

Output the feedback form.<br>

Output the end of the web page.<br>

Define the </i><tt><i>getFormData()</i></tt><i>

fuNCtion.<br>

Declare a local variable to hold hash refereNCe in parameter array.

<br>

Declare and initialize buffer to hold the unprocessed form data.

<br>

Declare some temporary variables.<br>

Read all of the form data into the </i><tt><i>$in</i></tt><i>

variable.<br>

Iterate over the elements that result from splitting the input

buffer using &amp; as the delimiter.<br>

Convert plus signs into spaces.<br>

Split each item using the = as a delimiter.<br>

Store the form data into the hash parameter.</i>

</blockquote>

<hr>

<p>

<b>Listing 21.8&nbsp;&nbsp;21LST08.PL-How to Generate an On-the-Fly

Feedback Form<br>

</b>

<blockquote>

<pre>#!/usr/bin/perl -w

use strict;



my(%formData);



getFormData(\%formData);



print &quot;Content-type: text/html\n\n&quot;;

print(&quot;&lt;HTML&gt;&quot;);

print(&quot;&lt;HEAD&gt;&lt;TITLE&gt;Web Page Comment Form&lt;/TITLE&gt;&lt;/HEAD&gt;\n&quot;);

print(&quot;&lt;BODY&gt;\n&quot;);

print(&quot;&lt;H1 ALIGN=CENTER&gt;Web Page Comment Form&lt;/H1&gt;\n&quot;);



print(&quot;&lt;FORM METHOD=\&quot;POST\&quot; Action=\&quot;mailto:$formData{'to'}\&quot;&gt;\n&quot;);

print(&quot;&lt;TABLE CELLPADDING=3&gt;&quot;);

print(&quot;&lt;TR&gt;&lt;TD&gt;To:&lt;/TD&gt;&lt;TD&gt;$formData{'to'}&lt;TD&gt;&lt;/TR&gt;\n&quot;);

print(&quot;&lt;TR&gt;&lt;TD&gt;Subject:&lt;/TD&gt;&lt;TD&gt;$formData{'subject'}&lt;/TD&gt;&lt;/TR&gt;\n&quot;);

print(&quot;&lt;TR&gt;&quot;);

print(&quot;&lt;TD&gt;&lt;B&gt;Your email address:&lt;/B&gt;&lt;/TD&gt;&quot;);

print(&quot;&lt;TD&gt;&lt;INPUT TYPE=\&quot;text\&quot; NAME=\&quot;addr\&quot; SIZE=40 MAXLENGTH=80&gt;&lt;/TD&gt;&quot;);

print(&quot;&lt;/TR&gt;\n&quot;);

print(&quot;&lt;TR&gt;&lt;TD VALIGN=top&gt;&lt;B&gt;How urgently do you need a reply:&lt;/B&gt;&lt;/TD&gt;\n&quot;);

print(&quot;&lt;TD&gt;&lt;INPUT TYPE=\&quot;radio\&quot; NAME=\&quot;urgeNCy\&quot; VALUE=\&quot;fyi\&quot; CHECKED&gt;

Just FYI\n&quot;);

print(&quot;&lt;INPUT TYPE=\&quot;radio\&quot; NAME=\&quot;urgeNCy\&quot; VALUE=\&quot;plr\&quot;&gt; Please

Reply\n&quot;);

print(&quot;&lt;INPUT TYPE=\&quot;radio\&quot; NAME=\&quot;urgeNCy\&quot; VALUE=\&quot;rur\&quot;&gt; Reply Urgently&lt;/TD&gt;&lt;TR&gt;\n&quot;);

print(&quot;&lt;TR&gt;&lt;TD VALIGN=top&gt;&lt;B&gt;What is the nature of your feedback:&lt;/B&gt;&lt;/TD&gt;\n&quot;);

print(&quot;&lt;TD&gt;&lt;SELECT NAME=\&quot;nature\&quot; SIZE=3 MULTIPLE&gt;\n&quot;);

print(&quot;&lt;OPTION SELECTED&gt;General Comments\n&quot;);

print(&quot;&lt;OPTION&gt; Found Typo\n&quot;);

print(&quot;&lt;OPTION&gt; Bug Report\n&quot;);

print(&quot;&lt;/SELECT&gt;&lt;/TD&gt;&lt;/TR&gt;\n&quot;);

print(&quot;&lt;TR&gt;&lt;TD VALIGN=top&gt;&lt;B&gt;Please enter your comments:&lt;/B&gt;&lt;/TD&gt;\n&quot;);

print(&quot;&lt;TD&gt;&lt;TEXTAREA NAME=\&quot;comment\&quot; COLS=50 ROWS=5&gt;&lt;/TEXTAREA&gt;&lt;/TD&gt;&lt;/TR&gt;\n&quot;);

print(&quot;&lt;/TABLE&gt;&lt;P&gt;&quot;);

print(&quot;&lt;CENTER&gt;&lt;INPUT TYPE=\&quot;submit\&quot; VALUE=\&quot;Mail Your Comments\&quot;&gt;&lt;/CENTER&gt;\n&quot;);

print(&quot;&lt;/FORM&gt;&quot;);

print(&quot;&lt;/BODY&gt;&quot;);

print(&quot;&lt;/HTML&gt;&quot;);



sub getFormData {

    my($hashRef) = shift;	# ref to hash to hold form data.

    my($in) = &quot;&quot;;             # buffer for unprocessed form data.

    my($key, $value);         # temporary variables.





read(STDIN, $in, $ENV{'CONTENT_LENGTH'});



    foreach (split(/&amp;/, $in)) {

        s/\+/ /g;

        ($key, $value) = split(/=/, $_);

        %{$hashRef}-&gt;{$key} = $value;

    }

}

</pre>

</blockquote>

</blockquote>

<hr>

<p>

This form will send all of the information from the feedback form

to your e-mail address. ONCe there you need to perform further

processing in order to make use of the information. You might

want to have the feedback submit button call a second CGI script

that stores the feedback information into a database. The database

will make it much easier for you to track the comments and see

which Web pages generate the most feedback.

<p>

The <tt>getFormData()</tt> fuNCtion

does not do a very good job of processing the form data. Chapter

20, &quot;Form Processing&quot; describes more robust methods

of processing the data. This fuNCtion was kept simple to conserve

space.

<h2><a NAME="Summary"><font SIZE="5" COLOR="#FF0000">

Summary</font></a></h2>

<p>

Perl is an excellent tool to use when maintaining a Web site.

There are many tasks that can be automated such as analysis of

server logs and automatically generating HTML pages.

<p>

Server log files are created and maintained by Web servers for

a variety of reasons. They are created to monitor such things

as HTTP requests, CGI activity, and errors. Most Web servers use

a common log file format so programs written to support one server

will usually work on another.

<p>

Each log file entry in the access log holds information about

a single HTTP request. There is information such s the remote

site name, the time and date of the request, what documents was

requested, and the server's response to the request.

<p>

After reading about the log file format, you saw an example that

showed how to read a log file. The sample program evolved from

simply opening the log file and reading whole lines to opening

the log file and using a regular expression to parse the log file

entries. Using regular expressions lets you modify your code quickly

if you move to another server that has a nonstandard log file

format.

<p>

The next sample program showed how to count the number of times

each document has been accessed. This program uses the reporting

features of Perl to print a formatted report showing the document

and the number of accesses. A hash was used to store the document

names and the number of accesses.

<p>

The status code field in the log file entries is useful. Especially,

when you need to find out if unauthorized users have been attempting

to access secured documents. Status codes are three digits numbers.

Codes in the 400-499 range indicate problems on the client side.

These are the numbers to watch if you think someone is trying

to attack your site. Table 21.1 lists the most common status codes.

<p>

The next topic covered is converting a program that uses a report

into a program that generates Web pages. Instead of using format

statements, HTML tables were used to format the information.

<p>

There is no need for you to create Perl scripts to do all of the

analyzing. Some programmers have already done this type of work

and many of them have made their programs available on the Web

for little or no cost. You can find a complete list of these analysis

programs at:

<blockquote>

<pre>http://www.yahoo.com/Computers_and_Internet/Internet/

    World_Wide_Web/HTTP/Servers/Log_Analysis_Tools/

</pre>

</blockquote>

<p>

At times creating your own log file is good to do. You might want

to track the types of Web browsers visiting your site. Or you

might want to track the remote site addresses. Listing 21.6 showed

how to create your own log file.

<p>

The next major topic was communicating with your users. Of course,

communication is done through a variety of Web pages. One very

popular feature is a What's New page. This page is typically changed

every week and lets the user see what has changed in the past

week. Listing 21.7 showed a sample program that generates the

HTML for a What's New page. The program uses a data file to remember

the last time that it was run.

<p>

Another popular feature is the user feedback form. With a little

forethought, you can have the feedback automatically generated

by a CGI script. Listing 21.8 shows how to generate a form when

the user clicks a feedback button. This simple program can be

expanded as needed to generate different forms based on which

Web page the user clicked feedback on. You need to create a second

CGI script to process the results of the feedback form.

<p>

The next chapter, &quot;Internet Resources,&quot; will direct

you to some resources that are available on the Internet. The

chapter covers Usenet Newsgroups, Web sites, and the IRC.

<h2>Review Questions</h2>

<p>

Answers to Review Questions are in Appendix A.

<ol>

<li>What is the access log used for?

<li>Does the <tt>fullName</tt> field

in the log file correspond to the user's mail address?

<li>Why is the status code of the log file entry important?

<li>Can you find log file analysis programs on the Internet?

<li>What good is a customized log file?

<li>What are two popular features of Web sites?

<li>What does recursion mean?

</ol>

<h2><a NAME="ReviewExercises"><font SIZE="5" COLOR="#FF0000">

Review Exercises</font></a></h2>

<ol>

<li>Open your access server log and count and display the total

number of HTTP requests.

<li>Modify the program from exercise 1 to display and average

the number of requests per day.

<li>Change Listing 21.3 so that HTTP requests that don't specify

a filename translate into specifying <tt>index.html</tt>

or the filename of that directory's default page..

<li>Change Listing 21.3 to sort by the access count instead of

the document name.

</ol>

<hr>



<center><p><a HREF="ch20.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch20.htm"><img SRC="pc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="#CONTENTS"><img SRC="cc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/cc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="index-1.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/index-1.htm"><img SRC="hb.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/hb.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="ch22.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch22.htm"><img SRC="nc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/nc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<hr WIDTH="100%"></p></center>

</body>

</html>

