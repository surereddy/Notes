<html>

<head>

<title>Chapter 20  -- Form Processing</title>



<meta>

</head>

<body TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">

<h1><font SIZE="6" COLOR="#FF0000">Chapter&nbsp;20</font></h1>

<h1><font SIZE="6" COLOR="#FF0000">Form Processing</font></h1>

<hr>

<p>

<center><b><font SIZE="5">CONTENTS</font></b></center>

<ul>

<li><a HREF="#ABriefOverviewofHTML">

A Brief Overview of HTML</a>

<li><a HREF="#ServerSideINCludes">

Server-Side INCludes</a>

<li><a HREF="#HTMLForms">

HTML Forms</a>

<li><a HREF="#HandlingFormInformation">

Handling Form Information</a>

<li><a HREF="#FillinginaFormandMailingtheInformation">

Filling in a Form and Mailing the Information</a>

<li><a HREF="#DebuggingFormProcessingCGIScripts">

Debugging Form Processing CGI Scripts</a>

<li><a HREF="#CreatingaGuestbookforYourSite">

Creating a Guestbook for Your Site</a>

<ul>

<li><a HREF="#TheBasicGuestbook">

The Basic Guestbook</a>

</ul>

<li><a HREF="#Summary">

Summary</a>

<li><a HREF="#ReviewQuestions">

Review Questions</a>

<li><a HREF="#ReviewExercises">

Review Exercises</a>

</ul>



<hr>

<p>

One of the most popular uses for CGI programs is to process information

from HTML forms. This chapter gives you an extremely brief overview

of HTML and Forms. Next you see how the form information is sent

to CGI programs. After being introduced to form processing, a

Guest book application is developed.

<h2><a NAME="ABriefOverviewofHTML"><font SIZE="5" COLOR="#FF0000">

A Brief Overview of HTML</font></a></h2>

<p>

HTML, or <i>Hypertext</i> <i>Markup</i> <i>Language</i>, is used

by web programmers to describe the contents of a web page. It

is not a programming language. You simply use HTML to indicate

what a certain chunk of text is-such as a paragraph, a heading

or specially formatted text. All HTML directives are specified

using matched sets of angle brackets and are usually called <i>tags</i>.

For example <tt>&lt;B&gt;</tt> means

that the following text should be displayed in <b>bold</b>. To

stop the bold text, use the <tt>&lt;/B&gt;</tt>

directive. Most HTML directives come in pairs and surround the

affected text.

<p>

HTML documents need to have certain tags in order for them to

be considered &quot;correct&quot;. The <tt>&lt;HEAD&gt;..&lt;/HEAD&gt;</tt>

set of tags surround the header information for each document.

Inside the header, you can specify a document title with the <tt>&lt;TITLE&gt;..&lt;/TITLE&gt;</tt>

tags.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Tip</b></td></tr>

<tr><td>

<blockquote>

HTML tags are case-insensitive. For example, <tt>&lt;TITLE&gt;</tt> is the same as <tt>&lt;title&gt;</tt>. However, using all upper case letters in the HTML tags make HTML documents easier to understand because you can pick out the tags more readily.

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

After the document header, you need to have a set of <tt>&lt;BODY&gt;..&lt;/BODY&gt;</tt>

tags. Inside the document's body, you specify text headings by

using a set of <tt>&lt;H1&gt;..&lt;/H1&gt;</tt>

tags. Changing the number after the H changes the heading level.

For example, <tt>&lt;H1&gt;</tt> is

the first level. <tt>&lt;H2&gt;</tt>

is the second level, and so on.

<p>

You can use the <tt>&lt;P&gt;</tt>

tag to indicate paragraph endings or use the <tt>&lt;BR&gt;</tt>

to indicate a line break. The <tt>&lt;B&gt;..&lt;/B&gt;</tt>

and <tt>&lt;I&gt;..&lt;/I&gt;</tt>

tags are used to indicate bold and italic text.

<p>

The text and tags of the entire HTML document must be surrounded

by a set of <tt>&lt;HTML&gt;..&lt;/HTML&gt;</tt>

tags. For example:

<blockquote>

<pre>

&lt;HTML&gt;

&lt;HEAD&gt;&lt;TITLE&gt;This is the Title&lt;/TITLE&gt;&lt;/HEAD&gt;

&lt;BODY&gt;

&lt;H1&gt;This is a level one header&lt;/H1&gt;

This is the first paragraph.

&lt;P&gt;This is the second paragraph and it has &lt;I&gt;italic&lt;/I&gt; text.

&lt;H2&gt;This is a level two header&lt;/H2&gt;

This is the third paragraph and it has &lt;B&gt;bold&lt;/B&gt; text.

&lt;/BODY&gt;

&lt;/HTML&gt;

</pre>

</blockquote>

<p>

Most of the time, you will be inserting or modifying text inside

the <tt>&lt;BODY&gt;..&lt;/BODY&gt;</tt>

tags.

<p>

That's enough about generic HTML. The next section discusses Server-Side

INCludes. Today, Server-Side INCludes are replacing some basic

CGI programs, so it is important to know about them.

<h2><a NAME="ServerSideINCludes"><font SIZE="5" COLOR="#FF0000">

Server-Side INCludes</font></a></h2>

<p>

One of the newest features that has been added to web servers

is that of Server-Side INCludes or SSI. SSI is a set of fuNCtions

built into web servers that give HTML developers the ability to

insert data into HTML documents using special directives. This

means that you can have dynamic documents without needing to create

full CGI programs.

<p>

The inserted information can take the form of a local file or

a file refereNCed by a URL. You can also iNClude information from

a limited set of variables-similar to environmental variables.

Finally, you can execute programs that can insert text into the

document.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

The only real differeNCe between CGI programs and SSI programs is that CGI programs must output an HTTP header as their first line of output. See &quot;HTTP Headers&quot; in <a HREF="ch19.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch19.htm">Chapter 19</a>, &quot;What Is CGI?,&quot; for more 
information.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

Most Web servers need the file extension to be changed from <tt>html</tt>

to <tt>shtml</tt> in order for the

server to know that it needs to look for Server-Side directives.

The file extension is dependent on server configuration, but shtml

is a common choice.

<p>

All SSI directives look like HTML comments within a document.

This way, the SSI directives will simply be ignored on Web servers

that do not support them.

<p>

Table 20.1 shows a partial list of SSI directives supported by

the <tt>webSite</tt> server from O'Reilly.

Not all Web servers will support all of the directives in the

table. You need to check the documentation of your web server

to determine what directives it will support.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

Table 20.1 shows complete examples of SSI directives. You need to modify the examples so that they work for your Web site.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

<center><b>Table 20.1&nbsp;&nbsp;A Partial List of SSI Directives</b></center>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td WIDTH="283"><i>Directive</i></td><td WIDTH="307"><i>Description</i>

</td></tr>

<tr><td WIDTH="283"><tt>&lt;!--#config timefmt=&quot;%c&quot;--&gt;</tt>

</td><td WIDTH="307">Changes the format used to display dates.</td>

</tr>

<tr><td WIDTH="283"><tt>&lt;!--#config sizefmt=&quot;%d bytes&quot;--&gt;</tt>

</td><td WIDTH="307">Changes the format used to display file sizes. You may also be able to specify <tt>bytes</tt> (to display file sizes with commas) or <tt>abbrev</tt> (to display the file sizes in kilobytes or megabytes).

</td></tr>

<tr><td WIDTH="283"><tt>&lt;!--#config errmsg=&quot;##ERROR!##&quot;--&gt;</tt>

</td><td WIDTH="307">Changes the format used to display error messages caused by wayward SSI directives. Error messages are also sent to the server's error log.

</td></tr>

<tr><td WIDTH="283"><tt>&lt;!--#echo var=?--&gt;</tt>

</td><td WIDTH="307">Displays the value of the variable specified by ?. Several of the possible variables are mentioned in this table.

</td></tr>

<tr><td WIDTH="283"><tt>&lt;!--#echo var=&quot;DOCUMENT_NAME&quot;--&gt;</tt>

</td><td WIDTH="307">Displays the full path and filename of the current document.

</td></tr>

<tr><td WIDTH="283"><tt>&lt;!--#echo var=&quot;DOCUMENT_URI&quot;--&gt;</tt>

</td><td WIDTH="307">Displays the virtual path and filename of the current document.

</td></tr>

<tr><td WIDTH="283"><tt>&lt;!--#echo var=&quot;LAST_MODIFIED&quot;--&gt;</tt>

</td><td WIDTH="307">Displays the last time the file was modified. It will use this format for display: <tt>05/31/96 16:45:40</tt>.

</td></tr>

<tr><td WIDTH="283"><tt>&lt;!--#echo var=&quot;DATE_LOCAL&quot;--&gt;</tt>

</td><td WIDTH="307">Displays the date and time using the local time zone.

</td></tr>

<tr><td WIDTH="283"><tt>&lt;!--#echo var=&quot;DATE_GMT&quot;--&gt;</tt>

</td><td WIDTH="307">Displays the date and time using GMT.</td>

</tr>

<tr><td WIDTH="283"><tt>&lt;!--#exec cgi=&quot;/cgi-bin/ssi.exe&quot;--&gt;</tt>

</td><td WIDTH="307">Executes a specified CGI program. It must be activated to be used. You can also use a <tt>cmd=</tt> option to execute shell commands.

</td></tr>

<tr><td WIDTH="283"><tt>&lt;!--#flastmod virtual=&quot;/docs/demo/ssi.txt&quot;--&gt;</tt>

</td><td WIDTH="307">Displays the last modification date of the specified file given a virtual path.

</td></tr>

<tr><td WIDTH="283"><tt>&lt;!--#flastmod file=&quot;ssi.txt&quot;--&gt;</tt>

</td><td WIDTH="307">Displays the last modification date of the specified file given a relative path.

</td></tr>

<tr><td WIDTH="283"><tt>&lt;!--#fsize virtual=&quot;/docs/demo/ssi.txt&quot;--&gt;</tt>

</td><td WIDTH="307">Displays the size of the specified file given a virtual path.

</td></tr>

<tr><td WIDTH="283"><tt>&lt;!--#fsize file=&quot;ssi.txt&quot;--&gt;</tt>

</td><td WIDTH="307">Displays the size of the specified file given a relative path.

</td></tr>

<tr><td WIDTH="283"><tt>&lt;!--#iNClude virtual=&quot;/docs/demo/ssi.txt&quot;--&gt;</tt>

</td><td WIDTH="307">Displays a file given a virtual path.</td>

</tr>

<tr><td WIDTH="283"><tt>&lt;!--#iNClude file=&quot;ssi.txt&quot;--&gt;</tt>

</td><td WIDTH="307">Displays a file given a relative path. The relative path can't start with the <tt>../</tt> character sequeNCe or the <tt>/</tt> character to avoid security risks.

</td></tr>

</table>

</center>

<p>

<p>

SSI provides a fairly rich set of features to the programmer.

You might use SSI if you had an existing set of documents to which

you wanted to add modification dates. You might also have a file

you want to iNClude in a number of your pages-perhaps to act as

a header or footer. You could just use the SSI iNClude command

on each of those pages, instead of copying the document into each

page manually. When available, Server-Side INCludes provide a

good way to make simple pages more interesting.

<p>

Before Server-Side INCludes were available, a CGI program was

needed in order to automatically generate the last modification

date text or to add a generic footer to all pages.

<p>

Your particular web server might have additional directives that

you can use. Check the documentation that came with it for more

information.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Tip</b></td></tr>

<tr><td>

<blockquote>

If you'd like more information about Server-Side INCludes, check out the following Web site:</blockquote>

<blockquote>

<tt>http://www.sigma.net/tdunn/</tt>

</blockquote>

<blockquote>

Tim Dunn has created a nice site that documents some of the more technical aspects of Web sites.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Caution</b></td></tr>

<tr><td>

<blockquote>

I would be remiss if I didn't mention the down side of Server-Side INCludes. They are very processor intensive. If you don't have a high-powered computer running your web server and you expect to have a lot of traffic, you might want to limit the number 
of documents that use Server-Side INCludes.</blockquote>



</td></tr>

</table>

</center>

<p>

<h2><a NAME="HTMLForms"><font SIZE="5" COLOR="#FF0000">

HTML Forms</font></a></h2>

<p>

HTML forms are designed to let a web page designer interact with

users by letting them fill out a form. The form can be composed

of elements such as input boxes, buttons, checkboxes, radio buttons,

and selection lists. All of the form elements are specified using

HTML tags surrounded by a set of <tt>&lt;FORM&gt;..&lt;/FORM&gt;</tt>

tags. You can have more than one form per HTML document.

<p>

There are several modifiers or options used with the <tt>&lt;FORM&gt;</tt>

tag. The two most important are <tt>METHOD</tt>

and <tt>ACTION</tt>:

<ul>

<li><b>METHOD</b>-Specifies the manner in which form information

is passed to the CGI scripts. The normal values are either <tt>GET</tt>

or <tt>POST</tt>. See &quot;Handling

Form Information&quot; later in this chapter.

<li><b>ACTION</b>-Specifies the URL of the CGI script that will

be invoked when the submit button is clicked. You could also specify

an email address by using the mailto: notation. For example, sending

mail would be accomplished by <tt>ACTION=&quot;mailto:medined@planet.net&quot;</tt>

and invoking a CGI script would be accomplished by <tt>ACTION=&quot;/cgi-bin/feedback.pl&quot;.</tt>

</ul>

<p>

Most field elements are defined using the <tt>&lt;INPUT&gt;</tt>

tag. Like the <tt>&lt;FORM&gt;</tt>

tag, <tt>&lt;INPUT&gt;</tt> has several

modifiers. The most important are:

<ul>

<li><b>CHECKED</b>-Specifies that the checkbox or radio button

being defined is selected. This modifier should only be used when

the element type is <tt>checkbox</tt>

or <tt>radio</tt>.

<li><b>NAME</b>-Specifies the name of a form element. Most form

elements need to have unique names. You'll see in the &quot;Handling

Form Information&quot; section later in this chapter that your

CGI script will use the element names to access form information.

<li><b>MAXLENGTH</b>-Specifies the maximum number of characters

that the user can enter into a form element. If <tt>MAXLENGTH</tt>

is larger than <tt>SIZE</tt>, the

user will be able to scroll to access text that is not visible.

<li><b>TYPE</b>-Specifies the type of input field. The most important

field types are <tt>checkbox</tt>,

<tt>hidden</tt>, <tt>password</tt>,

<tt>radio</tt>, <tt>reset</tt>,

<tt>submit</tt>, and <tt>text</tt>.

<li><b>SIZE</b>-Specifies the size of an input field.

<li><b>VALUE</b>-Specifies the default value for a field. The

<tt>VALUE</tt> modifier is required

for radio buttons.

</ul>

<p>

Let's look at how to specify a plain text field:

<blockquote>

<pre>

&lt;INPUT TYPE=text NAME=lastName VALUE=WasWaldo SIZE=25 MAXLENGTH=50&gt;

</pre>

</blockquote>

<p>

This HTML line specifies an input field with a default value of

<tt>WasWaldo</tt>. The input box will

be 25 characters long although the user can enter up to 50 characters.

<p>

At times, you may want the user to be able to enter text without

that text being readable. For example, passwords need to be protected

so that people passing behind the user can't secretly steal them.

In order to create a protected field, use the <tt>password</tt>

type.

<blockquote>

<pre>

&lt;INPUT TYPE=password NAME=password SIZE=10&gt;

<br>



</pre>

</blockquote>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Caution</b></td></tr>

<tr><td>

<blockquote>

The <tt>password</tt> input option still sends the text through the Internet without any eNCryption. In other words, the data is still sent as clear text. The sole fuNCtion of the <tt>password</tt> input option is to ensure that the password is not 
visible on the screen at the time of entry.

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

The <tt>&lt;INPUT&gt;</tt> tag is

also used to define two possible buttons-the submit and reset

buttons. The submit button sends the form data to a specified

URL-in other words to a CGI program. The reset button restores

the input fields on the forms to their default states. Any information

that the user had entered is lost. Frequently, the <tt>VALUE</tt>

modifier is used to change the text that appears on the buttons.

For example:

<blockquote>

<pre>

&lt;INPUT TYPE=submit VALUE=&quot;Process Information&quot;&gt;

</pre>

</blockquote>

<p>

Hidden fields are frequently used as sneaky ways to pass information

into a CGI program. Even though the fields are hidden, the field

name and value are still sent to the CGI program when the submit

button is clicked. For example, if your script generated an email

form, you might iNClude a list of email addresses that will be

carbon-copied when the message is sent. SiNCe the form user doesn't

need to see the list, the field can be hidden. When the submit

button is clicked, the hidden fields are still sent to the CGI

program along with the rest of the form information.

<p>

The last two input types are checkboxes and radio buttons. Checkboxes

let the user indicate either of two responses. Either the box

on the form is checked or it is not. The meaning behind the checkbox

depends entirely on the text that you place adjacent to it. Checkboxes

are used when users can check off as many items as they'd like.

For example:

<blockquote>

<pre>

&lt;INPUT TYPE=checkbox NAME=orange CHECKED&gt;Do you like the color Orange?

&lt;INPUT TYPE=checkbox NAME=blue   CHECKED&gt;Do you like the color Blue?

</pre>

</blockquote>

<p>

Radio buttons force the user to select only one of a list of options.

Using radio buttons for a large number of items (say, over five)

is not recommended because they take up too much room on a web

page. The <tt>&lt;SELECT&gt;</tt>

tag should be used instead. Each grouping of radio buttons must

have the same name but different values. For example,

<blockquote>

<pre>

Operating System:&lt;BR&gt;

&lt;INPUT TYPE=radio NAME=os VALUE=Win95&gt;Windows 95

&lt;INPUT TYPE=radio NAME=os VALUE=WinNT&gt;Windows NT

&lt;INPUT TYPE=radio NAME=os VALUE=UNIX CHECKED&gt;UNIX

&lt;INPUT TYPE=radio NAME=os VALUE=OS2&gt;OS/2

CPU Type:&lt;BR&gt;

&lt;INPUT TYPE=radio NAME=cpu VALUE=Pentium&gt;Intel Pentium

&lt;INPUT TYPE=radio NAME=cpu VALUE=Alpha CHECKED&gt;DEC Alpha

&lt;INPUT TYPE=radio NAME=cpu VALUE=Unknown&gt;Unknown

</pre>

</blockquote>

<p>

You should always provide a default value for radio buttons because

it is assumed that one of them must be selected. Quite ofen, it

is appropriate to provide a &quot;none&quot; or &quot;unknown&quot;

radio button (like the &quot;CPU Type&quot; in the above example)

so that the user won't be forced to pick an item at random.

<p>

Another useful form element is the drop-down list input field

specified by the <tt>&lt;SELECT&gt;..&lt;/SELECT&gt;</tt>

set of tags. This form element provides a compact way to let the

user choose one item from a list. The options are placed inside

the <tt>&lt;SELECT&gt;..&lt;/SELECT&gt;</tt>

tags. For example,

<blockquote>

<pre>

&lt;SELECT NAME=weekday&gt;

&lt;OPTION SELECTED&gt;Monday

&lt;OPTION&gt;Tuesday

&lt;OPTION&gt;Wednesday

&lt;OPTION&gt;Thursday

&lt;OPTION&gt;Friday

&lt;/SELECT&gt;

</pre>

</blockquote>

<p>

You can use the <tt>SELECTED</tt>

modifier to make one of the options the default. Drop-down lists

are very useful when you have three or more options to choose

from. If you have less, consider using radio buttons. The <tt>&lt;SELECT&gt;</tt>

tag has additional options that provide you with much flexibility.

You can read about these advaNCed options at:

<blockquote>

<pre>

http://robot0.ge.uiuc.edu/~carlosp/cs317/ft.4-5f.html

</pre>

</blockquote>

<p>

The last form element that I should mention is the text box. You

can create a multi-line input field or text box using the <tt>&lt;TEXTAREA&gt;..&lt;/TEXTAREA&gt;</tt>

set of tags. The <tt>&lt;TEXTAREA&gt;</tt>

tag requires both a <tt>ROWS</tt>

and a <tt>COLS</tt> modifer. You can

place any default text for the text box inside the <tt>&lt;TEXTAREA&gt;..&lt;/TEXTAREA&gt;</tt>

tags.

<blockquote>

<pre>

&lt;TEXTAREA NAME=comments ROWS=3 COLS=60&gt;&lt;/TEXTAREA&gt;

</pre>

</blockquote>

<p>

The user's Web browser will automatically provide scroll bars

as needed. However, the text box will probably not word-wrap.

In order to move to the next line, the user must press the enter

key.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

If you'd like a more advaNCed introduction to HTML forms, try this web site:</blockquote>

<blockquote>

<tt>http://robot0.ge.uiuc.edu/~carlosp/cs317/ft.1.html</tt>

</blockquote>



</td></tr>

</table>

</center>

<p>

<h2><a NAME="HandlingFormInformation"><font SIZE="5" COLOR="#FF0000">

Handling Form Information</font></a></h2>

<p>

There are two ways for your form to receive form information-the

<tt>GET</tt> method and the <tt>POST</tt>

method. The transfer mechanism is specified in the <tt>&lt;FORM&gt;</tt>

tag using the <tt>METHOD</tt> modifier.

For example, the following HTML line tells the client web browser

to send the form information back to the server using the <tt>GET</tt>

method.

<blockquote>

<pre>

&lt;FORM METHOD=get ACTION=/cgi-bin/gestbook.pl&gt;

</pre>

</blockquote>

<p>

The <tt>GET</tt> method appends all

of the form data to the end of the URL used to invoke the CGI

script. A question mark is used to separate the original URL (specified

by the <tt>ACTION</tt> modifier in

the <tt>&lt;FORM&gt;</tt> tag) and

the form information. The server software then puts this information

into the <tt>QUERY_STRING</tt> environment

variable for use in the CGI script that will process the form.

<p>

The <tt>GET</tt> method can't be used

for larger forms because some web servers limit the length of

the URL portion of a request. (Check the documentation on your

particular server.) This means that larger forms might blow up

if submitted using the <tt>GET</tt>

method. For larger forms, the <tt>POST</tt>

method is the answer.

<p>

The <tt>POST</tt> method sends all

of the form information to the CGI program using the <tt>STDIN</tt>

filehandle. The web server will set the <tt>CONTENT_LENGTH</tt>

environment variable to indicate how much data the CGI program

needs to read.

<p>

The rest of this section develops a fuNCtion capable of reading

both types of form information. The goal of the fuNCtion is to

create a hash that has one entry for each input field on the form.

<p>

The first step is simply to read the form information. The method

used to send the information is stored in the <tt>REQUEST_METHOD</tt>

environment variable. Therefore, we can examine it to tell if

the fuNCtion needs to look at the <tt>QUERY_STRING</tt>

environment variable or the <tt>STDIN</tt>

filehandle. Listing 20.1 contains a fuNCtion called <tt>getFormData()</tt>

that places the form information in a variable called <tt>$buffer</tt>

regardless of the method used to transmit the information.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Define the </i><tt><i>getFormData()</i></tt><i>

fuNCtion.<br>

Initialize a buffer.<br>

If the </i><tt><i>GET</i></tt><i>

method is used, copy the form information into the buffer.<br>

If the </i><tt><i>POST</i></tt><i>

method is used, read the form information into the buffer.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 20.1&nbsp;&nbsp;20LST01.PL-The First Step Is to Get

the Form Information<br>

</b>

</blockquote>

<blockquote>

<pre>

sub getFormData {

    my($buffer) = &quot;&quot;;



    if ($ENV{'REQUEST_METHOD'} eq 'GET') {

        $buffer = $ENV{'QUERY_STRING'};

    }

    else {

        read(STDIN, $buffer, $ENV{'CONTENT_LENGTH'});

    }

}

</pre>

</blockquote>

<hr>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Tip</b></td></tr>

<tr><td>

<blockquote>

SiNCe a single fuNCtion can handle both the <tt>GET</tt> and <tt>POST</tt> methods, you really don't have to worry about which one to use. However, because of the limitation regarding URL length, I suggest that you stick with the <tt>POST</tt> method.

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

I'm sure that you find this fuNCtion pretty simple. But you might

be wondering what information is contained in the <tt>$buffer</tt>

variable.

<p>

Form information is passed to a CGI program in <tt>name=value</tt>

format and each input field is delimited by an ampersand (<tt>&amp;</tt>).

For example, if you have a form with two fields-one called <tt>name</tt>

and one called <tt>age</tt>-the form

information would look like this:

<blockquote>

<pre>

name=Rolf+D%27Barno&amp;age=34

</pre>

</blockquote>

<p>

Can you see the two input fields? First, split up the information

using the <tt>&amp;</tt> as the delimiter:

<blockquote>

<pre>

name=Rolf+D%27Barno

age=34

</pre>

</blockquote>

<p>

Next, split up the two input fields based on the <tt>=</tt>

character:

<blockquote>

<pre>

Field Name: name    Field Value: Rolf+D%27Barno

Field Name: age     Field Value: 34

</pre>

</blockquote>

<p>

Remember the section on URL eNCoding from <a HREF="ch19.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch19.htm">Chapter 19</a>? You see

it in action in the name field. The name is really <tt>Rolf

D'Barno</tt>. However, with URL eNCoding spaces are converted

to plus signs and some characters are converted to their hexadecimal

ASCII equivalents. If you think about how a single quote might

be mistaken for the beginning of an HTML value, you can understand

why the ASCII equivalent is used.

<p>

Let's add some features to the <tt>getFormData()</tt>

fuNCtion to split up the input fields and store them in a hash

variable. Listing 20.2 shows the new version of the <tt>getFormData()</tt>

fuNCtion.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Declare a hash variable to hold the form's input fields.<br>

Call the </i><tt><i>getFormData()</i></tt><i>

fuNCtion.<br>

Define the </i><tt><i>getFormData()</i></tt><i>

fuNCtion.<br>

Declare a local variable to hold the refereNCe to the input field

hash.<br>

Initialize a buffer.<br>

If the </i><tt><i>GET</i></tt><i>

method is used, copy the form information into the buffer.<br>

If the </i><tt><i>POST</i></tt><i>

method is used, read the form information into the buffer.<br>

Iterate over the array returned by the </i><tt><i>split()</i></tt><i>

fuNCtion.<br>

Decode both the input field name and value.<br>

Create an entry in the input field hash variable.<br>

Define the </i><tt><i>decodeURL()</i></tt><i>

fuNCtion.<br>

Get the eNCoded string from the parameter array.<br>

Translate all plus signs into spaces.<br>

Convert character coded as hexadecimal digits into regular characters.

<br>

Return the decoded string.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 20.2&nbsp;&nbsp;20LST02.PL-The First Step Is to Get

the Form Information<br>

</b>

</blockquote>

<blockquote>

<pre>

my(%frmFlds);



getFormData(\%frmFlds);



sub getFormData {

    my($hashRef) = shift;

    my($buffer) = &quot;&quot;;



    if ($ENV{'REQUEST_METHOD'} eq 'GET') {

        $buffer = $ENV{'QUERY_STRING'};

    }

    else {

        read(STDIN, $buffer, $ENV{'CONTENT_LENGTH'});

    }



    foreach (split(/&amp;/, $buffer)) {

        my($key, $value) = split(/=/, $_);

        $key   = decodeURL($key);

        $value = decodeURL($value);

        %{$hashRef}-&gt;{$key} = $value;

    }

}



sub decodeURL {

    $_ = shift;

    tr/+/ /;

    s/%(..)/pack('c', hex($1))/eg;

    return($_);

}

</pre>

</blockquote>

<hr>

<p>

The <tt>getFormData()</tt> fuNCtion

could be considered complete at this point. It correctly reads

from both the <tt>GET</tt> and <tt>POST</tt>

transmission methods, decodes the information, and places the

input fields into a hash variable for easy access.

<p>

There are some additional considerations of which you need to

be aware. If you simply display the information that a user entered,

there are some risks involved that you may not be aware of. Let's

take a simple example. What if the user enters <tt>&lt;B&gt;Rolf&lt;/B&gt;</tt>

in the <tt>name</tt> field and you

subsequently displayed that field's value? Yep, you guessed it,

<tt>Rolf</tt> would be displayed in

bold! For simple formatting HTML tags this is not a problem, and

may even be a feature. However, if the user entered an SSI tag,

he or she may be able to take advantage of a security hole-remember

the <tt>&lt;!--#exec --&gt;</tt> tag?

<p>

You can thwart would-be hackers by converting every instaNCe of

<tt>&lt;</tt> to <tt>&amp;lt;</tt>

and of <tt>&gt;</tt> to <tt>&amp;gt;</tt>.

The HTML standard allows for certain characters to be displayed

using symbolic codes. This allows you to display a <tt>&lt;</tt>

character without the web browser thinking that a new HTML tag

is starting.

<p>

If you'd like to give users the ability to retain the character

formatting HTML tags, you can test for each tag that you want

to allow. When an allowed tag is found, reconvert it back to using

normal <tt>&lt;</tt> and <tt>&gt;</tt>

tags.

<p>

You might want to check for users entering a series of <tt>&lt;P&gt;</tt>

tags in the hopes of generating pages and pages of blank lines.

Also, you might want to convert pressing the enter key into spaces

so that the line endings that the user entered are ignored and

the text will wrap normally when displayed by a web browser. One

small refinement of eliminating the line endings could be to convert

two consecutive newlines into a paragraph (<tt>&lt;P&gt;</tt>)

tag.

<p>

When you put all of these new features together, you wind up with

a <tt>getFormData()</tt> fuNCtion

that looks like Listing 20.3.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Declare a hash variable to hold the form's input fields.<br>

Call the </i><tt><i>getFormData()</i></tt><i>

fuNCtion.<br>

Define the </i><tt><i>getFormData()</i></tt><i>

fuNCtion.<br>

Declare a local variable to hold the refereNCe to the input field

hash.<br>

Initialize a buffer.<br>

If the </i><tt><i>GET</i></tt><i>

method is used, copy the form information into the buffer.<br>

If the </i><tt><i>POST</i></tt><i>

method is used, read the form information into the buffer.<br>

Iterate over the array returned by the </i><tt><i>split()</i></tt><i>

fuNCtion.<br>

Decode both the input field name and value.<br>

Compress multiple </i><tt><i>&lt;P&gt;</i></tt><i>

tags into one.<br>

Convert </i><tt><i>&lt;</i></tt><i>

into </i><tt><i>&amp;lt;</i></tt><i>

and </i><tt><i>&gt;</i></tt><i> into

</i><tt><i>&amp;gt;</i></tt><i> stopping

HTML tags from interpretation.<br>

Turn back on the bold and italic HTML tags.<br>

Remove unneded carriage returns.<br>

Convert two newlines into a HTML paragraph tag.<br>

Convert single newlines into spaces.<br>

Create an entry in the input field hash variable.<br>

Define the </i><tt><i>decodeURL()</i></tt><i>

fuNCtion.<br>

Get the eNCoded string from the parameter array.<br>

Translate all plus signs into spaces.<br>

Convert character coded as hexadecimal digits into regular characters.

<br>

Return the decoded string.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 20.3&nbsp;&nbsp;20LST03.PL-The First Step Is to Get

the Form Information<br>

</b>

</blockquote>

<blockquote>

<pre>

my(%frmFlds);



getFormData(\%frmFlds);



sub getFormData {

    my($hashRef) = shift;

 my($buffer) = &quot;&quot;;



    if ($ENV{'REQUEST_METHOD'} eq 'GET') {

        $buffer = $ENV{'QUERY_STRING'};

    }

    else {

        read(STDIN, $buffer, $ENV{'CONTENT_LENGTH'});

    }



    foreach (split(/&amp;/, $buffer)) {

        my($key, $value) = split(/=/, $_);

        $key   = decodeURL($key);

        $value = decodeURL($value);



        $value =~ s/(&lt;P&gt;\s*)+/&lt;P&gt;/g;   # compress multiple &lt;P&gt; tags.

        $value =~ s/&lt;/&amp;lt;/g;           # turn off all HTML tags.

        $value =~ s/&gt;/&amp;gt;/g;

        $value =~ s/&amp;lt;b&amp;gt;/&lt;b&gt;/ig;   # turn on the bold tag.

        $value =~ s!&amp;lt;/b&amp;gt;!&lt;/b&gt;!ig;

        $value =~ s/&amp;lt;i&amp;gt;/&lt;b&gt;/ig;   # turn on the italic tag.

        $value =~ s!&amp;lt;/i&amp;gt;!&lt;/b&gt;!ig;

        $value =~ s!\cM!!g;            # Remove unneeded carriage re

        $value =~ s!\n\n!&lt;P&gt;!g;        # Convert 2 newlines into para

        $value =~ s!\n! !g;            # Convert newline into spaces.

        %{$hashRef}-&gt;{$key} = $value;

    }

}



sub decodeURL {

    $_ = shift;

    tr/+/ /;

    s/%(..)/pack('c', hex($1))/eg;

    return($_);

}

</pre>

</blockquote>

<hr>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Caution</b></td></tr>

<tr><td>

<blockquote>

Tracking security problems seems like a never-ending task but it is very important, especially if you are responsible for a web server. As complicated as the <tt>getFormData()</tt> fuNCtion is, it is still not complete. The <tt>&lt;TEXTAREA&gt;</tt> tag 
lets users enter an unlimited amount of information. What would happen to your web server if someone used the cut and paste ability in Windows 95 to insert four or five megabytes into your form? Perhaps the <tt>getFormData()</tt> fuNCtion should have some 
type of limitation that any individual field should only be 1,024 bytes in length?

</blockquote>



</td></tr>

</table>

</center>

<p>

<h2><a NAME="FillinginaFormandMailingtheInformation"><font SIZE="5" COLOR="#FF0000">

Filling in a Form and Mailing the Information</font></a></h2>

<p>

You can have a form's information automatically mailed to an email

address by using the <tt>mailto:</tt>

notation in the <tt>ACTION</tt> modifier

of the <tt>&lt;FORM&gt;</tt> tag.

For example,

<blockquote>

<pre>

&lt;FORM METHOD=get ACTION=mailto:medined@planet.net&gt;

</pre>

</blockquote>

<p>

When the form's submit button is clicked, the form's information

will be mailed to the email address specified in the <tt>&lt;FORM&gt;</tt>

tag. The information will be URL eNCoded and all on one line.

This means you can't read the information until it has been processed.

<p>

It is generally a bad idea to email form information because of

the URL eNCoding that is done. It is better to save the information

to a data file so that you can easily read and analyze it later.

Sending notifications by email is a good idea. For example, you

could tell an email reader that a certain form has been completed

and that the log file should be checked. If you want to send email

from a CGI script, you can use the sample program from Listing

18.2 in <a HREF="ch18.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch18.htm">Chapter 18</a>, &quot;Using Internet Protocols.&quot;

<p>

Before sending any form information, ensure that it has been decoded.

If you are using one of the CGI modules or the decoding fuNCtions

from <a HREF="ch19.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch19.htm">Chapter 19</a>, &quot;What Is CGI?,&quot; then you don't have

to worry about this requirement. Otherwise, please reread the

section called &quot;URL ENCoding&quot; in <a HREF="ch19.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch19.htm">Chapter 19</a>.

<p>

Make sure to use a <tt>Reply-To</tt>

field in the body of your email message because you won't know

which login name the CGI program will be running under. INCluding

the <tt>Reply-To</tt> field will ensure

that the reader of the message can easily respond to the email

message if needed.

<h2><a NAME="DebuggingFormProcessingCGIScripts"><font SIZE="5" COLOR="#FF0000">

Debugging Form Processing CGI Scripts</font></a></h2>

<p>

CGI programs get their information from three sources: the URL

that invokes them, environment variables, and from the <tt>STDIN</tt>

filehandle. Most of the time, this information comes from the

web server that invokes the CGI script. However, you can manually

recreate the script's normal environment. This lets you debug

a CGI program from the operating system's command line which should

save you time.

<p>

The first thing to look at is how to set environment variables.

The method used depends on your operating system. Table 20.2 shows

you how to set environment variables for a variety of operating

systems.<br>

<p>

<center><b>Table 20.2&nbsp;&nbsp;How to Set Environment Variables

by Hand</b></center>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td WIDTH="164"><i>Operating System</i></td><td WIDTH="349"><i>Command Or UNIX Command Shells</i>

</td></tr>

<tr><td WIDTH="164">csh</td><td WIDTH="349"><tt>setenv HTTP_USER_AGENT &quot;Mozilla&quot;</tt>

</td></tr>

<tr><td WIDTH="164">ksh or bash</td><td WIDTH="349"><tt>export HTTP_USER_AGENT = &quot;Mozilla&quot;</tt>

</td></tr>

<tr><td WIDTH="164">Win95, WinNT, OS/2</td><td WIDTH="349"><tt>set HTTP_USER_AGENT = Mozilla</tt>

</td></tr>

</table>

</center>

<p>

<p>

In order to recreate the environmental variables that a server

sets, you need to initialize at least the following environmental

variables:

<ul>

<li>CONTENT_LENGTH-If you are using the <tt>POST</tt>

method of processing information, set this variable to the length

of the input. Finding the input length is easier than it sounds.

SiNCe you'll be creating a file to hold the test form information,

you only need to find that file's size.

<li>REQUEST_METHOD-You should set this to either <tt>GET</tt>

or <tt>POST</tt>.

<li>QUERY_STRING-You should value this variable, if you are using

the <tt>GET</tt> method or if your

script needs information passed to it via its URL and the extra

information should follow a question mark (<tt>?</tt>).

<li>PATH_INFO-If your script needs information passed to it via

its URL and the extra information should follow a slash (<tt>/)</tt>,

then value this variable with the extra information.

</ul>

<p>

You also need to initialize any other variables that your program

needs. Rather than retyping the <tt>set</tt>

commands each time you want to test your CGI program, create a

shell or batch file.

<p>

The next step is to create a text file that will be substituted

for STDIN when the CGI program is run. You only need to create

this text file if you are using the <tt>GET</tt>

method. The text file can be called anything you'd like and should

contain just one line-the line of form information. For example:

<blockquote>

<pre>

name=Rolf D'Barno&amp;age=34

</pre>

</blockquote>

<p>

Notice that you don't need to use URL eNCoding because the information

will not be sent through the Internet.

<p>

When you are ready, execute your CGI program from the command

line with a command like this:

<blockquote>

<pre>

perl -w gestbook.pl &lt; input.dat

</pre>

</blockquote>

<p>

To summarize the debugging process follows these steps:

<ol>

<li>Create a DOS batch or UNIX script file to initialize the environment

variables that your CGI program will use.

<li>Create a test  file that contains the form information. Use

an <tt>&amp;</tt> character between

<tt>name=value</tt> fields.

<li>Execute your CGI script using file redirection to use the

test file as <tt>STDIN</tt>.

<li>Fix any errors that arise.

</ol>

<h2><a NAME="CreatingaGuestbookforYourSite"><font SIZE="5" COLOR="#FF0000">

Creating a Guestbook for Your Site</font></a></h2>

<p>

In this section, you create a Guest book for your web site. A

Guest book gives visitors a place to add comments and see what

comments other visitors have made. I find that they add to the

sense of community that a Web site has.

<p>

The sample Guestbook application will be presented in two stages.

First, an HTML form is used to request information, then the information

is saved and all the Guest book entries are displayed by a CGI

program. Second, the CGI program is enhaNCed with better error

handling and some new features. Figure 20.1 shows what the finished

Guestbook will look like.

<p>

<a HREF="f20-1.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/f20-1.gif"><b>Figure 20.1 : </b><i>The finished Guestbook</i>.</a>

<h3><a NAME="TheBasicGuestbook">

The Basic Guestbook</a></h3>

<p>

Typically a Guestbook application is reached from a Web site's

home page. You might want to add a link like the following to

your home page:

<blockquote>

<pre>

&lt;A HREF=&quot;addgest.htm&quot;&gt;[Guestbook]&lt;/A&gt;

</pre>

</blockquote>

<p>

Then place the web page in Listing 20.4 into the virtual root

directory of your Web server. Clicking the hypertext link will

bring visitors to the Add Entry form.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Start the HTML web page.<br>

Define the web page header which holds the title.<br>

Start the body of the page.<br>

Display a header.<br>

Display some instructions.<br>

Start a HTML form.<br>

Start a HTML table.<br>

Each row of the table is another input field.<br>

Define the submit button.<br>

End the table.<br>

End the Form<br>

End the body of the page.<br>

End the page.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 20.4&nbsp;&nbsp;ADDGEST.htm-The Add Entry to Guestbook

HTML Form<br>

</b>

</blockquote>

<blockquote>

<pre>

&lt;HTML&gt;

&lt;HEAD&gt;&lt;TITLE&gt;Add to our Guestbook&lt;/TITLE&gt;&lt;/HEAD&gt;

&lt;BODY&gt;

&lt;CENTER&gt;&lt;H1&gt;Add to our Guestbook&lt;/H1&gt;&lt;/CENTER&gt;

Fill in the blanks below to add to our Guestbook.  The only fields that you 

have to fill in are the comments and name section.  Thanks!

&lt;HR&gt;

&lt;FORM METHOD=POST ACTION=&quot;/cgi-bin/gestbook.pl&quot;&gt;

  &lt;TABLE BORDER=0 CELLPADDING=10&gt;

    &lt;TR&gt;

      &lt;TD&gt;Your Name:&lt;/TD&gt;

      &lt;TD&gt;&lt;INPUT TYPE=text NAME=name SIZE=30&gt;&lt;/TD&gt;

    &lt;/TR&gt;

      

&lt;TR&gt;

      &lt;TD&gt;Email:&lt;/TD&gt;

      &lt;TD&gt;&lt;INPUT TYPE=text NAME=email SIZE=40&gt;&lt;/TD&gt;

    &lt;/TR&gt;

    &lt;TR&gt;

      &lt;TD VALIGN=top&gt;Comments:&lt;/TD&gt;

      &lt;TD&gt;&lt;TEXTAREA NAME=comments COLS=60 ROWS=4&gt;&lt;/TEXTAREA&gt;&lt;/TD&gt;

    &lt;/TR&gt;

  &lt;/TABLE&gt;

  &lt;INPUT TYPE=submit VALUE=&quot;Add Entry&quot;&gt; &lt;INPUT TYPE=reset&gt;

&lt;/FORM&gt;

&lt;/BODY&gt;

&lt;/HTML&gt;

</pre>

</blockquote>

<hr>

<p>

The only thing you might need to change in order for this form

to work is the <tt>ACTION</tt> modifier

in the <tt>&lt;FORM&gt;</tt> tag.

The directory where you place the CGI program might not be <tt>/cgi-bin</tt>.

The <tt>addgest.htm</tt> file will

generate a Web page that looks like the following figure.

<p>

<a HREF="f20-2.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/f20-2.gif"><b>Figure 20.2 : </b><i>The Add Entry Form</i>.</a>

<p>

The CGI program in Listing 20.5 is invoked when a visitor clicks

on the submit button of the Add Entry HTML form. This program

will process the form information, save it to a data file and

then create a web page to display all of the entries in the data

file.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Turn on the warning option.<br>

Turn on the strict pragma.<br>

Declare a hash variable to hold the HTML form field data.<br>

Get the local time and pretend that it is one of the form fields.

<br>

Get the data from the form.<br>

Save the data into a file.<br>

Send the HTTP header to the remove web browser.<br>

Send the start of page and header information.<br>

Send the heading and request a horizontal line.<br>

Call the </i><tt><i>readFormData()</i></tt><i>

fuNCtion to display the Guest book entries.<br>

End the web page.<br>

Define the </i><tt><i>getFormData()</i></tt><i>

fuNCtion.<br>

Declare a local variable to hold the refereNCe to the input field

hash.<br>

Initialize a buffer.<br>

If the </i><tt><i>GET</i></tt><i>

method is used, copy the form information into the buffer.<br>

If the </i><tt><i>POST</i></tt><i>

method is used, read the form information into the buffer.<br>

Iterate over the array returned by the </i><tt><i>split()</i></tt><i>

fuNCtion.<br>

Decode both the input field name and value.<br>

Compress multiple </i><tt><i>&lt;P&gt;</i></tt><i>

tags into one.<br>

Convert </i><tt><i>&lt;</i></tt><i>

into </i><tt><i>&amp;lt;</i></tt><i>

and </i><tt><i>&gt;</i></tt><i> into

</i><tt><i>&amp;gt;</i></tt><i> stopping

HTML tags from interpretation.<br>

Turn back on the bold and italic HTML tags.<br>

Remove unneded carriage returns.<br>

Convert two newlines into a HTML paragraph tag.<br>

Convert single newlines into spaces.<br>

Create an entry in the input field hash variable.<br>

Define the </i><tt><i>decodeURL()</i></tt><i>

fuNCtion.<br>

Get the eNCoded string from the parameter array.<br>

Translate all plus signs into spaces.<br>

Convert character coded as hexadecimal digits into regular characters.

<br>

Return the decoded string.<br>

Define the </i><tt><i>zeroFill()</i></tt><i>

fuNCtion-turns &quot;1&quot; into &quot;01&quot;.<br>

Declare a local variable to hold the number to be filled.<br>

Declare a local variable to hold the string length that is needed.

<br>

Find differeNCe between current string length and needed length.

<br>

If the string is big enough (like &quot;12&quot;) then return

it.<br>

If the string is too big, prefix it with some zeroes.<br>

Define the </i><tt><i>saveFormData()</i></tt><i>

fuNCtion.<br>

Declare two local variables to hold the hash and file name.<br>

Open the file for appending.<br>

Store the contents of the hash in the data file.<br>

Close the file.<br>

Define the </i><tt><i>readFormData()</i></tt><i>

fuNCtion.<br>

Declare a local variable to hold the file name.<br>

Open the file for reading.<br>

Iterate over the lines of the file.<br>

Split the line into four variables using ~ as demlimiter.<br>

Print the Guest book entry using a minimal amount of HTML tags.

<br>

Use a horizontal rule to separate entries.<br>

Close the file.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 20.5&nbsp;&nbsp;20LST05.PL-A CGI Program to Add a Guestbook

Entry and Display a Guestbook HTML Page<br>

</b>

</blockquote>

<blockquote>

<pre>

#! /user/bin/perl -w

use strict;



    my(%fields);

    my($sec, $min, $hour, $mday, $mon, $year) = (localtime(time))[0..5];

    my($dataFile) = &quot;data/gestbook.dat&quot;;



    $mon  = zeroFill($mon, 2);

    $hour = zeroFill($hour, 2);

    $min  = zeroFill($min, 2);

    $sec  = zeroFill($sec, 2);

    $fields{'timestamp'} = &quot;$mon/$mday/$year, $hour:$min:sec&quot;;



    getFormData(\%fields);

    saveFormData(\%fields, $dataFile);



    print(&quot;Content-type: text/html\n\n&quot;);

    print(&quot;&lt;HTML&gt;\n&quot;);

    print(&quot;&lt;HEAD&gt;&lt;TITLE&gt;Guestbook&lt;/TITLE&gt;&lt;/HEAD&gt;\n&quot;);

    print(&quot;&lt;H1&gt;Guestbook&lt;/H1&gt;\n&quot;);

    print(&quot;&lt;HR&gt;\n&quot;);

    readFormData($dataFile);

    print(&quot;&lt;/BODY&gt;\n&quot;);

    print(&quot;&lt;/HTML&gt;\n&quot;);



sub getFormData {

    my($hashRef) = shift;

    my($buffer) = &quot;&quot;;



    if ($ENV{'REQUEST_METHOD'} eq &quot;GET&quot;) {

        $buffer = $ENV{'QUERY_STRING'};

    }

    else {

        read(STDIN, $buffer, $ENV{'CONTENT_LENGTH'});

    }



    foreach (split(/&amp;/, $buffer)) {

        my($key, $value) = split(/=/, $_);

        $key   = decodeURL($key);

        $value = decodeURL($value);

        $value =~ s/(&lt;P&gt;\s*)+/&lt;P&gt;/g;   # compress multiple &lt;P&gt; tags.

        $value =~ s/&lt;/&amp;lt;/g;           # turn off all HTML tags.

        $value =~ s/&gt;/&amp;gt;/g;

        $value =~ s/&amp;lt;b&amp;gt;/&lt;b&gt;/ig;    # turn on the bold tag.

        $value =~ s!&amp;lt;/b&amp;gt;!&lt;/b&gt;!ig;

        $value =~ s/&amp;lt;i&amp;gt;/&lt;b&gt;/ig;    # turn on the italic tag.

        $value =~ s!&amp;lt;/i&amp;gt;!&lt;/b&gt;!ig;

        $value =~ s!\cM!!g;            # Remove unneeded carriage re

        

    

        $value =~ s!\n\n!&lt;P&gt;!g;        # Convert 2 newlines into para

        $value =~ s!\n! !g;            # convert newline into space.



        %{$hashRef}-&gt;{$key} = $value;

    }



    $fields{'comments'} =~ s!\cM!!g;

    $fields{'comments'} =~ s!\n\n!&lt;P&gt;!g;

    $fields{'comments'} =~ s!\n!&lt;BR&gt;!g;

}



sub decodeURL {

    $_ = shift;

    tr/+/ /;

    s/%(..)/pack('c', hex($1))/eg;

    return($_);

}



sub zeroFill {

    my($temp) = shift;

    my($len)  = shift;

    my($diff) = $len - length($temp);



    return($temp) if $diff &lt;= 0;

    return(('0' x $diff) . $temp);

}



sub saveFormData {

    my($hashRef) = shift;

    my($file)    = shift;



    open(FILE, &quot;&gt;&gt;$file&quot;) or die(&quot;Unable to open Guestbook data file.&quot;);

    print FILE (&quot;$hashRef-&gt;{'timestamp'}~&quot;);

    print FILE (&quot;$hashRef-&gt;{'name'}~&quot;);

    print FILE (&quot;$hashRef-&gt;{'email'}~&quot;);

    print FILE (&quot;$hashRef-&gt;{'comments'}&quot;);

    print FILE (&quot;\n&quot;);

    close(FILE);

}



sub readFormData {

    my($file)    = shift;



    open(FILE, &quot;&lt;$file&quot;) or die(&quot;Unable to open Guestbook data file.&quot;);

    while (&lt;FILE&gt;) {

        my($timestamp, $name, $email, $comments) = split(/~/, $_);



        print(&quot;$timestamp: &lt;B&gt;$name&lt;/B&gt; &lt;A HREF=mailto:$email&gt;$email&lt;/A&gt;\n&quot;);

        print(&quot;&lt;OL&gt;&lt;I&gt;$comments&lt;/I&gt;&lt;/OL&gt;\n&quot;);

        print(&quot;&lt;HR&gt;\n&quot;);



    }

    close(FILE);

}

</pre>

</blockquote>

<hr>

<p>

This program introduces no new Perl tricks so you should be able

to easily understand it. When the program is invoked, it will

read the form information and then save the information to the

end of a data file. After the information is saved, the program

will generate an HTML page to display all of the entries in the

data file.

<p>

While the program in Listing 20.5 works well, there are several

things that can improve it:

<ul>

<li>Error Handling-instead of simply dying, the program could

generate an error page that indicates the problem.

<li>Field Validation-blank fields should be checked for and warned

against.

<li>Guest book display-visitors should be able to see the Guest

book without needing to add an entry.

</ul>

<p>

The CGI program in Listing 20.6 implements these new features.

If you add <tt>?display</tt> to the

URL of the script, the script will simply display the entries

in the data file. If you add <tt>?add</tt>

to the URL of the script, it will redirect the client browser

to the <tt>addgest.htm</tt> Web page.

If no additional information is passed with the URL, the script

will assume that it has been invoked from a form and will read

the form information. After saving the information, the Guestbook

page will be displayed.

<p>

A debugging routine called <tt>printENV()</tt>

has been added to this listing. If you have trouble getting the

script to work, you can call the <tt>printENV()</tt>

routine in order to display all of the environment variables and

any form information that was read. Place the call to <tt>printENV()</tt>

right before the <tt>&lt;/BODY&gt;</tt>

tag of a Web page. The <tt>displayError()</tt>

fuNCtion calls the <tt>printENV()</tt>

fuNCtion so that the error can have as much information as possible

when a problem arises.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Turn on the warning option.<br>

Turn on the strict pragma.<br>

Declare a hash variable to hold the HTML form field data.<br>

Get the local time and pretend that it is one of the form fields.

<br>

Get the data from the form.<br>

Was the program was invoked with added URL information?<br>

if the display command was used, display the Guest book.<br>

if the add command was use, redirect to the Add Entry page.<br>

otherwise display an error page.<br>

If no extra URL information, check for blank fields.<br>

if blank fields, display an error page.<br>

Save the form data.<br>

Display the Guest book.    <br>

Exit the program.<br>

Define the </i><tt><i>displayError()</i></tt><i>

fuNCtion.<br>

Display an error page with a specified error message.<br>

Define the </i><tt><i>displayPage()</i></tt><i>

fuNCtion.<br>

Read all of the entries into a hash.<br>

Display the Guest book.<br>

Define the </i><tt><i>readFormData()</i></tt><i>

fuNCtion.<br>

Declare local variables for a file name and a hash refereNCe.

<br>

Open the file for reading.<br>

Iterate over the lines of the file.<br>

Split the line into four variables using ~ as demlimiter.<br>

Create a hash entry to hold the Guest book information.<br>

Close the file.<br>

Define the </i><tt><i>getFormData()</i></tt><i>

fuNCtion.<br>

Declare a local variable to hold the refereNCe to the input field

hash.<br>

Initialize a buffer.<br>

If the </i><tt><i>GET</i></tt><i>

method is used, copy the form information into the buffer.<br>

If the </i><tt><i>POST</i></tt><i>

method is used, read the form information into the buffer.<br>

Iterate over the array returned by the </i><tt><i>split()</i></tt><i>

fuNCtion.<br>

Decode both the input field name and value.<br>

Compress multiple </i><tt><i>&lt;P&gt;</i></tt><i>

tags into one.<br>

Convert </i><tt><i>&lt;</i></tt><i>

into </i><tt><i>&amp;lt;</i></tt><i>

and </i><tt><i>&gt;</i></tt><i> into

</i><tt><i>&amp;gt;</i></tt><i> stopping

HTML tags from interpretation.<br>

Turn back on the bold and italic HTML tags.<br>

Remove unneded carriage returns.<br>

Convert two newlines into a HTML paragraph tag.<br>

Convert single newlines into spaces.<br>

Create an entry in the input field hash variable.<br>

Define the </i><tt><i>decodeURL()</i></tt><i>

fuNCtion.<br>

Get the eNCoded string from the parameter array.<br>

Translate all plus signs into spaces.<br>

Convert character coded as hexadecimal digits into regular characters.

<br>

Return the decoded string.<br>

Define the </i><tt><i>zeroFill()</i></tt><i>

fuNCtion-turns &quot;1&quot; into &quot;01&quot;.<br>

Declare a local variable to hold the number to be filled.<br>

Declare a local variable to hold the string length that is needed.

<br>

Find differeNCe between current string length and needed length.

<br>

If the string is big enough (like &quot;12&quot;) then return

it.<br>

If the string is too big, prefix it with some zeroes.<br>

Define the </i><tt><i>saveFormData()</i></tt><i>

fuNCtion.<br>

Declare two local variables to hold the hash and file name.<br>

Open the file for appending.<br>

Store the contents of the hash in the data file.<br>

Close the file.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 20.6&nbsp;&nbsp;20LST06.PL-A More AdvaNCed Guestbook

<br>

</b>

</blockquote>

<blockquote>

<pre>

#! /user/bin/perl -w

#use strict;



    my(%fields);

    my($sec, $min, $hour, $mday, $mon, $year) = (localtime(time))[0..5];

    my($dataFile) = &quot;data/gestbook.dat&quot;;



    $mon  = zeroFill($mon, 2);

    $hour = zeroFill($hour, 2);

    $min  = zeroFill($min, 2);

    $sec  = zeroFill($sec, 2);

    $fields{'timestamp'} = &quot;$mon/$mday/$year, $hour:$min:$sec&quot;;



    getFormData(\%fields);



    if ($ENV{'QUERY_STRING'}) {

        if ($ENV{'QUERY_STRING'} eq 'display') {

            displayPage();

        }

        elsif ($ENV{'QUERY_STRING'} eq 'add') {

            print(&quot;Location: /addgest.htm\n\n&quot;);

        }

        else {

            displayError(&quot;Unknown Command: &lt;B&gt;$ENV{'QUERY_STRING'}&lt;/B&gt;&quot;);

        }

    }

    else {

        if (length($fields{'name'}) == 0) {

            displayError(&quot;Please fill the name field,&lt;BR&gt;\n&quot;);

        }

if (length($fields{'comments'}) == 0) {

            displayError(&quot;Please fill the comments field,&lt;BR&gt;\n&quot;);

        }

        saveFormData(\%fields, $dataFile);

        displayPage();

    }



    exit(0);



sub displayError {

    print(&quot;Content-type: text/html\n\n&quot;);

    print(&quot;&lt;HTML&gt;\n&quot;);

    print(&quot;&lt;HEAD&gt;&lt;TITLE&gt;Guestbook Error&lt;/TITLE&gt;&lt;/HEAD&gt;\n&quot;);

    print(&quot;&lt;H1&gt;Guestbook&lt;/H1&gt;\n&quot;);

    print(&quot;&lt;HR&gt;\n&quot;);

    print(&quot;@_&lt;BR&gt;\n&quot;);

    print(&quot;&lt;HR&gt;\n&quot;);

    printENV();

    print(&quot;&lt;/BODY&gt;\n&quot;);

    print(&quot;&lt;/HTML&gt;\n&quot;);

    exit(0);

}



        

sub displayPage {

    my(%entries);



    readFormData($dataFile, \%entries);



    print(&quot;Content-type: text/html\n\n&quot;);

    print(&quot;&lt;HTML&gt;\n&quot;);

    print(&quot;&lt;HEAD&gt;&lt;TITLE&gt;Guestbook&lt;/TITLE&gt;&lt;/HEAD&gt;\n&quot;);

    print(&quot;&lt;TABLE&gt;&lt;TR&gt;&lt;TD VALIGN=top&gt;&lt;H1&gt;Guestbook&lt;/H1&gt;&lt;/TD&gt;\n&quot;);



    print(&quot;&lt;TD VALIGN=top&gt;&lt;UL&gt;&lt;LI&gt;&lt;A HREF=\&quot;/cgi-bin/gestbook.pl?add\&quot;&gt;Add an Entry&lt;/A&gt;\n&quot;);

    print(&quot;&lt;LI&gt;&lt;A HREF=\&quot;/cgi-bin/gestbook.pl?display\&quot;&gt;Refresh&lt;/A&gt;&lt;/UL&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;\n&quot;);

    print(&quot;&lt;HR&gt;\n&quot;);



    foreach (sort(keys(%entries))) {

        my($arrayRef) = $entries{$_};

        my($timestamp, $name, $email, $comments) = ($_, @{$arrayRef});



        print(&quot;$timestamp: &lt;B&gt;$name&lt;/B&gt; &lt;A HREF=mailto:$email&gt;$email&lt;/A&gt;\n&quot;);

        print(&quot;&lt;OL&gt;$comments&lt;/OL&gt;\n&quot;);

        print(&quot;&lt;HR&gt;\n&quot;);

    }

    print(&quot;&lt;/BODY&gt;\n&quot;);

    print(&quot;&lt;/HTML&gt;\n&quot;);

}



sub readFormData {

    my($file)    = shift;

    my($hashRef) = shift;



    open(FILE, &quot;&lt;$file&quot;) or displayError(&quot;Unable to open Guestbook data file.&quot;);

    while (&lt;FILE&gt;) {

        my($timestamp, $name, $email, $comments) = split(/~/, $_);



        $hashRef-&gt;{$timestamp} = [ $name, $email, $comments ];

    }

    close(FILE);

}



sub getFormData {

    my($hashRef) = shift;

    my($buffer) = &quot;&quot;;



    if ($ENV{'REQUEST_METHOD'} eq &quot;GET&quot;) {

        $buffer = $ENV{'QUERY_STRING'};

    }

    

   else {

        read(STDIN, $buffer, $ENV{'CONTENT_LENGTH'});

    }



    foreach (split(/&amp;/, $buffer)) {

        my($key, $value) = split(/=/, $_);

        $key   = decodeURL($key);

        $value = decodeURL($value);



        $value =~ s/(&lt;P&gt;\s*)+/&lt;P&gt;/g;   # compress multiple &lt;P&gt; tags.

        $value =~ s/&lt;/&amp;lt;/g;           # turn off all HTML tags.

        $value =~ s/&gt;/&amp;gt;/g;

        $value =~ s/&amp;lt;b&amp;gt;/&lt;b&gt;/ig;    # turn on the bold tag.

        $value =~ s!&amp;lt;/b&amp;gt;!&lt;/b&gt;!ig;

        $value =~ s/&amp;lt;i&amp;gt;/&lt;b&gt;/ig;    # turn on the italic tag.

        $value =~ s!&amp;lt;/i&amp;gt;!&lt;/b&gt;!ig;

        $value =~ s!\cM!!g;            # Remove unneeded carriage returns.

        $value =~ s!\n\n!&lt;P&gt;!g;        # Convert 2 newlines into paragraph.

        $value =~ s!\n! !g;            # convert newline into space.

        %{$hashRef}-&gt;{$key} = $value;

    }

}



sub decodeURL {

    $_ = shift;

    tr/+/ /;

    s/%(..)/pack('c', hex($1))/eg;

    return($_);

}



sub zeroFill {

    my($temp) = shift;

    my($len)  = shift;

    my($diff) = $len - length($temp);



    return($temp) if $diff &lt;= 0;

    return(('0' x $diff) . $temp);

}



sub saveFormData {

    my($hashRef) = shift;

    my($file)    = shift;



    open(FILE, &quot;&gt;&gt;$file&quot;) or die(&quot;Unable to open Guestbook data file.&quot;);

    print FILE (&quot;$hashRef-&gt;{'timestamp'}~&quot;);

    print FILE (&quot;$hashRef-&gt;{'name'}~&quot;);

    print FILE (&quot;$hashRef-&gt;{'email'}~&quot;);

    print FILE (&quot;$hashRef-&gt;{'comments'}&quot;);

    print FILE (&quot;\n&quot;);

    

close(FILE);

}



sub printENV {

    print &quot;The Environment report&lt;BR&gt;\n&quot;;

    print &quot;----------------------&lt;BR&gt;&lt;PRE&gt;\n&quot;;

    print &quot;REQUEST_METHOD:  *$ENV{'REQUEST_METHOD'}*\n&quot;;

    print &quot;SCRIPT_NAME:     *$ENV{'SCRIPT_NAME'}*\n&quot;;

    print &quot;QUERY_STRING:    *$ENV{'QUERY_STRING'}*\n&quot;;

    print &quot;PATH_INFO:       *$ENV{'PATH_INFO'}*\n&quot;;

    print &quot;PATH_TRANSLATED: *$ENV{'PATH_TRANSLATED'}*&lt;/PRE&gt;\n&quot;;



    if ($ENV{'REQUEST_METHOD'} eq 'POST') {

        print &quot;CONTENT_TYPE:    $ENV{'CONTENT_TYPE'}&lt;BR&gt;\n&quot;;

        print &quot;CONTENT_FILE:    $ENV{'CONTENT_FILE'}&lt;BR&gt;\n&quot;;

        print &quot;CONTENT_LENGTH:  $ENV{'CONTENT_LENGTH'}&lt;BR&gt;\n&quot;;

    }

    print(&quot;&lt;BR&gt;&quot;);



    foreach (sort(keys(%ENV))) {

        print(&quot;$_: $ENV{$_}&lt;BR&gt;\n&quot;);

    }

    print(&quot;&lt;BR&gt;&quot;);



     foreach (sort(keys(%fields))) {

        print(&quot;$_: $fields{$_}&lt;BR&gt;\n&quot;);

    }

    print(&quot;&lt;BR&gt;&quot;);

}

</pre>

</blockquote>

<hr>

<p>

One of the major changes between Listing 20.5 and Listing 20.6

is in the <tt>readFormData()</tt>

fuNCtion. Instead of actually printing the Guest book data, the

fuNCtion now creates hash entries for it. This change was done

so that an error page could be generated if the data file could

not be opened. Otherwise, the error message would have appeared

it the middle of the Guest book page-leading to confusion on the

part of vistors.

<p>

A table was used to add two hypertext links to the top of the

web page. One link will let visitors add a new entry and the other

refreshes the page. If a second visitor has added a Guest book

entry while the first visitor was reading, refreshing the page

will display the new entry.

<h2><a NAME="Summary"><font SIZE="5" COLOR="#FF0000">

Summary</font></a></h2>

<p>

This chapter introduced you to HTML forms and form processing.

You learned that HTML tags are used to provide guidelines about

how the content of a document. For example, the <tt>&lt;P&gt;</tt>

tag indicates a new paragraph is starting and the <tt>&lt;H1&gt;..&lt;/H1&gt;</tt>

tags indicate a text heading.

<p>

A &quot;correct&quot; HTML document will be entirely eNClosed

inside of a set of &lt;HTML&gt;..&lt;/HTML&gt; tags. Inside the

<tt>&lt;HTML&gt;</tt> tag are <tt>&lt;HEAD&gt;..&lt;/HEAD&gt;</tt>

(surrounds document identification information) and <tt>&lt;BODY&gt;..&lt;/BODY&gt;</tt>

(surrounds document content information) tags.

<p>

After the brief introduction to HTML, you read about Server-Side

INCludes. They are used to insert information into a document

at the time that the page is sent to the Web browser. This lets

the document designer create dynamic pages without needing CGI

programs. For example, you can display the last modification date

of a document, or iNClude other document such as a standard footer

file.

<p>

Next, HTML forms were discussed. HTML forms display input fields

that query the visitor to your Web site. You can display input

boxes, checkboxes, radio but-tons, selection lists, submit buttons

and reset buttons. Everything inside a set of <tt>&lt;FORM&gt;..&lt;/FORM&gt;</tt>

tags is considered one form. You can have multiple forms on a

single Web page.

<p>

The <tt>&lt;FORM&gt;</tt> tag takes

two modifiers. The <tt>ACTION</tt>

modifier tell the web browser the name of the CGI program that

gets invoked when the form's submit button is clicked. And the

<tt>METHOD</tt> modifier determines

how the form information should be sent to the CGI program. If

the <tt>GET</tt> method is used, the

information from the form's fields will be available in the <tt>QUERY_STRING</tt>

environment variable. IF the <tt>POST</tt>

method is used, the form information will be available via the

<tt>STDIN</tt> variable.

<p>

The <tt>getFormData()</tt> fuNCtion

was developed to process form information about make it available

via a hash variable. This fuNCtion is the first line of defense

against hackers. By investing time developing this fuNCtion to

close security holes, you are rewarded by having a safer, more

stable web site.

<p>

Debugging a CGI script takes a little bit of preparation. First,

create a batch or shell file that defines the environment variables

that your CGI program needs. Then, create a test input file if

you are using the <tt>POST</tt> method.

Lastly, execute the CGI program from the command line using redirection

to point STDIN to your test input file.

<p>

Next, a Guestbook application was presented. This application

used an HTML form to gather comments from a user. The comments

are saved to a database. Then, all of the comments stored in the

database are displayed. The first version of the Guestbook required

the user to add an entry before seeing the contents of the Guest-

book. The second version of the Guestbook let users view the contents

without this requirement. In addition, better error checking and

new features were added.

<p>

The next chapter, &quot;Using Perl with Web Servers,&quot; explores

web server log files and ways to automatically create Web pages.

<h2><a NAME="ReviewQuestions"><font SIZE="5" COLOR="#FF0000">

Review Questions</font></a></h2>

<p>

Answers to Review Questions are in Appendix A. 

<ol>

<li>What does the acronym HTML stand for?

<li>What are the &lt;H1&gt;..&lt;/H1&gt; set of tags used for?

<li>What is the down side of using SSI directives?

<li>Can an HTML form have two submit buttons?

<li>Why should all angle brackets be replaced in form information?

<li>How much text can be entered into a &lt;TEXTAREA&gt; input

field?

<li>Can you debug a CGI script?

</ol>

<h2><a NAME="ReviewExercises"><font SIZE="5" COLOR="#FF0000">

Review Exercises</font></a></h2>

<ol>

<li>Create a HTML document with a title of &quot;My First HTML

Document.&quot;

<li>Modify the document from exercise one to iNClude a form with

two input boxes and a text area field.

<li>Modify the <tt>getFormData()</tt>

fuNCtion from Listing 20.3 to limit field information to 1,024

characters or less.

<li>Modify the second Guest book application to only display the

first ten entries. Add hypertext links to read the next and previous

ten entries.

</ol>

<hr>



<center><p><a HREF="ch19.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch19.htm"><img SRC="pc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="#CONTENTS"><img SRC="cc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/cc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="index-1.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/index-1.htm"><img SRC="hb.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/hb.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="ch21.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch21.htm"><img SRC="nc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/nc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<hr WIDTH="100%"></p></center>

</body>

</html>

