<html>

<head>

<title>Chapter 9 -- Using Files</title>



<meta>

</head>

<body TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">

<h1><font SIZE="6" COLOR="#FF0000">Chapter&nbsp;9</font></h1>

<h1><font SIZE="6" COLOR="#FF0000">Using Files</font></h1>

<hr>

<p>

<center><b><font SIZE="5">CONTENTS</font></b></center>

<ul>

<li><a HREF="#SomeFilesAreStandard">

Some Files Are Standard</a>

<ul>

<li><a HREF="#ExampleUsingSTDIN">

Example: Using STDIN</a>

<li><a HREF="#ExampleUsingRedirectiontoChangeSTDINandSTDOUT">

Example: Using Redirection to Change STDIN and STDOUT</a>

<li><a HREF="#ExampleUsingtheDiamondOperatorltgt">

Example: Using the Diamond Operator (&lt;&gt;)</a>

</ul>

<li><a HREF="#FileTestOperators">

File Test Operators</a>

<ul>

<li><a HREF="#ExampleUsingFileTests">

Example: Using File Tests</a>

</ul>

<li><a HREF="#FileFuNCtionsBR">

File FuNCtions<br>

</a>

<ul>

<li><a HREF="#ExampleOpeningFiles">

Example: Opening Files</a>

<li><a HREF="#ExampleBinaryFiles">

Example: Binary Files</a>

<li><a HREF="#ExampleGettingFileStatistics">

Example: Getting File Statistics</a>

<li><a HREF="#ExampleUsingtheDirectoryFuNCtions">

Example: Using the Directory FuNCtions</a>

<li><a HREF="#ExamplePrintingRevisited">

Example: Printing Revisited</a>

</ul>

<li><a HREF="#Globbing">

Globbing</a>

<ul>

<li><a HREF="#ExampleAssigningaGlobtoanArray">

Example: Assigning a Glob to an Array</a>

</ul>

<li><a HREF="#UsingDataStructureswithFiles">

Using Data Structures with Files</a>

<ul>

<li><a HREF="#ExampleSplittingaRecordintoFields">

Example: Splitting a Record into Fields</a>

</ul>

<li><a HREF="#Summary">

Summary</a>

<li><a HREF="#ReviewQuestions">

Review Questions</a>

<li><a HREF="#ReviewExercises">

Review Exercises</a>

</ul>



<hr>

<p>

If you've read the previous chapters and have executed some of

the programs, then you already know that a file is a series of

bytes stored on a disk instead of inside the computer's memory.

A <i>file</i> is good for long-term storage of information. Information

in the computer's memory is lost when the computer is turned off.

Information on a disk, however, is persistent. It will be there

when the computer is turned back on.

<p>

Back in <a HREF="ch1.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch1.htm">Chapter 1</a> &quot;Getting Your Feet Wet,&quot; you saw

how to create a file using the edit program that comes with Windows

95 and Windows NT. In this chapter, you'll see how to manipulate

files with Perl.

<p>

There are four basic operations that you can do with files. You

can open them, read from them, write to them, and close them.

Opening a file creates a connection between your program and the

location on the disk where the file is stored. Closing a file

shuts down that connection.

<p>

Every file has a unique <i>fully qualified </i>name so that it

can't be confused with other files. The fully qualified name iNCludes

the name of the disk, the directory, and the file name. Files

in different directories can have the same name because the operating

system considers the directory name to be a part of the file name.

Here are some fully qualified file names:

<blockquote>

<pre>

c:/windows/win95.txt

c:/windows/command/scandisk.ini

c:/a_long_directory_name/a_long_subdirectory_name/a_long_file_name.doc

<br>



</pre>

</blockquote>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Caution</b></td></tr>

<tr><td>

<blockquote>

You may be curious to know if spaces can be used inside file names. Yes, they can. But, if you use spaces, you need to surround the file name with quotes when referring to it from a DOS or UNIX command line.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

It is very important that you check for errors when dealing with files. To simplify the examples in this chapter, little error checking will be used in the example. Instead, error checking information will be discussed in <a HREF="ch13.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch13.htm">Chapter 
13</a>, &quot;Handling Errors and Signals.&quot;</blockquote>



</td></tr>

</table>

</center>

<p>

<h2><a NAME="SomeFilesAreStandard"><font SIZE="5" COLOR="#FF0000">

Some Files Are Standard</font></a></h2>

<p>

In an effort to make programs more uniform, there are three connections

that always exist when your program starts. These are <tt>STDIN</tt>,

<tt>STDOUT</tt>, and <tt>STDERR</tt>.

Actually, these names are <i>file handles</i>. File handles are

variables used to manipulate files. Just like you need to grab

the handle of a hot pot before you can pick it up, you need a

file handle before you can use a file. Table 9.1 describes the

three file handles.<br>

<p>

<center><b>Table 9.1&nbsp;&nbsp;The Standard File Handles</b></center>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td WIDTH="73"><i>Name</i></td><td WIDTH="517"><i>Description</i>

</td></tr>

<tr><td WIDTH="73"><tt>STDIN</tt></td>

<td WIDTH="517">Reads program input. Typically this is the computer's keyboard.

</td></tr>

<tr><td WIDTH="73"><tt>STDOUT</tt></td>

<td WIDTH="517">Displays program output. This is usually the computer's monitor.

</td></tr>

<tr><td WIDTH="73"><tt>STDERR</tt></td>

<td WIDTH="517">Displays program errors. Most of the time, it is equivalent to <tt>STDOUT</tt>, which means the error messages will be displayed on the computer's monitor.

</td></tr>

</table>

</center>

<p>

<p>

You've been using the <tt>STDOUT</tt>

file handle without knowing it for every <tt>print()</tt>

statement in this book. The <tt>print()</tt>

fuNCtion uses <tt>STDOUT</tt> as the

default if no other file handle is specified. Later in this chapter,

in the &quot;Examples: Printing Revisited&quot; section, you will

see how to send output to a file instead of to the monitor.

<h3><a NAME="ExampleUsingSTDIN">

Example: Using STDIN</a></h3>

<p>

Reading a line of input from the standard input, <tt>STDIN</tt>,

is one of the easiest things that you can do in Perl. This following

three-line program will read a line from the keyboard and then

display it. This will continue until you press <tt>Ctrl+Z</tt>

on DOS systems or <tt>Ctrl-D</tt>

on UNIX systems.

<hr>

<blockquote>

<b>Listing 9.1&nbsp;&nbsp;09LST01.PL-Read from Standard Input

Until an End-of-File Character Is Found<br>

</b>

</blockquote>

<blockquote>

<pre>

while (&lt;STDIN&gt;) {

    print();

}

</pre>

</blockquote>

<hr>

<p>

The <tt>&lt;&gt;</tt> characters,

when used together, are called the <i>diamond</i> operator. It

tells Perl to read a line of input from the file handle inside

the operator. In this case, <tt>STDIN</tt>.

Later, you'll use the diamond operator to read from other file

handles.

<p>

In this example, the diamond operator assigned the value of the

input string to <tt>$_ </tt>. Then,

the <tt>print()</tt> fuNCtion was

called with no parameters, which tells <tt>print()</tt>

to use <tt>$_</tt> as the default

parameter. Using the <tt>$_ </tt>

variable can save a lot of typing, but I'll let you decide which

is more readable. Here is the same program without using <tt>$_</tt>.

<blockquote>

<pre>

while ($inputLine = &lt;STDIN&gt;) {

    print($inputLine);

}

</pre>

</blockquote>

<p>

When you pressed <tt>Ctrl+Z</tt> or

<tt>Ctrl+D</tt>, you told Perl that

the input file was finished. This caused the diamond operator

to return the undefined value which Perl equates to false and

caused the <tt>while</tt> loop to

end. In DOS (and therefore in all of the flavors of Windows),

26-the value of <tt>Ctrl+Z</tt>-is

considered to be the end-of-file indicator. As DOS reads or writes

a file, it monitors the data stream and when a value of 26 is

eNCountered the file is closed. UNIX does the same thing when

a value of 4-the value of <tt>Ctrl+D</tt>-is

read.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Tip</b></td></tr>

<tr><td>

<blockquote>

When a file is read using the diamond operator, the newline character that ends the line is kept as part of the input string. Frequently, you'll see the <tt>chop()</tt> fuNCtion used to remove the newline. For instaNCe, <tt>chop($inputLine = 
&lt;INPUT_FILE&gt;);</tt>. This statement reads a line from the input file, assigns its value to <tt>$inputLine</tt> and then removes that last character from <tt>$inputLine</tt>-which is almost guaranteed to be a newline character. If you fear that the 
last character is not a newline, use the <tt>chomp()</tt> fuNCtion instead.

</blockquote>



</td></tr>

</table>

</center>

<p>

<h3><a NAME="ExampleUsingRedirectiontoChangeSTDINandSTDOUT">

Example: Using Redirection to Change STDIN and STDOUT</a></h3>

<p>

DOS and UNIX let you change the standard input from being the

keyboard to being a file by changing the command line that you

use to execute Perl programs. Until now, you probably used a command

line similar to:

<blockquote>

<pre>

perl -w 09lst01.pl

</pre>

</blockquote>

<p>

In the previous example, Perl read the keyboard to get the standard

input. But, if there was a way to tell Perl to use the file <tt>09LST01.PL</tt>

as the standard input, you could have the program print itself.

Pretty neat, huh? Well, it turns out that you can change the standard

input. It's done this way:

<blockquote>

<pre>

perl -w 09lst01.pl &lt; 09lst01.pl

</pre>

</blockquote>

<p>

The &lt; character is used to <i>redirect</i> the standard input

to the 09LST01.PL file. You now have a program that duplicates

the fuNCtionality of the DOS type command. And it only took three

lines of Perl code!

<p>

You can redirect standard output to a file using the <tt>&gt;</tt>

character. So, if you wanted a copy of <tt>09LST01.PL</tt>

to be sent to <tt>OUTPUT.LOG,</tt>

you could use this command line:

<blockquote>

<pre>

perl -w 09lst01.pl &lt;09lst01.pl &gt;output.log

</pre>

</blockquote>

<p>

Keep this use of the <tt>&lt;</tt>

and <tt>&gt;</tt> characters in mind.

You'll be using them again shortly when we talk about the <tt>open()</tt>

fuNCtion. The <tt>&lt;</tt> character

will signify that files should be opened for input and the <tt>&gt;</tt>

will be used to signify an output file. But first, let's continue

talking about accessing files listed on the command line.

<h3><a NAME="ExampleUsingtheDiamondOperatorltgt">

Example: Using the Diamond Operator (&lt;&gt;)</a></h3>

<p>

If no file handle is used with the diamond operator, Perl will

examine the <tt>@ARGV</tt> special

variable. If <tt>@ARGV</tt> has no

elements, then the diamond operator will read from <tt>STDIN</tt>-either

from the keyboard or from a redirected file. So, if you wanted

to display the contents of more than one file, you could use the

program shown in Listing 9.2.

<hr>

<blockquote>

<b>Listing 9.2&nbsp;&nbsp;09LST02.PL-Read from Multiple Files

or from </b><tt><i><b><font FACE="Courier">STDIN<br>

</font></b></i></tt>

</blockquote>

<blockquote>

<pre>

while (&lt;&gt;) {

    print();

}

</pre>

</blockquote>

<hr>

<p>

The command line to run the program might look like this:

<blockquote>

<pre>

perl -w 09lst02.pl 09lst01.pl 09lst02.pl

</pre>

</blockquote>

<p>

And the output would be:

<blockquote>

<pre>

while (&lt;STDIN&gt;) {

    print();

}

while (&lt;&gt;) {

    print();

}

</pre>

</blockquote>

<p>

Perl will create the <tt>@ARGV</tt>

array from the command line. Each file name on the command line-after

the program name-will be added to the <tt>@ARGV</tt>

array as an element. When the program runs the diamond operator

starts reading from the file name in the first element of the

array. When that entire file has been read, the next file is read

from, and so on, until all of the elements have been used. When

the last file has be finished, the <tt>while</tt>

loop will end.

<p>

Using the diamond operator to iterate over a list of file names

is very handy. You can use it in the middle of your program by

explicitly assigning a list of file names to the <tt>@ARGV</tt>

array. Listing 9.3 shows what this might look like in a program.

<hr>

<blockquote>

<b>Listing 9.3&nbsp;&nbsp;09LST03.PL-Read from Multiple Files

Using the @ARGV Array<br>

</b>

</blockquote>

<blockquote>

<pre>

@ARGV = (&quot;09lst01.pl&quot;, &quot;09lst02.pl&quot;);

while (&lt;&gt;) {

    print();

}

</pre>

</blockquote>

<hr>

<p>

This program displays:<br>

<blockquote>

<pre>

while (&lt;STDIN&gt;) {

    print();

}

while (&lt;&gt;) {

    print();

}

</pre>

</blockquote>

<p>

Next, we will take a look at the ways that Perl lets you test

files, and following that, the fuNCtions that can be used with

files.

<h2><a NAME="FileTestOperators"><font SIZE="5" COLOR="#FF0000">

File Test Operators</font></a></h2>

<p>

Perl has many operators that you can use to test different aspects

of a file. For example, you can use the <tt>-e</tt>

operator to ensure that a file exists before deleting it. Or,

you can check that a file can be written to before appending to

it. By checking the feasibility of the impending file operation,

you can reduce the number of errors that your program will eNCounter.

Table 9.2 shows a complete list of the operators used to test

files.<br>

<p>

<center><b>Table 9.2&nbsp;&nbsp;Perl's File Test Operators</b></center>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td WIDTH="121"><i>Operator</i></td><td WIDTH="469"><i>Description</i>

</td></tr>

<tr><td WIDTH="121"><tt>-A</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Returns the access age of <tt>OPERAND</tt> when the program started.

</td></tr>

<tr><td WIDTH="121"><tt>-b</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> is a block device.

</td></tr>

<tr><td WIDTH="121"><tt>-B</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> is a binary file. If <tt>OPERAND</tt> is a file handle, then the current buffer is examined, instead of the file itself.

</td></tr>

<tr><td WIDTH="121"><tt>-c OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> is a character device.

</td></tr>

<tr><td WIDTH="121"><tt>-C</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Returns the inode change age of <tt>OPERAND</tt> when the program started.

</td></tr>

<tr><td WIDTH="121"><tt>-d</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> is a directory.

</td></tr>

<tr><td WIDTH="121"><tt>-e</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> exists.

</td></tr>

<tr><td WIDTH="121"><tt>-f</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> is a regular  file as opposed to a directory, symbolic link or other type of file.

</td></tr>

<tr><td WIDTH="121"><tt>-g</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> has the setgid bit set.

</td></tr>

<tr><td WIDTH="121"><tt>-k</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> has the sticky bit set.

</td></tr>

<tr><td WIDTH="121"><tt>-l</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> is a symbolic link. Under DOS, this operator always will return false.

</td></tr>

<tr><td WIDTH="121"><tt>-M</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Returns the age of <tt>OPERAND</tt> in days when the program started.

</td></tr>

<tr><td WIDTH="121"><tt>-o</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> is owned by the effective uid. Under DOS, it always returns true.

</td></tr>

<tr><td WIDTH="121"><tt>-O</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> is owned by the read uid/gid. Under DOS, it always returns true.

</td></tr>

<tr><td WIDTH="121"><tt>-p</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> is a named pipe.

</td></tr>

<tr><td WIDTH="121"><tt>-r</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> can be read from.

</td></tr>

<tr><td WIDTH="121"><tt>-R</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> can be read from by the real uid/gid. Under DOS, it is identical to -r.

</td></tr>

<tr><td WIDTH="121"><tt>-s</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Returns the size of <tt>OPERAND</tt> in bytes. Therefore, it returns true if <tt>OPERAND</tt> is non-zero.

</td></tr>

<tr><td WIDTH="121"><tt>-S</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> is a socket.

</td></tr>

<tr><td WIDTH="121"><tt>-t</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> is opened to a tty.

</td></tr>

<tr><td WIDTH="121"><tt>-T</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> is a text file. If <tt>OPERAND</tt> is a file handle, then the current buffer is examined, instead of the file itself.

</td></tr>

<tr><td WIDTH="121"><tt>-u</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> has the setuid bit set.

</td></tr>

<tr><td WIDTH="121"><tt>-w</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> can be written to.

</td></tr>

<tr><td WIDTH="121"><tt>-W</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> can be written to by the real uid/gid. Under DOS, it is identical to -w.

</td></tr>

<tr><td WIDTH="121"><tt>-x</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> can be executed.

</td></tr>

<tr><td WIDTH="121"><tt>-X</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> can be executed by the real uid/gid. Under DOS, it is identical to -x.

</td></tr>

<tr><td WIDTH="121"><tt>-z</tt> <tt>OPERAND</tt>

</td><td WIDTH="469">Tests if <tt>OPERAND</tt> size is zero.

</td></tr>

</table>

</center>

<p>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

If the <tt>OPERAND</tt> is not specified in the file test, the <tt>$ </tt>variable will be used instead.

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

The operand used by the file tests can be either a file handle

or a file name. The file tests work by internally calling the

operating system to determine information about the file in question.

The operators will evaluate to true if the test succeeds and false

if it does not.

<p>

If you need to perform two or more tests on the same file, you

use the special underscore (<tt>_</tt>)

file handle. This tells Perl to use the file information for the

last system query and saves time. However, the underscore file

handle does have some caveats. It does not work with the <tt>-t</tt>

operator. In addition, the <tt>lstat()</tt>

fuNCtion and <tt>-l</tt> test will

leave the system buffer filled with information about a symbolic

link, not a real file.

<p>

The <tt>-T</tt> and <tt>-B</tt>

file tests will examine the first block or so of the file. If

more than 10 percent of the bytes are non-characters or if a null

byte is eNCountered, then the file is considered a binary file.

<i>Binary</i> files are normally data files, as opposed to text

or human-readable files. If you need to work with binary files,

be sure to use the <tt>binmode()</tt>

file fuNCtion, which is described in the section, &quot;Example:

Binary Files,&quot; later in this chapter.

<h3><a NAME="ExampleUsingFileTests">

Example: Using File Tests</a></h3>

<p>

For our first example with file tests, let's examine a list of

files from the command line and determine if each is a regular

file or a special file.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Start a </i><tt><i>foreach</i></tt><i>

loop that looks at the command line array. Each element in the

array is assigned to the default loop variable </i><tt><i>$_</i></tt><i>.

<br>

Print the file name contained in </i><tt><i>$_</i></tt><i>.

<br>

Print a message indicating the type of file by checking the evaluation

of the </i><tt><i>-f</i></tt><i> operator.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 9.4&nbsp;&nbsp;09LST04.PL-Using the </b><tt><i><b><font FACE="Courier">-f</font></b></i></tt><b>

Operator to Find Regular Files Inside a </b><tt><i><b><font FACE="Courier">foreach</font></b></i></tt><b>

Loop<br>

</b>

</blockquote>

<blockquote>

<pre>

foreach (@ARGV) {

    print;

    print((-f) ? &quot; -REGULAR\n&quot; : &quot; -SPECIAL\n&quot;)

}

</pre>

</blockquote>

<hr>

<p>

When this program is run using the following command line:

<blockquote>

<pre>

perl -w 09lst01.pl \perl5 perl.exe \windows

</pre>

</blockquote>

<p>

the following is displayed:

<blockquote>

<pre>

09lst01.pl -REGULAR

\perl5 -SPECIAL

perl.exe -REGULAR

\windows -SPECIAL

</pre>

</blockquote>

<p>

Each of the directories listed on the command line were recognized

as special files. If you want to ignore all special files in the

command line, you do so like this:

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Start a </i><tt><i>foreach</i></tt><i>

loop that looks at the command line array.<br>

If the current file is special, then skip it and go on to the

next iteration of the </i><tt><i>foreach</i></tt><i>

loop.<br>

Print the current file name that is contained in </i><tt><i>$_</i></tt><i>.

<br>

Print a message indicating the type of file.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 9.5&nbsp;&nbsp;09LST05.PL-Using the </b><tt><i><b><font FACE="Courier">-f</font></b></i></tt><b>

Operator to Find Regular Files Inside a </b><tt><i><b><font FACE="Courier">foreach</font></b></i></tt><b>

Loop<br>

</b>

</blockquote>

<blockquote>

<pre>

foreach (@ARGV) {

    next unless -f;    # ignore all non-normal files.

    print;

    print((-f) ? &quot; -REGULAR\n&quot; : &quot; -SPECIAL\n&quot;)

}

</pre>

</blockquote>

<hr>

<p>

When this program is run using the following command line:

<blockquote>

<pre>

perl -w 09lst01.pl \perl perl.exe \windows

</pre>

</blockquote>

<p>

the following is displayed:

<blockquote>

<pre>

09lst01.pl -REGULAR

perl.exe -REGULAR

</pre>

</blockquote>

<p>

Notice that only the regular file names are displayed. The two

directories on the command line were ignored.

<p>

As mentioned above, you can use the underscore file handle to

make two tests in a row on the same file so that your program

can execute faster and use less system resources. This could be

important if your application is time critical or makes many repeated

tests on a large number of files.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Start a </i><tt><i>foreach</i></tt><i>

loop that looks at the command line array.<br>

If the current file is special, then skip it and go on to the

next iteration of the </i><tt><i>foreach</i></tt><i>

loop.<br>

Determine the number of bytes in the file with the </i><tt><i>-s</i></tt><i>

operator using the underscore file handle so that a second operating

system call is not needed.<br>

Print a message indicating the name and size of the file.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 9.6&nbsp;&nbsp;09LST06.PL-Finding the Size in Bytes

of Regular Files Listed on the Command Line<br>

</b>

</blockquote>

<blockquote>

<pre>

foreach (@ARGV) {

    next unless -f;

    $fileSize = -s _;

    print(&quot;$_ is $fileSize bytes long.\n&quot;);

}

</pre>

</blockquote>

<hr>

<p>

When this program is run using the following command line:

<blockquote>

<pre>

perl -w 09lst06.pl \perl5 09lst01.pl \windows perl.exe

</pre>

</blockquote>

<p>

the following is displayed:

<blockquote>

<pre>

09lst01.pl is 36 bytes long.

perl.exe is 61952 bytes long.<br>



</pre>

</blockquote>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Tip</b></td></tr>

<tr><td>

<blockquote>

Don't get the underscore file handle confused with the <tt>$_</tt> special variable. The underscore file handle tells Perl to use the file information from the last system call and the <tt>$ </tt>variable is used as the default parameter for a variety of 
fuNCtions.

</blockquote>



</td></tr>

</table>

</center>

<p>

<h2><a NAME="FileFuNCtionsBR"><font SIZE="5" COLOR="#FF0000">

File FuNCtions<br>

</font></a></h2>

<p>

<center><b>Table 9.3&nbsp;&nbsp;Perl's File FuNCtions</b></center>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td WIDTH="241"><i>FuNCtion</i></td><td WIDTH="349"><i>Description</i>

</td></tr>

<tr><td WIDTH="241"><tt>binmode</tt>(<tt>FILE_HANDLE</tt>)

</td><td WIDTH="349">This fuNCtion puts FILE_HANDLE into a binary mode. For more information, see the section, &quot;Example: Binary Files,&quot; later in this chapter.

</td></tr>

<tr><td WIDTH="241"><tt>chdir</tt>(<tt>DIR_NAME</tt>)

</td><td WIDTH="349">Causes your program to use DIR_NAME as the current directory. It will return true if the change was successful, false if not.

</td></tr>

<tr><td WIDTH="241"><tt>chmod</tt>(<tt>MODE</tt>, <tt>FILE_LIST</tt>)

</td><td WIDTH="349">This UNIX-based fuNCtion changes the permissions for a list of files. A count of the number of files whose permissions was changed is returned. There is no DOS equivalent for this fuNCtion.

</td></tr>

<tr><td WIDTH="241"><tt>chown</tt>(<tt>UID</tt>, <tt>GID</tt>, <tt>FILE_LIST</tt>)

</td><td WIDTH="349">This UNIX-based fuNCtion changes the owner and group for a list of files. A count of the number of files whose ownership was changed is returned. There is no DOS equivalent for this fuNCtion.

</td></tr>

<tr><td WIDTH="241"><tt>close</tt>(<tt>FILE_HANDLE</tt>)

</td><td WIDTH="349">Closes the connection between your program and the file opened with <tt>FILE_HANDLE</tt>.

</td></tr>

<tr><td WIDTH="241"><tt>closedir</tt>(<tt>DIR_HANDLE</tt>)

</td><td WIDTH="349">Closes the connection between your program and the directory opened with <tt>DIR_HANDLE</tt>.

</td></tr>

<tr><td WIDTH="241"><tt>eof</tt>(<tt>FILE_HANDLE</tt>)

</td><td WIDTH="349">Returns true if the next read on <tt>FILE_HANDLE</tt> will result in hitting the end of the file or if the file is not open. If <tt>FILE_HANDLE</tt> is not specified the status of the last file read is returned. All input fuNCtions 
return the undefined value when the end of file is reached, so you'll almost never need to use <tt>eof()</tt>.

</td></tr>

<tr><td WIDTH="241"><tt>fcntl</tt>(<tt>FILE_HANDLE</tt>, 

</td><td WIDTH="349">Implements the <tt>fcntl()</tt> fuNCtion which lets 

</td></tr>

<tr><td WIDTH="241"><tt>FUNCTION</tt>, <tt>SCALAR</tt>)

</td><td WIDTH="349">you perform various file control operations. Its use is beyond the scope of this book.

</td></tr>

<tr><td WIDTH="241"><tt>fileno</tt>(<tt>FILE_HANDLE</tt>)

</td><td WIDTH="349">Returns the file descriptor for the specified <tt>FILE_HANDLE</tt>.

</td></tr>

<tr><td WIDTH="241"><tt>flock</tt>(<tt>FILEHANDLE</tt>, <tt>OPERATION</tt>)

</td><td WIDTH="349">This fuNCtion will place a lock on a file so that multiple users or programs can't simultaneously use it. The <tt>flock()</tt> fuNCtion is beyond the scope of this book.

</td></tr>

<tr><td WIDTH="241"><tt>getc</tt>(<tt>FILE_HANDLE</tt>)

</td><td WIDTH="349">Reads the next character from <tt>FILE_HANDLE</tt>. If <tt>FILE_HANDLE</tt> is not specified, a character will be read from <tt>STDIN</tt>.

</td></tr>

<tr><td WIDTH="241"><tt>glob</tt>(<tt>EXPRESSION</tt>)

</td><td WIDTH="349">Returns a list of files that match the specification of <tt>EXPRESSION</tt>, which can contain wildcards. For instaNCe, <tt>glob</tt>(<tt>&quot;*.pl&quot;</tt>) will return a list of all Perl program files in the current directory.

</td></tr>

<tr><td WIDTH="241"><tt>ioctl</tt>(<tt>FILE_HANDLE</tt>, 

</td><td WIDTH="349">Implements the <tt>ioctl()</tt> fuNCtion which lets 

</td></tr>

<tr><td WIDTH="241"><tt>FUNCTION</tt>, <tt>SCALAR</tt>)

</td><td WIDTH="349">you perform various file control operations. Its use is beyond the scope of this book. For more in-depth discussion of this fuNCtion see Que's <i>Special Edition Using Perl for Web Programming</i>.

</td></tr>

<tr><td WIDTH="241"><tt>link</tt>(<tt>OLD_FILE_NAME</tt>, 

</td><td WIDTH="349">This UNIX-based fuNCtion creates a new </td>

</tr>

<tr><td WIDTH="241"><tt>NEW_FILE_NAME</tt>)

</td><td WIDTH="349">file name that is linked to the old file name. It returns true for success and false for failure. There is no DOS equivalent for this fuNCtion.

</td></tr>

<tr><td WIDTH="241"><tt>lstat</tt>(<tt>FILE_HANDLE_OR_</tt>

</td><td WIDTH="349">Returns file statistics in a 13-element array. 

</td></tr>

<tr><td WIDTH="241"><tt>FILE_NAME</tt>)

</td><td WIDTH="349"><tt>lstat()</tt> is identical to <tt>stat()</tt> except that it can also return information about symbolic links. See the section,&quot;Example: Getting File Statistics,&quot; for more information.

</td></tr>

<tr><td WIDTH="241"><tt>mkdir</tt>(<tt>DIR_NAME</tt>, <tt>MODE</tt>)

</td><td WIDTH="349">Creates a directory named <tt>DIR_NAME</tt>. If you try to create a subdirectory, the parent must already exist. This fuNCtion returns false if the directory can't be created. The special variable <tt>$!</tt> is assigned the error 
message.

</td></tr>

<tr><td WIDTH="241"><tt>open</tt>(<tt>FILE_HANDLE</tt>, <tt>EXPRESSION</tt>)

</td><td WIDTH="349">Creates a link between <tt>FILE_HANDLE</tt> and a file specified by <tt>EXPRESSION</tt>. See the section, &quot;Example: Opening a File,&quot; for more information.

</td></tr>

<tr><td WIDTH="241"><tt>opendir</tt>(<tt>DIR_HANDLE</tt>, <tt>DIR_NAME</tt>)

</td><td WIDTH="349">Creates a link between <tt>DIR_HANDLE</tt> and the directory specified by <tt>DIR_NAME</tt>. <tt>opendir()</tt> returns true if successful, false otherwise.

</td></tr>

<tr><td WIDTH="241"><tt>pipe</tt>(<tt>READ_HANDLE</tt>, 

</td><td WIDTH="349">Opens a pair of connected pipes like the </td>

</tr>

<tr><td WIDTH="241"><tt>WRITE_HANDLE</tt>)

</td><td WIDTH="349">corresponding system call. Its use is beyond the scope of this book. For more on this fuNCtion see Que's <i>Special Edition Using Perl for Web Programming</i>.

</td></tr>

<tr><td WIDTH="241"><tt>print FILE_HANDLE</tt> (<tt>LIST</tt>)

</td><td WIDTH="349">Sends a list of strings to <tt>FILE_HANDLE</tt>. If <tt>FILE_HANDLE</tt> is not specified, then <tt>STDOUT</tt> is used. See the section, &quot;Example: Printing Revisited,&quot; for more information.

</td></tr>

<tr><td WIDTH="241"><tt>printf FILE_HANDLE</tt> 

</td><td WIDTH="349">Sends a list of strings in a format specified by 

</td></tr>

<tr><td WIDTH="241">(<tt>FORMAT</tt>, <tt>LIST</tt>)

</td><td WIDTH="349"><tt>FORMAT</tt> to <tt>FILE_HANDLE</tt>. If <tt>FILE_HANDLE</tt> is not specified, then <tt>STDOUT</tt> is used. See the section, &quot;Example: Printing Revisited,&quot; for more information.

</td></tr>

<tr><td WIDTH="241"><tt>read</tt>(<tt>FILE_HANDLE</tt>, <tt>BUFFER</tt>, 

</td><td WIDTH="349">Reads bytes from <tt>FILE_HANDLE</tt> starting at 

</td></tr>

<tr><td WIDTH="241"><tt>LENGTH</tt>,<tt>LENGTH</tt> <tt>OFFSET</tt>)

</td><td WIDTH="349"><tt>OFFSET</tt> position in the file into the scalar variable called <tt>BUFFER</tt>. It returns the number of bytes read or the undefined value.

</td></tr>

<tr><td WIDTH="241"><tt>readdir</tt>(<tt>DIR_HANDLE</tt>)

</td><td WIDTH="349">Returns the next directory entry from <tt>DIR_HANDLE</tt> when used in a scalar context. If used in an array context, all of the file entries in <tt>DIR_HANDLE</tt> will be returned in a list. If there are no more entries to return, the 
undefined value or a null list will be returned depending on the context.

</td></tr>

<tr><td WIDTH="241"><tt>readlink</tt>(<tt>EXPRESSION</tt>)

</td><td WIDTH="349">This UNIX-based fuNCtion returns that value of a symbolic link. If an error occurs, the undefined value is returned and the special variable <tt>$!</tt> is assigned the error message. The <tt>$_ </tt>special variable is used if 
<tt>EXPRESSION</tt> is not specified.

</td></tr>

<tr><td WIDTH="241"><tt>rename</tt>(<tt>OLD_FILE_NAME</tt>, 

</td><td WIDTH="349">Changes the name of a file. You can use this 

</td></tr>

<tr><td WIDTH="241"><tt>NEW_FILE_NAME</tt>)

</td><td WIDTH="349">fuNCtion to change the directory where a file resides, but not the disk drive or volume.

</td></tr>

<tr><td WIDTH="241"><tt>rewinddir</tt>(<tt>DIR_HANDLE</tt>)

</td><td WIDTH="349">Resets <tt>DIR_HANDLE</tt> so that the next <tt>readdir()</tt> starts at the beginning of the directory.

</td></tr>

<tr><td WIDTH="241"><tt>rmdir</tt>(<tt>DIR_NAME</tt>)

</td><td WIDTH="349">Deletes an empty directory. If the directory can be deleted it returns false and <tt>$!</tt> is assigned the error message. The <tt>$ </tt>special variable is used if <tt>DIR_NAME</tt> is not specified.

</td></tr>

<tr><td WIDTH="241"><tt>seek</tt>(<tt>FILE_HANDLE</tt>, <tt>POSITION</tt>, 

</td><td WIDTH="349">Moves to <tt>POSITION</tt> in the file connected to 

</td></tr>

<tr><td WIDTH="241"><tt>WHENCE</tt>)

</td><td WIDTH="349"><tt>FILE_HANDLE</tt>. The <tt>WHENCE</tt> parameter determines if <tt>POSITION</tt> is an offset from the beginning of the file (<tt>WHENCE=0</tt>), the current position in the file (<tt>WHENCE=1</tt>), or the end of the file 
(<tt>WHENCE=2</tt>).

</td></tr>

<tr><td WIDTH="241"><tt>seekdir</tt>(<tt>DIR_HANDLE</tt>, <tt>POSITION</tt>)

</td><td WIDTH="349">Sets the current position for <tt>readdir()</tt>. <tt>POSITION</tt> must be a value returned by the <tt>telldir()</tt> fuNCtion.

</td></tr>

<tr><td WIDTH="241"><tt>select</tt>(<tt>FILE_HANDLE</tt>)

</td><td WIDTH="349">Sets the default <tt>FILE_HANDLE</tt> for the <tt>write()</tt> and <tt>print()</tt> fuNCtions. It returns the currently selected file handle so that you may restore it if needed. You can see the section, &quot;Example: Printing 
Revisited,&quot; to see this fuNCtion in action.

</td></tr>

<tr><td WIDTH="241"><tt>sprintf</tt>(<tt>FORMAT</tt>, <tt>LIST</tt>)

</td><td WIDTH="349">Returns a string whose format is specified by <tt>FORMAT</tt>.

</td></tr>

<tr><td WIDTH="241"><tt>stat</tt>(<tt>FILE_HANDLE_OR_</tt>

</td><td WIDTH="349">Returns file statistics in a 13-element array. 

</td></tr>

<tr><td WIDTH="241"><tt>FILE_NAME</tt>)

</td><td WIDTH="349">See the section, &quot;Example: Getting File Statistics,&quot; for more information.

</td></tr>

<tr><td WIDTH="241"><tt>symlink</tt>(<tt>OLD_FILE_NAME</tt>, 

</td><td WIDTH="349">This UNIX-based fuNCtion creates a new </td>

</tr>

<tr><td WIDTH="241"><tt>NEW_FILE_NAME</tt>)

</td><td WIDTH="349">file name symbolically linked to the old file name. It returns false if the <tt>NEW_FILE_NAME</tt> cannot be created.

</td></tr>

<tr><td WIDTH="241"><tt>sysread</tt>(<tt>FILE_HANDLE</tt>, <tt>BUFFER</tt>, 

</td><td WIDTH="349">Reads <tt>LENGTH</tt> bytes from <tt>FILE_HANDLE</tt> starting 

</td></tr>

<tr><td WIDTH="241"><tt>LENGTH</tt>,<tt> OFFSET</tt>)

</td><td WIDTH="349">at <tt>OFFSET</tt> position in the file into the scalar variable called <tt>BUFFER</tt>. It returns the number of bytes read or the undefined value.

</td></tr>

<tr><td WIDTH="241"><tt>syswrite</tt>(<tt>FILE_HANDLE</tt>, <tt>BUFFER</tt>, 

</td><td WIDTH="349">Writes <tt>LENGTH</tt> bytes from <tt>FILE_HANDLE</tt> starting 

</td></tr>

<tr><td WIDTH="241"><tt>LENGTH</tt>, <tt>OFFSET</tt>)

</td><td WIDTH="349">at <tt>OFFSET</tt> position in the file into the scalar variable called <tt>BUFFER</tt>. It returns the number of bytes written or the undefined value.

</td></tr>

<tr><td WIDTH="241"><tt>tell</tt>(<tt>FILE_HANDLE</tt>)

</td><td WIDTH="349">Returns the current file position for <tt>FILE_HANDLE</tt>. If <tt>FILE_HANDLE</tt> is not specified, the file position for the last file read is returned.

</td></tr>

<tr><td WIDTH="241"><tt>telldir</tt>(<tt>DIR_HANDLE</tt>)

</td><td WIDTH="349">Returns the current position for <tt>DIR_HANDLE</tt>. The return value may be passed to <tt>seekdir()</tt> to access a particular location in a directory.

</td></tr>

<tr><td WIDTH="241"><tt>truNCate</tt>(<tt>FILE_HANDLE</tt>, <tt>LENGTH</tt>)

</td><td WIDTH="349">TruNCates the file opened on <tt>FILE_HANDLE</tt> to be <tt>LENGTH</tt> bytes long.

</td></tr>

<tr><td WIDTH="241"><tt>unlink</tt>(<tt>FILE_LIST</tt>)

</td><td WIDTH="349">Deletes a list of files. If <tt>FILE_LIST</tt> is not specified, then <tt>$</tt> will be used. It returns the number of files successfully deleted. Therefore, it returns false or 0 if no files were deleted.

</td></tr>

<tr><td WIDTH="241"><tt>utime</tt>(<tt>FILE_LIST</tt>)

</td><td WIDTH="349">This UNIX-based fuNCtion changes the access and modification times on each file in <tt>FILE_LIST</tt>.

</td></tr>

<tr><td WIDTH="241"><tt>write</tt>(<tt>FILE_HANDLE</tt>)

</td><td WIDTH="349">Writes a formatted record to <tt>FILE_HANDLE</tt>. See <a HREF="ch11.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch11.htm">Chapter 11</a>, &quot;Creating Reports,&quot; for more information.

</td></tr>

</table>

</center>

<p>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

The UNIX-based fuNCtions will be discussed further in <a HREF="ch18.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch18.htm">Chapter 18</a>, &quot;Using Internet Protocols.&quot;</blockquote>

<blockquote>

UNIX-based implementations of Perl have several database fuNCtions available to them. For example, <tt>dbmopen()</tt> and <tt>dbmclose()</tt>. These fuNCtions are beyond the scope of this book.

</blockquote>



</td></tr>

</table>

</center>

<p>

<h3><a NAME="ExampleOpeningFiles">

Example: Opening Files</a></h3>

<p>

The <tt>open()</tt> fuNCtion is used

to open a file and create a connection to it called a file handle.

The basic <tt>open()</tt> fuNCtion

call looks like this:

<blockquote>

<pre>

open(FILE_HANDLE);

</pre>

</blockquote>

<p>

The <tt>FILE_HANDLE </tt>parameter

in this version of open() is the name for the new file handle.

It is also the name of the scalar variable that holds the file

name that you would like to open for input. For example:

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Assign the file name, </i><tt><i>FIXED.DAT</i></tt><i>,

to the </i><tt><i>$INPUT_FILE</i></tt><i>

variable. All capital letters are used for the variable name to

indicate that it is also the name of the file handle.<br>

Open the file for reading.<br>

Read the entire file into </i><tt><i>@array</i></tt><i>.

Each line of the file becomes a single element of the array.<br>

Close the file.<br>

Use a </i><tt><i>foreach</i></tt><i>

loop to look at each element of </i><tt><i>@array</i></tt><i>.

<br>

Print </i><tt><i>$_</i></tt><i>, the

loop variable, which contains one of the elements of </i><tt><i>@array</i></tt><i>.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 9.7&nbsp;&nbsp;09LST07.PL-How to Open a File for Input

<br>

</b>

</blockquote>

<blockquote>

<pre>

$INPUT_FILE = &quot;fixed.dat&quot;;



open(INPUT_FILE);

@array = &lt;INPUT_FILE&gt;;

close(INPUT_FILE);



foreach (@array) {

    print();

}

</pre>

</blockquote>

<hr>

<p>

This program displays:

<blockquote>

<pre>

1212Jan       Jaspree             Painter

3453Kelly     Horton              Jockey

</pre>

</blockquote>

<p>

It is considered good programming practice to close any connections

that are made with the <tt>open()</tt>

fuNCtion as soon as possible. While not strictly needed, it does

ensure that all temporary buffers and caches are written to the

hard disk in case of a power failure or other catastrophic failure.

<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

DOS-and by extension, Windows-limits the number of files that you can have open at any given time. Typically, you can have from 20 to 50 files open. Normally, this is plenty. If you need to open more files, please see your DOS documentation.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

The <tt>open()</tt> fuNCtion has many

variations to let you access files in different ways. Table 9.4

shows all of the different methods used to open a file.<br>

<p>

<center><b>Table 9.4&nbsp;&nbsp;The Different Ways to Open a File</b></center>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td WIDTH="175"><i>Open Statement</i></td><td WIDTH="415"><i>Description</i>

</td></tr>

<tr><td WIDTH="175"><tt>open</tt>(<tt>FILE_HANDLE</tt>);

</td><td WIDTH="415">Opens the file named in <tt>$FILE_HANDLE</tt> and connect to it using <tt>FILE_HANDLE</tt> as the file handle. The file will be opened for input only.

</td></tr>

<tr><td WIDTH="175"><tt>open</tt>(<tt>FILE_HANDLE</tt>, <tt><i>FILENAME.EXT</i></tt>);

</td><td WIDTH="415">Opens the file called <tt><i>FILENAME.EXT</i></tt> for input using  <tt>FILE_HANDLE</tt> as the file handle.

</td></tr>

<tr><td WIDTH="175"><tt>open</tt>(<tt>FILE_HANDLE</tt>, +<tt><i>&lt;FILENAME.EXT</i></tt>);

</td><td WIDTH="415">Opens <tt><i>FILENAME.EXT</i></tt> for input using <tt>FILE_HANDLE</tt> as the file handle.

</td></tr>

<tr><td WIDTH="175"><tt>open</tt>(<tt>FILE_HANDLE</tt>, <tt><i>&gt;FILENAME.EXT</i></tt>);

</td><td WIDTH="415">Opens <tt><i>FILENAME.EXT</i></tt> for output using <tt>FILE_HANDLE</tt> as  the file handle.

</td></tr>

<tr><td WIDTH="175"><tt>open</tt>(<tt>FILE_HANDLE</tt>, <tt><i>-</i></tt>);

</td><td WIDTH="415">Opens standard input.</td></tr>

<tr><td WIDTH="175"><tt>open</tt>(<tt>FILE_HANDLE</tt>, <tt><i>&gt;-</i></tt>);

</td><td WIDTH="415">Opens standard output.</td></tr>

<tr><td WIDTH="175"><tt>open</tt>(<tt>FILE_HANDLE</tt>, <tt><i>&gt;&gt;FILENAME.EXT</i></tt>);

</td><td WIDTH="415">Opens <tt><i>FILENAME.EXT</i></tt> for appending using <tt>FILE_HANDLE</tt> as the file handle.

</td></tr>

<tr><td WIDTH="175"><tt>open</tt>(<tt>FILE_HANDLE</tt>, <tt><i>+&lt;FILENAME.EXT</i></tt>);

</td><td WIDTH="415">Opens <tt><i>FILENAME.EXT</i></tt> for both input and output using <tt>FILE_HANDLE</tt> as the file handle.

</td></tr>

<tr><td WIDTH="175"><tt>open</tt>(<tt>FILE_HANDLE</tt>, <tt><i>+&gt;FILENAME.EXT</i></tt>);

</td><td WIDTH="415">Opens <tt><i>FILENAME.EXT</i></tt> for both input and output using <tt>FILE_HANDLE</tt> as the file handle.

</td></tr>

<tr><td WIDTH="175"><tt>open</tt>(<tt>FILE_HANDLE</tt>, <tt><i>+&gt;&gt;FILENAME.EXT</i></tt>);

</td><td WIDTH="415">Opens <tt><i>FILENAME.EXT</i></tt> for both input and output using <tt>FILE_HANDLE</tt> as the file handle.

</td></tr>

<tr><td WIDTH="175"><tt>open</tt>(<tt>FILE_HANDLE</tt>, <tt><i>| PROGRAM</i></tt>)

</td><td WIDTH="415">Sends the output printed to <tt>FILE_HANDLE</tt> to another program.

</td></tr>

<tr><td WIDTH="175"><tt>open</tt>(<tt>FILE_HANDLE</tt>, <tt><i>PROGRAM |</i></tt>)

</td><td WIDTH="415">Reads the output from another program using  <tt>FILE_HANDLE</tt>.

</td></tr>

</table>

</center>

<p>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

I am currently researching the differeNCes between +&lt;, +&gt;, and +&gt;&gt;. The research should be available by 12/1/97 as a link from </blockquote>

<blockquote>

<tt>http:\\www.mtolive.com\pbe\index.html.</tt>

</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

For information about handling failures while opening files, see

<a HREF="ch13.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch13.htm">Chapter 13</a>, &quot;Handling Errors and Signals.&quot; 

<p>

By prefixing the file name with a &gt; character you open the

file for output. This next example opens a file that will hold

a log of messages.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Call the </i><tt><i>open()</i></tt><i>

fuNCtion to open the </i><tt><i>MESSAGE.LOG</i></tt><i>

file for writing with </i><tt><i>LOGFILE</i></tt><i>

as the file handle. If the open was successful, a true value will

be returned and the statement block will be executed.<br>

Send the first message to the </i><tt><i>MESSAGE.LOG</i></tt><i>

file using the </i><tt><i>print()</i></tt><i>

fuNCtion. Notice that an alternate method is being used to call

</i><tt><i>print()</i></tt><i>.<br>

Send the second message to the </i><tt><i>MESSAGE.LOG</i></tt><i>

file.<br>

Close the file.</i>

</blockquote>

<blockquote>

<pre>

if (open(LOGFILE, &quot;&gt;message.log&quot;)) {

    print LOGFILE (&quot;This is message number 1.\n&quot;);

    print LOGFILE (&quot;This is message number 2.\n&quot;);

    close(LOGFILE);

}

</pre>

</blockquote>

<p>

This program displays nothing. Instead, the output from the <tt>print()</tt>

fuNCtion is sent directly to the <tt>MESSAGE.LOG</tt>

file using the connection established by the <tt>open()</tt>

fuNCtion.

<p>

In this example, the <tt>print()</tt>

fuNCtion uses the first parameter as a file handle and the second

parameter as a list of things to print. You can find more information

about printing in the section, &quot;Example: Printing Revisited,&quot;

later in this chapter.

<p>

If you needed to add something to the end of the MESSAGE.LOG file,

you use <tt>&gt;&gt;</tt> as the file

name prefix when opening the file. For example:

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Call the </i><tt><i>open()</i></tt><i>

fuNCtion to open the </i><tt><i>MESSAGE.LOG</i></tt><i>

file for appending with </i><tt><i>LOGFILE</i></tt><i>

as the file handle. If the file does not exist, it will be created;

otherwise, anything printed to </i><tt><i>LOGFILE</i></tt><i>

will be added to the end of the file.<br>

Send a message to the </i><tt><i>MESSAGE.LOG</i></tt><i>

file.<br>

Send a message to the </i><tt><i>MESSAGE.LOG</i></tt><i>

file.<br>

Close the file.</i>

</blockquote>

<blockquote>

<pre>

if (open(LOGFILE, &quot;&gt;&gt;message.log&quot;)) {

    print LOGFILE (&quot;This is message number 3.\n&quot;);

    print LOGFILE (&quot;This is message number 4.\n&quot;);

    close(LOGFILE);

}

</pre>

</blockquote>

<p>

Now, when <tt>MESSAGE.LOG</tt> is

viewed, it contains the following lines:

<blockquote>

<pre>

This is message number 1.

This is message number 2.

This is message number 3.

This is message number 4.

</pre>

</blockquote>

<h3><a NAME="ExampleBinaryFiles">

Example: Binary Files</a></h3>

<p>

When you need to work with data files, you will need to know what

binary mode is. There are two major differeNCes between binary

mode and text mode:

<ul>

<li>In DOS and Windows, line endings are indicated by two characters-the

newline and carriage return characters. When in text mode, these

characters are input as a single character, the newline character.

In binary mode, both characters can be read by your program. UNIX

systems only use one character, the newline, to indicate line

endings.

<li>In DOS and Windows, the end of file character is 26. When

a byte with this value is read in text mode, the file is considered

ended and your program cannot read any more information from the

file. UNIX considers the end-of-file character to be 4. For both

operating systems, binary mode will let the end-of-file character

be treated as a regular character.

</ul>

<p>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Note</b></td></tr>

<tr><td>

<blockquote>

The examples in this section relate to the DOS operating system.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

In order to demonstrate these differeNCes, we'll use a data file

called BINARY.DAT with the following contents:

<blockquote>

<pre>

01

02

03

</pre>

</blockquote>

<p>

First, we'll read the file in the default text mode.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Initialize a buffer variable. Both </i><tt><i>read()</i></tt><i>

and </i><tt><i>sysread()</i></tt><i>

need their buffer variables to be initialized before the fuNCtion

call is executed.<br>

Open the </i><tt><i>BINARY.DAT</i></tt><i>

file for reading.<br>

Read the first 20 characters of the file using the </i><tt><i>read()</i></tt><i>

fuNCtion.<br>

Close the file.<br>

Create an array out of the characters in the </i><tt><i>$buffer</i></tt><i>

variable and iterate over that array using a </i><tt><i>foreach</i></tt><i>

loop.<br>

Print the value of the current array element in hexadecimal format.

<br>

Print a newline character. The current array element is a newline

character.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 9.8&nbsp;&nbsp;09LST08.PL-Reading a File to Show Text

Mode Line Endings<br>

</b>

</blockquote>

<blockquote>

<pre>

$buffer = &quot;&quot;;



open(FILE, &quot;&gt;binary.dat&quot;);

read(FILE, $buffer, 20, 0);

close(FILE);



foreach (split(//, $buffer)) {

    printf(&quot;%02x &quot;, ord($_));

    print &quot;\n&quot; if $_ eq &quot;\n&quot;;

}

</pre>

</blockquote>

<hr>

<p>

This program displays:

<blockquote>

<pre>

30 31 0a

30 32 0a

30 33 0a

</pre>

</blockquote>

<p>

This example does a couple of things that haven't been seen yet

in this book. The <tt>Read()</tt>

fuNCtion is used as an alternative to the line-by-line input done

with the diamond operator. It will read a specified number of

bytes from the input file and assign them to a buffer variable.

The fourth parameter specifies an offset at which to start reading.

In this example, we started at the beginning of the file.

<p>

The <tt>split()</tt> fuNCtion in the

<tt>foreach</tt> loop breaks a string

into pieces and places those pieces into an array. The double

slashes indicate that each character in the string should be an

element of the new array. 

<p>

For more information about the <tt>split()</tt>

fuNCtion, see <a HREF="ch5.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch5.htm">Chapter 5</a> &quot;FuNCtions,&quot; and <a HREF="ch10.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch10.htm">Chapter 10</a>,

&quot;Regular Expressions.&quot; 

<p>

ONCe the array of characters has been created, the <tt>foreach</tt>

loop iterates over the array. The <tt>printf()</tt>

statement converts the ordinal value of the character into hexadecimal

before displaying it. The <i>ordinal</i> value of a character

is the value of the ASCII representation of the character. For

example, the ordinal value of '0' is 0x30 or 48.

<p>

The next line, the print statement, forces the output onto a new

line if the current character is a newline character. This was

done simply to make the output display look a little like the

input file. 

<p>

For more information about the <tt>printf()</tt>

fuNCtion, see the section, &quot;Example: Printing Revisited,&quot;

later in this chapter.

<p>

Now, let's read the file in binary mode and see how the output

is changed.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Initialize a buffer variable.<br>

Open the </i><tt><i>BINARY.DAT</i></tt><i>

file for reading.<br>

Change the mode to binary.<br>

Read the first 20 characters of the file using the </i><tt><i>read()</i></tt><i>

fuNCtion.<br>

Close the file.<br>

Create an array out of the characters in the </i><tt><i>$buffer</i></tt><i>

variable and iterate over that array using a </i><tt><i>foreach</i></tt><i>

loop.<br>

Print the value of the current array element in hexadecimal format.

<br>

Print a newline character. The current array element is a newline

character.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 9.9&nbsp;&nbsp;09LST09.PL-Reading a File to Show Binary

Mode Line Endings<br>

</b>

</blockquote>

<blockquote>

<pre>

$buffer = &quot;&quot;;



open(FILE, &quot;&lt;binary.dat&quot;);

binmode(FILE); 

read(FILE, $buffer, 20, 0);

close(FILE);



foreach (split(//, $buffer)) {

    printf(&quot;%02x &quot;, ord($_));

    print &quot;\n&quot; if $_ eq &quot;\n&quot;;

}

</pre>

</blockquote>

<hr>

<p>

This program displays:<br>

<blockquote>

<pre>

30 31 0d 0a

30 32 0d 0a

30 33 0d 0a

</pre>

</blockquote>

<p>

When the file is read in binary mode, you can see that there are

really two characters at the end of every line-the linefeed and

newline characters.

<p>

Our next example will look at the end-of-file character in both

text and binary modes. We'll use a data file called <tt>EOF.DAT</tt>

with the following contents:

<blockquote>

<pre>

01

02

&lt;end of file character&gt;03

</pre>

</blockquote>

<p>

SiNCe the end-of-file character is a non-printing character, it

can't be shown directly. In the spot <tt>&lt;end

of file character&gt;</tt> above is really the value 26.

<p>

Here is the program that you saw previously read the BINARY.DAT

file, only this time, it will read EOF.DAT.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Initialize a buffer variable.<br>

Open the </i><tt><i>BINARY.DAT</i></tt><i>

file for reading.<br>

Read the first 20 characters of the file using the </i><tt><i>read()</i></tt><i>

fuNCtion.<br>

Close the file.<br>

Create an array of out of the characters in the </i><tt><i>$buffer</i></tt><i>

variable and iterate over that array using a </i><tt><i>foreach</i></tt><i>

loop.<br>

Print the value of the current array element in hexadecimal format.

<br>

Print a newline character. The current array element is a newline

character.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 9.10&nbsp;&nbsp;09LST10.PL-Reading a File to Show the

Text Mode End-of-File Character<br>

</b>

</blockquote>

<blockquote>

<pre>

$buffer = &quot;&quot;;



open(FILE, &quot;&lt;eof.dat&quot;);

read(FILE, $buffer, 20, 0);

close(FILE);



foreach (split(//, $buffer)) {

    printf(&quot;%02x &quot;, ord($_));

    print &quot;\n&quot; if $_ eq &quot;\n&quot;;

}

</pre>

</blockquote>

<hr>

<p>

This program displays:

<blockquote>

<pre>

30 31 0d 0a

30 32 0d 0a

</pre>

</blockquote>

<p>

The end-of-file character prevents the read() fuNCtion from reading

the third line. If the file is placed into binary mode, the whole

file can be read.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Initialize a buffer variable.<br>

Open the </i><tt><i>BINARY.DAT</i></tt><i>

file for reading.<br>

Change the mode to binary.<br>

Read the first 20 characters of the file using the </i><tt><i>read()</i></tt><i>

fuNCtion.<br>

Close the file.<br>

Create an array of out of the characters in the </i><tt><i>$buffer</i></tt><i>

variable and iterate over that array using a </i><tt><i>foreach</i></tt><i>

loop.<br>

Print the value of the current array element in hexadecimal format.

<br>

Print a newline character. The current array element is a newline

character.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 9.11&nbsp;&nbsp;09LST11.PL-Reading a File to Show that

Binary Mode Does Not Recognize the End-of-File Character<br>

</b>

</blockquote>

<blockquote>

<pre>

$buffer = &quot;&quot;;



open(FILE, &quot;&lt;eof.dat&quot;);

binmode(FILE);

read(FILE, $buffer, 20, 0);

close(FILE);



foreach (split(//, $buffer)) {

    printf(&quot;%02x &quot;, ord($_));

    print &quot;\n&quot; if $_ eq &quot;\n&quot;;

}

</pre>

</blockquote>

<hr>

<p>

This program displays:

<blockquote>

<pre>

30 31 0d 0a

30 32 0d 0a

1a 30 33 0d 0a

</pre>

</blockquote>

<p>

With binary mode on, bytes with a value of 26 have no special

meaning and the third line can be read. You see that the value

26-33 in hexadecimal-was printed along with the rest of the characters.

<p>

<tt>Example: Reading into a Hash</tt>

<p>

You've already seen that you can read a file directly into a regular

array using this syntax:

<blockquote>

<pre>

@array = &lt;FILE_HANDLE&gt;;

</pre>

</blockquote>

<p>

Unfortunately, there is no similar way to read an entire file

into a hash. But, it's still pretty easy to do. The following

example will use the line number as the hash key for each line

of a file.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Open the </i><tt><i>FIXED.DAT</i></tt><i>

file for reading.<br>

For each line of </i><tt><i>FIXED.DAT </i></tt><i>create

a hash element using the record number special variable (</i><tt><i>$.</i></tt><i>)

as the key and the line of input (</i><tt><i>$_</i></tt><i>)

as the value.<br>

Close the file.<br>

Iterate over the keys of the hash.<br>

Print each key, value pair.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 9.12&nbsp;&nbsp;09LST12.PL-Reading a Fixed Length Record

with Fixed Length Fields into a Hash<br>

</b>

</blockquote>

<blockquote>

<pre>

open(FILE, &quot;&lt;fixed.dat&quot;);

while (&lt;FILE&gt;) {

    $hash{$.} = $_;

}

close(FILE);



foreach (keys %hash) {

    print(&quot;$_: $hash{$_}&quot;);

}

</pre>

</blockquote>

<hr>

<p>

This program displays:<br>

<blockquote>

<pre>

1: 1212Jan       Jaspree             Painter

2: 3453Kelly     Horton              Jockey

</pre>

</blockquote>

<h3><a NAME="ExampleGettingFileStatistics">

Example: Getting File Statistics</a></h3>

<p>

The file test operators can tell you a lot about a file, but sometimes

you need more. In those cases, you use the <tt>stat()</tt>

or <tt>lstat()</tt> fuNCtion. The

<tt>stat()</tt> returns file information

in a 13-element array. You can pass either a file handle or a

file name as the parameter. If the file can't be found or another

error occurs, the null list is returned. Listing 9.13 shows how

to use the <tt>stat()</tt> fuNCtion

to find out information about the <tt>EOF.DAT</tt>

file used earlier in the chapter.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Assign the return list from the </i><tt><i>stat()</i></tt><i>

fuNCtion to 13 scalar variables.<br>

Print the scalar values.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 9.13&nbsp;&nbsp;09LST13.PL-Using the </b><tt><i><b><font FACE="Courier">stat()</font></b></i></tt><b>

FuNCtion<br>

</b>

</blockquote>

<blockquote>

<pre>

($dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size,

    $atime, $mtime, $ctime, $blksize, $blocks) = stat(&quot;eof.dat&quot;);



print(&quot;dev     = $dev\n&quot;);

print(&quot;ino     = $ino\n&quot;);

print(&quot;mode    = $mode\n&quot;);

print(&quot;nlink   = $nlink\n&quot;);

print(&quot;uid     = $uid\n&quot;);

print(&quot;gid     = $gid\n&quot;);

print(&quot;rdev    = $rdev\n&quot;);

print(&quot;size    = $size\n&quot;);

print(&quot;atime   = $atime\n&quot;);

print(&quot;mtime   = $mtime\n&quot;);

print(&quot;ctime   = $ctime\n&quot;);

print(&quot;blksize = $blksize\n&quot;);

print(&quot;blocks  = $blocks\n&quot;);

</pre>

</blockquote>

<hr>

<p>

In the DOS environment, this program displays:

<blockquote>

<pre>

dev     = 2

ino     = 0

mode    = 33206

nlink   = 1

uid     = 0

gid     = 0

rdev    = 2

size    = 13

atime   = 833137200

mtime   = 833195316

ctime   = 833194411

blksize =

blocks  =

</pre>

</blockquote>

<p>

Some of this information is specific to the UNIX environment and

is beyond the scope of this book. For more information on this

topic, see Que's 1994 edition of <i>Using Unix</i>. One interesting

piece of information is the <tt>$mtime</tt>

value-the date and time of the last modification made to the file.

You can interpret this value by using the following line of code:

<blockquote>

<pre>

($sec, $min, $hr, $day, $month, $year, $day_Of_Week, 

    $julianDate, $dst) = localtime($mtime);

</pre>

</blockquote>

<p>

If you are only interested in the modification date, you can use

the array slice notation to just grab that value from the 13-element

array returned by <tt>stat()</tt>.

For example:

<blockquote>

<pre>

$mtime = (stat(&quot;eof.dat&quot;))[9];

</pre>

</blockquote>

<p>

Notice that the <tt>stat()</tt> fuNCtion

is surrounded by parentheses so that the return value is evaluated

in an array context. Then the tenth element is assigned to <tt>$mtime</tt>.

You can use this technique whenever a fuNCtion returns a list.

<h3><a NAME="ExampleUsingtheDirectoryFuNCtions">

Example: Using the Directory FuNCtions</a></h3>

<p>

Perl has several fuNCtions that let you work with directories.

You can make a directory with the <tt>mkdir()</tt>

fuNCtion. You can delete a directory with the <tt>rmdir()</tt>

fuNCtion. Switching from the current directory to another is done

using the <tt>chdir()</tt> fuNCtion.

<p>

Finding out which files are in a directory is done with the <tt>opendir()</tt>,

<tt>readdir()</tt>, and <tt>closedir()</tt>

fuNCtions. The next example will show you how to create a list

of all Perl programs in the current directory-well, at least those

files that end with the pl extension.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Open the current directory using </i><tt><i>DIR</i></tt><i>

as the directory handle.<br>

Read a list of file names using the </i><tt><i>readdir()</i></tt><i>

fuNCtion; extract only those that end in </i><tt><i>pl</i></tt><i>;

and the sorted list. The sorted list is assigned to the </i><tt><i>@files</i></tt><i>

array variable.<br>

Close the directory.<br>

Print the file names from the </i><tt><i>@files</i></tt><i>

array unless the file is a directory.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 9.14&nbsp;&nbsp;09LST14.PL-Print All Files in the Current

Directory Whose Name Ends in PL<br>

</b>

</blockquote>

<blockquote>

<pre>

opendir(DIR, &quot;.&quot;);

@files = sort(grep(/pl$/, readdir(DIR)));

closedir(DIR);



foreach (@files) {

    print(&quot;$_\n&quot;) unless -d;

}

</pre>

</blockquote>

<hr>

<p>

For more information about the grep() fuNCtion, see <a HREF="ch10.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch10.htm">Chapter 10</a>,

&quot;Regular Expressions.&quot; 

<p>

This program will display each file name that ends in <tt>pl</tt>

on a separate line. If you need to know the number of Perl programs,

evaluate the <tt>@files</tt> array

in a scalar context. For example:

<blockquote>

<pre>

$num_Perl_Programs = @files;<br>



</pre>

</blockquote>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Tip</b></td></tr>

<tr><td>

<blockquote>

For this example, I modified the naming convention used for the variables. I feel that <tt>$num_Perl_Programs</tt> is easier to read than <tt>$numPerlPrograms</tt>. No naming convention should be inflexible. Use it as a guideline and break the rules when 
it seems wise.

</blockquote>



</td></tr>

</table>

</center>

<p>

<h3><a NAME="ExamplePrintingRevisited">

Example: Printing Revisited</a></h3>

<p>

We've been using the <tt>print()</tt>

fuNCtion throughout this book without really looking at how it

works. Let's remedy that now.

<p>

The <tt>print()</tt> fuNCtion is used

to send output to a file handle. Most of the time, we've been

using <tt>STDOUT</tt> as the file

handle. Because <tt>STDOUT</tt> is

the default, we did not need to specify it. The syntax for the

<tt>print()</tt> fuNCtion is:

<blockquote>

<pre>

print FILE_HANDLE (LIST)

</pre>

</blockquote>

<p>

You can see from the syntax that <tt>print()</tt>

is a list operator because it's looking for a list of values to

print. If you don't specify a list, then $  will be used. You

can change the default file handle by using the <tt>select()</tt>

fuNCtion. Let's take a look at this:

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Open </i><tt><i>TESTFILE.DAT</i></tt><i>

for output.<br>

Change the default file handle for write and print statements.

Notice that the old default handle is returned and saved in the

</i><tt><i>$oldHandle</i></tt><i>

variable.<br>

This line prints to the default handle which now the </i><tt><i>TESTFILE.DAT</i></tt><i>

file.<br>

Change the default file handle back to </i><tt><i>STDOUT</i></tt><i>.

<br>

This line prints to </i><tt><i>STDOUT</i></tt><i>.</i>

</blockquote>

<blockquote>

<pre>

open(OUTPUT_FILE, &quot;&gt;testfile.dat&quot;);

$oldHandle = select(OUTPUT_FILE);

print(&quot;This is line 1.\n&quot;);

select($oldHandle);

print(&quot;This is line 2.\n&quot;);

</pre>

</blockquote>

<p>

This program displays:

<blockquote>

<pre>

This is line 2.

</pre>

</blockquote>

<p>

and creates the TESTFILE.DAT file with a single line in it:

<blockquote>

<pre>

This is line 1.

</pre>

</blockquote>

<p>

Perl also has the <tt>printf()</tt>

fuNCtion which lets you be more precise in how things are printed

out. The syntax for <tt>printf()</tt>

looks like this:

<blockquote>

<pre>

printf FILE_HANDLE (FORMAT_STRING, LIST)

</pre>

</blockquote>

<p>

Like <tt>print()</tt>, the default

file handle is <tt>STDOUT</tt>. The

<tt>FORMAT_STRING</tt> parameter controls

what is printed and how it looks. For simple cases, the formatting

parameter looks identical to the list that is passed to <tt>printf()</tt>.

For example:

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Create two variables to hold costs for January and February.

<br>

Print the cost variables using variable interpolation. Notice

that the dollar sign needs to be preceded by the backslash to

avoid interpolation that you don't want.</i>

</blockquote>

<blockquote>

<pre>

$januaryCost = 123.34;

$februaryCost = 23345.45;



printf(&quot;January  = \$$januaryCost\n&quot;);

printf(&quot;February = \$$februaryCost\n&quot;);

</pre>

</blockquote>

<p>

This program displays:

<blockquote>

<pre>

January  = $123.34

February = $23345.45

</pre>

</blockquote>

<p>

In this example, only one parameter is passed to the <tt>printf()</tt>

fuNCtion-the formatting string. Because the formatting string

is eNClosed in double quotes, variable interpolation will take

place just like for the <tt>print()</tt>

fuNCtion.

<p>

This display is not good enough for a report because the decimal

points of the numbers do not line up. You can use the formatting

specifiers shown in Table 9.5 together with the modifiers shown

in Table 9.6 to solve this problem.<br>

<p>

<b>Table 9.5&nbsp;&nbsp; Format Specifiers for the printf() FuNCtion</b>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td WIDTH="79"><center><i>Specifier</i></center></td><td WIDTH="511"><i>Description</i>

</td></tr>

<tr><td WIDTH="79"><center>c</center></td><td WIDTH="511">Indicates that a single character should be printed.

</td></tr>

<tr><td WIDTH="79"><center>s</center></td><td WIDTH="511">Indicates that a string should be printed.

</td></tr>

<tr><td WIDTH="79"><center>d</center></td><td WIDTH="511">Indicates that a decimal number should be printed.

</td></tr>

<tr><td WIDTH="79"><center>u</center></td><td WIDTH="511">Indicates that an unsigned decimal number should be printed.

</td></tr>

<tr><td WIDTH="79"><center>x</center></td><td WIDTH="511">Indicates that a hexadecimal number should be printed.

</td></tr>

<tr><td WIDTH="79"><center>o</center></td><td WIDTH="511">Indicates that an octal number should be printed.

</td></tr>

<tr><td WIDTH="79"><center>e</center></td><td WIDTH="511">Indicates that a floating point number should be printed in scientific notation.

</td></tr>

<tr><td WIDTH="79"><center>f</center></td><td WIDTH="511">Indicates that a floating point number should be printed.

</td></tr>

<tr><td WIDTH="79"><center>g</center></td><td WIDTH="511">Indicates that a floating point number should be printed using the most space-spacing format, either e or f.

</td></tr>

</table>

</center>

<p>

<p>

<center><b>Table 9.6&nbsp;&nbsp;Format Modifiers for the printf()

FuNCtion</b></center>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td WIDTH="79"><center><i>Modifier</i></center></td><td WIDTH="511"><i>Description</i>

</td></tr>

<tr><td WIDTH="79"><center>-</center></td><td WIDTH="511">Indicates that the value should be printed left-justified.

</td></tr>

<tr><td WIDTH="79"><center>#</center></td><td WIDTH="511">Forces octal numbers to be printed with a leading zero. Hexadecimal numbers will be printed with a leading 0x.

</td></tr>

<tr><td WIDTH="79"><center>+</center></td><td WIDTH="511">Forces signed numbers to be printed with a leading + or - sign.

</td></tr>

<tr><td WIDTH="79"><center>0</center></td><td WIDTH="511">Pads the displayed number with zeros instead of spaces.

</td></tr>

<tr><td WIDTH="79"><center>.</center></td><td WIDTH="511">Forces the value to be at least a certain width. For example, %10.3f means that the value will be at least 10 positions wide. And because f is used for floating point, at most 3 positions to the right 
of the decimal point will be displayed. %.10s will print a string at most 10 characters long.

</td></tr>

</table>

</center>

<p>

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Create two variables to hold costs for January and February.

<br>

Print the cost variables using format specifiers.</i>

</blockquote>

<blockquote>

<pre>

$januaryCost = 123.34;

$februaryCost = 23345.45;



printf(&quot;January  = \$%8.2f\n&quot;, $januaryCost);

printf(&quot;February = \$%8.2f\n&quot;, $februaryCost);

</pre>

</blockquote>

<p>

This program displays:

<blockquote>

<pre>

January  = $  123.34

February = $23345.45

</pre>

</blockquote>

<p>

This example uses the <tt>f</tt> format

specifier to print a floating point number. The numbers are printed

right next to the dollar sign because <tt>$februaryCost</tt>

is 8 positions width.

<p>

If you did not know the width of the numbers that you need to

print in advaNCe, you could use the following technique.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Create two variables to hold costs for January and February.

<br>

Find the length of the largest number.<br>

Print the cost variables using variable interpolation to determine

the width of the numbers to print.<br>

Define the </i><tt><i>max()</i></tt><i>

fuNCtion. You can look in the &quot;Example: </i><tt><i>Foreach</i></tt><i>

Loops&quot; of <a HREF="ch7.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch7.htm">Chapter 7</a> &quot;Control Statements,&quot; for

more information about the </i><tt><i>max()</i></tt><i>

fuNCtion.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 9.15&nbsp;&nbsp;09LST15.PL-Using Variable Interpolation

to Align Numbers When Printing<br>

</b>

</blockquote>

<blockquote>

<pre>

$januaryCost = 123.34;

$februaryCost = 23345.45;



$maxLength = length(max($januaryCost, $februaryCost));



printf(&quot;January  = \$%$maxLength.2f\n&quot;, $januaryCost);

printf(&quot;February = \$%$maxLength.2f\n&quot;, $februaryCost);



sub max {

    my($max) = shift(@_);



    foreach $temp (@_) {

        $max = $temp if $temp &gt; $max;

    }

    return($max);

}

</pre>

</blockquote>

<hr>

<p>

This program displays:

<blockquote>

<pre>

January  = $  123.34

February = $23345.45

</pre>

</blockquote>

<p>

While taking the time to find the longest number is more work,

I think you'll agree that the result is worth it.<br>

<p>

<center>

<table BORDERCOLOR="#000000" BORDER="1" WIDTH="80%">

<tr><td><b>Tip</b></td></tr>

<tr><td>

<blockquote>

In the next chapter, &quot;Regular Expressions,&quot; you see how to add commas when printing numbers for even more readability when printing numbers.</blockquote>



</td></tr>

</table>

</center>

<p>

<p>

So far, we've only looked at printing numbers. You also can use

<tt>printf()</tt> to control printing

strings. Like the printing of numbers above, <tt>printf()</tt>

is best used for controlling the alignment and length of strings.

Here is an example:

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Assign &quot;John O'Mally&quot; to </i><tt><i>$name</i></tt><i>.

<br>

Print using format specifiers to make the value 10 characters

wide but only print the first 5 characters from the string.</i>

</blockquote>

<blockquote>

<pre>

$name = &quot;John O'Mally&quot;;

printf(&quot;The name is %10.5s.\n&quot;, $name);

</pre>

</blockquote>

<p>

This program displays:

<blockquote>

<pre>

The name is      John.

</pre>

</blockquote>

<p>

The left side of the period modifier controls the width of the

printed value also called the <i>print field</i>. If the length

of the string to be printed is less than the width of the print

field, then the string is right justified and padded with spaces.

<p>

You can left-justify the string by using the dash modifier. For

example:

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Assign &quot;John O'Mally&quot; to </i><tt><i>$name</i></tt><i>.

<br>

Print using format specifiers to left-justify the value.</i>

</blockquote>

<blockquote>

<pre>

$name = &quot;John O'Mally&quot;;

printf(&quot;The name is %-10.5s.\n&quot;, $name);

</pre>

</blockquote>

<p>

This program displays:

<blockquote>

<pre>

The name is John     .

</pre>

</blockquote>

<p>

The period way off to the right shows that the string was left-justified

and padded with spaces until it was 10 positions wide.

<h2><a NAME="Globbing"><font SIZE="5" COLOR="#FF0000">

Globbing</font></a></h2>

<p>

Perl supports a feature called <i>globbing</i> which lets you

use wildcard characters to find file names. A <i>wildcard</i>

character is like the wild card in poker. It can have more than

one meaning. Let's look at some of the simpler examples.

<h3><a NAME="ExampleAssigningaGlobtoanArray">

Example: Assigning a Glob to an Array</a></h3>

<p>

One common chore for computer administrators is the removal of

backup files. You can use the globbing technique with the <tt>unlink()</tt>

fuNCtion to perform this chore.

<blockquote>

<pre>

unlink(&lt;*.bak&gt;);

</pre>

</blockquote>

<p>

The file specification, <tt>*.bak</tt>,

is placed between the diamond operator and when evaluated returns

a list of files that match the specification. An asterisk means

zero or more of any character will be matched. So this <tt>unlink()</tt>

call will delete all files with a <tt>BAK</tt>

extension.

<p>

You can use the following: To get a list of all files that start

with the letter f.

<blockquote>

<pre>

@array = &lt;f*.*&gt;;

</pre>

</blockquote>

<p>

 The next chapter, &quot;Regular Expressions,&quot; will show

you more ways to specify file names. Most of the meta-characters

used in <a HREF="ch10.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch10.htm">Chapter 10</a> can be used inside globs.

<h2><a NAME="UsingDataStructureswithFiles"><font SIZE="5" COLOR="#FF0000">

Using Data Structures with Files</font></a></h2>

<p>

In the last chapter, you saw how to create complex data structures.

Creating a program to read and write those structures is beyond

the scope of this book. However, the following examples will show

you how to use simpler data structures. The same techniques can

be applied to the more complicated data structures as well.

<h3><a NAME="ExampleSplittingaRecordintoFields">

Example: Splitting a Record into Fields</a></h3>

<p>

This example will show you how to read a file line-by-line and

break the input records into fields based on a separator string.

The file, <tt>FIELDS.DAT</tt>, will

be used with the following contents:

<blockquote>

<pre>

1212:Jan:Jaspree:Painter

3453:Kelly:Horton:Jockey

</pre>

</blockquote>

<p>

The individual fields or values are separated from each other

by the colon (:)  character. The <tt>split()</tt>

fuNCtion will be used to create an array of fields. Then a  foreach

loop will print the fields. Listing 9.16 shows how to input lines

from a file and split them into fields.

<p>

<img SRC="pseudo.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pseudo.gif" BORDER="1" ALIGN="RIGHT" WIDTH="31" HEIGHT="34"><p>

<blockquote>

<i>Use the </i><tt><i>qw()</i></tt><i>

notation to create an array of words.<br>

Open the </i><tt><i>FIELDS.DAT</i></tt><i>

file for input.<br>

Loop while there are lines to read in the file.<br>

Use the split fuNCtion to create an array of fields, using the

colon as the field separator. The scalar value of </i><tt><i>@fieldList</i></tt><i>

is passed to split to indicate how many fields to expect. Each

element in the new array is then added to the </i><tt><i>%data</i></tt><i>

hash with a key of the field name.<br>

Loop through </i><tt><i>@fieldList</i></tt><i>

array.<br>

Print each element and its value in the </i><tt><i>%data</i></tt><i>

hash.</i>

</blockquote>

<hr>

<blockquote>

<b>Listing 9.16&nbsp;&nbsp;09LST16.PL-Reading Records from Standard

Input<br>

</b>

</blockquote>

<blockquote>

<pre>

@fieldList = qw(fName lName job age);



open(FILE, &quot;&lt;fields.dat&quot;);



while(&lt;FILE&gt;) {

    @data{@fieldList} = split(/:/, $_, scalar @fieldList);



    foreach (@fieldList) {

        printf(&quot;%10.10s = %s\n&quot;, $_, $data{$_});

    }

}



close(FILE);

</pre>

</blockquote>

<hr>

<p>

This program will display:

<blockquote>

<pre>

fName = 1212

     lName = Jan

       job = Jaspree

       age = Painter



     fName = 3453

     lName = Kelly

       job = Horton

       age = Jockey

</pre>

</blockquote>

<p>

The first line of this program uses the <tt>qw()</tt>

notation to create an array of words. It is identical to <tt>@fieldList

= (&quot;fName&quot;, &quot;lName&quot;, &quot;job&quot;, &quot;age&quot;);</tt>

but without the distracting quotes and commas.

<p>

The split statement might require a little explanation. It is

duplicated here so that you can focus on it.

<blockquote>

<pre>

@data{@fieldList} = split(/:/, $_, scalar @fieldList);

</pre>

</blockquote>

<p>

Let's use the first line of the input file as an example. The

first line looks like this:

<blockquote>

<pre>

1212:Jan:Jaspree:Painter

</pre>

</blockquote>

<p>

The first thing that happens is that split creates an array using

the colon as the separator, creating an array that looks like

this:

<blockquote>

<pre>

 (&quot;1212&quot;, &quot;Jan&quot;, &quot;Jaspree&quot;, &quot;Painter&quot;)

</pre>

</blockquote>

<p>

You can substitute this list in place of the <tt>split()</tt>

fuNCtion in the statement.

<blockquote>

<pre>

@data{@fieldList} = (&quot;1212&quot;, &quot;Jan&quot;, &quot;Jaspree&quot;, &quot;Painter&quot;);

</pre>

</blockquote>

<p>

And, you already know that <tt>@fieldList</tt>

is a list of field name. So, the statement can be further simplified

to:

<blockquote>

<pre>

@data{&quot;fName&quot;, &quot;lName&quot;, &quot;job&quot;, &quot;age&quot;} = 

    (&quot;1212&quot;, &quot;Jan&quot;, &quot;Jaspree&quot;, &quot;Painter&quot;);

</pre>

</blockquote>

<p>

This assignment statement shows that each array element on the

right is paired with a key value on the left so that four separate

hash assignments are taking place in this statement.

<h2><a NAME="Summary"><font SIZE="5" COLOR="#FF0000">

Summary</font></a></h2>

<p>

This was a rather long chapter, and we've really only talked about

the basics of using files. You have enough information now to

explore the rest of the file fuNCtions. You also could  create

fuNCtions to read more complicated data structures with what you've

learned so far.

<p>

Let's review what you know about files. You read that files are

a series of bytes stored somewhere outside the computer's memory.

Most of the time, a file will be on a hard disk in a directory.

But, the file also could be on a floppy disk or on a networked

computer. The physical location is not important as long as you

know the fully qualified file name. This name will iNClude any

computer name, drive name, and directory name that is needed to

uniquely identify the file.

<p>

There are three files-actually file handles-that always  are opened

before your program starts. These are <tt>STDIN</tt>,

<tt>STDOUT</tt>, and <tt>STDERR</tt>.

The <tt>STDIN</tt> file handle is

used to connect to the standard input, usually the keyboard. You

can use the <tt>&lt;</tt> character

to override the standard input on the command line so that input

comes from a file instead of the keyboard. The <tt>STDOUT</tt>

file handle is used to connect to the standard output, usually

the monitor. The <tt>&gt;</tt> character

is used to override the standard output. And finally, the <tt>STDERR</tt>

file handle is used when you want to output error messages. <tt>STDERR</tt>

usually points to the computer's monitor.

<p>

The diamond operator (<tt>&lt;&gt;</tt>)

is used to read an entire line of text from a file. It stops reading

when the end of line character-the newline-character is read.

The returned string always iNCludes the newline character. If

no file handle is used with the diamond operator, it will attempt

to read from files listed in the <tt>@ARGV</tt>

array. If that array is empty, it will read from <tt>STDIN</tt>.

<p>

Next, you read about Perl's file test operators. There are way

too many to recap here, but some of the more useful ones are the

-d used to test for a directory name, -e used to see if a file

exists, and -w to see if a file can be written to. The special

file handle, _, can be used to prevent Perl from making a second

system call if you need to make two tests on the same file one

right after another.

<p>

A table of file fuNCtions (refer to Table 9.3) was shown which

shows many fuNCtions that deal with opening files, reading and

writing information, and closing files. Some fuNCtions were specific

to UNIX, although not many.

<p>

You learned how to open a file and that files can be opened for

input, for output, or for appending. When you read a file, you

can use text mode (the default) or binary mode. In binary mode

on DOS systems, line endings are read as two characters-the line

feed and the carriage return. On both DOS and UNIX systems, binary

mode lets you read the end of file character as regular characters

with no special meaning.

<p>

Reading file information directly from the directory was shown

to be very easy by using the <tt>opendir()</tt>,

<tt>readdir()</tt>, and <tt>closedir()</tt>

fuNCtions. An example was given that showed how to find all files

with an extension of PL by using the <tt>grep()</tt>

fuNCtion in conjuNCtion with <tt>readdir()</tt>.

<p>

Then, we looked closely at the <tt>print()</tt>

and <tt>printf()</tt> fuNCtions. Both

can be used to send output to a file handle. The <tt>select()</tt>

fuNCtion was used to change the default handle from <tt>STDOUT</tt>

to another file. In addition, some examples were given of the

formatting options available with the <tt>printf()</tt>

fuNCtion.

<p>

The topic of globbing was briefly touched on. Globs let you specify

a file name using wildcards. A list of file names is returned

that can be processed like any other array.

<p>

And finally, you read about how to split a record into fields

based on a separator character.

<p>

This chapter covered a lot of ground. And some of the examples

did not relate to each other. Instead, I tried to give you a feel

for the many ways that files can be used. An entire book can be

written on the different ways to use files. But, you now know

enough to create any kind of file that you might need.

<p>

<a HREF="ch10.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch10.htm">Chapter 10</a>, &quot;Regular Expressions,&quot; will cover this difficult

topic. In fact, Perl's regular expressions are one of the main

reasons to learn the language. Few other languages will give you

equivalent fuNCtionality.

<h2><a NAME="ReviewQuestions"><font SIZE="5" COLOR="#FF0000">

Review Questions</font></a></h2>

<p>

Answers to Review Questions are in Appendix A.

<ol>

<li>What is a file handle?

<li>What is binary mode?

<li>What is a fully qualified file name?

<li>Are variables in the computer's memory considered persistent

storage?

<li>What is the <tt>&lt;&gt;</tt>

operator used for?

<li>What is the default file handle for the <tt>printf()</tt>

fuNCtion?

<li>What is the differeNCe between the following two open statements?

<br>

<br>

<tt>open(FILE_ONE, &quot;&gt;FILE_ONE.DAT&quot;);

<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;open(FILE_TWO, &quot;&gt;&gt;FILE_TWO.DAT&quot;);</tt>

<li>What value will the following expression return?<br>

<br>

&nbsp;<tt>(stat(&quot;09lst01.pl&quot;))[7];</tt>

<li>What is globbing?

<li>What will the following statement display?<br>

<br>

<tt>printf(&quot;%x&quot;, 16);</tt>

</ol>

<h2><a NAME="ReviewExercises"><font SIZE="5" COLOR="#FF0000">

Review Exercises</font></a></h2>

<ol>

<li>Write a program to open a file and display each line along

with its line number.

<li>Write a program that prints to four files at oNCe.

<li>Write a program that gets the file statistics for <tt>PERL.EXE</tt>

and displays its size in bytes.

<li>Write a program that uses the <tt>sysread()</tt>

fuNCtion. The program should first test the file for existeNCe

and determine the file size. Then the file size should be passed

to the <tt>sysread()</tt> fuNCtion

as one of its parameters.

<li>Write a program that reads from the file handle in the following

line of code. Read all of the input into an array and then sort

and print the array.<br>

<br>

<tt>open(FILE, &quot;dir *.pl |&quot;);</tt>

<li>Using the binary mode, write a program that reads the <tt>PERL.EXE</tt>

and print any characters that are greater than or equal to &quot;A&quot;

and less than or equal to &quot;Z.&quot;

<li>Write a program that reads a file with two fields. The first

field is a customer ID and the second field is the customer name.

Use the ! character as a separator between the fields. Store the

information into a hash with the customer id as the key and the

customer name as the value.

<li>Write a program that reads a file into a array, then displays

20 lines at time.

</ol>

<hr>



<center><p><a HREF="ch8.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch8.htm"><img SRC="pc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/pc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="#CONTENTS"><img SRC="cc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/cc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="index-1.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/index-1.htm"><img SRC="hb.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/hb.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<a HREF="ch10.htm" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/ch10.htm"><img SRC="nc.gif" tppabs="http://202.113.16.101/%7eeb%7e/Perl%205%20By%20Example/nc.gif" BORDER="0" HEIGHT="88" WIDTH="140"></a>

<hr WIDTH="100%"></p></center>

</body>

</html>

