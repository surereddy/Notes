<HTML>

<HEAD>

<TITLE>Chapter 8 -- Understanding Basic User Authentication</TITLE>



<META>

</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">

<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;8</FONT></H1>

<H1><FONT SIZE=6 COLOR=#FF0000>Understanding Basic User Authentication</FONT>

</H1>

<P>

<I><B>by Paul Doyle</B></I>

<HR>

<P>

<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>

<UL>

<LI><A HREF="#BasicUserAuthentication">

Basic User Authentication</A>

<UL>

<LI><A HREF="#ProcessesandUserIDs">

Processes and User IDs</A>

<LI><A HREF="#CGIProgramExecution">

CGI Program Execution</A>

<LI><A HREF="#AccessControl">

Access Control</A>

<LI><A HREF="#UserIdentification">

User Identification</A>

</UL>

<LI><A HREF="#UserAuthenticationontheApacheServer">

User Authentication on the Apache Server</A>

<UL>

<LI><A HREF="#AccessRestrictions">

Access Restrictions</A>

<LI><A HREF="#ApacheConfigurationFiles">

Apache Configuration Files</A>

<LI><A HREF="#ConfigurationDirectives">

Configuration Directives</A>

</UL>

<LI><A HREF="#UserAdministration">

User Administration</A>

<UL>

<LI><A HREF="#AddingUsers">

Adding Users</A>

<LI><A HREF="#DeletingUsers">

Deleting Users</A>

<LI><A HREF="#ChangingPasswords">

Changing Passwords</A>

<LI><A HREF="#AddingUserstoGroups">

Adding Users to Groups</A>

<LI><A HREF="#DeletingUsersfromGroups">

Deleting Users from Groups</A>

</UL>

<LI><A HREF="#FromHere">

From Here   </A>

</UL>



<HR>

<P>

One reason why the Web has grown so quickly is that it is a very

open environment. Services are set up for anyone who cares to

use them, quite often with the aim of attracting as many users

as possible.

<P>

Sometimes, though, services need to be restricted so that only

designated people can use them. Restrictions can apply to files

or directories, with different levels of access for different

users. With such restrictions in place, authenticating the identity

of all users who attach to the server is a priority.

<P>

This chapter explains how user authentication works and tells

you how to set up and administer user accounts on an Apache Web

server. This chapter is not about Perl per se, but is intended

primarily to serve as a foundation for the rest of the chapters

in Part III, &quot;Authentication and Site Administration.&quot;

<H2><A NAME="BasicUserAuthentication"><FONT SIZE=5 COLOR=#FF0000>

Basic User Authentication</FONT></A></H2>

<P>

A read-only Web service that is open to everyone presents no particular

security problems. The files are made available in read-only mode,

and the Web server process presents the files to any users who

request them. As long as basic precautions are taken with regard

to access rights to the files and the parent directory, the service

is secure.

<P>

A service in which the user has write access to one or more files

is a little more complex. The Guestbook example in <A HREF="ch2.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch2.htm" >Chapter 2</A>

&quot;Introduction to CGI,&quot; is an example of this type of

service. Actually, the user does not really write to any files;

the Web server process does that on the user's behalf. Making

such a service secure means granting the Web server process the

appropriate access restrictions (read-only to all files except

the ones that it needs to write to) and making sure that your

CGI program does not offer the end user any security loopholes,

such as executing arbitrary strings involving user input through

a HTML form.

<P>

The type of service with which this chapter is concerned has access

restrictions that involve one or more of the following complexities:

<UL>

<LI>Only designated users can use the service, and only when they

provide a valid user ID and password.

<LI>Not all users who can access the service are allowed to use

all functions. Some users may be able to update data files through

a HTML form, for example; others can read data only.

<LI>Users from some Internet addresses may be allowed to use the

system; users from other addresses may not.

</UL>

<P>

Restrictions such as these are more relevant when you are using

CGI programs than when plain old HTML files are involved. To understand

why, you need to look at the way in which a Web server works.

<H3><A NAME="ProcessesandUserIDs">

Processes and User IDs</A></H3>

<P>

A Web server consists of a networked computer running special

software under a special user ID. The fact that all three elements-hardware,

software, and process-are referred to as Web servers in different

contexts isn't very helpful. For clarity, I'll use the following

definitions:

<UL>

<LI>The <I>Web server</I> is the entire system: hardware, software,

and process.

<LI>The <I>HTTP daemon (httpd)</I> is the Web server software.

<LI>The <I>httpd process</I> is the process under which the Web

server software is running.

<LI>The <I>httpd user ID</I> is the user ID under which the httpd

is executed.

</UL>

<P>

So the <I>httpd</I> runs as the <I>httpd process</I> under the

<I>httpd user ID </I>on the <I>Web server</I>.

<H3><A NAME="CGIProgramExecution">

CGI Program Execution</A></H3>

<P>

The central issue here is that all file accesses on the Web server

are performed by an httpd process. For this process to be capable

of serving up files from many different directories, it must run

under a user ID with relatively liberal access rights. If the

process is to run CGI programs, too, it probably will require

generous write access throughout the same directories.

<P>

This access is a security risk, however, because the process executes

CGI programs under the httpd user ID on behalf of users from elsewhere

on the Internet. In effect, you are allowing complete strangers

to run programs on your system with a privileged user ID. A CGI

program potentially can do anything on the server machine that

a user who logged in under the httpd user ID could do, including

reading, writing, creating, and deleting files. So if you're not

careful, you can open your server to attack from anywhere on the

Internet.

<P>

By default, the httpd user ID is the ID of the process that executes

it. This user ID should not be root! Create a special user ID

with limited privileges to start the httpd. Then you can start

the httpd by using this user ID. Alternatively, if you are using

the Apache httpd, use the User and Group configuration directives

(described in &quot;Apache Server Configuration Directives&quot;

later in this chapter) to get httpd to switch user IDs at startup

time.

<H3><A NAME="AccessControl">

Access Control</A></H3>

<P>

The server's user ID is, of course, subject to access restrictions

in the same way that any other user ID on the system is. But because

you need to give the server read and write access to so many places,

and because you also allow it to perform tasks on behalf of complete

strangers, you need to introduce an extra layer of access control.

<P>

It is important to note here that this extra layer involves user

IDs and passwords that belong to the server, not to the host system.

In other words, the Web server has a password file that is separate

from the /etc/passwd file on UNIX systems. Having a logon account

on a system does not guarantee that a user can use a restricted

Web page on the server, even if the user has read access to that

page when logged on interactively. The opposite also is true-a

user who doesn't have a logon ID can access restricted Web pages

on the server if that user has the appropriate Web server user

ID and password.

<P>

The extra security layer takes a different form for each HTTP

server package, but in essence, this layer has two strands:

<UL>

<LI>A mechanism for identifying all users who attempt to attach

<LI>A set of rules governing access rights on the server (who

can access which files and what they can do with those files)

</UL>

<P>

The &quot;User Authentication on the Apache Server&quot; section

later in this chapter describes how access restrictions work on

the Apache server and how to implement restrictions that are appropriate

for your site. First, however, you need to consider the issues

that are involved in verifying a user's identity.

<H3><A NAME="UserIdentification">

User Identification</A></H3>

<P>

The effectiveness of your server's access restrictions depends

on whether you can authenticate the identity of users who attempt

to attach to your server. If you can't confirm that a user is

who he says he is, you may as well make everything read-only and

remove all sensitive information that you don't want to publish

to the world.

<P>

Fortunately, you can check the identity of users in many ways.

This section describes the most useful methods, starting with

a simple unencrypted password check and moving to secure HTTP

using public key cryptography.

<P>

<B>User ID and Password&nbsp;&nbsp;</B>The most basic kind of

authentication is a simple user ID and password check against

a list of user IDs and passwords in a file. Users initially connect

to a CGI script on the server that challenges them for a user

ID and password. If a user enters a valid combination, the script

displays another page or sends a HTTP redirect header to the browser

to force it to load the other page.

<P>

This rather facile approach to authentication is weak for three

reasons:

<UL>

<LI><B>Privacy.</B> The user ID and password are transmitted over

the network in plain text.

<LI><B>Verification.</B> There is no guarantee that the user ID

and password were not sent by some user other than the person

who is entitled to use them.

<LI><B>Manageability.</B> This method can make it difficult to

manage access to multiple pages.

</UL>

<P>

The following sections examine these reasons in detail.

<P>

<I><B>Privacy&nbsp;&nbsp;</B></I>Given the openness of the Internet,

you should assume that all transmissions-messages, Web pages,

or (in this case) parts of a HTTP request-can be intercepted.

If a transmission is sent in plain text and is intercepted, its

contents become known to the person who intercepted it. If the

transmission is encrypted in some way and is intercepted, the

original content will not be known to the interceptor without

substantial extra effort.

<P>

Encrypting the content of transmissions on the Internet is, therefore,

a means of ensuring privacy. If a user ID and password are sent

in plain-text mode, they might be used subsequently in a so-called

impostor attack. This type of attack occurs when somebody other

than the owner of the user ID-password pair attempts to use the

pair to access the server. Encrypting the user ID and password

before they are sent to the server protects them from the bad

guys and helps ensure user authentication. Encryption by itself,

however, does not provide authentication.

<P>

<I><B>Verification</B></I><B>&nbsp;&nbsp;</B>Assume that the user

ID and password have been discovered by a person who should not

have access to a service. This person may have made this discovery

in any of several ways: intercepting a user ID-password pair sent

as plain text; intercepting and successfully decrypting an encrypted

user ID-password pair, although this event is unlikely; or watching

the real owner of the pair type them, which is a more likely event.

If no other checks are in place, this miscreant can then access

the service from any Internet location.

<P>

You can encrypt transmissions in such a way that:

<UL>

<LI>Only the intended recipient can decrypt them

<LI>The recipient can be sure that the transmission originated

where it claims to have originated

</UL>

<P>

These methods are described in detail in &quot;Public Key Cryptography&quot;

later in this chapter.

<P>

<I><B>Manageability&nbsp;&nbsp;</B></I>The simple user ID-password

methodology outlined in the preceding section is simple only if

it is used to control access to a single location. If this method

is extended to several CGI programs that form a single system,

coordinating the activities of all the CGI programs can be difficult.

Users may have authenticated themselves upon accessing one CGI

program, but they will have to authenticate themselves again if

they access the same program a second time (or access a different

CGI program that forms part of the same system).

<P>

The basic idea outlined here, however, can be developed to the

stage at which a single CGI script manages access to a set of

other files, so that users need to validate themselves only one

time. This type of system is examined in detail in <A HREF="ch9.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch9.htm" >Chapter 9</A>

&quot;Understanding CGI Security.&quot;

<P>

<I><B>User ID and Password Summary</B>&nbsp;&nbsp;</I>A simple

user ID-password mechanism has flaws. The basic principle is sound,

though: Users must say who they are (user ID) and then prove it

(password). The mechanism is adequate as it stands for services

in which security is a low priority, but it needs to be developed

a little to allow for really secure transactions. The following

section, &quot;Public Key Cryptography,&quot; outlines the current

best technology to achieve secure user authentication and describes

some of the products that use it.

<P>

<B>Public Key Cryptography&nbsp;&nbsp;</B>The main problem with

the simple user ID-password schema outlined in the preceding sections

is the fact that the origin of the user ID-password pair cannot

be verified. The problem of adequate verification extends to many

other areas on the Internet, including the contents of messages

themselves. But in this case, you're concerned only with ensuring

adequate verification of a user's identity before allowing that

user to access your CGI scripts or Web pages.

<P>

<I>Public key cryptography</I> is a method of transmitting data

from a sender to a recipient in such a way that nobody other than

the recipient can receive the data and the recipient can be certain

of the identity of the sender.

<P>

The basic idea underlying public key cryptography is the use of

a pair of keys:

<UL>

<LI>The <I>private key</I> is kept secret by its owner and is

used to decrypt encrypted messages sent by other people.

<LI>The <I>public key</I> is advertised widely and is used by

people other than the owner to encrypt messages before sending

them to the owner.

</UL>

<P>

The public and private keys are derived simultaneously, using

a special algorithm in such a way that messages encrypted with

a person's <I>public</I> key can be decrypted only with that person's

<I>private</I> key. Likewise, messages encrypted with a person's

<I>private</I> key can be decrypted only with that person's <I>public</I>

key.

<P>

<I><B>Key Pairs&nbsp;&nbsp;</B></I>Suppose that I want to send

a message to you, using public key cryptography. You have a public

and a private key. You tell me your public key, perhaps by including

it in your e-mail signature, but you keep your private key to

yourself. This is what happens:

<OL>

<LI>I encrypt the original message text, using your public key,

and then send the encrypted message to you.

<LI>You receive the message in encrypted form and then decrypt

it, using your private key.

</OL>

<P>

The details of how messages are encrypted and decrypted with particular

key strings are beyond the scope of this book.

<P>

This transmission is secure in the sense that anybody else who

receives the message while it travels across the network in encrypted

form will be unable to determine the original content of the message

without knowing the value of your private key. In theory, someone

could crack the code and read the message, but the amount of effort

required runs into so many thousands of hours on a powerful computer

that the possibility is a concern only if you are, say, a major

world power. Even then, cracking a single transmission is of no

use for cracking other transmissions if you change your key pair

on a regular basis.

<P>

<I><B>Certificate Authorities&nbsp;&nbsp;</B></I>The problem with

the scheme described in the preceding section is the fact that

your public key is unverified. How do I know that the public key

really is your public key and not a public key generated by some

impostor who wants to intercept messages to you? When public key

cryptography is used to protect mail messages, this problem is

not too serious-the impostor would have to establish e-mail communication

with me for long enough to convince me that he is you, before

he transmits the fake public key. This situation is possible,

though.

<P>

The problem is much more acute when public key cryptography is

used to automatically verify transmissions between two Internet

hosts, such as a Web server and a client running a Web browser.

The reason is that the public key is transmitted during the same

dialogue as the transmission of the secure message that is encrypted

with that key value. No opportunity exists to develop trust through

a person-to-person dialogue, such as an exchange of e-mail messages.

<P>

That's where certificate authorities come into the picture. <I>Certificate

authorities</I> are companies that are trusted to issue certificates

to Internet users and to verify the contents of those certificates

at a later stage.

<P>

A certificate contains the following information:

<UL>

<LI>The identity of the certificate-issuing authority

<LI>The identity of the person or organization on whose behalf

the certificate is issued

<LI>The public key of the person or organization on whose behalf

the certificate is issued

</UL>

<P>

Certificates cost money and are issued at the request of the person

or organization to which they refer. The certificates are used

as a trusted point of referral by the recipient of an encrypted

message, to verify that the sender really is who he or she claims

to be.

<P>

In terms of the earlier example, here's how I would go about sending

you an encrypted message, using certificate verification:

<OL>

<LI>I send a message to you, asking for your certificate.

<LI>You send your certificate to me.

<LI>I check with the certificate issuer to see whether the certificate

is valid. Specifically, I want to know that the issuer really

did issue the certificate on your behalf and that your public

key is the same as the public key stated in the certificate.

<LI>I receive confirmation from the certificate issuer that the

certificate is valid.

<LI>I encrypt the original message text, using your public key,

and then send the encrypted message to you.

<LI>You receive the message in encrypted form and then decrypt

it, using your private key.

</OL>

<P>

As is true of all Internet communications, the possibility always

exists that someone will attempt to impersonate the entity with

which you are dealing, so as to eavesdrop on your communications.

When you deal with a certificate authority, that company's reputation

is your guarantee. Attempting to impersonate a certificate authority

brings tremendous wrath down on the head of any malefactor-a great

deterrent to that form of impersonation.

<P>

Now suppose that you receive a message from me, encrypted with

my private key, and you want to decrypt it while making sure that

it really did come from me. This is what would happen:

<OL>

<LI>I encrypt the original message text, using my private key,

and then send the encrypted message to you, along with details

of my certificate.

<LI>You receive the message in encrypted form.

<LI>You check with the certificate issuer to verify that my public

key is correct.

<LI>You decode the message, using my public key.

</OL>

<P>

Remember-all this works because of the unique properties of the

public-private key pair. In this example, information on my public

key is freely available and verifiable. Only messages that are

encrypted with the corresponding private key can be decrypted

with this public key. That fact means that nobody can fake messages

from me without knowing my private key.

<P>

Public key cryptography is an algorithmic method. The algorithms

that do the real work-deriving public and private keys, and encrypting

and decrypting data-were developed by RSA Data Security, Inc.

RSA does not produce any end-user software for performing authentication;

instead, it licenses its algorithms to other companies for incorporation

into their products.

<P>

To ensure secure communications between a server and a browser,

you need both the server and the browser to execute these algorithms

automatically, behind the scenes, acting under an agreed protocol.

The next two sections, &quot;Secure HTTP&quot; and &quot;Secure

Sockets Layer,&quot; discuss two products that use RSA's public

key cryptography technology to authenticate Web communications.

<P>

<I><B>Secure HTTP&nbsp;&nbsp;</B></I>Secure HTTP (S-HTTP) is an

extension of the HTTP protocol developed by Enterprise Integration

Technologies (EIT); the National Center for Supercomputing Applications

(NCSA); and RSA Data Security, Inc. S-HTTP uses public key cryptography

to guarantee the authenticity of signed transmissions, allowing

for comprehensive user verification. Although the S-HTTP protocol

specification is public, the toolkit necessary to build applications

that use it is a commercial product. S-HTTP has not yet become

prominent on the Web.

<P>

<B>Secure Sockets Layer&nbsp;&nbsp;</B>Netscape Communications

has approached the authentication issue from a different angle.

Netscape has licensed RSA's public key cryptography technology

and used it to developed a security protocol called Secure Sockets

Layer (SSL). This layer resides between TCP/IP (the communications

layer) and HTTP (the applications layer). Netscape states that

SSL will support other application protocols, such as NNTP, but

that support has not materialized yet.

<P>

Netscape has developed another proprietary extension of the HTTP

protocol to support SSL on Web servers. This extension is called

<I>https</I>, and URLs that are to be delivered through SSL need

to have the prefix <TT>https:</TT> instead of <TT>http</TT>. A

Web server that supports SSL normally watches for <TT>http</TT>

requests on port 80 and <TT>https</TT> requests on port 443. The

use of two separate ports makes it possible for a server to communicate

securely with clients that support https while providing normal,

unauthenticated communications with other browsers.

<P>

<B>User Verification Summary&nbsp;&nbsp;</B>The fields of cryptography

and secure communications are much too vast to cover in detail

in this book, and doing so wouldn't be appropriate anyway-this

is a Perl book, after all. But understanding the different types

of user authentication is important, especially if you're going

to introduce user authentication on your Web server. The last

few pages should be enough to give you a flavor for the various

types of user authentication and the current trends in authentication

technology.

<P>

If your server uses S-HTTP or SSL technology, authentication becomes

a matter of server configuration, so your Perl programs don't

need to concern themselves with it. If your server doesn't use

either technology, you must provide authentication yourself, in

your Perl programs. Your Internet Service Provider may not be

able or willing to provide support of this kind on its server,

for example. <A HREF="ch9.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch9.htm" >Chapter 9</A> &quot;Understanding CGI Security,&quot;

describes a method for implementing user authentication on a Web

server entirely by means of Perl. This method works with or without

an authentication-aware protocol such as https or S-HTTP.

<P>

If you need to be absolutely certain of the identity of anyone

who is accessing your CGI/Perl programs, you have to use a certificate

authority via S-HTTP, SSL, or some other method. If you want to

make it difficult for people to fake their identity, a simple

user ID-password system may be more appropriate. You may decide

to combine the two approaches, requiring a user ID and password

for your Perl script even if it runs on a secure server. Ultimately,

the level of security that you choose depends on the sensitivity

of your data and your estimate of the risk involved.

<H2><A NAME="UserAuthenticationontheApacheServer"><FONT SIZE=5 COLOR=#FF0000>

User Authentication on the Apache Server</FONT></A></H2>

<P>

Assuming that you can satisfactorily verify the identity of all

users who attach to your server, you need to implement a strategy

that gives users of your server enough access to do the things

that you want them to be able to do, but not enough access to

do the things that you <I>don't</I> want them to be able to do.

This section describes the specific details of user authentication

on the Apache server.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

This section focuses on access restrictions for the Apache httpd server only; the chapter can't cover all features of all Web servers. Apache is fairly representative, being a superset of the NCSA httpd server. Apache also is an excellent piece of work 
and currently is the most popular Web server software in the world.</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<H3><A NAME="AccessRestrictions">

Access Restrictions</A></H3>

<P>

You can use two basic parameters to restrict access to a service:

<UL>

<LI><B>Host IP address.</B> Access can be restricted to individual

Internet nodes or subnets by IP address. Users who access the

service from these nodes do not need to provide a user ID or password.

<LI><B>User.</B> Access can be restricted to individual users

or groups of users. All users who attempt to access the service

are challenged for a user ID and password. Those who enter a valid

combination are allowed to access the requested file; those who

enter invalid combinations are denied access.

</UL>

<P>

Access can be restricted for one or more HTTP access methods (<TT>GET</TT>,

<TT>PUT</TT>, <TT>POST</TT>, and so on) for users, groups, IP

addresses, subnets, or a combination.

<H3><A NAME="ApacheConfigurationFiles">

Apache Configuration Files</A></H3>

<P>

All aspects of configuration of the Apache server are controlled

by a number of configuration files. Each file contains several

configuration directives, each of which controls a specific aspect

of Apache behavior in a specific directory tree. Table 8.1 lists

the configuration files, in the order in which they are processed

by the server. The default file specs shown in the table are relative

to the server root directory.<BR>

<P>

<CENTER><B>Table 8.1&nbsp;&nbsp;Apache Server Configuration Files</B></CENTER>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>File</B></TD><TD><B>Default File Spec</B>

</TD><TD><B>Override With</B></TD><TD><B>Controls</B>

</TD></TR>

<TR VALIGN=TOP><TD>Server configuration</TD><TD><TT>conf/httpd.conf</TT>

</TD><TD>httpd's <TT>-d </TT>command-line switch</TD>

<TD>Server daemon</TD></TR>

<TR VALIGN=TOP><TD>Resource configuration</TD><TD><TT>conf/srm.conf</TT>

</TD><TD><TT>ResourceConfig </TT>directive</TD><TD>Document provision

</TD></TR>

<TR VALIGN=TOP><TD>Access configuration</TD><TD><TT>conf/access.conf</TT>

</TD><TD><TT>AccessConfig </TT>directive</TD><TD>Access permissions

</TD></TR>

</TABLE></CENTER>

<P>

<P>

Additional configuration directives can be stored in a special

file in each directory to provide a fine level of access control.

The per-directory configuration file is called .htaccess by default,

but you can override this name with the <TT>AccessFileName</TT>

directive (described in &quot;Apache Server Configuration Directives&quot;

later in this chapter).

<P>

<B>Filtering of Rights&nbsp;&nbsp;</B>The directives in the .htaccess

files control server behavior with regard to files in the directory

tree in which the .htaccess file is stored. Notice that the directives

in a .htaccess file propagate through subdirectories. An attempt

to access a file causes the server to look for a file called .htaccess

in the directory in which the file is stored, in the parent directory

of that subdirectory, in the parent's parent directory, and so

on up to the server's document root directory. The .htaccess files

found in this fashion are parsed in sequence, with directives

in .htaccess files in lower-level subdirectories overriding directives

in higher-level directories.

<P>

<B>Realms, Users, and Groups&nbsp;&nbsp;</B>The information used

to determine whether a user has access to a particular directory

on the server is specific to the httpd server. The access-control

mechanism used by the system on which httpd executes is not involved.

So on UNIX systems, the contents of /etc/passwd are not relevant.

<P>

Instead, user information is stored in several user and group

files, which can be either plain text or DBM files. Group definitions

can be omitted if access is to be defined on a user-by-user basis.

<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>CAUTION</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

User and group files should be stored in a location that is not exported by the Web server. Otherwise, users may be able to download them and thereby breach your server's security.</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

User and group definitions apply to a particular authorization

realm. An <I>authorization realm</I> is a set of directories for

which access rights are evaluated as a unit. The concept of authorization

realms allows a user to access any directory in a designated set

on the basis of a single authentication pass. This means that

users are prompted for their user ID and password only one time

during a session: the first time that they attempt to access a

URL within the realm.

<P>

<B>Configuration Delimiters&nbsp;&nbsp;</B>Configuration directives

appear, one per line, in any of these configuration files. Directives

can be grouped by means of the &lt;Directory&gt;...&lt;/Directory&gt;

and &lt;Limit&gt;...&lt;/Limit&gt; delimiters, as follows:

<UL>

<LI>The <TT>&lt;Directory&gt;</TT> and <TT>&lt;/Directory&gt;</TT>

delimiters enclose a set of directives that apply to the named

directory. The following configuration statements, for example,

allow the server to follow symbolic links in the /usr/local/projects

directory:<BR>

<TT>&lt;Directory /usr/local/projects&gt;<BR>

Options FollowSymLinks<BR>

&lt;/Directory&gt;<BR>

</TT>The <TT>Options</TT> directive is explained later

in this chapter.

<LI>The <TT>&lt;Limit&gt;</TT> and <TT>&lt;/Limit&gt;</TT> delimiters

enclose a set of directives that apply only to certain access

methods (<TT>GET, POST,</TT> and so on). The following configuration

statements allow the server to follow symbolic links in the /usr/local/projects

directory for <TT>GET</TT> requests only:<BR>

<TT>&lt;Directory /usr/local/projects&gt;<BR>

&lt;Limit GET&gt;<BR>

Options FollowSymLinks<BR>

&lt;/Limit&gt;<BR>

&lt;/Directory&gt;</TT>

</UL>

<P>

Directory groups can contain <TT>Limit</TT> groups, but no other

nesting of delimiters is permitted. This means that <TT>Limit</TT>

groups may not contain either <TT>Limit</TT> or <TT>Directory</TT>

groups, and <TT>Directory</TT> groups may not contain <TT>Directory</TT>

groups.

<H3><A NAME="ConfigurationDirectives">

Configuration Directives</A></H3>

<P>

The authentication-related configuration directives for the Apache

httpd are listed in tables 8.2 through 8.4. Directives related

to server configuration are listed in Table 8.2; directives that

can be used in local .htaccess files are listed in Table 8.3;

and directory-specific configuration directives are listed in

Table 8.4.

<P>

Notice that a certain amount of overlap occurs among these tables,

because some directives can be used in more than one context.

Those directives that are relevant to user authentication and

access restriction are described in separate sections after each

table. Refer to the Apache server documentation for detailed information

on all directives, including the ones described in this chapter.

<P>

<B>Apache Server Configuration Directives&nbsp;&nbsp;</B>Table

8.2 lists the directives that can be used in the server configuration

files.<BR>

<P>

<CENTER><B>Table 8.2&nbsp;&nbsp;Apache HTTPD Server Configuration

Directives</B></CENTER>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD WIDTH=151><B>Directive</B></TD><TD WIDTH=142><B>Argument Type</B>

</TD><TD WIDTH=142><B>Default Value</B></TD><TD WIDTH=142><B>Purpose</B>

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>AccessConfig</TT></TD><TD WIDTH=142>File name

</TD><TD WIDTH=142><TT>conf/access.conf</TT></TD><TD WIDTH=142>Name of file containing access-control directives

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>AccessFileName</TT></TD><TD WIDTH=142>File name

</TD><TD WIDTH=142><TT>.htaccess</TT></TD><TD WIDTH=142>Name of per-directory access-control file

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>BindAddress</TT></TD><TD WIDTH=142>IP address

</TD><TD WIDTH=142><TT>*</TT> (all IP addresses)</TD><TD WIDTH=142>IP address of server to listen on

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>DefaultType</TT></TD><TD WIDTH=142>MIME type

</TD><TD WIDTH=142><TT>text/html</TT></TD><TD WIDTH=142>Default type for documents with no MIME type specifier

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>DocumentRoot</TT></TD><TD WIDTH=142>Directory name 

</TD><TD WIDTH=142><TT>/usr/local/etc/</TT></TD><TD WIDTH=142>Name of top-level directory from

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151>&nbsp;</TD><TD WIDTH=142>&nbsp;</TD><TD WIDTH=142><TT>httpd/htdocs</TT>

</TD><TD WIDTH=142>which files will be served</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>ErrorDocument</TT></TD><TD WIDTH=142>Error code

</TD><TD WIDTH=142>-</TD><TD WIDTH=142>Specifies which document to return in the event of a given error code

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>ErrorLog</TT></TD><TD WIDTH=142>File name

</TD><TD WIDTH=142><TT>logs/error_log</TT></TD><TD WIDTH=142>Name of server error log file

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>GroupUnix</TT></TD><TD WIDTH=142>Group ID

</TD><TD WIDTH=142><TT>#-1</TT></TD><TD WIDTH=142>Name or number of user group under which server will run

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>IdentityCheck</TT></TD><TD WIDTH=142>on/off

</TD><TD WIDTH=142><TT>off</TT></TD><TD WIDTH=142>Whether to try to log remote user names

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>MaxClients</TT></TD><TD WIDTH=142>Number

</TD><TD WIDTH=142><TT>150</TT></TD><TD WIDTH=142>Maximum number of clients that theserver will support

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>MaxRequests</TT>&aring; <TT>PerChild</TT>

</TD><TD WIDTH=142>Number</TD><TD WIDTH=142>-</TD><TD WIDTH=142>Maximum number of<TT> </TT>requests that the server will  handle simultaneously for any one client

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>MaxSpare</TT>&aring; <TT>Servers</TT></TD>

<TD WIDTH=142>Number</TD><TD WIDTH=142><TT>10</TT></TD><TD WIDTH=142>Maximum number of desired idle processes

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>MinSpare</TT> &aring; <TT>Servers</TT> &aring;

</TD><TD WIDTH=142>Number</TD><TD WIDTH=142><TT>5</TT></TD><TD WIDTH=142>Minimum desired idle options

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>Options</TT> &aring;</TD><TD WIDTH=142>List of options

</TD><TD WIDTH=142>-</TD><TD WIDTH=142>Defines which server features are allowed

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>PidFile</TT></TD><TD WIDTH=142>File name

</TD><TD WIDTH=142><TT>logs/</TT></TD><TD WIDTH=142>Name of file where server daemon process ID is  stored 

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151>&nbsp;</TD><TD WIDTH=142>&nbsp;</TD><TD WIDTH=142><TT>httpd.pid</TT>

</TD><TD WIDTH=142>&nbsp;</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>Port</TT></TD><TD WIDTH=142>Port number

</TD><TD WIDTH=142><TT>80</TT></TD><TD WIDTH=142>Port number where server listens for requests

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>ResourceConfig</TT></TD><TD WIDTH=142>File name

</TD><TD WIDTH=142><TT>conf/</TT> <TT>srm.conf</TT></TD><TD WIDTH=142>Name of file to read forserver resource configuration details

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>ServerAdmin</TT></TD><TD WIDTH=142>E-mail address

</TD><TD WIDTH=142>-</TD><TD WIDTH=142>E-mail quoted by address server when reporting errors to client

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>ServerName</TT></TD><TD WIDTH=142>IP address

</TD><TD WIDTH=142>-</TD><TD WIDTH=142>Server's host name</TD>

</TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>ServerRoot</TT></TD><TD WIDTH=142>directory name

</TD><TD WIDTH=142><TT>/usr/local/ etc/httpd</TT></TD><TD WIDTH=142>Name of directory where httpd is stored

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>ServerType</TT></TD><TD WIDTH=142><TT>inetd/standalone</TT>

</TD><TD WIDTH=142><TT>standalone</TT></TD><TD WIDTH=142>Whether to run as one process per HTTP connection (<TT>inetd</TT>) or one process to handle all connections (<TT>standalone</TT>)

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>StartServers</TT></TD><TD WIDTH=142>Number

</TD><TD WIDTH=142><TT>5</TT></TD><TD WIDTH=142>Number of child processes to create at startup

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>TimeOut</TT></TD><TD WIDTH=142>Number</TD>

<TD WIDTH=142><TT>200</TT></TD><TD WIDTH=142>Maximum server wait time

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151><TT>User</TT></TD><TD WIDTH=142>User ID</TD>

<TD WIDTH=142><TT>#-1</TT></TD><TD WIDTH=142>User ID under which server will run

</TD></TR>

</TABLE></CENTER>

<P>

<P>

The server configuration directives that are relevant to user

authentication are explained in the following sections.

<P>

<TT><B>AccessConfig&nbsp;&nbsp;</B></TT>This

directive overrides the default access configuration file specification,

<TT>conf/access.conf</TT>, where access-control directives (such

as directory-specific restrictions) are supposed to be stored.

In fact, you can store these directives either in the access configuration

file or in the resource configuration file.

<P>

The following directive in the server configuration file tells

the server to read <TT>access_test.conf</TT> for directives instead

of <TT>conf/access.conf</TT>:

<BLOCKQUOTE>

<PRE>

AccessConfig conf/access_test.conf

</PRE>

</BLOCKQUOTE>

<P>

You can tell the server not to look for an access configuration

file by using the file spec <TT>/dev/null</TT> with the <TT>AccessConfig</TT>

directive.

<P>

<TT><B>AccessFileName&nbsp;&nbsp;</B></TT>Before

the server sends any file to a client, it looks in the directory

in which the file is stored for that directory's optional local

configuration file. You can override the default file name, .htaccess,

by using the <TT>AccessFileName</TT><I> </I>directive.

<P>

<TT><B>Group</B>&nbsp;&nbsp;</TT>Use

the <TT>Group</TT><I> </I>directive in conjunction with the <TT>User</TT><I>

</I>directive to control the access rights of the server process.

If you start the httpd server process as root, the <TT>Group</TT>

and <TT>User</TT><I> </I>directives cause the server to become

the designated user in the designated group before answering any

requests. By specifying a user ID and group that has access only

to those files that you want to export onto the Web, you can avoid

accidental exposure of sensitive information.

<P>

Apache recommends that you set up a special user ID and user group

to run the server process. This user ID normally should have access

only to the documents directory within the httpd directory tree

(normally, /etc/local/http/htdocs). You may want to grant read

access to the users' home directory tree as well if you want to

allow your users to maintain Web material in their home areas.

<P>

<TT><B>IdentityCheck&nbsp;&nbsp;</B></TT>Some

Web clients run a daemon that allows the client to provide the

user name of the remote user to the Web server on request. This

identification is not secure and should not be taken seriously;

it may be useful in some cases for crude access counts, but such

counts will be incomplete, because most clients do not provide

identification of this sort.

<P>

Setting the <TT>IdentityCheck</TT> directive to <TT>on</TT> instructs

httpd to ask clients to identify the remote user and, if an identity

is provided, to log this information in the server log file.

<P>

<TT><B>Options&nbsp;&nbsp;</B></TT>The

Apache httpd allows a great deal of control of the use of extra

server features on a directory-by-directory level. The <TT>Options</TT><I>

</I>directive allows you to turn extra server features on for

all directories (if used outside a <TT>Directory</TT> group) or

for a specific directory (if used within a <TT>Directory</TT>

group).

<P>

The <TT>Options</TT><I> </I>directive takes any combination of

the arguments in the following list and turns on the specific

feature described by that argument. The directive has two special

arguments: <TT>All</TT> turns on all extra server features, and

<TT>None</TT> turns them all off.

<UL>

<LI><TT>ExecCGI</TT>: allows execution of CGI scripts in the designated

directory. Use this directive for all directories in which you

intend to run Perl scripts.

<LI><TT>FollowSymLinks</TT>: allows the server to follow symbolic

links in the designated directory.

<LI><TT>Includes</TT>: allows the server to parse server-side

includes in HTML files.

<LI><TT>IncludesNOEXEC</TT>: allows the server to parse server-side

includes in HTML files, with the exception of the <TT>#exec</TT>

and <TT>#include</TT> commands.

<LI><TT>Indexes</TT>: allows the user to browse this directory.

If a browser requests a URL that points to a directory, and if

no index.html file is found in that directory, the server returns

a directory listing of the directory to the browser.

<LI><TT>MultiViews</TT>: allows content-negotiated <TT>MultiViews</TT>,

a feature that allows the server to return data in one of several

formats, depending on the capabilities of the browser.

<LI><TT>SymLinksIfOwnermatch</TT>: allows the server to follow

symbolic links in the designated directory only if the link points

to a file or directory owned by the same user who owns the link.

This security precaution is useful, because it prevents users

from making files available on the Web unless they own those files.

</UL>

<P>

<TT><B>ResourceConfig&nbsp;&nbsp;</B></TT>This

directive is quite similar to <TT>AccessConfig</TT><I> </I>and

is provided largely for backward compatibility. <TT>ResourceConfig</TT>

overrides the default resource configuration file specification,

<TT>conf/srm.conf</TT>, which is where resource control directives

are supposed to be stored. In fact, you can store the directives

either in the resource configuration file or in the server configuration

file.

<P>

The following directive in the server configuration file tells

the server to read <TT>srm_test.conf</TT> for directives instead

of <TT>conf/srm.conf</TT>:

<BLOCKQUOTE>

<PRE>

AccessConfig conf/srm_test.conf

</PRE>

</BLOCKQUOTE>

<P>

You can tell the server not to look for a resource configuration

file by using the file spec <TT>/dev/null</TT> with the <TT>ResourceConfig</TT><I>

</I>directive.

<P>

<TT><B>User&nbsp;&nbsp;</B></TT>Use

the <TT>User</TT> directive in conjunction with the <TT>Group</TT>

directive to control the access rights of the server process.

If you start the httpd server process as root, the <TT>Group</TT>

and <TT>User</TT> directives cause the server to become the designated

user in the designated group before answering any requests. By

specifying a user ID and group that has access only to those files

that you want to export onto the Web, you can avoid accidental

exposure of sensitive information.

<P>

The argument to the <TT>User</TT><I> </I>directive can be either

a user ID or a user number preceded by a pound sign (<TT>#</TT>).

<P>

Apache recommends that you set up a special user ID and user group

to run the server process. This user ID normally should have access

only to the documents directory within the httpd directory tree

(normally, /etc/local/http/htdocs). You may want to grant read

access to the users' home directory tree as well if you want to

allow your users to maintain Web material in their home areas.

<P>

<B>Apache Directory Directives&nbsp;&nbsp;</B>Table 8.3 lists

the directives that may be applied to individual directories.

These directives are used in server configuration files to override

default settings for a particular directory.<BR>

<P>

<CENTER><B>Table 8.3&nbsp;&nbsp;Apache HTTPD Directory Authorization

Directives</B></CENTER>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD WIDTH=115><B>Directive</B></TD><TD WIDTH=115><B>Argument Type</B>

</TD><TD WIDTH=115><CENTER><B>Default Value</B></CENTER></TD>

<TD WIDTH=230><B>Purpose</B></TD></TR>

<TR VALIGN=TOP><TD WIDTH=115><TT>allow from</TT></TD><TD WIDTH=115>List of hosts

</TD><TD WIDTH=115><CENTER>-</CENTER></TD><TD WIDTH=230>Allows access to this directory from the designated IP hosts

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=115><TT>deny from</TT></TD><TD WIDTH=115>List of hosts

</TD><TD WIDTH=115><CENTER>-</CENTER></TD><TD WIDTH=230>Denies access to this directory from the designated IP hosts

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=115><TT>order</TT></TD><TD WIDTH=115>Evaluation order

</TD><TD WIDTH=115><CENTER><TT>deny,allow</TT></CENTER></TD><TD WIDTH=230>Sets the order in which <TT>deny</TT> and <TT>allow</TT> directives are applied.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=115><TT>Require user</TT></TD><TD WIDTH=115>List of user IDs

</TD><TD WIDTH=115><CENTER>-</CENTER></TD><TD WIDTH=230>List of IDs of users who can access a directory

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=115><TT>require group</TT></TD><TD WIDTH=115>List of groups

</TD><TD WIDTH=115><CENTER>-</CENTER></TD><TD WIDTH=230>List of groups that can access a directory

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=115><TT>require</TT>  <TT>valid-user</TT></TD><TD WIDTH=115><CENTER>-</CENTER>

</TD><TD WIDTH=115><CENTER>-</CENTER></TD><TD WIDTH=230>Allows access to all users who provide a valid user ID and password

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=115><TT>AuthName</TT></TD><TD WIDTH=115>Domain name

</TD><TD WIDTH=115><CENTER>-</CENTER></TD><TD WIDTH=230>Name of authorization domain for a directory

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=115><TT>AuthType</TT></TD><TD WIDTH=115>Basic</TD>

<TD WIDTH=115><CENTER><TT>Basic</TT></CENTER></TD><TD WIDTH=230>Type of user authorization (only Basic available)

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=115><TT>AuthUserFile</TT></TD><TD WIDTH=115>File name

</TD><TD WIDTH=115><CENTER>-</CENTER></TD><TD WIDTH=230>Name of text file containing list of users and passwords

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=115><TT>AuthDBM</TT>  <TT>UserFile</TT></TD><TD WIDTH=115>File name

</TD><TD WIDTH=115><CENTER>-</CENTER></TD><TD WIDTH=230>Name of DBM file containing list of users and passwords

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=115><TT>AuthGroupFile</TT></TD><TD WIDTH=115>File name

</TD><TD WIDTH=115><CENTER>-</CENTER></TD><TD WIDTH=230>Name of text file containing list of user groups

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=115><TT>AuthDBM</TT>  <TT>GroupFile</TT></TD><TD WIDTH=115>File name

</TD><TD WIDTH=115><CENTER>-</CENTER></TD><TD WIDTH=230>Name of DBM file containing list of user groups

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=115><TT>Options</TT></TD><TD WIDTH=115>List of options

</TD><TD WIDTH=115><CENTER>-</CENTER></TD><TD WIDTH=230>Defines which server features are allowed

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=115><TT>Allow</TT></TD><TD WIDTH=115>Override list

</TD><TD WIDTH=115><CENTER><TT>All</TT></CENTER></TD><TD WIDTH=230>Specifies which directives can be overridden by local .htaccess file

</TD></TR>

</TABLE></CENTER>

<P>

<P>

The directory configuration directives that are relevant to user

authentication are explained in the following sections.

<P>

<TT><B>allow from</B>&nbsp;&nbsp;</TT>Use

the <TT>allow from</TT> directive to specify which IP hosts are

allowed to access a given directory. This directive takes a series

of host names as arguments, and allows access from each of the

designated hosts. Host names may be fully qualified (as in <TT>bilbo.tolkien.org</TT>)

or partially qualified (as in <TT>.tolkien.org</TT>). A partially

qualified host name (such as <TT>tolkien.org</TT>) allows access

from all hosts whose name ends in the string supplied (<TT>bilbo.tolkien.org,

gandalf.tolkien.org</TT>, and so on).

<P>

Use the <TT>order</TT> directive (described later in this chapter)

to determine the sequence in which the <TT>allow from</TT> and

<TT>deny from</TT> directives are evaluated.

<P>

<TT><B>deny from&nbsp;&nbsp;</B></TT>Use

the <TT>deny from</TT> directive to specify which IP hosts are

not allowed to access a given directory. This directive takes

a series of host names as arguments and denies access to the directory

from each of the designated hosts. Host names may be fully qualified

(as in <TT>bilbo.tolkien.org</TT>) or partially qualified (as

in <TT>.tolkien.org</TT>). A partially qualified host name (such

as <TT>.tolkien.org</TT>) denies access from all hosts whose name

ends in the string supplied (<TT>bilbo.tolkien.org, gandalf.tolkien.org</TT>,

and so on).

<P>

Use the <TT>order</TT> directive (described in the following section)

to determine the sequence in which the <TT>allow from</TT> and

<TT>deny from</TT> directives are evaluated.

<P>

<TT><B>order&nbsp;&nbsp;</B></TT>The

<TT>allow from</TT> and <TT>deny from</TT> directives have opposite

effects; they can be used in tandem to control exactly which IP

hosts can and cannot access a particular directory. The order

in which these directives are evaluated for a particular directory

is significant, however.

<P>

Consider the effect on <TT>frodo.tolkien.org</TT> of <TT>allow

from .tolkien.org</TT> followed by <TT>deny from frodo.tolkien.org</TT>.

The net<TT> </TT>result is to allow access from all hosts in <TT>.tolkien.org</TT>

<I>except</I> <TT>frodo</TT>. Now consider the effect of <TT>deny

from frodo.tolkien.org</TT> followed by <TT>allow from tolkien.org</TT>.

The net result in this case is to allow access from all hosts

in <TT>tolkien.org</TT>, <I>including</I> <TT>frodo</TT>.

<P>

The <TT>order</TT> directive allows you to specify whether the

<TT>allow from</TT> or <TT>deny from</TT> directives are evaluated

first. The first argument is either <TT>allow,deny</TT> or <TT>deny,allow</TT>.

In the first case, <TT>deny from</TT> directives can override

<TT>allow from</TT> directives; in the second case, <TT>allow

from</TT> directives can override <TT>deny from</TT> directives.

<P>

The following example allows access to <TT>frodo.tolkien.org</TT>

but to no other hosts within the <TT>tolkien.org</TT> domain:

<BLOCKQUOTE>

<PRE>

order deny,allow deny from .tolkien.org allow from .frodo.tolkien.org

</PRE>

</BLOCKQUOTE>

<P>

<TT><B>require&nbsp;&nbsp;</B></TT>Use

the <TT>require</TT> directive to restrict access to a directory

to one or more designated users. Any user who attempts to access

a restricted directory is challenged; the user must provide a

valid user ID and password before the server returns the requested

URL.

<P>

The <TT>require</TT> directive can be used to restrict access

in three distinct ways:

<UL>

<LI><TT><B>require valid-</B>user</TT>.

All users in all user groups are allowed access. Users who attempt

to attach and who cannot provide a valid user ID and password

are denied access.

<LI><TT><B>require group</B></TT><B>.</B>

All users in a set of named user groups are allowed access. Users

who cannot provide a valid user ID and password, or who are not

members of one of the named groups, are denied access.

<LI><TT><B>require user</B></TT>.

Named users in a specific set are allowed access. All other users

are denied access.

</UL>

<P>

The following directive restricts access to users <TT>JohnB</TT>

and <TT>DaveD</TT> only:

<BLOCKQUOTE>

<PRE>

require user JohnB DaveD

</PRE>

</BLOCKQUOTE>

<P>

This set of directives restricts access to the membership domain

to members of the <TT>leaders</TT> group:

<BLOCKQUOTE>

<PRE>

AuthType Basic

AuthName membership

AuthUserFile /www/staffmembers

AuthGroupFile /www/staffgroups

require group leaders

</PRE>

</BLOCKQUOTE>

<P>

<TT><B>AuthName&nbsp;&nbsp;</B></TT>Used

with the <TT>AuthType, require</TT>, and <TT>AuthUserFile</TT>

directives, the <TT>AuthName</TT> directive sets the authorization

realm of the current directory when used inside a <TT>Directory</TT>

group. For an example of using <TT>AuthName</TT>, see the section

on the <TT>require</TT> directive earlier in this chapter.

<P>

<TT><B>AuthType&nbsp;&nbsp;</B></TT>Apache

currently has only one type of user authentication: Basic. The

<TT>AuthType</TT> directive was introduced to allow for the anticipated

introduction of other methods at a later stage.

<P>

Use the <TT>AuthType</TT> directive with the <TT>AuthName</TT>

and <TT>require</TT> directives. For an example, see the <TT>require</TT>

directive section earlier in this chapter.

<P>

<TT><B>AuthUserFile&nbsp;&nbsp;</B></TT>Use

the <TT>AuthUserFile</TT> directive to specify the name of the

text file containing user IDs and passwords that is to be used

to verify access to the current directory.

<P>

Each line of a user definition file contains a user ID, followed

by a colon and a password encrypted with the <TT>crypt()</TT>

function, as in the following example:

<BLOCKQUOTE>

<PRE>

jeremiah:sn/A4bkdRjylI

ruth:1H.yzi5xcMPbk

</PRE>

</BLOCKQUOTE>

<P>

This directive should be used in conjunction with the <TT>AuthName,

AuthType, AuthGroupFile</TT>, and <TT>require</TT> directives.

<P>

<TT><B>AuthDBMUserFile&nbsp;&nbsp;</B></TT>UNIX

DBM files are a more efficient way than plain text files of storing

user IDs and passwords. Use DBM files if you are dealing with

more than a handful of users. Use the <TT>AuthDBMUserFile</TT>

directive to specify the name of the DBM file containing user

IDs and passwords that is to be used to verify access to the current

directory. This directive should be used in conjunction with the

<TT>AuthName, AuthType, AuthDBMGroupFile</TT>, and <TT>require</TT>

directives.

<P>

<TT><B>AuthGroupFile&nbsp;&nbsp;</B></TT>Use

the <TT>AuthGroupFile</TT> directive to specify the name of the

text file containing group definitions.

<P>

Each line of a group definition file contains a group name, followed

by a colon and a list of the users in the group, as in the following

example:

<BLOCKQUOTE>

<PRE>

admin: henry martha dave

</PRE>

</BLOCKQUOTE>

<P>

<TT><B>AuthDBMGroupFile&nbsp;&nbsp;</B></TT>The

group file for a given directory may be a UNIX DBM file rather

than a plain text file. If so, use the <TT>AuthDBMGroupFile</TT>

directive, rather than the <TT>AuthDBMFile</TT> directive, to

specify the group definition file.

<P>

<TT><B>Options&nbsp;&nbsp;</B></TT>The

<TT>Options</TT> directive described earlier in this chapter can

also be used within a <TT>Directory</TT> group to control behavior

for that directory. For details, refer to the &quot;Options&quot;

section earlier in this chapter.

<P>

<TT><B>AllowOverride&nbsp;&nbsp;</B></TT>Directives

in the server configuration files can be overridden by directives

in local .htaccess files, as described in the following section.

As a server administrator, you may not want users to override

all server directives. In such a case, use the <TT>AllowOverride</TT>

directive in a <TT>Directory</TT> group to specify which directives

can be overridden.

<P>

The default behavior is to allow the user to override all directives,

which is the equivalent of using <TT>AllowOverride</TT> with an

argument of <TT>All</TT>. Using an argument of <TT>None</TT> has

the opposite effect, telling the server to ignore the contents

of any .htaccess files. You can use the following arguments to

fine-tune override behavior related to access control:

<UL>

<LI><TT>AuthConfig</TT>: allows overriding of the <TT>AuthDBMGroupFile,

AuthDBMUserFile, AuthGroupFile, AuthName, AuthType, AuthUserFile</TT>,

and <TT>require</TT> directives.

<LI><TT>Limit</TT> (not to be confused with the <TT>&lt;Limit&gt;</TT>

and <TT>&lt;/Limit&gt;</TT> delimiters): allows overriding of

the <TT>allow from, deny from</TT>, and <TT>order</TT> directives.

<LI><TT>Options</TT>: allows overriding of the <TT>Options</TT>

directive.

</UL>

<P>

The directive <TT>AllowOverride Limit</TT> in the server configuration

file, for example, allows local .htaccess files to control which

hosts can access files.

<P>

<B>Apache .htaccess Directives&nbsp;&nbsp;</B>Table 8.4 lists

the directives that can be used in the local .htaccess files.

These files override server configuration directives for the directory

in which they reside.<BR>

<P>

<CENTER><B>Table 8.4&nbsp;&nbsp;Apache httpd .htaccess Configuration

Directives</B></CENTER>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD WIDTH=144><B>Directive</B></TD><TD WIDTH=125><B>Argument Type</B>

</TD><TD WIDTH=125><CENTER><B>Default Value</B></CENTER></TD>

<TD WIDTH=182><B>Purpose</B></TD></TR>

<TR VALIGN=TOP><TD WIDTH=144><TT>allow from</TT></TD><TD WIDTH=125>List of hosts

</TD><TD WIDTH=125><CENTER>-</CENTER></TD><TD WIDTH=182>Allows access to this directory from the designated IP hosts

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=144><TT>deny from</TT></TD><TD WIDTH=125>List of hosts

</TD><TD WIDTH=125><CENTER>-</CENTER></TD><TD WIDTH=182>Denies access to this directory from the designated IP hosts

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=144><TT>order</TT></TD><TD WIDTH=125>Evaluation order

</TD><TD WIDTH=125><CENTER><TT>deny,allow</TT></CENTER></TD><TD WIDTH=182>Sets the order in which <TT>deny</TT> and <TT>allow</TT> directives are applied.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=144><TT>Require user</TT></TD><TD WIDTH=125>List of user IDs

</TD><TD WIDTH=125><CENTER>-</CENTER></TD><TD WIDTH=182>List of IDs of users who can access a directory

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=144><TT>require group</TT></TD><TD WIDTH=125>List of groups

</TD><TD WIDTH=125><CENTER>-</CENTER></TD><TD WIDTH=182>List of groups that can access a directory

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=144><TT>require</TT> &aring; <TT>valid-user</TT>

</TD><TD WIDTH=125>-</TD><TD WIDTH=125><CENTER>-</CENTER></TD>

<TD WIDTH=182>Allows access to all users who provide a valid user ID and password

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=144><TT>AuthGroupFile</TT></TD><TD WIDTH=125>File name

</TD><TD WIDTH=125><CENTER>-</CENTER></TD><TD WIDTH=182>Name of file containing list of user groups

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=144><TT>AuthName</TT></TD><TD WIDTH=125>domain name

</TD><TD WIDTH=125><CENTER>-</CENTER></TD><TD WIDTH=182>Name of authorization domain for a directory

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=144><TT>AuthType</TT></TD><TD WIDTH=125>Basic</TD>

<TD WIDTH=125><CENTER><TT>Basic</TT></CENTER></TD><TD WIDTH=182>Type of user authorization (only Basic available)

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=144><TT>AuthUserFile</TT></TD><TD WIDTH=125>File name

</TD><TD WIDTH=125><CENTER>-</CENTER></TD><TD WIDTH=182>Name of file containing list of  users and passwords

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=144><TT>Options</TT></TD><TD WIDTH=125>List of options

</TD><TD WIDTH=125><CENTER>-</CENTER></TD><TD WIDTH=182>Defines which server features are allowed in a given directory

</TD></TR>

</TABLE></CENTER>

<P>

<P>

These directives can be used in the .htaccess files as well as

in the server configuration files. For details on each of these

directives, refer to &quot;Apache Directory Directives&quot; earlier

in this chapter.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>CAUTION</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

Be careful not to give users too much leeway with .htaccess files. Local .htaccess directives can be used for purposes such as exporting files that would not otherwise be available. The best way to provide security is to use the <TT>AllowOverride</TT> 
directive in the server configuration file. The following example provides reasonable protection against accidental or deliberate security breaches:

</BLOCKQUOTE>

<BLOCKQUOTE>

<TT>&lt;Directory&gt;<BR>

AllowOverride None<BR>

Options None<BR>

&lt;Limit GET PUT POST&gt;<BR>

allow from all<BR>

&lt;/Limit&gt;<BR>

&lt;/Directory&gt;</TT>

</BLOCKQUOTE>

<BLOCKQUOTE>

This code prevents any overriding of directives by means of .htaccess files; explicitly turns off extra server features by means of the <TT>Options</TT> directive; and allows accesses from all hosts, but only by means of the <TT>GET</TT>, <TT>PUT</TT>, 
and <TT>POST</TT> methods.

</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<H2><A NAME="UserAdministration"><FONT SIZE=5 COLOR=#FF0000>

User Administration</FONT></A></H2>

<P>

The extra layer of access control required on a Web server that

uses user-related access restrictions has a certain amount of

maintenance overhead. Aside from setting up the configuration

files that define a realm (and the users and groups that have

access to it), you need to be able to add and delete users in

the various realms, change passwords for users who lose or forget

them, and so on.

<P>

Fortunately, that task is just the kind of task for which Perl

was brought into this world. The remainder of this chapter describes

some sample Perl scripts that make it easy to administer the httpd's

user accounts.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

The code for the samples in this chapter is available on the CD-ROM that comes with this book. Copy these files into a directory in your path, and make sure that <TT>UserUtil.pl</TT> is in your Perl library directory (/usr/local/perl/lib, for example). 
This file contains the shared subroutines that do all the work.

</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<H3><A NAME="AddingUsers">

Adding Users</A></H3>

<P>

The first task is to define a user, which means adding a line

to a user file that contains the user name, a colon, and the user's

password in encrypted format.

<P>

<B>Encrypting Passwords&nbsp;&nbsp;</B>Getting the password into

encrypted form is fairly straightforward when you use Perl. This

task is one that you're going to want to perform again (in your

script for setting passwords for existing users), so write a subroutine

to do the job for you and then store it in UserUtil.pl, where

it can be shared by several scripts.

<P>

Listing 8.1 shows the source for the <TT>GetPWord()</TT> subroutine.

The subroutine takes no arguments, prompts the user for the password

(twice, to prevent errors), and returns the encrypted password.

<HR>

<BLOCKQUOTE>

<B>Listing 8.1&nbsp;&nbsp;The <I>GetPword</I> Subroutine<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

# Subroutine to prompt for and return (encrypted) password.

sub GetPword {



    my ( $pwd1, $pwd2, $salt, $crypted );

    my @saltchars = (a .. z, A .. Z, 0 .. 9);



    print &quot;Enter password: &quot;;

    $pwd1 = &lt;STDIN&gt;;

    chop($pwd1);

    length($pwd1) &gt;= 8 ||

        die &quot;Password length must be eight characters or more.\n&quot;;



    print &quot;Enter the password again: &quot;;

    $pwd2 = &lt;STDIN&gt;;

    chop($pwd2);



    # Check that they match:

    ($pwd1 eq $pwd2 ) || die

        &quot;Sorry, the two passwords you entered do not match.\n&quot;;



    # Generate a random salt value for encryption:

    srand(time || $$);

    $salt = $saltchars[rand($#saltchars)] . $saltchars[rand($#saltchars)];



    return crypt($pwd1, $salt);

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>The <I>crypt()</I> Function</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

n the UNIX world, the <TT>crypt()</TT> function looks after the job of encrypting passwords. The function takes two arguments:



<UL>

<LI>A password in raw text

<LI>A random salt argument, consisting of two characters

</UL>



The <TT>crypt()</TT> function applies an encryption algorithm to the password, using the <TT>salt</TT> value. Then the function returns the encrypted password, which consists of the <TT>salt</TT> value followed by 11 other characters. The password 
<TT>password</TT>, encrypted with the <TT>salt</TT><B> </B>Xb, is <TT>Xbs.myqnmA.bI</TT>

</BLOCKQUOTE>

<BLOCKQUOTE>

Decrypting a password from the encrypted form of the password is almost impossible, but comparing a given string with the password is easy.</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<P>

The following list steps through the code to show you how it works:

<OL>

<LI>An array <TT>(@saltchars)</TT> of characters suitable for

use in the <TT>salt</TT> value is defined.

<LI>The user is prompted for a password, which is stored in <TT>$pwd1</TT>.

If the password has fewer than eight characters, the subroutine

dies.

<LI>The user is prompted to re-enter the password. If the two

passwords do not match, the program aborts with an error message.

<LI>The random-number generator is seeded with a Boolean or combination

of the current time and perl's process ID.

<LI>A character from the set of <TT>salt</TT> characters is selected

at random, using the expression <TT>$saltchars[rand($#saltchars)]</TT>.

<LI>A second character is similarly selected, and the two are

combined with the . (period) concatenation operator. The result

is the two-character encryption <TT>salt</TT> value.

<LI>Finally, the password specified by the user and the <TT>salt</TT>

value that you generated are passed to Perl's <TT>crypt()</TT>

function. The value returned by <TT>crypt()</TT> is passed, intact,

back to the calling subroutine.

</OL>

<P>

<B>Adding a User&nbsp;&nbsp;</B>Adding a user amounts to no more

than adding a line that contains the user name and password to

the user definition file. You can perform this task by using the

SetPword(&nbsp;) function, the code for which appears in Listing

8.2.

<HR>

<BLOCKQUOTE>

<B>Listing 8.2&nbsp;&nbsp;The SetPword</B><I> </I><B>Subroutine

<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

# Store a user's password in a user definition file

# Arguments:

# - user file spec

# - user name

# - password

sub SetPword  {

    my( $filespec, $user, $pword ) = @_;



    # Open user file for appending:



    open(USERFILE, &quot;+&gt;&gt;$filespec&quot;) ||

     die &quot;Could not open user file \&quot;$filespec\&quot; for appending: $!\n&quot;;



    # Write to the user file

    print USERFILE &quot;$user:$pword\n&quot; ||

     die &quot;Failed to write the user/password to file \&quot;$filespec\&quot;.\n&quot;;



    # Tidy up:



    close USERFILE;

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

This code opens the named user definition file for appending by

including the <TT>&gt;&gt;</TT> append operator in the file specification

argument to the <TT>open()</TT> function. If the file does not

already exist, perl creates it.

<P>

The code then writes the supplied user ID and encrypted password

(with a colon between them and a new line at the end), closes

the user definition file, and returns.

<P>

<B>Putting It All Together: <I>Aaddu</I>&nbsp;&nbsp; </B>The script

that you invoke when you actually want to add a user is relatively

simple, because most of the work has been separated out into reusable

subroutines. Listing 8.3 shows the code for <TT>Aaddu</TT>.

<HR>

<BLOCKQUOTE>

<B>Listing 8.3&nbsp;&nbsp;The Aaddu Script<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#!/usr/local/bin/perl -I. -T



# Script to add a user to an Apache user file.



require &quot;UserUtil.pl&quot;;  # Need utilities



# Takes two arguments:

# - username to add

# - file to add to



# Get the arguments:

($user, $file) = @ARGV;



# Check that we got two arguments:

$file ||

    die &quot;Aaddu: Add user utility for Apache (text) user files.\n&quot;,

    &quot;Usage: Aaddu username filespec\n&quot;;



$file =~ /(.+)/;

$safefile = $1;



# Get the encrypted password:

$password = &amp;GetPword;



# Store the new username and password:

&amp;SetPword($safefile, $user, $password);



# End

</PRE>

</BLOCKQUOTE>

<HR>

<P>

This script simply takes the user name and user definition file

as arguments; gets the password interactively, using the <TT>GetPWord()</TT>

subroutine; and then calls <TT>SetPWord()</TT> to add the users.

<P>

One more detail here. Examine the following mysterious lines:

<BLOCKQUOTE>

<PRE>

$file =~ /(.+)/;

$safefile = $1;

</PRE>

</BLOCKQUOTE>

<P>

These lines are here because the script turns on Perl's taint

checking with the <TT>-T</TT> switch. In this mode, Perl does

not allow you to pass an argument from the command line-namely,

<TT>$file</TT>-to a function such as <TT>open()</TT>, because

doing so might compromise security. Making a copy of <TT>$file</TT>

won't work either, because it will be similarly tainted.

<P>

So how do you get the file name from <TT>$file</TT> in a way that

won't upset Perl's taint-checking sensibilities? One way is to

perform a regular expression match on the contents of <TT>$file</TT>

and then store what was matched. Perl allows this method because

it assumes that if you go to this much trouble in your own code,

you know what you're doing.

<P>

The statement <TT>$file =</TT>~<TT> /(.+)/</TT> carries out a

regular expression match on <TT>$file</TT>, using the expression

<TT>(.+)</TT>. This expression simply matches the entire contents

of <TT>$file</TT> and returns what it found as <TT>$1</TT>. The

script then stashes this result in the new variable <TT>$safefile</TT>.

If you are writing scripts to be executed by other users, you

may want to use a more elaborate regular expression to eliminate

any suspicious characters from the variable before passing it

to <TT>open</TT>.

<P>

<B>Avoiding Duplicate User Names&nbsp;&nbsp;</B>The major difficulty

with simply appending new users to a user definition file is that

there is no safeguard against the possibility of adding the same

user name more than once. The procedure would be much safer if

the <TT>Aaddu</TT> script determined whether a user already existed

in a user definition file before trying to add the user.

<P>

The <TT>UserDefined()</TT> function in <TT>UserUtil.pl</TT> makes

just that determination. Listing 8.4 shows the code.

<HR>

<BLOCKQUOTE>

<B>Listing 8.4&nbsp;&nbsp;The UserDefined Subroutine<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

# Return 1 if user defined in named text file

sub UserDefined  {



    my ( $username, $filespec ) = @_;



    # No file, no user

    open(USERFILE, $filespec) || return 0;



    # Check each line for username:

    while (&lt;USERFILE&gt;)  {

     if ( /^$username:/ )  {

         close USERFILE;

         return 1;

     }

    }

    close USERFILE;

    return 0;

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The function takes a user name and a user definition file specification

as arguments; it returns <TT>1</TT> if the user exists in that

file and <TT>0</TT> if the user doesn't exist. This function will

also be useful in the opposite context when you want to change

the passwords of existing users.

<P>

The operation of this function is quite straightforward: It opens

the user definition file for reading, and checks each line in

the file. If the line starts with the user name followed immediately

by a colon, the function returns <TT>1</TT> to confirm that the

user is defined.

<P>

Notice the use of the <TT>close()</TT> function before both <TT>return

1</TT> and <TT>return 0</TT>. Placing a single <TT>close()</TT>

statement at the end of a subroutine is not sufficient, because

a <TT>return</TT> statement earlier in the subroutine may prevent

the <TT>close()</TT> statement from being reached. It is, therefore,

important to place <TT>close()</TT> statements immediately before

every <TT>return</TT> point in the subroutine.

<P>

Listing 8.5 shows the new, improved <TT>Aaddu</TT> script.

<HR>

<BLOCKQUOTE>

<B>Listing 8.5&nbsp;&nbsp;The Aaadu Script with Duplicate Checking

<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#!/usr/local/bin/perl -I. -T



# Script to add a user to an Apache user definition file.

# Prevents duplicate entries.



require &quot;UserUtil.pl&quot;;  # Need utilities



# Takes two arguments:

# - username to add

# - file to add to



# Get the arguments:

($user, $file) = @ARGV;



# Check that we got two arguments:

$file ||

    die &quot;Aaddu: Add user utility for Apache user definition files.\n&quot;,

    &quot;Usage: Aaddu username filespec\n&quot;;



$file =~ /(.+)/;

$safefile = $1;



# First check that the user does not already exist:

&amp;UserDefined($user, $safefile) &amp;&amp;

    die &quot;User \&quot;$user\&quot; already exists in file \&quot;$safefile\&quot;.\n&quot;;



# Get the encrypted password:

$password = &amp;GetPword;



# Store the new username and password:

&amp;TextSetPword($safefile, $user, $password);



# End

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The only change from the earlier version of <TT>Aaddu</TT> is

the addition of a call to <TT>UserDefined()</TT> to check for

the existence of the user.

<H3><A NAME="DeletingUsers">

Deleting Users</A></H3>

<P>

Deleting users is a little less straightforward than adding them.

Adding a user is simply a matter of sticking a new user line at

the end of a file. Deleting a user, however, involves finding

that user in the file and then rewriting the file without that

user line but with all others left intact.

<P>

The simplest way to perform this task in Perl is to read the entire

contents of the user definition file into an associative array,

delete the entry that corresponds to the user that you want to

drop, and then write the whole array out to the same file. This

approach may not be immediately intuitive if you're not used to

working with associative arrays, but it will become familiar to

you in a short time, as you learn to leverage the power of associative

arrays.

<P>

Listing 8.6 shows the code for the <TT>DeleteUser()</TT> subroutine.

<HR>

<BLOCKQUOTE>

<B>Listing 8.6&nbsp;&nbsp;The<I> DeleteUser </I>Subroutine<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

# Subroutine to delete a user from a user file

# Input: Username, filespec



sub DeleteUser  {



    my ($user, $filespec) = @_;

    my ($thisusr, $thispw, $elem, %passwords);



    # Open the file for reading:

    open(USERFILE, &quot;$filespec&quot;) ||

        die &quot;Could not open user file \&quot;$filespec\&quot; for reading: $!\n&quot;;



    # Grab the contents of the user file in an associative array:

    while (&lt;USERFILE&gt;)  {

        chop;

        ($thisusr, $thispw) = split(':', $_) ;

        $passwords{$thisusr} = $thispw;

    }

    close USERFILE;



    # Check that the named user exists:

    $passwords{$user} ||

        die &quot;User \&quot;$user\&quot; not found in file \&quot;$filespec\&quot;.\n&quot;;



    # Now delete the user from the array:

    delete $passwords{$user};



    # Now write the whole user/password array to the user file:



    # First re-open the user file for writing:

    open(USERFILE, &quot;&gt;$filespec&quot;) ||

        die &quot;Could not open user file \&quot;$filespec\&quot; for reading: $!\n&quot;;



    # Now write each element of the array in the correct format:

    foreach $elem ( keys %passwords )  {

        print USERFILE $elem, &quot;:&quot;, $passwords{$elem}, &quot;\n&quot; ||

            die &quot;Failed to write user/password to file \&quot;$filespec\&quot;: $!.\n&quot;;

    }



    close USERFILE;

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The following list goes through this script a step at a time:

<OL>

<LI>The named user definition file is opened for reading.

<LI>The contents of the file are read into the <TT>%passwords</TT>

associative array by the following three lines, in a <TT>while(&lt;&gt;)</TT>

loop:<BR>

<TT>chop;<BR>

($thisusr, $thispw) = split(':', $_)

;<BR>

$passwords{$thisusr} = $thispw;<BR>

</TT>The <TT>chop</TT> statement drops the new-line character

from each line as it is read in. The <TT>split()</TT> function

breaks the line into the user name (<TT>$thisusr</TT>) and password

(<TT>$thispw</TT>) components. Then a new entry is created in

the <TT>%passwords</TT> associative array, with <TT>$thisusr</TT>

as the key and <TT>$thispw</TT> as the value.

<LI>With the associative array complete, the script throws away

the entry that corresponds to the user that you want to drop,

using the <TT>delete</TT> command.

<LI>The script re-opens the user definition file for writing and

iterates through all elements of the<TT> %passwords</TT> array,

writing one at a time in the correct <TT>user:password</TT> format.

</OL>

<H3><A NAME="ChangingPasswords">

Changing Passwords</A></H3>

<P>

Changing the password of an existing user is trivial now; you've

already written the code that does all the work.  All you need

is the following simple wrapper, <TT>Asetpw</TT>, to call the

<TT>UserDefined()</TT> and <TT>SetPWord()</TT> subroutines, as

shown in Listing 8.7.

<HR>

<BLOCKQUOTE>

<B>Listing 8.7&nbsp;&nbsp;The Asetpw Script<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#!/usr/local/bin/perl -I. -T



# Script to change a password in an Apache user file.



require &quot;UserUtil.pl&quot;;  # Need utilities



# Takes two arguments:

# - username to change

# - file containing userid, password



# Get the arguments:

($user, $file) = @ARGV;



# Check that we got two arguments:

$file ||

    die &quot;Asetpw: Change password utility for Apache user definition files.\n&quot;,

    &quot;Usage: Asetpw username filespec\n&quot;;



$file =~ /(.+)/;

$safefile = $1;



# First check that the user exists:

&amp;UserDefined($user, $safefile) ||

    die &quot;User \&quot;$user\&quot; does not exist in file \&quot;$safefile\&quot;.\n&quot;;



# Get the encrypted password:

$password = &amp;GetPword;



# Store the new username and password:

&amp;SetPword($safefile, $user, $password);



# End

</PRE>

</BLOCKQUOTE>

<HR>

<P>

This listing illustrates just how useful a modular approach to

code design can be.

<H3><A NAME="AddingUserstoGroups">

Adding Users to Groups</A></H3>

<P>

A group definition file consists of a series of lines, one per

group, each of which contains the name of the group, followed

by a colon and a list of space-separated member names. This format

is somewhat similar to the format of a user definition file, but

the task of adding or deleting a user is more complex, because

user definition lines have a single name and a single password-ideal

material for an associative array. Group definition files, on

the other hand, have a single group name and multiple member names.

<P>

You will still use associative arrays to deal with groups, but

you need to do a little extra work to allow for the storage of

a list of members as a single value. The approach that you take

in this section is to deal with a group file as a whole, reading

its contents to and from an associative array. This approach allows

you to modularize your code into neat functional elements. This

method lends itself particularly well to working with UNIX DBM

files, should you decide to use them at a later stage.

<P>

<B>Reading Groups&nbsp;&nbsp;</B>Listing 8.8 shows the source

code for GetGroupMembers(&nbsp;), which is stored in UserUtil.pl.

GetGroupMembers(&nbsp;) is a subroutine that reads the entire

contents of a group file into an associative array.

<HR>

<BLOCKQUOTE>

<B>Listing 8.8&nbsp;&nbsp;The GetGroupMembers Subroutine<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

# Subroutine to extract group member list from group file

# Input: file spec of group membership file

# Returns: Associative array of groups, members.



sub GetGroupMembers {

    my( $filespec ) = @_;

    my ($thisgrp, $grpmembers, %groupmembers);



    # Just return now if file does not exist:

    -e $filespec || return;



    # Open the group file:

    open(GFILE, &quot;$filespec&quot;) ||

     die &quot;Could not open user file \&quot;$filespec\&quot; for reading: $!\n&quot;;



    while (&lt;GFILE&gt;)  {

     chop;

     ($thisgrp, $grpmembers) = split(':' , $_);

     $groupmembers{$thisgrp} = $grpmembers;

    }



    close GFILE;



    return %groupmembers;

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

When the input file has been opened, each line is read and split

at the colon into a group name (<TT>$thisgrp</TT>) and a member

list (<TT>$grpmembers</TT>). The member list is a single string

containing the user names of all group members, separated by spaces.

The associative array <TT>%groupmembers</TT> is built by adding

<TT>$thisgrp</TT> as a key and <TT>$grpmembers</TT> as a corresponding

value for each line read from the file. Then the entire associative

array is returned to the calling routine.

<P>

<B>Writing Groups&nbsp;&nbsp;</B>Listing 8.9 shows the source

code for SetGroupMembers(&nbsp;), which is stored in UserUtil.pl

and which is similar to SetPword(&nbsp;).

<HR>

<BLOCKQUOTE>

<B>Listing 8.9&nbsp;&nbsp;The SetGroupMembers() Subroutine<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

# Subroutine to store group member list in group file

# Input: file spec of group membership file,

#        associative array of groups/users



sub SetGroupMembers {

    my( $filespec, %groups ) = @_;

    my ($grp);



    # Open the group file:

    open(GFILE, &quot;&gt;$filespec&quot;) ||

     die &quot;Could not open group file \&quot;$filespec\&quot; for writing: $!\n&quot;;



    foreach $grp ( keys %groups )  {

     print GFILE &quot;$grp: $groups{$grp}\n&quot;;

    }



    close GFILE;

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

This function does the opposite of <TT>GetGroupMembers()</TT>:

It opens the group definition file for writing and writes out

one line per entry in the <TT>%groups</TT> associative array.

Each line is written as the key, followed by a colon and then

the corresponding value.

<P>

<B>Putting It All Together: <I>Agrpaddu</I>&nbsp;&nbsp;</B>The

source code for <TT>Agrpaddu</TT> is relatively short, making

use of the functionality in <TT>UserUtil.pl</TT>, as shown in

Listing 8.10.

<HR>

<BLOCKQUOTE>

<B>Listing 8.10&nbsp;&nbsp;The Agrpaddu Script<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#!/usr/local/bin/perl -I. -T

# Script to add a user to a group in an Apache group file.

require &quot;UserUtil.pl&quot;;  # Need utilities



# Takes two arguments:

# - group to add to

# - username to add

# - file to add to



# Get the arguments:

($group, $user, $file) = @ARGV;



# Check that we got three arguments:

$file ||

    die &quot;Agrpaddu: Utility for adding users to Apache group files.\n&quot;,

    &quot;Usage: Agrpaddu groupname username filespec\n&quot;;



# Extract filename:

$file =~ /(.+)/;

$safefile = $1;



# Read the current group membership into an associative array:

%groups = &amp;GetGroupMembers($safefile);



# Check if user already in group:

$groups{$group} =~ /\b$user\b/ &amp;&amp;

    die &quot;User \&quot;$user\&quot; is already a member of group \&quot;$group\&quot;.\n&quot;;



# Add the user to the group:

$groups{$group} .= &quot; $user&quot;;



# Write the array out to the groups file:

&amp;SetGroupMembers($safefile, %groups);



# End

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The following list describes what this script does:

<OL>

<LI>The script reads the designated group definition file into

the <TT>%groups</TT> associative array.

<LI>The script checks to see whether the user is already in the

named group.

<LI>If the user is not in the named group, the script appends

a space and the user name to the value of the entry in <TT>%groups</TT>

that has the group name for a key. (If the group was not defined,

this step defines it.)

<LI>The script writes the <TT>%groups</TT> associative array out

to the group definition file.

</OL>

<H3><A NAME="DeletingUsersfromGroups">

Deleting Users from Groups</A></H3>

<P>

The task of deleting users from groups is a little more involved<TT>

</TT>than adding them. Listing 8.11 shows the source for <TT>Agrpdelu</TT>.

<HR>

<BLOCKQUOTE>

<B>Listing 8.11&nbsp;&nbsp;The <I>Agrpdelu</I> Script<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#!/usr/local/bin/perl -I. -T



# Script to delete a user from a group in an Apache group file.



require &quot;UserUtil.pl&quot;;  # Need utilities



# Takes two arguments:

# - group to delete from

# - username to delete

# - file to delete from



# Get the arguments:

($group, $user, $file) = @ARGV;



# Check that we got three arguments:

$file ||

    die &quot;Agrpdelu: Utility for deleting users from Apache group files.\n&quot;,

    &quot;Usage: Agrpdelu groupname username filespec\n&quot;;



# Extract filename:

$file =~ /(.+)/;

$safefile = $1;



# Read the current group membership into an associative array:

%groups = &amp;GetGroupMembers($safefile);



# Check if user is in group:

$groups{$group} =~ /\b$user\b/ ||

    die &quot;User \&quot;$user\&quot; is not a member of group \&quot;$group\&quot;.\n&quot;;



# First make an array of all members of this list:

(@oldmembers) = $groups{$group} =~ /(\w+)/g;



# Clear down the current member list for this group:

$groups{$group} = &quot;&quot;;



# now add all but the member to be deleted to a new string:

foreach $member (@oldmembers)  {

    if ( $member ne $user )  {

     $groups{$group} .= &quot; $member&quot;;

    }

}



# Write the array out to the groups file:

&amp;SetGroupMembers($safefile, %groups);



# End

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The following list shows the essential steps:

<OL>

<LI>The script reads the group definition file into the <TT>%groups</TT>

associative array.

<LI>The script stores the membership of the named group in the

<TT>@oldmembers</TT> array, using this statement:<BR>

<TT>(@oldmembers) = $groups{$group} =~ /(\w+)/g;<BR>

</TT>This statement is worth examining. <TT>$groups{$group}</TT>

is the string that contains all group member names, separated

by spaces. Applying the <TT>/(\w+)/g</TT> operator performs a

pattern match on the member list, saving all full words in <TT>$1</TT>,

<TT>$2</TT>, and so on. Then these values are stored in <TT>@oldmembers</TT>.

<LI>The script obliterates the group membership for the named

group by setting it to an empty string.

<LI>The script rebuilds the member list for the named group- <TT>$groups{$group}</TT>-by

looping through all elements of the <TT>@oldmembers</TT> array,

adding each element to <TT>$groups{$group}</TT> unless it matches

the user name that is to be dropped.

<LI>The script writes the <TT>%groups</TT> associative array back

out to the group definition file.

</OL>

<P>

Again, you get to reuse the <TT>GetGroupMembers()</TT> and <TT>SetGroupMembers()</TT>

functions.

<H2><A NAME="FromHere"><FONT SIZE=5 COLOR=#FF0000>

From Here...</FONT></A></H2>

<P>

This chapter describes how user authentication combines user verification

with access restrictions to ensure that your server is as open

as it needs to be, and no more. This book has a great deal more

to say about server security and Perl:

<UL>

<LI><A HREF="ch9.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch9.htm" >Chapter 9</A> &quot;Understanding CGI Security,&quot; explains

how you can maintain the state of an authenticated session across

several Perl scripts.

<LI><A HREF="ch10.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch10.htm" >Chapter 10</A>, &quot;Site Administration,&quot; has more information

on how you can use Perl to assist in the management of your Web

server.

</UL>

<HR>



<CENTER><P><A HREF="ch7.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch7.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="index.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="ch9.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch9.htm"><IMG SRC="nc.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<HR WIDTH="100%"></P></CENTER>

</BODY>

</HTML>

