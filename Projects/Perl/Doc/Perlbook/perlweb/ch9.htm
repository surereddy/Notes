<HTML>

<HEAD>

<TITLE>Chapter 9 -- Understanding CGI Security</TITLE>



<META>

</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">

<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;9</FONT></H1>

<H1><FONT SIZE=6 COLOR=#FF0000>Understanding CGI Security</FONT>

</H1>

<P>

<I><B>by Paul Doyle</B></I>

<HR>

<P>

<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>

<UL>

<LI><A HREF="#UnderstandingtheSecurityIssues">

Understanding the Security Issues</A>

<UL>

<LI><A HREF="#TracingtheChainofCommand">

Tracing the Chain of Command</A>

<LI><A HREF="#ReadingFiles">

Reading Files</A>

<LI><A HREF="#WritingtoFiles">

Writing to Files</A>

<LI><A HREF="#StoringVariables">

Storing Variables</A>

<LI><A HREF="#LosingtheData">

Losing the Data</A>

</UL>

<LI><A HREF="#ManagingSessions">

Managing Sessions</A>

<UL>

<LI><A HREF="#TheNatureofaSession">

The Nature of a Session</A>

<LI><A HREF="#TheWrapper">

The Wrapper</A>

<LI><A HREF="#GenericSubstitutions">

Generic Substitutions</A>

<LI><A HREF="#FlowControl">

Flow Control</A>

</UL>

<LI><A HREF="#DesigningtheSampleApplication">

Designing the Sample Application</A>

<UL>

<LI><A HREF="#ProgramFlow">

Program Flow</A>

<LI><A HREF="#DataIssues">

Data Issues</A>

</UL>

<LI><A HREF="#ImplementingtheSampleApplication">

Implementing the Sample Application</A>

<UL>

<LI><A HREF="#GettingStartedTheMainRoutine">

Getting Started: The Main Routine</A>

<LI><A HREF="#GettingtheCGIValues">

Getting the CGI Values</A>

<LI><A HREF="#ReadingtheProductData">

Reading the Product Data</A>

<LI><A HREF="#InvokingaSpecificFunction">

Invoking a Specific Function</A>

<LI><A HREF="#ParsinganHTMLFile">

Parsing an HTML File</A>

<LI><A HREF="#InitiatingaLogin">

Initiating a Login</A>

</UL>

<LI><A HREF="#LoggingInandOut">

Logging In and Out</A>

<UL>

<LI><A HREF="#LoggingIn">

Logging In</A>

<LI><A HREF="#ValidatingtheUser">

Validating the User</A>

<LI><A HREF="#LoggingOut">

Logging Out</A>

</UL>

<LI><A HREF="#ManagingSessionData">

Managing Session Data</A>

<UL>

<LI><A HREF="#StoringSessionData">

Storing Session Data</A>

<LI><A HREF="#RetrievingSessionData">

Retrieving Session Data</A>

</UL>

<LI><A HREF="#ManagingtheOrders">

Managing the Orders</A>

<UL>

<LI><A HREF="#BuildinganOrder">

Building an Order</A>

<LI><A HREF="#ReviewingtheOrder">

Reviewing the Order</A>

<LI><A HREF="#PlacingtheOrder">

Placing the Order</A>

</UL>

<LI><A HREF="#WrappingUp">

Wrapping Up</A>

<LI><A HREF="#FromHere">

From Here   </A>

</UL>



<HR>

<P>

Providing a secure but open Web service is a balancing act. You

want to make your site as easily accessible as possible so that

the maximum number of people can use it, but you also want to

make sure that access is not so open that your service can be

harmed, accidentally or deliberately, due to a lack of security.

<P>

Achieving the correct balance between security and openness is

easier if you simply eliminate all write access on the server.

Often, however, the nature of the service that you are providing

dictates that users have write access to files on the server.

<P>

This chapter deals with one approach to providing a secure Web

service that permits writing of data on the server. The chapter

examines the security issues in detail and shows how you can accept

data from users and store it on the server while protecting the

integrity of your service. To illustrate the techniques, a sample

Web-based ordering system using shopping-cart logic is developed

in the course of the chapter.

<H2><A NAME="UnderstandingtheSecurityIssues"><FONT SIZE=5 COLOR=#FF0000>

Understanding the Security Issues</FONT></A></H2>

<P>

Previous chapters (particularly <A HREF="ch8.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch8.htm" >Chapter 8</A> &quot;Understanding

Basic User Authentication&quot;) dealt with the general issues

involved in verifying the identity of users who access your Web

server and in restricting access to files on the server by using

the HTTP daemon's configuration mechanism. Before you get started

using CGI wrapper scripts, take a closer look at the specific

security issues that arise when you decide to accept input from

users.

<H3><A NAME="TracingtheChainofCommand">

Tracing the Chain of Command</A></H3>

<P>

The transparency of the Web's infrastructure is one thing that

has contributed to the enormous growth in its popularity in recent

years. The user clicks a button in his browser, and a server somewhere

on the planet sends him whatever his little heart desires.

<P>

<B>The Browser As Interface&nbsp;&nbsp;</B>Users feel as though

they are interacting directly with the material that they read

on the Internet, with only their browsers between them and the

words or images that they see. A browser picks up files for a

user and displays images. From time to time, the user may need

to enter a user ID and a password to access a special service.

To most users, their browsers appear to be logging them on to

the server. If a user notices that a program on the server is

being executed, the impression is that the browser is executing

the program for the user.

<P>

<B>Beneath the Surface&nbsp;&nbsp;</B>In fact, looking just below

the surface of the action in a typical point-and-click operation,

you can see that what actually happens is considerably more complex.

The sequence of events can be summarized as follows:

<OL>

<LI>The user selects a location on the Web, using a browser.

<LI>The browser locates the server that stores the requested item.

<LI>The browser sends a request to the server for the contents

of the location.

<LI>The server examines the request and decides, based on its

access restrictions, whether access to the location is allowed

from the IP address at which the request originated.

<LI>If access is allowed from that IP address, the server decides

whether its access restrictions mean that user authentication

is required for the requested location.

<LI>If so, the server challenges the browser to provide a valid

user ID and password for the authentication domain that contains

the requested location.

<LI>If the user ID and password are verified, and if that user

ID is entitled to access the authentication domain that contains

the requested location, the server reads the contents of the location.

<LI>If the location is a CGI program, the server executes it and

sends the results to the browser. If the location is not a CGI

program, the contents of the location are sent as they are to

the browser.

<LI>The browser displays the content sent to it by the server.

</OL>

<P>

This schema could be broken down into much finer levels of detail,

but for now, the points of interest are:

<UL>

<LI>The server decides whether a user ID and password are required.

<LI>The server validates the user ID and password.

<LI>The server executes the CGI program.

<LI>The server transmits the contents of the requested location.

</UL>

<P>

In short, all the action takes place on the server, and all of

it is done by the Web server (httpd) process. The user sends a

request to the server and receives the result from the server;

everything that happens in between involves activity carried out

by the server process on behalf of the user.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

Browser extensions such as Java and SafeTcl are exceptions to this rule. They are executed by the browser after the browser downloads script files from a server.</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<P>

<B>The Server As Interface&nbsp;&nbsp;</B>This execution by the

server on behalf of the user presents a serious security issue.

If the user were logging in to the server interactively and running

a program in a shell that was governed by the user's own private

account privileges, matters would be simpler. It would be relatively

easy to ensure that the user did not have privileges that endangered

the integrity of the rest of the system. Many system administrators

would protest that it is far from easy to restrict privileges

in this way on even a moderately large system. The difficulty,

however, certainly pales in comparison with the effort involved

in maintaining the integrity of data in a directory to which everyone

on the Internet has some form of write access.

<P>

The fact is, users do not log in to the Web server. The Web server

responds to requests from anyone on the Internet, reading files

on the server on the user's behalf or even executing programs

on the server on the user's behalf. The same httpd process generally

executes programs for all users who access the server, so the

system that works on interactive systems-containing the activities

of the user at the operating-system level based on the user's

process ID-will not work on Web servers.

<P>

Instead, the httpd process uses its own verification mechanisms

to ensure that users are who they say they are, and it interprets

its access restriction rules to determine who can do what (and

where). From the point of view of the operating system, everyone

who accesses a service shares the same process ID and has the

same privileges to all files. The following sections explain why

sharing a process is a problem.

<H3><A NAME="ReadingFiles">

Reading Files</A></H3>

<P>

All Web servers make files available for reading. If your server

does nothing else, you can concentrate on making sure that the

http daemon has no write access anywhere on your server, with

the exception of its log files.

<P>

But even then, you need to take care. Some files may be intended

for the eyes of a particular group of people only. In that case,

creating Web server user groups and carefully planning authentication

domains (containers for the files) can protect the data from unwelcome

attention.

<P>

It is also important to avoid exporting files that should not

be visible over the network. A classic example is exporting the

server's password file so that anyone on the Internet can have

a crack at it. Restricting the exported area on the Web server

to a particular, specially designated directory tree can help

you avoid security holes such as this, but you also must prevent

users from placing links or aliases to sensitive files in the

exported area. <A HREF="ch8.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch8.htm" >Chapter 8</A> &quot;Understanding Basic User Authentication,&quot;

explains how to secure against this kind of security breach.

<H3><A NAME="WritingtoFiles">

Writing to Files</A></H3>

<P>

The primary area of concern in this chapter is allowing users

to write files, not just read them. When you decide that it is

necessary to allow the httpd server to write to files on behalf

of remote users, you must take great care to limit the circumstances

under which the httpd writes data to disk.

<P>

You may need to allow the server to write files on behalf of users

for several reasons:

<UL>

<LI><B>Accepting user input.</B> The guestbook example in Chapter

2, &quot;Introduction to CGI,&quot; stores data entered by users

who visit a site. Other examples include name and address or customer

feedback fields in Web forms.

<LI><B>Taking orders.</B> The same concept can be extended to

cover actual orders for goods. The Web server acts as a front

end for an ordering database, with the order data being read from

a form filled in by users on their browsers. Although it is similar

in many technical respects to survey-type data collection (user

feedback, for example), this type of input is conceptually quite

different. The data received by the server in this way is not

simply stored on disk; it directly initiates a sequence of events

that leads to the delivery of a product and the generation of

an invoice.

<LI><B>Providing temporary storage.</B> The page-based nature

of Web services raises a special difficulty for the Web programmer.

Each screen that the user sees on his browser is a separate Web

location. If a user is presented with a menu on one page and chooses

one of the menu options, the menu choice generally leads to a

separate location. In the case of CGI programs, a separate program

is invoked for each menu choice. And that fact, to the dismay

of programmers, unfortunately means that variables must be stored

on disk between pages.

</UL>

<H3><A NAME="StoringVariables">

Storing Variables</A></H3>

<P>

This section takes a closer look at providing temporary storage.

Suppose that you, the CGI programmer, want to implement a system

that involves three screens. Screen A presents a form that contains

the usual elements: fill-in boxes, drop-down menus, and such.

When form A is submitted, assuming that no essential data is missing,

screen B appears. This screen is also a form, but it picks up

additional information from the user. When form B is submitted,

screen C appears-another form, this time summarizing the user's

entries in forms A and B.

<P>

When I fill in form A and click the submit button, the <TT>ACTION</TT>

parameter of the <TT>FORM</TT> statement in form A contains the

name of a CGI program that generates form B. This CGI program-call

it <TT>MakeB.c</TT>-receives the values that I entered in form

A through the process environment, as described in earlier chapters.

The program then generates form B with a <TT>FORM</TT> statement

that has an <TT>ACTION</TT><B> </B>parameter specifying that another

program-call it <TT>MakeC.cgi</TT>-should be invoked when form

B is submitted. So I fill in form B and click the submit button.

<TT>MakeC.cgi</TT> receives the values that I entered in form

B and generates form C appropriately.

<H3><A NAME="LosingtheData">

Losing the Data</A></H3>

<P>

Just one thing is missing in form C: the data that I entered in

form A! This data was held in two places: in the form where I

entered it and in <TT>MakeB.cgi</TT>, which received it. That's

as far as <TT>the data</TT> goes unless you take explicit steps

to pass it along.

<P>

So you need to make sure that all values that I enter or select

in both forms A and B arrive safely in <TT>MakeC.cgi</TT>.

<P>

<B>Overloading the <I>ACTION </I>Parameter&nbsp;&nbsp;</B>One

way is to make sure that the data gets passed along is to add

the <TT>cgi</TT> variable information to the <TT>ACTION</TT> parameter

of the <TT>FORM</TT> statement in form B. The value of <TT>ACTION</TT>

is a hyperlink, so it can take CGI parameters in the usual way.

This example invokes <TT>MakeC.cgi</TT>, with the variables <TT>Name</TT>,<TT>

ColorChoice</TT>, and <TT>Horsepower</TT> equal to <TT>Kurt</TT>,<TT>

Blue</TT>, and <TT>0</TT>, respectively, when the user submits

the form:

<BLOCKQUOTE>

<PRE>

&lt;FORM ACTION=&quot;MakeC.cgi?Name=Kurt&amp;ColorChoice=Blue&amp;Horsepower=0&quot;&gt;

</PRE>

</BLOCKQUOTE>

<P>

Notice that a statement such as this must be generated by a CGI

program.  The values <TT>Kurt</TT>,<TT> Blue</TT>, and <TT>0</TT>

are decided only when the user fills in form B, so these values

cannot be hard-coded into a HTML file on disk.

<P>

This method ensures that the designated values get to <TT>MakeC.cgi</TT>.

Unfortunately, the contents of form B will be lost, replaced by

these manually imposed values. This method may be useful in limited

circumstances, but beware-it can get out of hand quickly. Consider

a case in which a group of HTML forms are used to build up a set

of data over a series of transactions, with the user being allowed

to go back and forth between forms at will. Consider the number

of variables that you need to put on the <TT>ACTION</TT> parameter's

hyperlink, and consider the impossibility of keeping everything

straight. Then read on.

<P>

<B>Saving It to Disk&nbsp;&nbsp;</B>Another approach is to store

the values of all such variables to a file as the filled-in forms

are received. This type of method is easier to manage when you

have multiple pages and when flow between pages is not strictly

linear-that is, in virtually all Web services. From the point

of view of the Web programmer, writing pages and scripts to use

such a system is not terribly arduous; the main requirement is

that you store to disk all data that you may want to see again

later.

<P>

Although saving data to disk is the preferred option for all but

the most trivial cases, it has some drawbacks:

<UL>

<LI>You need to allow write access in CGI directories. This situation

is not a security risk in itself, but it does make security risks

more likely, and it certainly precludes the possibility of a watertight,

read-only Web server.

<LI>A good deal of programming overhead is involved in setting

up a system of this sort. You need to write low-level storage

management functions that other, higher-level scripts will invoke;

you need to decide on a user authentication strategy; and you

may have to write a primitive interpreter to allow stored values

to reappear in HTML pages. (Fortunately, I've done all that work

for you.)

<LI>Finally, you must do a certain amount of minor housekeeping

work on a regular basis with a system of this type-deleting stale

data from time to time, reviewing access restrictions, and so

on.

</UL>

<P>

These disadvantages are easily outweighed by the flexibility of

a solid intermediate storage system, especially when you consider

that most of the work has already been done. The system described

in the rest of this chapter has all the essentials that you need

to get up and running quickly. Just finish this chapter, copy

some files from the CD-ROM that comes with this book, and prepare

to amaze and astound your friends!

<H2><A NAME="ManagingSessions"><FONT SIZE=5 COLOR=#FF0000>

Managing Sessions</FONT></A></H2>

<P>

The type of write-to-file system described in the preceding sections

is a session-based system. A solid understanding of the way in

which such a system works is essential before you can start writing

code, so this section examines the building blocks of a session-based

Web service.

<H3><A NAME="TheNatureofaSession">

The Nature of a Session</A></H3>

<P>

A URL is the basic unit of Web access. You want to allow users

to access several such locations-CGI scripts and HTML pages-on

your server in a linked sequence, in such a way that you can track

users' actions and any data that they enter. Therefore, you need

to identify the user when she makes contact initially, and if

she follows a link within our service, you want to regard the

new access as being a continuation of the initial one. That means

identifying her when she requests the second and subsequent locations,

and making the logical connection between these accesses and the

initial one. This logical sequence of connected accesses is what

I refer to as a <I>session</I>.

<P>

This section is concerned with tracking the user's access over

a sequence of steps <I>within</I> the service, not with gathering

historical data over an extended period. If the user attaches

to your service and follows links between pages for a few minutes

one day, and then does something similar the next day, those accesses

count as two sessions, not as two parts of one session.

<P>

<B>The End&nbsp;&nbsp;</B>The preceding section's definition of

a session contains a loose end: when does a session finish?

<P>

In some cases, you may want to provide the user an explicit menu

option for logging off and terminating the session. This approach

makes sense in the case of password-protected services, in which

a dangling open connection may represent a security risk.

<P>

In other cases, in which services are open to all users, an explicit

disconnect or logout button may not be necessary. You simply follow

the user's actions until she stops using the service, at which

time any data stored on a temporary basis is deleted by a housekeeping

process of some sort.

<P>

This open-ended approach can be messy. How do you know whether

your user has really left your service and is not just reading

what you displayed on her screen or handling some other business,

with the intention of resuming the session later?

<P>

The answer lies in a time-out mechanism. You decide on a reasonable

upper limit to the length of a pause between accesses to your

service, and you regard as abandoned any sessions that pause for

longer than that duration. A separate housekeeping process-a Perl

script executed as a cron job at regular intervals, for example-deletes

session files that have not been modified within the designated

time.

<P>

A time-out system is also useful in systems that use an explicit

logout option. If the connection goes down or the user forgets

to log off, the session was not terminated properly and remains

active until you kill it. You can use a time-out mechanism to

put these suspended sessions to sleep.

<P>

<B>The Session Identifier&nbsp;&nbsp;</B>Tracking each user separately

from one CGI script or HTML page to the next is essential. You

may have dozens of users accessing your page simultaneously, and

you don't want one person's data becoming confused with that of

another.

<P>

The key to keeping track of users is the <I>session identifier</I>-a

unique number or string that your service assigns to a user when

she first connects to the service. This identifier is automatically

included in all subsequent requests made by the user during that

session, allowing the service to determine which session file

to use for the user when she reconnects.

<P>

You can pass the key between the server and the client in several

ways. If you can guarantee that all clients who access your server

are capable of supporting cookies, you can set a cookie to the

value of the key, as described in <A HREF="ch7.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch7.htm" >Chapter 7</A> &quot;Dynamic and

Interactive HTML Content in Perl and CGI.&quot; The simplest approach-and

the one that you'll use for your sample application-is to store

the key in a HTML form as a hidden value.

<P>

The following HTML statement, for example, results in a CGI variable

called <TT>sessionkey</TT>, with a value of <TT>clef</TT>:

<BLOCKQUOTE>

<PRE>

&lt;input type=&quot;hidden&quot; name=&quot;sessionkey&quot; value=&quot;clef&quot;&gt;

</PRE>

</BLOCKQUOTE>

<P>

The value is not displayed on the browser in any way, but when

the user submits the form, <TT>sessionkey</TT> and <TT>clef</TT>

are included in the list of CGI variables and values that the

CGI script on the server receives.

<P>

To summarize, a <I>session</I> is a set of connected accesses

of a service by one user. A session is terminated when the user

explicitly sends a termination request or when a designated time-out

period elapses. The service-your Perl program-tracks the user

throughout the session by checking for the user's unique session

identifier on each access request.

<H3><A NAME="TheWrapper">

The Wrapper</A></H3>

<P>

So far, so good. The user has a session ID, which she provides

with each new request for a location within your service. Using

this ID, she hops from one page, form, or CGI program to another,

and you keep track of all her data for her.

<P>

This process should be managed by a single CGI program rather

than by a series of interconnected scripts, for a few good reasons:

<UL>

<LI>If you use several CGI scripts-one to handle each distinct

task carried out within your service-you must take great care

to ensure that all scripts deal with session files in a coherent

way.

<LI>Managing the hyperlinks between a series of interconnected

scripts can be a real nightmare. Suppose that you have a link

from script A to script B to script C and another link from script

X to script B. Then you decide to edit script A to go directly

to script C, and delete script B. You don't realize that you've

broken the connection between X and B<TT> </TT>until a customer

runs script X, tries to follow the link to B, and gets a nasty

error message. If you use a single CGI program, there is only

one link to follow.

<LI>If you want to send to the browser a HTML page that is mostly

static, but that has a few simple text substitutions based on

values from the user's session file, you have to write an entire

CGI program to do the job. If you can get your single CGI program

to perform those substitutions for you, you can write plain HTML

where appropriate.

<LI>Using many scripts is too much work. Remember, laziness is

officially a virtue in the Perl world.

</UL>

<P>

In short, a single program is easier to manage, and it makes the

HTML and associated hyperlinks easier to develop, too. This single

script is called a <I>CGI wrapper</I>, and it's how you'll write

your sample application.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>CGIWrap</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

A public-domain utility called CGIWrap (included on the CD-ROM that comes with this book) uses a CGI wrapper script for a different purpose. The problem that CGIWrap seeks to address originates in the fact that HTTP daemons (httpds) execute CGI programs 
on behalf of the end user. The httpd process runs on the server under a user ID that has privileges that are not available to the ordinary user of the server, such as write access to database files. Accordingly, a user on your Web server can write a CGI 
program to perform tasks that the end user cannot carry out. Examples include printing configuration or password files that you prefer to keep confidential and overwriting data. It would be relatively easy for one user to attack another by overwriting the 
data in the other user's CGI directory, for example, but damage of this kind can occur accidentally, too.</BLOCKQUOTE>

<BLOCKQUOTE>

The best solution to this kind of risk is to have each CGI program execute by using the user ID of the owner of the script, rather than using the user ID of the httpd process. The httpd process runs as root (on a UNIX machine) and gets the httpd to run 
each CGI program under a separate process, with the user ID of the script owner.</BLOCKQUOTE>

<BLOCKQUOTE>

CGIWrap, written by Nathan Neulinger, is a utility program that farms out CGI executions to a separate process in this way. The program also performs some other basic security checks on the CGI script before deciding whether it should allow the script to 
execute.</BLOCKQUOTE>

<BLOCKQUOTE>

Some HTTP daemons now have this type of functionality built in. If your HTTP daemon does not provide this feature, you may want to consider installing CGIWrap to enhance the security of your Web server.</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<H3><A NAME="GenericSubstitutions">

Generic Substitutions</A></H3>

<P>

The list in &quot;The Wrapper&quot; earlier in this chapter discussed

substitutions in HTML files. This process is best explained by

means of a simple example. Suppose that you want to greet your

user by using her first name, which she has already entered in

a form. The relevant line of the HTML would look something like

this:

<BLOCKQUOTE>

<PRE>

&lt;h3&gt;Welcome, Jean!&lt;/h3&gt;

</PRE>

</BLOCKQUOTE>

<P>

Assuming that you stored the user's name in the Perl variable

<TT>$firstname</TT>, you can produce this HTML by using a Perl

statement such as the following:

<BLOCKQUOTE>

<PRE>

print &quot;&lt;h3&gt;Welcome, $firstname!&lt;/h3&gt;&quot;;

</PRE>

</BLOCKQUOTE>

<P>

This statement could go in a special CGI script that prints out

the welcome page, or it could appear in a special subroutine in

your wrapper script. You don't want to adopt that approach, though-you

would find yourself writing special scripts or subroutines for

every bit of HTML that is not completely static.

<P>

A much more elegant solution would be to have your variable name

embedded in the HTML file and to have the variable replaced automatically

just before the page is sent to the user. You can't use that method,

of course; a HTML file is not a Perl program, so there's no point

in sticking Perl variable names in there. The principle is sound,

however, and you can achieve the same result by using a slightly

different mechanism.

<P>

Instead of embedding Perl variable names in the HTML file, you

can embed special place-holders that your script will translate

for you as it sends the page. The placeholder needs to be identifiable

as such to the wrapper script; you need to make sure that the

wrapper replaces all placeholders without altering any of the

HTML. You can identify your placeholders in several ways-by inventing

a new HTML tag, for example. (That method is risky, though, because

you never know what tag names will appear in the next version

of the HTML standard.)

<P>

The method in this section uses simple syntax. Placeholders in

your HTML files start and end with a backslash. The part between

the placeholders indicates the name of the variable whose value

is to go in the placeholder's position. The welcome line, for

example, would appear in the HTML file as follows:

<BLOCKQUOTE>

<PRE>

&lt;h3&gt;Welcome, \personalname\!&lt;/h3&gt;

</PRE>

</BLOCKQUOTE>

<P>

Your wrapper script will spot the backslashes, extract the <TT>personalname</TT>

token, and look it up in a table in memory. Because you're using

Perl, that table is implemented as an associative array. (The

section called &quot;Parsing an HTML File&quot; later in this

chapter explains exactly how that implementation is achieved.)

The wrapper script then spits out the original line, minus the

backslashes and the token name, which it replaces with the value

in the associative array for that token.

<P>

You probably will want to develop your own simple syntax for your

application. The syntax used in this chapter is deliberately simple,

so as to keep the sample code easy to follow.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>CAUTION</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

If you want to do anything more complicated than simply replace values, you probably should design proper syntax for your embedded commands before you start, because adding features as you go along will almost certainly result in obscure, confusing 
syntax. You may even want to add looping and other flow-control capabilities. If your needs really extend to features of that sort, you may want to consider server-side includes or Java for an out-of-the-box solution.</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<H3><A NAME="FlowControl">

Flow Control</A></H3>

<P>

The essential components of your managed system are:.

<UL>

<LI>Sessions

<LI>Session keys

<LI>Session management functions

<LI>HTML files with placeholders for variable values

<LI>A substitution mechanism to replace those placeholders with

real values

<LI>A wrapper script that manages all accesses within your system

</UL>

<P>

Before you start to develop this application, you need to know

how you're going to manage program flow.

<P>

This type of system is state-based in the sense that the current

state of the system-the aggregate of the values of all the system's

variables-dictates the next action taken by the system. Looking

at the system from the server side, a set of variables and values

are provided by the browser, and the CGI script decides what to

do based on these values. From the point of view of the browser,

the CGI program is directed by a sort of remote-control mechanism,

by which the browser sets CGI values to control the action on

the server.

<P>

<B>Pointing the Way&nbsp;&nbsp;</B>The most direct way to tell

the wrapper script which location to display next is to state

it in the CGI values. You can accomplish this task quite easily

by inserting into the outgoing form a hidden value that contains

the URL of the next location, such as this:

<BLOCKQUOTE>

<PRE>

&lt;input type=&quot;hidden&quot; name=&quot;location&quot; value=&quot;wrap.cgi&quot;&gt;

</PRE>

</BLOCKQUOTE>

<P>

Then the wrapper script can check the CGI values for a <TT>location</TT>

setting when it tries to decide what to do next.

<P>

<B>Directing the Action&nbsp;&nbsp;</B>Although a <TT>location</TT>

setting is adequate in many cases, you may not always know which

location will come next. You may need the server to do some processing

of the session-state values before deciding which location to

return next.

<P>

In some cases, the CGI program can determine the next action by

examining particular CGI values. If there is no session-key value,

for example, the only valid action is to force the user to log

on. In most cases, however, the number of values to be checked

and the possible combinations of values will get out of control

quickly. Statements of the form &quot;if (A=B and X=Y) but not

((C=B or Y=Z) and A=D)&quot; will start to appear.

<P>

A neat, direct way to implement this type of remote control is

to have a special CGI value-call it <TT>action</TT>-that specifies

the next action to be taken. This value is not always required

but is very useful in most cases.

<P>

Suppose that your welcome screen is to be followed by a product

menu. The following line, placed inside the form on the welcome

page, will tell the wrapper that the next action to be taken should

be <TT>product_menu</TT>:

<BLOCKQUOTE>

<PRE>

&lt;input type=&quot;hidden&quot; name=&quot;action&quot; action=&quot;product_menu&quot;&gt;

</PRE>

</BLOCKQUOTE>

<P>

Notice that this mechanism merely indicates a state to the wrapper

script; it does not dictate which Perl function should be invoked

in the event that a particular state arises.

<P>

<B>Walking Through the Wrapper&nbsp;&nbsp;</B>Figure 9.1 illustrates

the chain of events that take place during a typical session.

<P>

<A HREF="f9-1.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/f9-1.gif"><B> Figure 9.1 : </B><I>The typical program flow through the wrapper.



</I></A><P>

<P>

The following list provides a detailed explanation:

<OL>

<LI>The user begins a new session by accessing the wrapper script

without a session key.

<LI>The wrapper script sends back the logon screen (a simple HTML

form).

<LI>The user enters a user ID and password, and submits the form.

The <TT>ACTION</TT> parameter of the <TT>FORM</TT> statement ensures

that the wrapper is invoked again when the form is submitted.

<LI>The wrapper script determines whether the user ID and password

match; if they don't, the script sends a failure message back

to the user.

<LI>If the authentication succeeds, a new session key is generated,

and a welcome screen is displayed. This screen contains several

links or submit buttons, each of which points to the wrapper script.

The screen also contains a hidden field that stores the session

key for this user.

<LI>The user enters data, if the screen is a form, and then selects

a link or clicks a submit button.

<LI>The browser sends the user's CGI values to the wrapper script.

These values <I>always</I> include the user's session key. Generally,

there also is an action value to direct the wrapper script, as

explained in &quot;Directing the Action&quot; earlier in this

chapter.

<LI>The wrapper script reads the CGI values and extracts the session

key from them.

<LI>The wrapper script reads the user's current session state

from the user's session file, using the session-key value.

<LI>Depending on the value of the <TT>location</TT> and <TT>action</TT>

variables (or on a combination of other CGI values, if these values

are not defined), the wrapper invokes a subroutine to perform

whatever processing is required. This  subroutine usually involves

making changes in the user's session-state values.

<LI>The wrapper script saves the new session state to the user's

session file.

<LI>If a location was set, either by the <TT>location</TT> value

in the incoming CGI data or internally by the wrapper script,

the wrapper script starts to read the file that corresponds to

that location. Alternatively, the script can generate HTML to

go directly to the browser. In either case, the user's session

key is included in the HTML.

<LI>If a HTML file is being sent by the wrapper, each line of

the file is sent to the browser, with any placeholders being filled

in based on the user's session values.

<LI>The new location is displayed on the browser, and the entire

process starts again from step 6.

</OL>

<P>

Notice the overall level of program flow. The browser sends CGI

values to the wrapper script; the wrapper script process the values,

updates stored values, and returns HTML to the browser. The process

starts again when the user submits the form or follows a hyperlink

that leads back into the system.

<H2><A NAME="DesigningtheSampleApplication"><FONT SIZE=5 COLOR=#FF0000>

Designing the Sample Application</FONT></A></H2>

<P>

The example application in this chapter is a shopping-cart-style

ordering system for Camels 'R Us, which sells three types of products:

food, vacations, and accessories. You will develop an interface

that allows authorized users to browse product menus; build up

a list of purchases; review the order; and, finally, submit the

order. At that point, your program simply writes the order details

to a file. In real life, the order could be passed on to an ordering

database.

<H3><A NAME="ProgramFlow">

Program Flow</A></H3>

<P>

Start creating the application by outlining the sequence of events

that take place from the user's point of view. This outline is

not the same as the outline of the wrapper-script internals in

the walk-through section earlier in this chapter, but a description

of the functionality required of your application. The sequence

of events from the user's point of view is as follows:

<OL>

<LI>The action starts when a user accesses the wrapper script

for the first time-that is, without a currently valid session

key. The wrapper script sends a logon menu to the user's browser.

<LI>If the user provides a valid user ID and password, the main

menu is sent. This menu (see fig. 9.2) allows the user to choose

one of the three product categories.

<LI>When the user makes a choice from the main menu, an order

form for the chosen category appears. This form lists all the

available products and allows the user to enter the numbers of

all the products that she wants to order. A blank for any product

means that the user does not want to purchase the product.<BR>

Figures 9.3, 9.4, and 9.5 show the order screens for the three

product categories.

<LI>The user either submits or cancels the order form. If the

user submits the form, the order details from the form are added

to the user's session file, and the main menu reappears. If the

user cancels the form, the session file is unmodified, and the

main menu reappears.

<LI>The user can choose another product category to add to the

order list for this session. If she wants, she can revisit a product

category and amend the number of items ordered.

<LI>A submit button in the main menu allows the user to review

her order for the session so far. When the user clicks this button,

a form appears, showing the number of items of each type ordered

and the total cost of the order. Figure 9.6 shows a sample order-review

screen.

<LI>When the user finishes adding items to the order list, she

can click a submit button in the main menu to confirm the order.

Her order details for this session are appended to an order file.

<BR>

Alternatively, the user can choose to cancel the entire order.

This action clears the order list contained in her session file.

<LI>Finally, the user selects the log-off option from the main

menu to terminate the session. Her session file is deleted at

this point, and an appropriate end-of-session message is displayed.

</OL>

<P>

<A HREF="f9-2.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/f9-2.gif"><B> Figure 9.2 : </B><I>The main menu.



</I></A><P>

<P>

<A HREF="f9-3.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/f9-3.gif"><B> Figure 9.3 : </B><I>The Feeds menu.



</I></A><P>

<P>

<A HREF="f9-4.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/f9-4.gif"><B> Figure 9.4 : </B><I>The Vacations menu.



</I></A><P>

<P>

<A HREF="f9-5.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/f9-5.gif"><B> Figure 9.5 : </B><I>The Extras menu.



</I></A><P>

<P>

<A HREF="f9-6.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/f9-6.gif"><B> Figure 9.6 : </B><I>The order-review screen.



</I></A><P>

<P>

The main menu acts as a sort of anchor for the application, offering

three menu options and three submit buttons. A more hierarchical

system may be appropriate for a larger system, but this level

of complexity is fine for a simple example such as this one.

<H3><A NAME="DataIssues">

Data Issues</A></H3>

<P>

Next, you need to consider how data is to be stored by the application,

both internally (in Perl data structures) and externally (in session

files and raw data files). There are two principal data elements.

The first is the set of data representing the available products

and prices; the second is the order list built up by the user

in the course of a session.

<P>

<B>Product Data&nbsp;&nbsp;</B>The price list consists of a list

of product names and corresponding prices. You're writing this

application in Perl, so the obvious candidate for storing this

data is an associative array, with the product names being keys

and the prices being values. An expression such as <TT>$Price{&quot;Camelskin&quot;}</TT>

returns the unit price of the named product.

<P>

The data can be stored externally in several ways. On a UNIX system,

a simple products-to-prices lookup list would be most efficiently

stored in a DBM file, using a tied hash. You'll use this technique

to store the session information. In the case of the product data,

however, you will have two arrays indexed by product name: an

array of prices and an array of product descriptions. The best

approach for an application this simple is to store the data items

in a flat text file, one product per line. More complex programs

could interface with a relational database of product information,

if necessary.

<P>

Each record contains three items of information about a single

product: the product name, the product price, and a brief description.

In this application, use the separator <TT>:::</TT> between items

so that Perl can easily split the lines as it reads them.

<P>

Listing 9.1 shows the sample data file, which is stored in the

file products.dat on the CD-ROM that comes with this book.

<HR>

<BLOCKQUOTE>

<B>Listing 9.1&nbsp;&nbsp;The Contents of products.dat, the Data

File<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

feed_desertfruit:::14.95:::Fruit of the Desert

feed_driedhusks:::9.95:::Sun Dried Husks

feed_dromspecial:::19.95:::Special Dromedary Supplement



travel_kalahari:::1250:::A 1 year round trip of the Kalahari with the Tuareg.

travel_dakota:::1990:::Discover the magic of the Occident with our 2 week 

&aring;whirlwind tour of Dakota.

travel_alranch:::250:::Break in gently with a weekend at your local branch of 

&aring;Al's Camel Ranch Inc.



extras_pancam:::69:::Hand-stitched leather panniers (camel)

extras_pandrom:::99:::Hand-stitched leather panniers (dromedary)

extras_covers:::150:::Genuine camel-skin hump covers

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The first line in this file describes a product called <TT>feed_desertfruit</TT>,

which is described as &quot;Fruit of the Desert&quot; and which

has a unit price of $14.95. The product name is used as the key

in the price and description associative arrays-<TT>%Price</TT>

and <TT>%Desc</TT>, respectively. So <TT>$Price{'feed_desertfruit'}</TT>

is <TT>&quot;14.95&quot;</TT>, and <TT>$Desc{'feed_desertfruit'}</TT>

is <TT>&quot;Fruit of the Desert&quot;</TT>.

<P>

The three product categories are denoted by the <TT>feed_, travel_,

</TT>and <TT>extras_</TT> prefixes. These prefixes make maintaining

the product data file easier; they have no significance for the

program.

<P>

<B>Order Data&nbsp;&nbsp;</B>Orders are built up over the course

of a session, with the partial order being saved in a session

file until it is complete. You'll save the order as part of the

session data, in the form of an associative array. The keys of

order elements in the session data array are the product names,

and the values are the numbers of the items ordered by the user.

<P>

Internally, the wrapper program stores all session values in an

associative array called <TT>%state</TT>. If the user orders three

<TT>extras_covers</TT> items, <TT>$state{'Order_extras_covers'}</TT>

is set to 3. The <TT>Order_</TT> prefix here is used when you're

scanning the session file to pick up ordered items.

<P>

One advantage of storing this data internally in the form of an

associative array is that it makes the job of storing the data

externally very simple indeed. You'll use Perl's tied-hash functionality

to create a link between the internal storage (associative array)

and the external storage (DBM file), and leave it to Perl's innards

to keep the two in sync. Session files are stored in the LOG subdirectory

and called <TT>$Sessionid.DB</TT>. (<TT>$Sessionid</TT> is the

user's session ID.)

<H2><A NAME="ImplementingtheSampleApplication"><FONT SIZE=5 COLOR=#FF0000>

Implementing the Sample Application</FONT></A></H2>

<P>

Now you're ready to implement your wrapper program. In this section,

you develop a working wrapper system in Perl from scratch. This

application is not highly sophisticated, but it is fully functional,

and it is intended primarily to be an illustration of the techniques

involved. The source code for the program is explained along the

way; all source code for this basic wrapper program appears on

the CD-ROM that comes with this book.

<H3><A NAME="GettingStartedTheMainRoutine">

Getting Started: The Main Routine</A></H3>

<P>

The main routine is the best place to start. This code dictates

the overall program flow; it is also the only routine that is

guaranteed to be executed every time. Listing 9.2 shows the code

for the main routine.

<HR>

<BLOCKQUOTE>

<B>Listing 9.2&nbsp;&nbsp;The Wrapper Script's Main Routine<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#!/usr/local/bin/perl -TI.



# Import methods for DBM files:



require SDBM_File;

require Fcntl;





# Global variables:



%Price, %Desc, %cgivals;





# Read any form values passed in.



&amp;GetCGIVals(%cgivals);





# Extract the settings which dictate program flow:



$SessId = $cgivals{'sessionid'};

$Loc    = $cgivals{'location'};

$Action = $cgivals{'action'};





# Read the product details:



&amp;ReadProductData(&quot;products.dat&quot;);





# Now decide what to do. First check if session id supplied:



if ( $SessId ) {



    # Session Id supplied: perform action and/or show location.



    $Action &amp;&amp; &amp;DoAction($SessId, $Action);

    $Loc &amp;&amp; ShowLoc($SessId, $Loc);

}

else {



    # No session id supplied: login is only valid action.



    # Error check: session id required if location or action requested.



    ( $Loc || $Action ) &amp;&amp;

     HTMLError(&quot;Location/action requested but no session ID provided.&lt;br&gt;&quot;,

            &quot;Please &lt;a href=\&quot;./wrap.cgi\&quot;&gt;log in&lt;/a&gt; &quot;,

            &quot;and follow the instructions on screen.&quot;);



    # Default action: log in.



    &amp;DoLogin;

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The main routine performs these tasks:

<OL>

<LI>Reads the contents of <TT>SDBM_File.pm</TT> and <TT>Fcntl.pm</TT><B>,</B>

which are Perl modules that contain functions related to DBM files

and file access modes, respectively.

<LI>Declares three global associative arrays to store prices,

descriptions, and CGI values, respectively.

<LI>Calls <TT>&amp;GetCGIVals</TT> to read the CGI values. (The

<TT>&amp;GetCGIVals</TT> function is described in &quot;Getting

the CGI Values&quot; later in this chapter.)

<LI>Picks out the user's session ID, as well as the location to

be loaded next or the action to be carried out.

<LI>Reads the product data from the data file by using the <TT>&amp;ReadProductData</TT>

function (described in &quot;Reading the Product Data&quot; later

in this chapter).

<LI>If the session ID is defined and an action has been requested,

the <TT>&amp;DoAction</TT> function is called to carry out that

action. (For details, see &quot;Invoking a Specific Function&quot;

later in this chapter.)

<LI>If the session ID is defined and a location has been requested,

the <TT>&amp;ShowLoc</TT> function (described in &quot;Parsing

an HTML File&quot; later in this chapter) is called to display

that location.

<LI>If no session ID is defined, the only valid action is to display

the logon screen.

<LI>The wrapper determines whether a location or action was requested.

If no location or action was requested, the wrapper terminates

the session with an error message. Otherwise, it calls the <TT>&amp;DoLogin</TT>

function to initiate a login. (The <TT>&amp;DoLogin</TT> function

is described in the &quot;Initiating a Login&quot; section later

in this chapter.)

</OL>

<P>

The subroutines called by the main routine are described in the

following sections, in the sequence in which they appear.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>Error Messages and HTML Headers</B></TD>

</TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

The <TT>&amp;HTMLError</TT> function, which appears from time to time in the following code, is a utility function that displays an error message on the user's browser in HTML format. You could simply write error messages to <TT>STDOUT</TT>, knowing that 
the messages will get to the browser. If an error message is sent before the browser receives a <TT>Content-type:</TT> HTML header line, however, the browser reports a server error, and the user does not get to see your error message. For this reason, send 
a <TT>Content-type: text/html</TT> line first.

</BLOCKQUOTE>

<BLOCKQUOTE>

Another problem arises if you send the HTML header twice; the user sees the second header line on-screen along with the error message. This arrangement is a little untidy, so use a second utility function- <TT>&amp;HTMLhead</TT>-to write the header for 
you, as follows:

</BLOCKQUOTE>

<BLOCKQUOTE>

<TT># A utility routine to print the HTML header once only.<BR>

<BR>

Sub HTMLhead {<BR>

    if ( !$header_printed ) {<BR>

     print &quot;Content-type: text/html\n\n&quot;;<BR>

     $header_printed = 1;<BR>

    }<BR>

}</TT>

</BLOCKQUOTE>

<BLOCKQUOTE>

The variable <TT>$header_printed</TT> is <TT>0,</TT> or <TT>false</TT>, initially. The first time that you call this function, the HTML header is printed, and <TT>$header_printed</TT> is set to <TT>true</TT>; thereafter, the <TT>if</TT> statement is 
<TT>false</TT> and the header is not printed.

</BLOCKQUOTE>

<BLOCKQUOTE>

Following is the <TT>&amp;HTMLError</TT> function, which uses <TT>&amp;HTMLhead</TT>:

<P>

<TT># Utility routine to show a HTML error message<BR>

<BR>

sub HTMLError  {<BR>

<BR>

    my @ErrMsg = @_;<BR>

<BR>

    &amp;HTMLhead;<BR>

<BR>

    print &quot;&lt;title&gt;wrap.cgi Error&lt;/title&gt;\n&quot;;<BR>

    print &quot;&lt;h1&gt;Error&lt;/h1&gt;\n&quot;;<BR>

<BR>

    print @ErrMsg;<BR>

<BR>

    print &quot;&lt;p&gt;Execution aborted.&quot;;<BR>

    exit;<BR>

}</TT>

</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<H3><A NAME="GettingtheCGIValues">

Getting the CGI Values</A></H3>

<P>

The CGI values returned by the browser represent the sum of the

wrapper's knowledge about the user when the program starts. Other

information about the user and his or her previous actions is

contained in the user's session file, but that information cannot

be accessed without the session ID-a CGI value. Your first priority,

then, must be to interpret the CGI information and save the values

of all CGI variables.

<P>

The <TT>&amp;GetCGIVals</TT> subroutine queries the httpd's environment

values and saves the CGI values in the global <TT>%cgivals</TT>

associative array. These values can arrive in two forms, depending

on whether the form data was transmitted by means of the <TT>GET</TT>

or <TT>POST</TT> method:

<UL>

<LI>If the <TT>GET</TT> method was used, the CGI values are contained

in a single environment variable called <TT>QUERY_STRING</TT>.

<LI>If the <TT>POST</TT> method was used, the CGI values are available

on standard input, and the length of the string that contains

those values is provided by the environment variable <TT>CONTENT_LENGTH</TT>.

</UL>

<P>

The <TT>&amp;GetCGIVals</TT> routine checks for both the <TT>GET</TT>

and <TT>POST</TT> methods and saves the CGI information in either

case. Listing 9.3 shows the source code for <TT>&amp;GetCGIVals</TT>.

<HR>

<BLOCKQUOTE>

<B>Listing 9.3&nbsp;&nbsp;The GetCGIVals Subroutine<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

# Get the CGI Values



sub GetCGIVals {



    my (@settings, $set, $name, $value, $formvalues, $postlength);



    # First decide if GET or POST used:



    $postlength = $ENV{'CONTENT_LENGTH'};



    if ( $postlength ) {

	read (STDIN, $formvalues, $postlength);

    }

    else {

	$formvalues = $ENV{'QUERY_STRING'};

    }





    # Store settings in an associative array:



    # First split into &quot;A=B&quot; parts:

    @settings = split('&amp;', $formvalues);



    # Now store each name and value in the associative array:

    foreach $set ( @settings )  {

     ($name, $value) = split('=', $set);

     $cgivals{$name} = $value;

    }

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The code shown in Listing 9.3 carries out the following steps:

<OL>

<LI>Saves number of characters of CGI information waiting on standard

input in the <TT>$postlength</TT> Perl variable.

<LI>If <TT>$postlength</TT> is nonzero, reads exactly <TT>$postlength

</TT>characters from standard input and stores them in the <TT>$formvalues</TT>

Perl variable.If <TT>$postlength</TT> is zero, sets <TT>$formvalues</TT>

to the value of the <TT>QUERY_STRING</TT> environment variable.

<LI>The <TT>$formlength</TT> variable contains one or more CGI

settings and is of the form <TT>&quot;A=X&amp;B=Y&amp;C=Z&quot;</TT>-

a series of single settings concatenated with ampersands. The

<TT>&amp;GetCGIVals</TT> routine saves these individual settings

in the <TT>@settings</TT> array by means of the <TT>split</TT>

function.

<LI>Splits each element of the <TT>@settings</TT> array at the

equal sign (<B>=</B>) into a key and a value, and stores the key

and value in the <TT>$name</TT> and <TT>$value</TT> Perl variables,

respectively.

<LI>Adds a new element to the <TT>%cgivals</TT> associative array,

with <TT>$name</TT> as the index and <TT>$value</TT> as the value.

</OL>

<P>

This last section may seem to be unnecessarily complicated. Why

not split <TT>$formvalues</TT> into <TT>%cgivals</TT> in one step

by using a statement like the following, which would replace the

entire <TT>foreach</TT> loop in <TT>&amp;GetCGIVals</TT>?:

<BLOCKQUOTE>

<PRE>

%cgivals = map( split('='), split('&amp;', $formvalues) );

</PRE>

</BLOCKQUOTE>

<P>

The problem is that there may be &quot;empty&quot; CGI values,

which would disrupt the mapping shown in the single statement.

Suppose that a session ID was missing, for example. The <TT>$formvalues</TT>

string might look like this:

<BLOCKQUOTE>

<PRE>

sessionid=99353&amp;action=Validate&amp;userid=&amp;pass=www

</PRE>

</BLOCKQUOTE>

<P>

In this case, the first <TT>split</TT> function would break <TT>$formvalues</TT>

into these substrings:

<BLOCKQUOTE>

<PRE>

sessionid=99353

action=Validate

userid=

pass=www

</PRE>

</BLOCKQUOTE>

<P>

The second <TT>split</TT> operation carried out within the <TT>map</TT>

operation<TT> </TT>would break these substrings into the following

list of substrings: <TT>sessionid, 99353, action, Validate, userid,

pass,</TT> and <TT>www</TT>.

<P>

Finally, the assignment of <TT>%cgivals</TT> would result in the

following key/value pairs being stuffed into <TT>%cgivals</TT>

(<TT>www</TT> would be empty):

<BLOCKQUOTE>

<PRE>

sessionid=99353

action=Validate

userid=pass

</PRE>

</BLOCKQUOTE>

<P>

Breaking the operation into two steps is marginally more complicated,

but much safer.

<H3><A NAME="ReadingtheProductData">

Reading the Product Data</A></H3>

<P>

Having read the CGI values, you next read in the product data.

This data is stored in the <TT>%Price</TT> and <TT>%Desc</TT>

associative arrays by the <TT>&amp;ReadProductData</TT> subroutine,

which takes a single argument: the name of the product data file.

Listing 9.4 shows the code for <TT>&amp;ReadProductData</TT>.

<HR>

<BLOCKQUOTE>

<B>Listing 9.4&nbsp;&nbsp;The ReadProductData Routine<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

# Read in the product data:



sub ReadProductData {



    my ($infile) = @_;

    my $product, $price, $desc;



    # Check parameters:



    $infile || HTMLError(&quot;ReadProductData requires data file name.&quot;);



    # Open the data file:



    open (PRODUCTS, $infile)

     || HTMLError(&quot;Unable to open product data file $infile (!$).&quot;);





    # Read each line:



    while (&lt;PRODUCTS&gt;) {



     $line = $_;



     # drop trailing newlines:



     chop($line);



     if ( $line =&#247;/:::/) {    # Ignore lines without separator



         # Split on &quot;:::&quot; separators:



         ($product, $price, $desc) = split(':::', $line);



         # Store price and description using product name as key:



         $Price{$product} = $price;

         $Desc{$product} = $desc;

     }

    }



    # tidy up:



    close PRODUCTS;

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

If the named product file exists and is opened successfully, it

is read in one line at a time, and the following processing occurs

for each line:

<OL>

<LI>The new-line character at the end of the line is dropped by

means of the <TT>chop</TT> function.

<LI>If the line does not contain the separator string, Perl skips

to the next record in the file.<BR>

If the line contains the separator string, it is split into the

product name, price, and description fields by means of Perl's

<TT>split</TT> function.

<LI>The product's price and description fields are stored in the

<TT>%Price</TT> and <TT>%Desc</TT> arrays, respectively, using

the product name as the key.

<LI>Finally, the data file is closed.

</OL>

<H3><A NAME="InvokingaSpecificFunction">

Invoking a Specific Function</A></H3>

<P>

The next subroutine that the main routine may call is <TT>&amp;DoAction</TT>-a

function that encapsulates all specific processing functions other

than parsing and displaying a HTML file. <TT>&amp;DoAction</TT>

consists primarily of a list of <TT>if</TT> clauses, as you can

see from the source code in Listing 9.5.

<HR>

<BLOCKQUOTE>

<B>Listing 9.5&nbsp;&nbsp;The DoAction Subroutine<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

# Subroutine to perform a named action for a given session Id.

# Branches to required subroutine.



sub DoAction {



    my ($SessId, $Action ) = @_;





    # Argument check:



    $Action || &amp;HTMLError(&quot;DoAction called but no Action specified!&quot;);



    # Now a branch for each possible action -



    ( $Action eq &quot;Validate&quot; ) &amp;&amp;

     &amp;Validate($cgivals{'userid'}, $cgivals{'pass'});



    ( $Action eq &quot;Add+to+Order&quot; ) &amp;&amp;

     &amp;AddToOrder($SessId, %cgivals);



    ( $Action eq &quot;Cancel+Order&quot; ) &amp;&amp;

     &amp;ShowLoc($SessId, &quot;mainmenu.htmw&quot;);



    ( $Action eq &quot;Return+to+Main+Menu&quot; ) &amp;&amp;

     &amp;ShowLoc($SessId, &quot;mainmenu.htmw&quot;);



    ( $Action eq &quot;Review+Order&quot; ) &amp;&amp;

     &amp;ReviewOrder($SessId);



    ( $Action eq &quot;Confirm+Order&quot; ) &amp;&amp;

     &amp;ConfirmOrder($SessId);



    ( $Action eq &quot;Log+Out&quot; ) &amp;&amp;

     &amp;DoLogout($SessId);



}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The <TT>$DoAction</TT> subroutine takes two arguments: the user's

session ID and the name of the action to be taken. After a quick

check for valid arguments, the subroutine checks the action name

against a list of possible actions and, if it finds a match, calls

the appropriate subroutine. The available subroutines are described

in their own context later in this chapter.

<H3><A NAME="ParsinganHTMLFile">

Parsing an HTML File</A></H3>

<P>

If the main routine finds that a location was specified with the

<TT>$location</TT> variable, it invokes the <TT>&amp;ShowLoc</TT>

subroutine to show the contents of that file on the browser. Any

tokens found in the file (denoted by means of the syntax described

in &quot;Generic Substitutions&quot; earlier in this chapter)

are filled in by means of the contents of the <TT>%State, %Price,</TT>

and <TT>%Desc</TT> arrays.

<P>

This function is, in many ways, the core of the wrapper script.

Listing 9.6 shows the code.

<HR>

<BLOCKQUOTE>

<B>Listing 9.6&nbsp;&nbsp;The ShowLoc Subroutine<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

# Show a HTML file, filling in values using the supplied session ID



sub ShowLoc  {



    my ($ID, $URL) = @_;

    my %SessionValues, @matches;





    # Open the requested file for reading:



    open(RETURNFILE, $URL) ||

     &amp;HTMLError(&quot;Unable to open file \&quot;&quot;, $URL, &quot;\&quot; for reading.&quot;);





    # Send HTML header:



    &amp;HTMLhead;





    # Load all session values for this ID:



    %SessionValues = &amp;GetSessValues($ID);





    # Process each line of requested file:



    while(&lt;RETURNFILE&gt;) {



     # Store this line ($_ will be overwritten):

     $currentline = $_;



     # Check for prices, e.g. &quot;\\Price\itemname\&quot;:

     if ( @matches = /\\\\Price\\(\w+)\\/g )  {

         # Interpolate each match on this line:

         foreach $match ( @matches )  {

          $currentline =~ s/\\\\Price\\$match\\/$Price{$match}/;

         }

     }



     # Check for descriptions, e.g. &quot;\\Desc\itemname\&quot;:

     if ( @matches = /\\\\Desc\\(\w+)\\/g )  {

         # Interpolate each match on this line:

         foreach $match ( @matches )  {

          $currentline =~ s/\\\\Desc\\$match\\/$Desc{$match}/;

         }

     }



     # Check for tokens, e.g. &quot;\tokenname\&quot; =&gt; tokenvalue:

     if ( @matches = /\\(\w+)\\/g )  {

         # Interpolate each match on this line:

         foreach $match ( @matches )  {

          $currentline =~ s/\\$match\\/$SessionValues{$match}/;

         }

     }



     # Now print the line, including any substitutions:

     print $currentline;

    }





    # Tidy up:



    close RETURNFILE;

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The code is simpler than it looks. Step through the code to see

how it works:

<OL>

<LI>The designated file is opened.

<LI>The HTML header line is sent by means of the <TT>&amp;HTMLhead</TT>

function (described earlier in this chapter).

<LI>All session state values for the supplied session ID are read

in by means of the <TT>&amp;GetSessValues</TT> subroutine (described

in detail in &quot;Retrieving Session Data&quot; later in this

chapter).

<LI>Each line of the input file is read in and printed to standard

output.

<LI>The input file is closed.

</OL>

<P>

The fourth step is actually slightly more complicated. Each line

is checked for substitution tokens before being printed to standard

output. If any tokens are found, they are replaced by the appropriate

session-specific values.

<P>

Each line is checked for description, price, and other tokens.

The mechanism is very similar in each case. Start with looking

at the substitution of simple tokens, which are denoted by a token

name surrounded by single backslashes (<TT>\sessionid\</TT>, for

example).

<P>

The following steps are involved in replacing this value with

the actual session ID value:

<OL>

<LI>A regular-expression match is carried out. The regular expression

is <TT>/\\(\w+)\\/</TT> and has a trailing <TT>g</TT> to denote

that all such patterns within the string are to be matched.

<LI>This pattern looks for a backslash, followed by at least one

alphanumeric character, followed by another backslash. The backslash

has special meaning within regular expressions, so it must be

escaped by means of a second backslash.

<LI>The &quot;at least one alphanumeric character&quot; is the

token name, which is saved because it is surrounded by parentheses.

<LI>All such tokens are saved in the <TT>@matches</TT> array,

because the regular expression takes place in the context of an

array assignment.

<LI>The <TT>foreach</TT> clause replaces all matched patterns

on the current line with the actual value of the token in the

session-state array. This replacement is made by making a regular-expression

substitution; the matched token, surrounded by backslashes, is

replaced by a value in the <TT>%SessionValues</TT> associative

array. The index into this array is the current token name, <TT>$match</TT>.

</OL>

<P>

The steps for replacing price and description tokens are quite

similar. In the case of price tokens, the pattern match is <TT>/\\\\Price\\(\w+)\\/g</TT>,

which looks for an additional <TT>\\Price\</TT> before the token.

The replacement operation is similar, too, but the <TT>%Price</TT>

array is used instead of the <TT>%Price%SessionValues</TT> array.

The procedure for descriptions is identical, except for the fact

that the <TT>%Desc</TT> associative array is used.

<H3><A NAME="InitiatingaLogin">

Initiating a Login</A></H3>

<P>

The final subroutine that may be invoked from the main routine

is <TT>&amp;DoLogin</TT>. This subroutine assigns a session ID

and displays the login screen, which challenges the user to enter

a valid user ID and password. Listing 9.7 shows the source code

for <TT>&amp;DoLogin</TT>.

<HR>

<BLOCKQUOTE>

<B>Listing 9.7&nbsp;&nbsp;The DoLogin Subroutine<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

# Subroutine to perform login.



sub DoLogin {



    # Generate a pseudo-random session id:



    $SessId = time || $$;





    # Store this id in its own session file:



    $sessvals{'sessionid'} = $SessId;

    &amp;SetSessValues($SessId, %sessvals);





    # Show the login page



    &amp;ShowLoc( $SessId, &quot;login.htmw&quot; );

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The code carries out the following three simple steps:

<OL>

<LI>Generates a unique session ID for this session. This ID consists

of the system time on the httpd server combined with the process

ID of the process that is running the wrapper program.

<LI>Stores the session ID in the session values file. This ID

can be used at a later stage as a cross-check on the validity

of a session file, but this wrapper program does not use it in

this way. The value is stored by means of the <TT>&amp;SetSessvalues</TT>

function (described in &quot;Storing Session Data&quot; later

in this chapter).

<LI>Displays the login menu, using the <TT>&amp;ShowLoc</TT> function

(described earlier in this chapter).

</OL>

<P>

The mechanics of initiating and manually terminating a session

are explained in the following section.

<H2><A NAME="LoggingInandOut"><FONT SIZE=5 COLOR=#FF0000>

Logging In and Out</FONT></A></H2>

<P>

The first time that the user runs <TT>wrap.cgi, &amp;DoLogin</TT>

is invoked and displays the login screen on the user's browser.

The user enters a user ID and password and then sends them to

the server by submitting the form. Then the wrapper program calls

<TT>&amp;Validate</TT> to authenticate the details provided by

the user.

<P>

Notice that <TT>&amp;DoLogin</TT> does no more than initiate the

login. After the user fills in the user ID and password and submits

the form, the wrapper program is invoked again. At that point,

the <TT>&amp;Validate</TT> function is called to perform the actual

authentication of the user.

<H3><A NAME="LoggingIn">

Logging In</A></H3>

<P>

Listing 9.8 shows the HTML file <TT>login.html</TT>.

<HR>

<BLOCKQUOTE>

<B>Listing 9.8&nbsp;&nbsp;The login.html File<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

&lt;html&gt;

&lt;head&gt;

&lt;title&gt;Camel's 'R UsLog in&lt;/title&gt;

&lt;/head&gt;



&lt;body&gt;

&lt;h1&gt;Camels 'R Us Log in&lt;/h1&gt;



You must log in as a registered user before you can use the system.

&lt;p&gt;



&lt;ul&gt;



&lt;li&gt;

Click &lt;a href=&quot;http://www.camelsrus.com/register.html&quot;&gt;here&lt;/a&gt; to register as 

&aring;an on-line customer with Camels 'R Us.

&lt;p&gt;



&lt;li&gt;

If you have already registered, enter your userid and password and click &quot;Log on&quot;:



&lt;/ul&gt;



&lt;form method=&quot;post&quot; action=&quot;wrap.cgi&quot;&gt;



&lt;input name=&quot;sessionid&quot; type=&quot;hidden&quot; value=&quot;\sessionid\&quot;&gt;



&lt;input name=&quot;action&quot; type=&quot;hidden&quot; value=&quot;Validate&quot;&gt;



&lt;table&gt;



&lt;tr&gt;

&lt;td&gt;User ID:&lt;/td&gt;

&lt;td&gt;&lt;input name=&quot;userid&quot; type=&quot;text&quot; size=20&gt;&lt;/td&gt;

&lt;/tr&gt;



&lt;tr&gt;

&lt;td&gt;Password:&lt;/td&gt;

&lt;td&gt;&lt;input name=&quot;pass&quot; type=&quot;password&quot; size=20&gt;&lt;/td&gt;

&lt;/tr&gt;



&lt;tr&gt;

&lt;td&gt;&lt;/td&gt;

&lt;td&gt;&lt;input name=&quot;logon&quot; value=&quot;Log on&quot; type=&quot;submit&quot;&gt;&lt;/td&gt;

&lt;/tr&gt;



&lt;/table&gt;



&lt;/form&gt;



&lt;/body&gt;

&lt;/html&gt;

</PRE>

</BLOCKQUOTE>

<HR>

<P>

Following are the critical lines of this file:

<UL>

<LI><TT>&lt;form method=&quot;post&quot; action=&quot;wrap.cgi&quot;&gt;

<BR>

</TT>This statement tells the browser what location to request

when the form is submitted (<TT>wrap.cgi</TT>) and to submit its

CGI data via the <TT>POST</TT> method.

<LI><TT>&lt;input name=&quot;sessionid&quot; type=&quot;hidden&quot;

value=&quot;\sessionid\&quot;&gt;<BR>

</TT>The session ID is inserted into this line by the wrapper

program before the browser sees it, so to the browser, the line

will look more like the following:<BR>

<TT>&lt;input name=&quot;sessionid&quot; type=&quot;hidden&quot;

value=&quot;838604689&quot;&gt; <BR>

</TT>This statement tells the browser to store the CGI value <TT>sessionid=838604689</TT>

but not to display it. This value will be sent to the server with

the other CGI values when the form is submitted, allowing you

to identify the user.

<LI><TT>&lt;input name=&quot;action&quot; type=&quot;hidden&quot;

value=&quot;Validate&quot;&gt;<BR>

</TT>Another hidden value, <TT>action=Validate</TT>, is present

in this form. The CGI data that goes back to the server instructs

<TT>wrap.cgi</TT> what step to take next: validation of the user

ID and password provided by the user.

<LI>Finally, the <TT>userid</TT> and <TT>pass</TT> fields create

the text boxes where the user enters her authentication details.

</UL>

<H3><A NAME="ValidatingtheUser">

Validating the User</A></H3>

<P>

When the user submits the login form, the resulting CGI data contains

two items that are of interest to the wrapper program: the user's

session ID and a CGI value called <TT>action</TT>, which has the

value <TT>Validate</TT>. The <TT>&amp;DoAction</TT> function sees

this value and invokes the <TT>&amp;Validate</TT> function, which

is shown in Listing 9.9.

<HR>

<BLOCKQUOTE>

<B>Listing 9.9&nbsp;&nbsp;The Validate Subroutine<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

# Validate: Given a userid and password, check against

# a user database and if valid, show main menu.



sub Validate {



    my ($uid, $pwd) = @_;

    my %userdb;



    # Argument check: both userid and password are required.



    $pwd || return 0;



    # userid/password pairs are stored in the user db file:



    tie(%userdb, 'SDBM_File', &quot;.userdb&quot;, Fcntl::O_RDONLY(), 0664) ||

     HTMLError(&quot;Unable to open user database (!$).&quot;);



    # Success if password given matches password in file.

    # Note check that a password was actually given...



    if ( $pwd ne &quot;&quot; &amp;&amp; $userdb{$uid} eq $pwd ) {



     # Add customer name to session data:



     %sessvals = &amp;GetSessValues($SessId);

     $sessvals{'customerid'} = $uid;

     &amp;SetSessValues($SessId, %sessvals);



     # Show the main menu:



     &amp;ShowLoc($SessId, &quot;mainmenu.htmw&quot;);

    }

    else {

     &amp;ShowLoc($SessId, &quot;failedlogin.htmw&quot;);

    }



    # tidy up:



    untie(%userdb);

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

<TT>&amp;Validate</TT> takes two arguments-the user ID and password-and

attempts to match them with the contents of a DBM file that contains

user ID-password pairs by following these steps:

<OL>

<LI><TT>&amp;Validate</TT> first determines that a password has

been provided.

<LI>The <TT>tie</TT> statement creates a link between an associative

array (<TT>%userdb</TT>) and the DBM file that contains the valid

user IDs and passwords. The arguments are:

<UL>

<LI>The name of the associative array (<TT>%userdb</TT>).

<LI>The method to be used by Perl to associate external and internal

storage. You'll use <TT>SDBM_File</TT> so that Perl will use the

methods defined in <TT>SDBM_File.pm</TT> to connect the associative

array with a DBM file.

<LI>The name of the DBM database in which the user data is stored.

<LI>The file-access mode. You'll use <TT>Fcntl::RDONLY()</TT>,

which returns a read-only flag.

<LI>The default file protection for the database.

</UL>

</OL>

<BLOCKQUOTE>

If this call to <TT>tie</TT> is successful, the <TT>%userdb</TT>

array serves as an interface to the contents of the DBM file.

</BLOCKQUOTE>



<OL START=3>

<LI>If the password field is not empty, it is compared with the

password for the specified user ID. If the user does not exist,

the match fails. Likewise, if the user exists but the password

is not the same as the one in the authentication DBM file, the

match fails.

<LI>If the match succeeds, the authentication details are valid.

The user ID is added to the session file, and the main menu is

displayed; the user is logged in.<BR>

If the match fails, the file <TT>failedlogin.htmw</TT> is displayed.

This file explains what happens and allows the user to try logging

in again.

<LI>Finally, the <TT>untie</TT> command breaks the connection

between the <TT>%userdb</TT> array and the DBM file.

</OL>

<H3><A NAME="LoggingOut">

Logging Out</A></H3>

<P>

Logging out is much simpler than logging in. If the user clicks

a submit button called <TT>action</TT>, with a value of <TT>Log

Out</TT>, the wrapper script's <TT>&amp;DoLogout</TT> function

is called by <TT>&amp;DoAction</TT>. Listing 9.10 shows the code

for <TT>&amp;DoLogout</TT>.

<HR>

<BLOCKQUOTE>

<B>Listing 9.10&nbsp;&nbsp;The DoLogout Subroutine<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

# Perform a logout. Deletes session file and shows log off screen.



sub DoLogout {



    my ($sessionid) = @_;





    # zap the session file: two parts, *.pag and *.dir

    # taint checking =&gt; need to save file name via a pattern match:



    $sessionid =~/(\w+)/;

    unlink(&quot;./log/$1.DB.pag&quot;, &quot;./log/$1.DB.dir&quot;);





    # show the farewell screen:



    print &quot;Content-type: text/html\n\n&quot;,

    &quot;&lt;html&gt;&lt;head&gt;&quot;,

    &quot;&lt;title&gt;End of session&lt;/title&gt;&quot;,

    &quot;&lt;/head&gt;&quot;,

    &quot;&lt;body&gt;&quot;,

    &quot;&lt;h1&gt;Session Terminated&lt;/h1&gt;&quot;,

    &quot;you have logged out from the Camels 'R Us Web ordering system.&lt;p&gt;&quot;,

    &quot;&lt;a href=\&quot;wrap.cgi\&quot;&gt;Call again&lt;/a&gt; soon!&lt;p&gt;&quot;,

    &quot;&lt;/body&gt;&lt;/html&gt;&quot;;

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

This subroutine performs two simple steps: deletes the DBM file

associated with the session and displays a farewell message. The

latter task is simple, but the former is complicated somewhat

by the fact that you have turned on Perl's taint checking by using

the <TT>-T</TT> option in the command line.

<P>

There are, in fact, two DBM files for each session: one with a

<TT>.pag</TT> extension and one with a <TT>.dir</TT> extension.

Given a session ID stored in the Perl <TT>$sessionid</TT> variable,

the most direct way to delete these two files is to pass them

as a literal string to the <TT>unlink</TT> function, as follows:

<BLOCKQUOTE>

<PRE>

unlink(&quot;./log/$sessionid.DB.pag&quot;, &quot;./log/$sessionid.DB.dir&quot;);

</PRE>

</BLOCKQUOTE>

<P>

This statement fails, however. Perl can see that <TT>$sessionid</TT>

was passed in to the program via the environment and is, therefore,

not to be trusted. In this instance, a hacked session ID value

might result in the deletion of arbitrary files.

<P>

You need to extract the value contained in <TT>$sessionid</TT>

to another variable that Perl does not regard as being tainted.

Simply assigning a new variable to <TT>$sessionid</TT> does not

work; Perl will see that the new variable is tainted by such close

association with the old one.

<P>

Instead, perform a pattern match on <TT>$sessionid</TT>, looking

for all alphanumeric characters and saving the result, as follows:

<BLOCKQUOTE>

<PRE>

$sessionid =&#247; /(\w+)/;

</PRE>

</BLOCKQUOTE>

<P>

The expression <TT>/(\w+)/</TT> tells Perl to match the first

set of alphanumeric characters in <TT>$sessionid</TT> and store

them. Then this stored value-<TT>$1</TT>-is used in the arguments

to the <TT>unlink</TT> command.

<P>

This method works, because Perl assumes that you know what you

are doing when you save the results of a pattern match. The assumption

is based on the fact that you got hold of the tainted variable

and extracted something from it in a very specific way. It would

be quite difficult for a suspect value to survive a pattern match

of this sort.

<H2><A NAME="ManagingSessionData"><FONT SIZE=5 COLOR=#FF0000>

Managing Session Data</FONT></A></H2>

<P>

After you come this far, the management of session data becomes

relatively simple. You use associative arrays to store the session

data internally, and you use tied hashes to associate these arrays

with DBM files for external storage. You've already seen how to

use DBM files for user ID-password pairs; the principle is identical

for session data.

<H3><A NAME="StoringSessionData">

Storing Session Data</A></H3>

<P>

The current session data is stored by calling the <TT>&amp;SetSessValues</TT>

subroutine. Listing 9.11 shows the code for <TT>&amp;SetSessValues</TT>.

<HR>

<BLOCKQUOTE>

<B>Listing 9.11&nbsp;&nbsp;The SetSessValues Subroutine<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

# Store values for a given session id

# Takes an associative array as argument, saves to session file



sub SetSessValues {



    my ($Sessionid, %DBMdb) = @_;



    my %tiedDB;





    # Open the session file and set values:



    tie(%tiedDB, 'SDBM_File', &quot;./log/$Sessionid.DB&quot;,

      Fcntl::O_RDWR()|Fcntl::O_CREAT(), 0644) ||

       HTMLError(&quot;Unable to open session file for sessionid &quot;,

              $Sessionid, &quot; for writing ($!).&quot;);





    # Set the values in the DB to values passed as argument:



    %tiedDB = %DBMdb;





    # Store the new values:



    untie(%tiedDB);

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The code does the following things:

<OL>

<LI>Passes the user's session ID and the current session state

as arguments to the function.

<LI>Using the <TT>tie</TT> statement, creates the relationship

between an associative array (<TT>%tiedDB</TT>) and the session

file. The arguments are:

<UL>

<LI>The name of the associative array (<TT>%tiedDB</TT>).

<LI>The method to be used by Perl to associate external and internal

storage. You use <TT>SDBM_File</TT>, just as you did for the user-authentication

database.

<LI>The name of the DBM database in which the session data is

to be stored.

<LI>The file access mode. You use a Boolean <TT>or</TT> combination

of <TT>Fcntl::RDWR()</TT> and <TT>Fcntl::O_CREAT()</TT>, which

are methods that return file access flags. The flags used here

indicate that the file is to be opened in read/write mode and

created if it does not already exist.

<LI>The default file protection for the database.<BR>

If this call to <TT>tie</TT> is successful, the <TT>%tiedDB</TT>

array serves as an interface to the contents of the DBM database.

Making a change in <TT>%tiedDB</TT> has the same effect as making

the same change directly in the DBM file.

</UL>

<LI>Copies the entire contents of the session state, represented

by <TT>%DBMdb,</TT> to the tied array (<TT>%tiedDB</TT>).

<LI>Closes the DBM database and breaks <TT>%tiedDB</TT>'s connection

with it by calling the <TT>untie</TT> function. The contents of

<TT>%tiedDB</TT> are written in full to the DBM file at this point.

</OL>

<P>

That's the beauty of using tied hash arrays; they look after all

the storage implementation details for you. Simply assign a normal

associative array to a tied hash array, and you've stored the

contents of the normal array.

<H3><A NAME="RetrievingSessionData">

Retrieving Session Data</A></H3>

<P>

The principle for retrieving session data that has already been

stored to a DBM file is analogous. You can retrieve the session

state for a given session ID from DBM storage by using the <TT>&amp;GetSessValues</TT>

function, the code for which appears in Listing 9.12.

<HR>

<BLOCKQUOTE>

<B>Listing 9.12&nbsp;&nbsp;The GetSessValues Subroutine<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

# Retrieve session values for a given session ID

# Return them as an associative array



sub GetSessValues {



    my ($Sessionid) = @_;

    my %DBMdb, %returnvalue;





    # No session file, no values so just return.



    return unless -e &quot;./log/$Sessionid.DB.pag&quot;;





    # Open the session file and get values:



    tie(%DBMdb, 'SDBM_File', &quot;./log/$Sessionid.DB&quot;, Fcntl::O_RDONLY(), 0664) ||

     HTMLError(&quot;Unable to open session file for sessionid &quot;,

            $Sessionid, &quot; for reading ($!).&quot;);



    # Save the array before closing the file:



    %returnvalue = %DBMdb;



    untie %DBMdb;



    # Pass the associative array back to the calling routine:



    return %returnvalue;

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

All the action in this code is contained in the <TT>tie</TT> and

<TT>untie</TT> statements; the rest is error checking. The following

steps show how <TT>&amp;GetSessValues</TT> works:

<OL>

<LI>The user's session ID is passed in as the sole argument to

the function.

<LI>If no session file exists for the supplied session ID, the

function simply returns control to the calling function.

<LI>The <TT>tie</TT> statement creates the relationship between

an associative array (<TT>%DBMdb</TT>) and the session file. The

arguments are:

<UL>

<LI>The name of the associative array (<TT>%DBMdb</TT>).

<LI>The method to be used by Perl to associate external and internal

storage. You use <TT>SDBM_File</TT> again.

<LI>The name of the DBM database in which the session data is

stored.

<LI>The file access mode. You use <TT>Fcntl::RDONLY()</TT>, which

is a method within the <TT>Fcntl</TT> package that returns a read-only

flag.

<LI>The default file protection for the database.<BR>

If this call to <TT>tie</TT> is successful, the <TT>%DBMdb</TT>

array behaves as though it contains all the values stored in the

associated DBM file.

</UL>

<LI>Next, the code copies the entire contents of <TT>%DBMdb</TT>

into an array called <TT>%returnvalue</TT>, effectively making

a local copy of the entire database.

<LI>The code closes the DBM database and breaks <TT>%DBMdb</TT>'s

connection with it by calling the <TT>untie</TT> function. The

contents of <TT>%DBMdb</TT> are undefined after the code closes

the DBM file by means of the <TT>untie</TT> function, which is

why you needed to make the local copy of the database in <TT>%returnvalue</TT>

before calling <TT>untie</TT>.

<LI>Finally, the code passes the contents of <TT>%returnvalue</TT>

back to the calling function.

</OL>

<P>

Again, the tied hash looks after the storage implementation details

for you. These two functions allow you to store and retrieve an

entire set of session data quite easily.

<H2><A NAME="ManagingtheOrders"><FONT SIZE=5 COLOR=#FF0000>

Managing the Orders</FONT></A></H2>

<P>

You now have the necessary infrastructure to carry out the core

business of this application, which is to give the user an interface

to an ordering system. You need to allow the user to build an

order in stages during the course of a session; review that order

at any stage; cancel the entire order, if desired; and confirm

the order, at which point the order will be written to permanent

storage.

<H3><A NAME="BuildinganOrder">

Building an Order</A></H3>

<P>

A user builds an order by using the three order forms shown in

figures 9.3, 9.4, and 9.5 (refer to &quot;Program Flow&quot; earlier

in this chapter). These forms work in the same way, so this section

focuses on only one: the Feeds form. The source for the form is

stored in <TT>feeds.htm</TT>. The relevant lines for the first

product are as follows, with the other products being set up in

an identical fashion:

<UL>

<LI><TT>&lt;form method=&quot;post&quot; action=&quot;wrap.cgi&quot;&gt;

<BR>

</TT>The <TT>form</TT> statement tells the browser to send its

CGI data to the server by using the <TT>POST</TT> method and to

request the location <TT>wrap.cgi</TT> when the data is returned.

<LI><TT>&lt;input name=&quot;sessionid&quot; type=&quot;hidden&quot;

value=&quot;\sessionid\&quot;&gt;<BR>

</TT>The session ID is written to this line before the browser

sees the form. Just as in the case of the login menu, this line

ensures that the session ID is contained in the form as a CGI

value, so that the browser can pass it back to the server with

the rest of the CGI data.

<LI><TT>&lt;td&gt;\\Desc\feed_driedhusks\&lt;/td&gt;<BR>

</TT>The first data cell in the table contains the token <TT>\\Desc\feed_driedhusks\</TT>,

which will be replaced in the <TT>&amp;ShowLoc</TT> function by

the current value of <TT>$Desc{'feed_driedhusks'}</TT>.

<LI><TT>&lt;td align=right&gt;$\\Price\feed_driedhusks\&lt;/td&gt;

<BR>

</TT>Similarly, <TT>\\Price\feed_driedhusks\</TT> is replaced

by <TT>$Price{'feed_driedhusks'}</TT>.

<LI><TT>&lt;td&gt;&lt;input name=&quot;Order_feed_driedhusks&quot;

type=&quot;text&quot;<BR>

value=&quot;\Order_feed_driedhusks\&quot;

size=10&gt;&lt;/td&gt;<BR>

</TT>This line appears in the browser with the final token

filled in. If the number of items of this type that have been

ordered so far is 3, the line appears as follows: <BR>

<TT>&lt;td&gt;&lt;input name=&quot;Order_feed_driedhusks&quot;

type=&quot;text&quot;<BR>

   value=&quot;3&quot; size=10&gt;&lt;/td&gt;

<BR>

</TT>This line gives the text input field for this item

an initial value of <TT>3</TT>.

<LI><TT>&lt;input name=&quot;action&quot; type=&quot;submit&quot;

value=&quot;Add to Order&quot;&gt;<BR>

</TT>The submit button labeled <TT>Add to Order</TT> is called

<TT>action</TT>. If the user clicks this button, a CGI value of

<TT>action=Add+to+Order</TT> is sent to the server. This value

is trapped by <TT>&amp;DoAction</TT>, and the appropriate function

is called.

</UL>

<P>

After filling in the desired quantity of each product, the user

clicks the <TT>Add to Order</TT> submit button. A set of CGI data

goes back to <TT>wrap.cgi</TT>, containing an <TT>action</TT>

value that is caught by <TT>&amp;DoAction</TT> and that in turn

invokes the <TT>&amp;AddtoOrder</TT> function.

<P>

<TT>&amp;AddtoOrder</TT> takes two parameters: the user's session

ID and the associative array of CGI values. Notice that these

values are the CGI values, not the session values. You want to

extract some of the CGI information and discard the rest; the

data that you extract will be saved with the session data for

later use.

<P>

Listing 9.13 shows the code for the <TT>&amp;AddtoOrder</TT> function.

<HR>

<BLOCKQUOTE>

<B>Listing 9.13&nbsp;&nbsp;The AddToOrder Subroutine<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

# Given the cgi values from a form, add fields starting

# with &quot;Order_&quot; to the order for the current session.



sub AddToOrder {



    my ($SessId, %cgivals) = @_;

    my %state;





    # Get current session state first:



    %state = &amp;GetSessValues($SessId);





    # Add order items and quantities to state:



    foreach $item (keys %cgivals) {

     if ( $item =~ /^Order_/ &amp;&amp; $cgivals{$item} ) {

         $state{$item} = $cgivals{$item};

     }

    }





    # Save state after adding order:



    &amp;SetSessValues($SessId, %state);





    # Now drop back to main menu:



    &amp;ShowLoc($SessId, &quot;mainmenu.htmw&quot;);

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

This code takes the following actions:

<OL>

<LI>The current session values are retrieved from the DBM file

by means of <TT>&amp;GetSessVals</TT> and stored in <TT>%state</TT>.

<LI>Each item in the<TT> %cgivals</TT> array is checked. If an

item begins with <TT>Order_,</TT> it is an order and is saved

in the <TT>%state</TT> array. If one of the CGI values is <TT>Order_feed_driedhusks=4</TT>,

for example, <TT>$state{'Order_feed_driedhusks'}</TT> is set to

<TT>4</TT>.

<LI>The updated <TT>%state</TT> array is saved back to the DBM

file.

<LI>The main menu is displayed again, allowing the user to continue

building the order, review it, or commit it.

</OL>

<H3><A NAME="ReviewingtheOrder">

Reviewing the Order</A></H3>

<P>

It is reasonable to expect that the user may want to review the

order before confirming it. She can do so by selecting <TT>Review

Order</TT> from any of the menus. This option passes a CGI value

of <TT>action=Review+Order</TT> to the wrapper script. This value

is trapped by <TT>&amp;DoAction,</TT> causing<TT> &amp;ReviewOrder</TT>

to be invoked.

<P>

Listing 9.14 shows the code for &amp;ReviewOrder.

<HR>

<BLOCKQUOTE>

<B>Listing 9.14&nbsp;&nbsp;The ReviewOrder Subroutine<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

# Review the order for the current session



sub ReviewOrder {



    my ($sessionid) = @_;

    my %state = GetSessValues($sessionid);





    # Use &amp;ShowLoc to display start and end parts of form:

    # We'll build the list manually in this subroutine.



    # Print the form up to the start of the list:



    &amp;ShowLoc($sessionid, &quot;review_head.htmw&quot;);





    # Show the current order in a table:



    print &quot;&lt;table border=2&gt;&quot;,

    &quot;&lt;tr&gt;&quot;,

    &quot;&lt;th&gt;Item&lt;/th&gt;&quot;,

    &quot;&lt;th&gt;Unit price&lt;/th&gt;&quot;,

    &quot;&lt;th&gt;Number Ordered&lt;/th&gt;&quot;,

    &quot;&lt;th&gt;Total Price&lt;/th&gt;&quot;,

    &quot;&lt;/tr&gt;&quot;;





    # Keep a running total of price as we go



    $grand_total = 0;

    foreach $item ( keys %state ) {



     # If it starts with &quot;Order_&quot;, it's an order.



     if ( $item =~/^Order_(\w+)/ ) {

         $thisprice = $state{$item} * $Price{$1};

         print &quot;&lt;tr&gt;&quot;,

         &quot;&lt;td align=left&gt;$Desc{$1}&lt;/td&gt;&quot;,

         &quot;&lt;td align=right&gt;\$$Price{$1}&lt;/td&gt;&quot;,

         &quot;&lt;td align=right&gt;$state{$item}&lt;/td&gt;&quot;,

         &quot;&lt;td align=right&gt;\$$thisprice&lt;/td&gt;&quot;,

         &quot;&lt;/tr&gt;\n&quot;;

         $grand_total += $thisprice;

     }

    }



    print &quot;&lt;/table&gt;&lt;p&gt;&quot;;



    print &quot;Total cost this order: \$$grand_total. &quot;,

    &quot;Residents of Ireland please add 21\% sales tax.&quot;;



    # Now show the rest of the form:



    &amp;ShowLoc($sessionid, &quot;review_tail.htmw&quot;);



}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

This code builds a HTML table that shows the current order details,

one item at a time. To create this table, the code follows these

steps:

<OL>

<LI>Gets the current session state and stores it in <TT>%state</TT>.

<LI>Calls <TT>&amp;ShowLoc</TT> to display the header part of

this page. This header does not vary from one invocation to the

next, so it is stored in a HTML template file.

<LI>Prints the table header. The columns are Item, Unit Price,

Number Ordered, and Total Price.

<LI>Checks each item in the <TT>%state</TT> array and, if the

key starts with <TT>Order_</TT>, prints the details for that item.

<LI>Finishes the table.

<LI>Calls <TT>&amp;ShowLoc</TT><B> </B>to display the standard

footer for this page.

</OL>

<P>

You need to look closely at the code that displays the order information

for a given item. Notice first that the regular-expression match

that determines whether the item is an order item stores the text

after <TT>Order_</TT>. This backreference is available as <TT>$1</TT>

after the match takes place. If the item's key is <TT>Order_feed_driedhusks</TT>,

for example, <TT>$1</TT> will be <TT>feed_driedhusks</TT>. You

need to store this backreference so that you can reference values

in the <TT>%Price</TT> and <TT>%Desc</TT> arrays.

<P>

For each item, &amp;ReviewOrder does the following:

<OL>

<LI>Multiplies the number of items ordered (<TT>$state{$item}</TT>)

by the unit price of this item (<TT>$Price{$1}</TT>). The result

is stored in <TT>$thisprice</TT>.

<LI>Prints an HTML table cell that contains the product description:

<TT>$Desc{$1}</TT>.

<LI>Prints the unit price of this product: <TT>$Price{$1}</TT>.

The <TT>\$</TT> before <TT>$Price</TT> produces a real dollar

sign on-screen.

<LI>Prints the number of these items ordered: <TT>$state{$item}</TT>.

<LI>Prints the total price for this product, in dollars.

<LI>Keeps a running tally of the grand-total price for this order.

This total is printed below the table.

</OL>

<P>

Figure 9.6, earlier in this chapter, shows an example of the resulting

table.

<H3><A NAME="PlacingtheOrder">

Placing the Order</A></H3>

<P>

Finally, the order that you have so carefully built must be confirmed

by the user and written to a file. Order confirmation is triggered

when the user clicks one of the many <TT>Confirm Order</TT> buttons

that you have helpfully scattered around the various forms. The

CGI data that arrives back at <TT>wrap.cgi</TT> then contains

the setting <TT>action=Confirm+Order</TT>, which is caught by

<TT>&amp;DoAction</TT>; then <TT>&amp;ConfirmOrder</TT> is invoked.

<P>

Listing 9.15 shows the source code for <TT>&amp;ConfirmOrder</TT>.

<HR>

<BLOCKQUOTE>

<B>Listing 9.15&nbsp;&nbsp;The ConfirmOrder Subroutine<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

# Confirm the order and write it to file.



sub ConfirmOrder {



    my( $sessionid ) = @_;



    my %state = GetSessValues($sessionid);



    # Write a record to the orders file:



    open(ORDFILE, &quot;&gt;&gt;./orders.dat&quot;) ||

     &amp;HTMLError(&quot;Unable to open orders file for appending.&quot;);





    # Print a header line for this order:



    print ORDFILE &quot;Order for customer $state{'customerid'} at &quot;,

                  scalar(localtime(time)), &quot;:\n&quot;;





    # Each order item:



    foreach $item ( %state ) {

     $item =~ /^Order_(\w+)/ &amp;&amp;

         print ORDFILE &quot;$1 ($state{$item});\n&quot;;

    }





    # Finish:



    print ORDFILE &quot;End of order for customer $state{'customerid'}.\n&quot;;

    close ORDFILE;



    # Inform the user:



    &amp;ShowLoc($sessionid, &quot;confirm.htmw&quot;);

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

<TT>&amp;ConfirmOrder</TT> does the following things:

<OL>

<LI>Retrieves the current session values from DBM storage into

the <TT>%state</TT> associative array.

<LI>Opens the orders file (<TT>orders.dat</TT>) in append mode.

<LI>Prints a header line for this order in the orders file. This

line contains the customer name (<TT>$state{'customerid'}</TT>)

and the current time.

<LI>Recognizes any state item that begins with <TT>Order_</TT>

as an order item. The product name and number of items ordered

are recorded in the orders file for each item.

<LI>Closes the orders file.

<LI>Notifies the user that the order has been accepted.

</OL>

<H2><A NAME="WrappingUp"><FONT SIZE=5 COLOR=#FF0000>

Wrapping Up</FONT></A></H2>

<P>

The example wrapper application shown in this chapter, while primitive,

is functional. You could easily develop this application into

a practical package. Among the issues that need to be addressed

to make this application production-ready are:

<UL>

<LI>The user authentication used in this example is for illustrative

purposes only. If you have authority to control httpd user authentication

on your server, you probably should delegate the responsibility

for user authentication to the httpd. You can create user databases,

using standard tools, and know that you are benefiting from years

of development of secure user authentication technology.

<LI>You need a regular procedure for clearing orphaned session

files-files that remain on disk after a session is abandoned without

the user's explicitly logging out. A simple Perl script run as

a cron job should suffice.

<LI>The entire system, as it stands, will take orders but not

process them. A real system will feed directly into an ordering

database, so that orders are processed the same way as orders

that are taken by telephone or any other medium.

</UL>

<H2><A NAME="FromHere"><FONT SIZE=5 COLOR=#FF0000>

From Here...</FONT></A></H2>

<P>

You can learn more about the issues raised in this chapter by

reading the following chapters:

<UL>

<LI><A HREF="ch1.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch1.htm" >Chapter 1</A> &quot;Perl Overview,&quot; provides more information

on some of the Perl syntax used in this chapter.

<LI><A HREF="ch2.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch2.htm" >Chapter 2</A> &quot;Introduction to CGI,&quot; provides more

information about passing CGI values between browser and server.

<LI><A HREF="ch8.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch8.htm" >Chapter 8</A> &quot;Understanding Basic User Authentication,&quot;

provides background material on user authentication and Web security.

</UL>

<HR>



<CENTER><P><A HREF="ch8.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch8.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="index.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="ch10.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch10.htm"><IMG SRC="nc.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<HR WIDTH="100%"></P></CENTER>

</BODY>

</HTML>
