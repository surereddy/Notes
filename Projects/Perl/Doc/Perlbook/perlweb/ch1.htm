<HTML>

<HEAD>

<TITLE>Chapter 1 -- Perl Overview</TITLE>



<META>

</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">

<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;1</FONT></H1>

<H1><FONT SIZE=6 COLOR=#FF0000>Perl Overview</FONT></H1>

<P>

<I><B>by Paul Doyle</B></I>

<HR>

<P>

<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>

<UL>

<LI><A HREF="#Perl">

Perl</A>

<UL>

<LI><A HREF="#Origins">

Origins</A>

<LI><A HREF="#Borrowings">

Borrowings</A>

<LI><A HREF="#CostandLicensing">

Cost and Licensing</A>

<LI><A HREF="#Distribution">

Distribution</A>

</UL>

<LI><A HREF="#PerlPrograms">

Perl Programs</A>

<UL>

<LI><A HREF="#Invocation">

Invocation</A>

<LI><A HREF="#CommandLineArguments">

Command-Line Arguments</A>

<LI><A HREF="#ProgramLayout">

Program Layout</A>

</UL>

<LI><A HREF="#DataTypes">

Data Types</A>

<UL>

<LI><A HREF="#Scalars">

Scalars</A>

<LI><A HREF="#Arrays">

Arrays</A>

<LI><A HREF="#AssociativeArrays">

Associative Arrays</A>

<LI><A HREF="#FileHandles">

File Handles</A>

</UL>

<LI><A HREF="#SpecialVariables">

Special Variables</A>

<UL>

<LI><A HREF="#EnvironmentVariables">

Environment Variables</A>

<LI><A HREF="#ProgramArguments">

Program Arguments</A>

<LI><A HREF="#CurrentLine">

Current Line</A>

<LI><A HREF="#SystemErrorMessages">

System Error Messages</A>

</UL>

<LI><A HREF="#FlowControl">

Flow Control</A>

<UL>

<LI><A HREF="#LogicalOperators">

Logical Operators</A>

<LI><A HREF="#ConditionalExpressions">

Conditional Expressions</A>

<LI><A HREF="#CompoundStatements">

Compound Statements</A>

<LI><A HREF="#Loops">

Loops</A>

<LI><A HREF="#Labels">

Labels</A>

<LI><A HREF="#Subroutines">

Subroutines</A>

<LI><A HREF="#VariableScope">

Variable Scope</A>

</UL>

<LI><A HREF="#Patterns">

Patterns</A>

<UL>

<LI><A HREF="#RegularExpressions">

Regular Expressions</A>

<LI><A HREF="#Matching">

Matching</A>

<LI><A HREF="#Substitution">

Substitution</A>

</UL>

<LI><A HREF="#FromHere">

From Here   </A>

</UL>



<HR>

<P>

Before you get into the nitty-gritty of using Perl on World Wide

Web servers, you need to take some time to look at Perl itself.

<P>

This chapter provides an overview of the Perl language. It is

not a detailed course in Perl, but it should give you enough Perl

to get by with; as you use the language; you'll probably want

to delve into more deeply after you've been programming in it

for a while.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>The &quot;Camel Book&quot;</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

When you're ready to learn more, you may want to purchase the excellent <I>Programming Perl</I>, by Larry Wall and Randal L. Schwartz (O'Reilly &amp; Associates, Inc.). This book is the definitive work on Perl so far (as you might suspect with Wall's name 
on the cover). It's readable and humorous yet still sufficiently technical to be of genuine use in everyday Perl programming.

</BLOCKQUOTE>

<BLOCKQUOTE>

Incidentally, the book is called the &quot;Camel book&quot; after the dromedary that happens to adorn the cover. Because of the ubiquitous nature of the book in Perl-literate circles, this animal has become the emblem of the language.</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<P>

We're not going to go into too much detail in this chapter; all

the gory details are covered in Part V of this book. By the end

of this chapter, you should know enough to find your way around

the reference chapters for the answers to particular questions.

If you already know Perl, you may want to just skim this chapter

to refresh your memory of the language and how it works. If you

don't already know how to program in at least one language, this

book is not the place to start.

<H2><A NAME="Perl"><FONT SIZE=5 COLOR=#FF0000>

Perl</FONT></A></H2>

<P>

The story of how Perl began is a simple tale of one man's frustration

and (by his own account) inordinate laziness.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

This chapter is supposed to be a snappy introduction to the language, so why am I wasting your time with this stuff? The fact is, Perl is a unique language in ways that cannot be conveyed simply by describing the technical details of the language. Perl is 
a state of mind as much as it is a language grammar. So we'll take a few minutes to look at the external realities that provoked Perl into being; this information should give you some insight into the way that<TT> </TT>Perl was <I>meant</I> to be used.

</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<H3><A NAME="Origins">

Origins</A></H3>

<P>

Back in 1986, a UNIX programmer by the name of Larry Wall found

himself working on a task that involved generating reports from

a great many text files, with cross-references. Because he was

a UNIX programmer, and because the problem involved manipulating

the contents of text files, he started to use awk for the task.

But it soon became clear that awk wasn't up to the job, and with

no other obvious candidate for the job, he'd just have to write

some code.

<P>

Now, here's the interesting bit: Larry could have written a utility

to manage the particular job at hand and gotten on with his life.

He could see, though, that it wouldn't be long before he'd have

to write another special utility to handle something else that

the standard tools couldn't quite hack. (He may have realized

that most programmers are <I>always</I> writing special utilities

to handle things that the standard tools can't quite hack.)

<P>

So rather than waste any more of his time, he invented a new language

and wrote an interpreter for it. That statement may seem to be

a paradox, but it isn't. Setting yourself up with the right tools

is always an effort, but if you do it right, the effort pays off.

<P>

The new language emphasized system management and text handling.

After a few revisions, it could handle regular expressions, signals,

and network sockets, too. The language became known as Perl and

quickly became popular with frustrated, lazy UNIX programmers-and

with the rest of us.

<H3><A NAME="Borrowings">

Borrowings</A></H3>

<P>

Perl borrowed freely from many other tools, particularly sed and

awk. That's <I>Perl</I>, the language, not <I>perl</I>, the interpreter.

Perl does many of the things that sed, awk, and UNIX shell scripting

languages do, but (arguably) better every time; the perl code

is Larry's doing.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

Is it <I>Perl</I> or <I>perl</I>? The definitive word from Larry Wall is that it doesn't matter. Many programmers like to refer to languages with capitalized names (Perl), but the program originated on a UNIX system, on which short lowercase names (awk, 
sed, and so on) are the norm. As is true of many things about the language, there's no single &quot;right way&quot; to use the term; just use it the way you want. Perl is a tool, after all, and not a dogma.

</BLOCKQUOTE>

<BLOCKQUOTE>

If you're sufficiently pedantic, you may want to call it <I>[Pp]erl</I> after you read the &quot;Regular Expressions&quot; section later in this chapter.

</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<P>

Perl can handle low-level tasks quite well, particularly since

Perl 5, when the whole messy business of references was put on

a sound footing. In this sense, it has a great deal in common

with C. But Perl handles the internals of data types, memory allocation,

and so on automatically and seamlessly.

<P>

Perl code also bears a passing resemblance to C code, perhaps

because Perl was written in C or perhaps because Larry found some

of C's syntactic conventions to be handy. But Perl is less pedantic

and much more concise than C is.

<P>

This magpie habit of picking up interesting features along the

way-regular expressions here, database handling there-has been

regularized in Perl 5. Now you can add your favorite bag of tricks

to Perl fairly easily by using modules. Many of the added-on features

of Perl, such as socket handling, are likely to be dropped from

the core of Perl and moved out to modules in time.

<H3><A NAME="CostandLicensing">

Cost and Licensing</A></H3>

<P>

Perl is free. The full source and documentation are free to copy,

compile, print, and give away. Any programs that you write in

Perl are yours to do with as you please; there are no royalties

to pay and no restrictions on distribution, as far as Perl is

concerned.

<P>

Perl is not completely a public domain product, though, and for

very good reason. If the source were completely public domain,

someone could make minor alterations in it, compile it, and then

sell it-in other words, rip off its creator. On the other hand,

without distributing the source code, it's hard to make sure that

everyone who wants to can use Perl.

<P>

The GNU General Public License is one way to distribute free software

without the danger of being taken advantage of. Under this type

of license, source code may be distributed freely and used by

anybody, but any programs derived from such code must be released

under the same type of license. In other words, if you derive

any of your source code from GNU-licensed source code, you have

to release your source code to anyone who wants it.

<P>

This arrangement is often sufficient to protect the interests

of the author, but it can lead to a plethora of derivative versions

of the original package, which may deprive the original author

of a say in the development of his or her own creation. The situation

can also lead to confusion on the part of users-it becomes hard

to establish which version of the package is the definitive version,

whether a particular script will work with a given version, and

so on.

<P>

That's why Perl is released under the terms of the Artistic License-a

variation on the GNU General Public License that says that anyone

who releases a package derived from Perl must make it clear that

the package is not actually Perl. All modifications must be clearly

flagged; executables must be renamed, if necessary; and the original

modules must be distributed along with the modified version. The

effect is that the original author is clearly recognized as the

owner of the package. The general terms of the GNU General Public

license also apply.

<H3><A NAME="Distribution">

Distribution</A></H3>

<P>

New versions of Perl are released on the Internet and distributed

to Web sites and FTP archives across the world. The Perl source

and documentation are distributed, as are executable files for

many non-UNIX systems. UNIX binaries are generally not made available

on the Internet, because it generally is better to build Perl

on your system so you can be certain that it will work. All UNIX

systems have a C compiler, after all.

<P>

The perl distribution comes with a nifty utility called Configure

that tweaks the source files and the Makefile for your system.

It probes your system software, shell, C compiler, and so on to

determine the answers to various questions about how to build

Perl-which compiler flags to use, the sizes of fundamental data

types, and so on. You can override any of Configure's answers

if you disagree with its findings, but it's generally very accurate

indeed.

<P>

Running Configure before you make perl virtually guarantees you

a perl installation that is not only successfully compiled and

linked, but also well optimized for your particular system configuration-and

with no tweaking or editing of source files on your part. You're

more than welcome to tinker with obscure compiler flags if you

want, however; that's why GNU C was invented.

<H2><A NAME="PerlPrograms"><FONT SIZE=5 COLOR=#FF0000>

Perl Programs</FONT></A></H2>

<P>

After you install perl, how do you use it to do all those wonderful

things to enrich the Web? What, in other words, is a Perl program,

and how do you feed it to perl?

<H3><A NAME="Invocation">

Invocation</A></H3>

<P>

We're going to spend the rest of this chapter answering the first

two questions, so we'll get the third question out of the way

now. Invoking perl is quite simple, but the procedure varies a

little from system to system.

<P>

Suppose that perl is correctly installed and working on your system.

The simplest way to run perl on a Perl program is to invoke the

perl interpreter with the name of the Perl program as an argument,

as follows:

<BLOCKQUOTE>

<PRE>

perl sample.pl

</PRE>

</BLOCKQUOTE>

<P>

In this example, SAMPLE.PL is the name of a Perl file, and perl

is the name of the perl interpreter. The example assumes that

perl is in the execution path. If it isn't, you need to supply

the full path to perl, too, as follows:

<BLOCKQUOTE>

<PRE>

/usr/local/hin/perl sample.pl

</PRE>

</BLOCKQUOTE>

<P>

This syntax is the preferred way of invoking perl, because it

eliminates the possibility that you might invoke a copy of perl

other than the one you intended to use. Because we'll be working

with Web servers in this book-and, therefore, keenly aware of

security issues-we'll use the full path from now on.

<P>

That much is the same on all systems that have a command-line

interface. The following will do the trick in Windows NT, for

example:

<BLOCKQUOTE>

<PRE>

c:\NTperl\perl sample.pl

</PRE>

</BLOCKQUOTE>

<P>

<B>Invoking Perl in UNIX&nbsp;&nbsp;</B>UNIX systems have another

way to invoke an interpreter in a script file. Place a line such

as the following at the start of the Perl file:

<BLOCKQUOTE>

<PRE>

#!/usr/local/bin/perl

</PRE>

</BLOCKQUOTE>

<P>

This line tells UNIX that the rest of this script file is to be

interpreted by /USR/LOCAL/BIN/PERL. Next, you make the script

itself executable, as follows:

<BLOCKQUOTE>

<PRE>

chmod +x sample.pl

</PRE>

</BLOCKQUOTE>

<P>

Then you can execute the script file directly and have the script

file tell the operating system what interpreter to use while running

it.

<P>

<B>Invoking Perl in Windows NT</B>&nbsp;&nbsp;The procedures in

the preceding section are fine for UNIX, but Windows NT is quite

different. You can use File Manager (Explorer, in Windows NT 4)

to create an association between the file extension, .PL, and

the perl executable. Then, whenever a file that ends in .PL is

invoked, NT knows that perl should be used to interpret it.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

Usually, a few more steps are required to get a Web server to execute Perl programs automatically. Refer to Appendix A, &quot;Perl Acquisition and Installation,&quot; for platform-specific instructions on creating associations between scripts and 
interpreters.</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<H3><A NAME="CommandLineArguments">

Command-Line Arguments</A></H3>

<P>

Perl takes several optional command-line arguments for various

purposes (see Table 1.1). Most of these arguments are rarely used

but are listed here for reference purposes. The <TT>-t</TT> switch

in particular is <I>de rigueur</I> in Web-based Perl scripts.

<BR>

<P>

<CENTER><B>Table 1.1&nbsp;&nbsp;Perl Command-Line Switches</B></CENTER>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD WIDTH=67><CENTER><B>Option</B></CENTER></TD><TD WIDTH=125><B>Arguments</B>

</TD><TD WIDTH=192><B>Purpose</B></TD><TD WIDTH=192><B>Notes</B>

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=67><CENTER><TT>-0</TT></CENTER></TD><TD WIDTH=125>Octal character code

</TD><TD WIDTH=192>Specify record separator</TD><TD WIDTH=192>Default is new line (<TT>\n</TT>)

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=67><CENTER><TT>-a</TT></CENTER></TD><TD WIDTH=125>&nbsp;

</TD><TD WIDTH=192>Automatically split records</TD><TD WIDTH=192>Used with <TT>-n</TT> or <TT>-p</TT>

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=67><CENTER><TT>-c</TT></CENTER></TD><TD WIDTH=125>&nbsp;

</TD><TD WIDTH=192>Check syntax only do not execute  </TD><TD WIDTH=192>&nbsp;

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=67><CENTER><TT>-d</TT></CENTER></TD><TD WIDTH=125>&nbsp;

</TD><TD WIDTH=192>Run script, using Perl debugger</TD><TD WIDTH=192>If Perl debugger is installed

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=67><CENTER><TT>\-D</TT></CENTER></TD><TD WIDTH=125>Flags

</TD><TD WIDTH=192>Specify debugging behavior</TD><TD WIDTH=192>Refer to the PERLDEBUG man page on the CD-ROM that comes with this book

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=67><CENTER><TT>-e</TT></CENTER></TD><TD WIDTH=125>Command

</TD><TD WIDTH=192>Pass a command to Perl from the command line

</TD><TD WIDTH=192>Useful for quick operations; see tip after this table for an example

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=67><CENTER><TT>-F</TT></CENTER></TD><TD WIDTH=125>Regular expression

</TD><TD WIDTH=192>Expression to split by if <TT>-a</TT> is used

</TD><TD WIDTH=192>Default is white space</TD></TR>

<TR VALIGN=TOP><TD WIDTH=67><CENTER><TT>-i</TT></CENTER></TD><TD WIDTH=125>Extension

</TD><TD WIDTH=192>Replace original file with result</TD><TD WIDTH=192>Useful for modifying contents of files; see tip after this table for an example

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=67><CENTER><TT>-I</TT></CENTER></TD><TD WIDTH=125>Directory

</TD><TD WIDTH=192>Specify location of include files</TD><TD WIDTH=192>&nbsp;

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=67><CENTER><TT>-l</TT></CENTER></TD><TD WIDTH=125>Octal character code

</TD><TD WIDTH=192>Drop new lines when used with <TT>-n</TT> and <TT>-p</TT>, and use designated character as line-termination character

</TD><TD WIDTH=192>&nbsp;</TD></TR>

<TR VALIGN=TOP><TD WIDTH=67><CENTER><TT>-n</TT></CENTER></TD><TD WIDTH=125>&nbsp;

</TD><TD WIDTH=192>Process the script, using each specified file as an argument

</TD><TD WIDTH=192>Used for performing the same set of actions on a set of files

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=67><CENTER><TT>-p</TT></CENTER></TD><TD WIDTH=125>&nbsp;

</TD><TD WIDTH=192>Same as <TT>-n</TT>, but each line is printed

</TD><TD WIDTH=192>&nbsp;</TD></TR>

<TR VALIGN=TOP><TD WIDTH=67><CENTER><TT>-P</TT></CENTER></TD><TD WIDTH=125>&nbsp;

</TD><TD WIDTH=192>Run the script through the C preprocessor before Perl compiles it

</TD><TD WIDTH=192>&nbsp;</TD></TR>

<TR VALIGN=TOP><TD WIDTH=67><CENTER><TT>-s</TT></CENTER></TD><TD WIDTH=125>&nbsp;

</TD><TD WIDTH=192>Enable passing of arbitrary switches to Perl 

</TD><TD WIDTH=192>Use <TT>-s -what -ever </TT>to have the Perl variables <TT>$what</TT> and <TT>$ever</TT> defined within your script

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=67><CENTER><TT>-S</TT></CENTER></TD><TD WIDTH=125>&nbsp;

</TD><TD WIDTH=192>Tell Perl to look along thepath for the script

</TD><TD WIDTH=192>&nbsp;</TD></TR>

<TR VALIGN=TOP><TD WIDTH=67><CENTER><TT>-T</TT></CENTER></TD><TD WIDTH=125>&nbsp;

</TD><TD WIDTH=192>Use taint checking; don't evaluate expressions supplied in the command line

</TD><TD WIDTH=192>Very important for Web use</TD></TR>

<TR VALIGN=TOP><TD WIDTH=67><CENTER><TT>-u</TT></CENTER></TD><TD WIDTH=125>&nbsp;

</TD><TD WIDTH=192>Makes Perl dump core after compiling your script; intended to allow for generation of Perl executables

</TD><TD WIDTH=192>Very messy; wait for the Perl compiler</TD>

</TR>

<TR VALIGN=TOP><TD WIDTH=67><CENTER><TT>-U</TT></CENTER></TD><TD WIDTH=125>&nbsp;

</TD><TD WIDTH=192>Unsafe mode; overrides Perl's natural caution.

</TD><TD WIDTH=192>Don't use this!</TD></TR>

<TR VALIGN=TOP><TD WIDTH=67><CENTER><TT>-v</TT></CENTER></TD><TD WIDTH=125>&nbsp;

</TD><TD WIDTH=192>Print Perl version number</TD><TD WIDTH=192>&nbsp;

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=67><CENTER><TT>-w</TT></CENTER></TD><TD WIDTH=125>&nbsp;

</TD><TD WIDTH=192>Print warnings about script syntax</TD><TD WIDTH=192>Extremely useful, especially during development; warning messages can confuse browsers if sent raw

</TD></TR>

</TABLE></CENTER>

<P>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>TIP</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

The <TT>-e</TT> option is handy for quick Perl operations from the command line. Want to change all the <TT>foo</TT>s in WIFFLE.BAT to <TT>bar</TT>s? Try this:

</BLOCKQUOTE>

<BLOCKQUOTE>

<TT>perl -i.old -p -e &quot;s/foo/bar/g&quot; wiffle.bat</TT>

</BLOCKQUOTE>

<BLOCKQUOTE>

This code says, &quot;Take each line of WIFFLE.BAT (<TT>-p</TT>), store the original in WIFFLE.OLD (<TT>-i</TT>), replace all instances of <TT>foo</TT> with <TT>bar</TT> (<TT>-e</TT>), and write the result (<TT>-p</TT>) to the original file 
(<TT>-i</TT>).&quot;

</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<P>

You can supply Perl command-line arguments in the interpreter-invocation

line in UNIX scripts. Following is a good start for any Perl script:

<BLOCKQUOTE>

<PRE>

#!/usr/local/bin/perl -w -T<BR>

</PRE>

</BLOCKQUOTE>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>CAUTION</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

The <TT>-w</TT> switch is best omitted in versions of Perl older than 5.002, because it may produce spurious warnings.

</BLOCKQUOTE>

<BLOCKQUOTE>

Also, take care when you use the <TT>-w</TT> switch in scripts that send data to Web browsers. Warning messages sent before the browser receives a content-type line may result in an error message.

</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<H3><A NAME="ProgramLayout">

Program Layout</A></H3>

<P>

A Perl program consists of an ordinary text file that contains

a series of Perl commands. Commands are written in what looks

like a bastardized amalgam of C, shell script, and English. In

fact, that's pretty much what it is.

<P>

Perl code can be quite free-flowing. The broad syntactic rules

governing where a statement starts and ends are:

<UL>

<LI>Leading white space is ignored. You can start a Perl statement

anywhere you want: at the beginning of the line; indented, for

clarity (recommended); or even right-justified (definitely frowned

on), if you like.

<LI>Commands are terminated with a semicolon.

<LI>White space outside string literals is irrelevant; one space

is as good as a hundred, which means that you can split statements

over several lines for clarity.

<LI>Anything after a hash sign (<TT>#</TT>) is ignored. Use this

fact to pepper your code with useful comments.

</UL>

<P>

Here's a Perl statement inspired by Kurt Vonnegut:

<BLOCKQUOTE>

<PRE>

print &quot;My name is Yon Yonson\n&quot;;

</PRE>

</BLOCKQUOTE>

<P>

No prizes for guessing what happens when Perl runs this code-it

prints <TT>My name is Yon Yonson</TT>. If the <TT>\n</TT> doesn't

look familiar, don't worry; it simply means that Perl should print

a new-line character after the text (or, in other words, go to

the start of the next line).

<P>

Printing more text is a matter of either stringing together statements

like the following or giving multiple arguments to the print function:

<BLOCKQUOTE>

<PRE>

print &quot;My name is Yon Yonson,\n&quot;;

print &quot;I live in Wisconsin,\n&quot;,

      &quot;I work in a lumbermill there.\n&quot;;

</PRE>

</BLOCKQUOTE>

<P>

That's right-<TT>print</TT> is a function. It may not look like

one in any of the earlier examples in this chapter, which have

no parentheses to delimit the function arguments, but it <I>is</I>

a function, and it takes arguments. More accurately, in this example

<TT>print</TT> takes a single argument that consists of an arbitrarily

long list.

<P>

We'll have much more to say about lists and arrays in &quot;Data

Types&quot; later in this chapter. You'll find a few more examples

of the more common functions in the remainder of this chapter,

but refer to <A HREF="ch15.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch15.htm" >Chapter 15</A>, &quot;Function List,&quot; for a complete

rundown on Perl's built-in functions.

<P>

For now, if you're uncomfortable with functions that take arbitrary

numbers of arguments with no parentheses to corral them, pretend

that you see parentheses. You can use them in Perl programs, if

you like, but it would be better to get used to the idea that

Perl syntax is loose and groovy in a way that C, for example,

is not.

<P>

What does a complete Perl program look like? Here's a trivial

UNIX example, complete with the invocation line at the top and

a few comments:

<BLOCKQUOTE>

<PRE>

#!/usr/local/bin/perl -w                    # Show warnings



print &quot;My name is Yon Yonson,\n&quot;;           # Let's introduce ourselves

print &quot;I live in Wisconsin,\n&quot;,

      &quot;I work in a lumbermill there.\n&quot;;    # Remember the line breaks

</PRE>

</BLOCKQUOTE>

<P>

This example is not at all typical of a Perl program, though;

it's just a linear sequence of commands with no structural complexity.

The &quot;Flow Control&quot; section later in this chapter introduces

some of the constructs that make Perl what it is and provides

a more authentic flavor of what is normal in a Perl program. For

now, we'll stick to simple examples like this one for the sake

of clarity.

<H2><A NAME="DataTypes"><FONT SIZE=5 COLOR=#FF0000>

Data Types</FONT></A></H2>

<P>

Perl has a small number of data types. If you're used to working

with C, in which even characters can be either signed or unsigned,

this fact makes for a pleasant change. In essence, Perl has only

two data types: <I>scalars</I> and <I>arrays</I>. Perl also has

<I>associative arrays</I>, which are a very special type of array

and which merit a section of their own.

<H3><A NAME="Scalars">

Scalars</A></H3>

<P>

All numbers and strings are <I>scalars</I>. Scalar-variable names

start with a dollar sign (<TT>$</TT>).<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

All Perl variable names, including scalars, are case-sensitive. <TT>$Name</TT> and <TT>$name</TT>, for example, are completely different quantities.

</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<P>

Perl converts automatically between numbers and strings as required,

so that

<BLOCKQUOTE>

<PRE>

$a = 2;

$b = 6;

$c = $a . $b;  # The &quot;.&quot; operator concatenates two strings

$d = $c / 2;

print $d;

</PRE>

</BLOCKQUOTE>

<P>

yields the result

<BLOCKQUOTE>

<PRE>

13

</PRE>

</BLOCKQUOTE>

<P>

This example involves converting two integers to strings; concatenating

the strings into a new string variable; converting this new string

to an integer; dividing it by 2; converting the result to a string;

and printing it. All these conversions are handled implicitly,

leaving the programmer free to concentrate on what needs to be

done rather than on the low-level details of how it is to be done.

<P>

This situation might be a problem if Perl were regularly used

for tasks in which explicit memory offsets were used, for example,

and data types were critical. But for the type of task for which

Perl is normally used-and certainly for the types of tasks that

we'll be using it for in this book-these automatic conversions

are smooth, intuitive, and generally a Good Thing.

<P>

We can develop the earlier example script with some string variables,

as follows:

<BLOCKQUOTE>

<PRE>

#!/usr/local/bin/perl -w                    # Show warnings



$who = 'Yon Yonson';

$where = 'Wisconsin';

$what = 'in a lumbermill';



print &quot;My name is $who,\n&quot;;                 # Let's introduce ourselves

print &quot;I live in $where,\n&quot;,

      &quot;I work $what there.\n&quot;;                   # Remember the line breaks



print &quot;\nSigned: \t$who,\n\t\t$where.\n&quot;;

</PRE>

</BLOCKQUOTE>

<P>

This script yields the following:

<BLOCKQUOTE>

<PRE>

My name is Yon Yonson,

I work in Wisconsin,

I work in a lumbermill there.



Signed:	Yon Yonson,

		Wisconsin.

</PRE>

</BLOCKQUOTE>

<P>

Don't worry-it gets better.

<H3><A NAME="Arrays">

Arrays</A></H3>

<P>

A collection of scalars is an <I>array</I>. An array-variable

name starts with an at symbol (<TT>@</TT>), whereas an explicit

array of scalars is written as a comma-separated list within parentheses,

as follows:

<BLOCKQUOTE>

<PRE>

@trees = (&quot;Larch&quot;, &quot;Hazel&quot;, &quot;Oak&quot;);

</PRE>

</BLOCKQUOTE>

<P>

Array subscripts are denoted by brackets. <TT>$trees[0]</TT>,

for example, is the first element of the <TT>@trees</TT> array.

Notice that it's <TT>@trees</TT> but <TT>$trees[0]</TT>; individual

array elements are scalars, so they start with <TT>$</TT>.

<P>

Mixing scalar types in an array is not a problem. The code

<BLOCKQUOTE>

<PRE>

@items = (15, '45.67', &quot;case&quot;);

print &quot;Take $items[0] $items[2]s at \$$items[1] each.\n&quot;;

</PRE>

</BLOCKQUOTE>

<P>

results in the following:

<BLOCKQUOTE>

<PRE>

Take 15 cases at $45.67 each.

</PRE>

</BLOCKQUOTE>

<P>

All arrays in Perl are dynamic. You never have to worry about

memory allocation and management; Perl does all that stuff for

you. Combine that with the fact that arrays can contain arrays

as subarrays, and you're free to say things like the following:

<BLOCKQUOTE>

<PRE>

@A = (1, 2, 3);

@B = (4, 5, 6);

@C = (7, 8, 9);

@D = (@A, @B, @C);

</PRE>

</BLOCKQUOTE>

<P>

As a result of this code, the array <TT>@D</TT> contains the numbers

1 through 9. The power of constructs such as the following takes

getting used to:

<BLOCKQUOTE>

<PRE>

@Annual = (@Spring, @Summer, @Fall, @Winter);

</PRE>

</BLOCKQUOTE>

<P>

This code example combines arrays that represent some aspect of

each of the seasons in a concise and intuitive way. The arrays

for the seasons might in turn consist of arrays of months, each

of which might consist of an array of daily values. The <TT>@Annual</TT>

array then would consist of a value for each day of the year.

By defining your data in chunks such as this, you give yourself

the option of handling it on a daily, monthly, or annual basis.

<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

An aspect of Perl that often confuses newcomers (and occasionally old hands, too) is the context-sensitive nature of evaluations. Perl keeps track of the context in which an expression is being evaluated and can return a different value in an array 
context than in a scalar context. In this example, the array <TT>@B</TT> contains 1-4, whereas <TT>$C</TT> contains 4 (the number of values in the array):

</BLOCKQUOTE>

<BLOCKQUOTE>

<TT>@A = (1, 2, 3, 4);<BR>

@B = @A;<BR>

$C = @A;</TT>

</BLOCKQUOTE>

<BLOCKQUOTE>

This context sensitivity becomes more of an issue when you use functions and operators that can take either a single argument or multiple arguments. The function or argument behaves one way when it is passed a single <I>scalar</I> argument and another 
when it is passed multiple arguments, which it may interpret as a single <I>array</I> argument.

</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<P>

Many of Perl's built-in functions take arrays as arguments. One

example is <TT>sort</TT>, which takes an array as an argument

and returns the same array, sorted alphabetically. The code

<BLOCKQUOTE>

<PRE>

print sort ( 'Beta', 'Gamma', 'Alpha' );

</PRE>

</BLOCKQUOTE>

<P>

prints <TT>AlphaBetaGamma</TT>.

<P>

You can make this code neater by using another built-in function,

called <TT>join</TT>. This function takes two arguments: a string

to connect with, and an array of strings to connect. <TT>join</TT>

returns a single string that consists of all elements in the array

joined with the connecting string. The code

<BLOCKQUOTE>

<PRE>

print join ( ' : ', 'Name', 'Address', 'Phone'  );

</PRE>

</BLOCKQUOTE>

<P>

returns the string <TT>Name : Address : Phone</TT>.

<P>

Because <TT>sort</TT> returns an array, you can feed its output

straight into <TT>join</TT>. The code

<BLOCKQUOTE>

<PRE>

print join( ', ', sort ( 'Beta', 'Gamma', 'Alpha' ) );

</PRE>

</BLOCKQUOTE>

<P>

prints <TT>Alpha, Beta, Gamma</TT>.

<P>

Notice that this code doesn't separate the initial scalar argument

of <TT>join</TT> from the array that follows it. The first argument

is the string to join things with. The rest of the arguments are

treated as a single argument: the array to be joined. This is

true even if you use parentheses to separate groups of arguments.

The code

<BLOCKQUOTE>

<PRE>

print join( ': ', ('A', 'B', 'C'), ('D', 'E'), ('F', 'G', 'H', 'I'));

</PRE>

</BLOCKQUOTE>

<P>

returns <TT>A: B: C: D: E: F: G: H: I</TT>.

<P>

You can use one array or multiple arrays in a context such as

this because of the way that Perl treats arrays; adding an array

to an array gives you one larger array, not two arrays. In this

case, all three arrays are bundled into one.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>TIP</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

For even more powerful string-manipulation capabilities, refer to the <TT>splice</TT> function in <A HREF="ch15.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch15.htm" >Chapter 15</A>, &quot;Function List.&quot;

</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<H3><A NAME="AssociativeArrays">

Associative Arrays</A></H3>

<P>

Associative arrays have a certain elegance that makes experienced

Perl programmers a little snobbish about their language of choice.

Rightly so! Associative arrays give Perl a degree of database

functionality at a very low, yet useful, level. Many tasks that

would otherwise involve complex programming can be reduced to

a handful of Perl statements by means of associative arrays.

<P>

Arrays of the type that you've already seen are <I>lists of values

indexed by subscripts</I>. In other words, to get an individual

element of an array, you supply a subscript as a reference, as

follows:

<BLOCKQUOTE>

<PRE>

@fruit = ( &quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot; );

print $fruit[2];

</PRE>

</BLOCKQUOTE>

<P>

This example yields <TT>Banana</TT>, because subscripts start

at zero, so <TT>2</TT> is the subscript for the third element

of the <TT>@fruit</TT> array. A reference to <TT>$fruit[7]</TT>

here returns the null value, because no array element with that

subscript has been defined.

<P>

Now, here's the point of all this: <I>Associative arrays are lists

of values indexed by strings</I>. Conceptually, that's all there

is to them. The implementation of associative arrays is more complex,

because all the strings (<I>keys</I>) need to be stored in addition

to the values to which they refer.

<P>

When you want to refer to an element of an associative array,

you supply a string (the key) instead of an integer (the subscript).

Perl returns the corresponding value. Consider the following example:

<BLOCKQUOTE>

<PRE>

%fruit = (&quot;Green&quot;, &quot;Apple&quot;, &quot;Orange&quot;, &quot;Orange&quot;, &quot;Yellow&quot;, &quot;Banana&quot; );

print $fruit{&quot;Yellow&quot;};

</PRE>

</BLOCKQUOTE>

<P>

This code prints <TT>Banana</TT>, as before. The first line defines

the associative array in much the same way that you have already

defined ordinary arrays; the difference is that instead of listing

values, you list key/value pairs. The first value is <TT>Apple</TT>,

and its key is <TT>Green</TT>. The second value is <TT>Orange</TT>,

which happens to have the same string for both value and key.

Finally, the value <TT>Banana</TT> has the key <TT>Yellow</TT>.

<P>

On a superficial level, you can use string subscripts to provide

mnemonics for array references, allowing you to refer to <TT>$Total{'June'}</TT>

instead of <TT>$Total[5]</TT>. But you wouldn't even be beginning

to use the power of associative arrays. Think of the keys of an

associative arrays as you might think of a key that links tables

in a relational database, and you're closer to the idea. Consider

this example:

<BLOCKQUOTE>

<PRE>

%Folk =   ( 'YY', 'Yon Yonson',

            'TC', 'Terra Cotta',

            'RE', 'Ron Everly' );



%State = ( 'YY', 'Wisconsin',

           'TC', 'Minnesota',

           'RE', 'Bliss' );



%Job = ( 'YY', 'work in a lumbermill',

         'TC', 'teach nuclear physics',

         'RE', 'watch football');



foreach $person ( 'TC', 'YY', 'RE' )  {

        print &quot;My name is $Folk{$person},\n&quot;,

              &quot;I live in $State{$person},\n&quot;,

              &quot;I $Job{$person} there.\n\n&quot;;

        }

</PRE>

</BLOCKQUOTE>

<P>

We had to sneak the <TT>foreach</TT> construct in there for that

example to work. That construct is explained in full in &quot;Flow

Control&quot; later in this chapter. For now, you'll just have

to take it on trust that <TT>foreach</TT> makes Perl execute the

three <TT>print</TT> statements for each of the people in the

list after the <TT>foreach</TT> keyword. Otherwise, you could

try executing the code in the sample and see what happens.

<P>

You also can treat the keys and values of an associative array

as separate (ordinary) arrays by using the <TT>keys</TT> and <TT>values</TT>

keywords, respectively. The code

<BLOCKQUOTE>

<PRE>

print keys %Folk;

print values %State;

</PRE>

</BLOCKQUOTE>

<P>

prints the string <TT>YYRETCWisconsinBlissMinnesota</TT>.

<P>

Looks as though we need to do some more work on string handling.

That task is best left until after we cover some flow-control

mechanisms, however.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

A special associative array called <TT>%ENV</TT> stores the contents of all environment variables, indexed by variable name. <TT>$ENV{'PATH'}</TT>, for example, returns the current search path. Following is a way to print the current values of all 
environment variables, sorted by variable name for good measure:

</BLOCKQUOTE>

<BLOCKQUOTE>

<TT>foreach $var (sort keys %ENV ) {<BR>

     print &quot;$var: \&quot;$ENV{$var}\&quot;.\n&quot;;<BR>

     }</TT>

</BLOCKQUOTE>

<BLOCKQUOTE>

The <TT>foreach</TT> clause sets <TT>$var</TT> to each of the environment-variable names in turn (in alphabetical order), and the <TT>print</TT> statement prints each name and value. The backslash-<TT>quote</TT> (<TT>\&quot;</TT>) in there produces 
quotation marks around the values.

</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<H3><A NAME="FileHandles">

File Handles</A></H3>

<P>

This chapter finishes discussing Perl data types by discussing

file handles. A <I>file handle</I> is not really a data type at

all, but a special kind of literal string. A file handle behaves

like a variable in many ways, however, so this section is a good

place to cover them. (Besides, you won't get very far in Perl

without them.)

<P>

You can regard a file handle as being a pointer to a file from

which Perl is to read or to which it will write. (C programmers

are familiar with the concept.) The basic idea is that you associate

a handle with a file or device, and then refer to the handle in

the code whenever you need to perform a read or write operation.

<P>

File handles generally are written in uppercase. Perl has some

useful predefined file handles, as Table 1.2 shows.<BR>

<P>

<CENTER><B>Table 1.2&nbsp;&nbsp;Perl's Predefined File Handles</B></CENTER>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD WIDTH=96><B>File Handle</B></TD><TD WIDTH=494><B>Points to&#133;</B>

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><TT>STDIN</TT></TD><TD WIDTH=494>Standard input (normally, the keyboard)

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><TT>STDOUT</TT></TD><TD WIDTH=494>Standard output (normally, the console; in many Web applications, the browser)

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96>STDERR</TD><TD WIDTH=494>Device where error messages should be written (normally, the console; in a Web server environment, normally, the server-error log file)

</TD></TR>

</TABLE></CENTER>

<P>

<P>

The <TT>print</TT> statement can take a file handle as its first

argument, as follows:

<BLOCKQUOTE>

<PRE>

print STDERR &quot;Oops, something broke.\n&quot;;

</PRE>

</BLOCKQUOTE>

<P>

Notice that no comma appears after the file handle in this example.

That helps Perl figure out that the <TT>STDERR</TT> is not something

to be printed. If you're uneasy with this implicit list syntax,

you can put parentheses around all the <TT>print</TT> arguments,

as follows:

<BLOCKQUOTE>

<PRE>

print (STDERR &quot;Oops, something broke.\n&quot;);

</PRE>

</BLOCKQUOTE>

<P>

You still have no comma after the file handle, however.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>TIP</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

Use the standard file handles explicitly, especially in complex programs. Redefining the standard input or output device for a while is convenient sometimes; make sure that you don't accidentally wind up writing to a file what should have gone to the 
screen.</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<P>

You can use the <TT>open</TT> function to associate a new file

handle with a file, as follows:

<BLOCKQUOTE>

<PRE>

open (INDATA, &quot;/etc/stuff/Friday.dat&quot;);

open (LOGFILE, &quot;&gt;/etc/logs/reclaim.log&quot;);

print LOGFILE &quot;Log of reclaim procedure\n&quot;;

</PRE>

</BLOCKQUOTE>

<P>

By default, <TT>open</TT> opens files for reading only. If you

want to override this default behavior, add to the file name one

of the special direction symbols listed in Table 1.3. (The <TT>&gt;</TT>

at the start of the file name in the second <TT>output</TT> statement

of the preceding example, for example, tells Perl that you intend

to write to the named file.)<BR>

<P>

<CENTER><B>Table 1.3&nbsp;&nbsp;Perl File-Access Symbols</B></CENTER>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD WIDTH=144><B>Symbol</B></TD><TD WIDTH=432><B>Meaning</B>

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=144><TT>&lt;</TT></TD><TD WIDTH=432>Open the file for reading (the default action)

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=144><TT>&gt;</TT></TD><TD WIDTH=432>Open the file for writing

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=144><TT>&gt;&gt;</TT></TD><TD WIDTH=432>Open the file for appending

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=144><TT>+&lt;</TT></TD><TD WIDTH=432>Open the file for both reading and writing

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=144><TT>+&gt;</TT></TD><TD WIDTH=432>Open the file for both reading and writing

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=144><TT>|</TT> (before file name)</TD><TD WIDTH=432>Treat file as command into which Perl is to pipe text

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=144><TT>|</TT> (after file name)</TD><TD WIDTH=432>Treat file as command from which input is to be piped to Perl

</TD></TR>

</TABLE></CENTER>

<P>

<P>

To take a more complex example, here's one way to feed output

to the <TT>mypr</TT> printer on a UNIX system:

<BLOCKQUOTE>

<PRE>

open (MYLPR, &quot;|lpr -Pmypr&quot;);

print MYLPR &quot;A line of output\n&quot;;

close MYLPR;

</PRE>

</BLOCKQUOTE>

<P>

A special Perl operator for reading from files consists of two

angle brackets-&lt;&gt;-around the file handle of the file from

which you want to read. This operator returns the next line or

lines of input from the file or device, depending on whether the

operator is used in a scalar or an array context. When no more

input remains, the operator returns <TT>false</TT>.

<P>

A construct such as

<BLOCKQUOTE>

<PRE>

while (&lt;STDIN&gt;) {

print;

}

</PRE>

</BLOCKQUOTE>

<P>

simply echoes each line of input back to the console until Ctrl+D

(Ctrl+Z in Windows NT) is pressed, because the <TT>print</TT>

function takes the current default argument here: the most recent

line of input. For an explanation, see &quot;Special Variables&quot;

later in this chapter.

<P>

If the user types

<BLOCKQUOTE>

<PRE>

A

Bb

Ccc

^D

</PRE>

</BLOCKQUOTE>

<P>

the screen looks like this:

<BLOCKQUOTE>

<PRE>

A

A

Bb

Bb

Ccc

Ccc

^D

</PRE>

</BLOCKQUOTE>

<P>

Notice that in this case, <TT>&lt;STDIN&gt;</TT> is in a scalar

context, so one line of standard input is returned at a time.

Compare that example with the following example:

<BLOCKQUOTE>

<PRE>

print &lt;STDIN&gt;;

</PRE>

</BLOCKQUOTE>

<P>

In this case, because <TT>print</TT> expects an array of arguments

(it can be a single-element array, but it's an array as far as

<TT>print</TT> is concerned), the <TT>&lt;&gt;</TT> operator obligingly

returns all the contents of <TT>STDIN</TT> as an array, and then

<TT>print</TT> prints it. Because the array is fully built before

it is printed, nothing is written to the console until the user

presses Ctrl+D:

<BLOCKQUOTE>

<PRE>

A

Bb

Ccc

^D

A

Bb

Ccc

</PRE>

</BLOCKQUOTE>

<P>

This script prints out the contents of the file .SIGNATURE, double-spaced:

<BLOCKQUOTE>

<PRE>

open (SIGFILE, &quot;.signature&quot;);

while ( &lt;SIGFILE&gt; )  {

	print; print &quot;\n&quot;;

	}

</PRE>

</BLOCKQUOTE>

<P>

The first <TT>print</TT> here has no arguments, so it takes the

current default argument and prints it. The second <TT>print</TT>

has an argument, so it prints that instead. Perl's habit of using

default arguments extends to the <TT>&lt;&gt;</TT> operator; if

that operator is used with no file handle, Perl assumes that <TT>&lt;ARGV&gt;</TT>

is intended. <TT>&lt;ARGV&gt; </TT>expands to each line in turn

of each file listed in the command line.

<P>

If no files are listed in the command line, Perl instead assumes

that <TT>STDIN</TT> is intended. The following code, therefore,

keeps printing <TT>more   </TT> as long as something other than

Ctrl+D appears in standard input:

<BLOCKQUOTE>

<PRE>

while (&lt;&gt;) {

print &quot;more.... &quot;;

}<BR>

</PRE>

</BLOCKQUOTE>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

Perl 5 allows array elements to be references to any data type. As a result, you can build arbitrary data structures of the kind used in C and other high-level languages, but with all the power of Perl. You can have an array of associative arrays, for 
example.</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<H2><A NAME="SpecialVariables"><FONT SIZE=5 COLOR=#FF0000>

Special Variables</FONT></A></H2>

<P>

Like all languages, Perl has its special hieroglyphs, which are

laden with meaning. This section briefly examines some of the

most common and useful variables, and provides some examples of

typical Perl idioms in which you might find them.

<H3><A NAME="EnvironmentVariables">

Environment Variables</A></H3>

<P>

You have already seen one special variable: the environment-variable

associative array <TT>%ENV</TT>. This special associative array

allows you to easily use the value of any environment variable

within your Perl scripts:

<BLOCKQUOTE>

<PRE>

print &quot;Looking for files along the path ($ENV{'PATH'})   \n&quot;;

</PRE>

</BLOCKQUOTE>

<P>

The <TT>%ENV</TT> array is quite useful in CGI programming, in

which parameters are passed from the browser to CGI programs as

environment settings.

<H3><A NAME="ProgramArguments">

Program Arguments</A></H3>

<P>

Any arguments specified in the Perl command line are passed to

the Perl script in another special array: <TT>@ARGV</TT>.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>CAUTION</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

C programmers, beware: The first element of this array is the first actual argument, not the name of the program. The special variable <TT>$0</TT> contains the name of the Perl script that is being executed.

</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

The following code prints the command-line arguments one per line,

sorted alphabetically:

<BLOCKQUOTE>

<PRE>

print join(&quot;\n&quot;, sort @ARGV);

</PRE>

</BLOCKQUOTE>

<P>

The command-line arguments are of limited use in CGI scripts,

in which arguments are passed via the environment rather than

the command line. These arguments are quite useful in normal Perl

work, of course.

<H3><A NAME="CurrentLine">

Current Line</A></H3>

<P>

The special variable <TT>$_</TT> is often used to store the current

line of input. This situation is true when the <TT>&lt;&gt;</TT>

input operator is used. The following code, for example, prints

a numbered listing of the file pointed to by <TT>SOMEFILE</TT>:

<BLOCKQUOTE>

<PRE>

$line=0;

while ( &lt;SOMEFILE&gt; )  {

	++$line;

	print &quot;Line $line : &quot;, $_;

	}

</PRE>

</BLOCKQUOTE>

<P>

You occasionally need to store the contents of <TT>$_</TT> somewhere,

as in the following example:

<BLOCKQUOTE>

<PRE>

$oldvalue = $_;

</PRE>

</BLOCKQUOTE>

<P>

But the opposite operation-setting the value of <TT>$_</TT> manually-is

rarely appropriate, as in this example:

<BLOCKQUOTE>

<PRE>

$_ = $oldvalue;

</PRE>

</BLOCKQUOTE>

<P>

Pattern matching and substitution take place on the contents of

this variable unless you specify otherwise. These topics are covered

in &quot;Regular Expressions&quot; later in this chapter.

<H3><A NAME="SystemErrorMessages">

System Error Messages</A></H3>

<P>

The special variable <TT>$!</TT> contains the current system-error

number (<TT>errno</TT>, on UNIX systems) or system-error string,

depending on whether it is evaluated in a numeric or string context.

This variable may not contain anything meaningful; it should be

used only if an error occurred.

<P>

This example reports failure if the open call failed:

<BLOCKQUOTE>

<PRE>

open ( INFILE, &quot;./missing.txt&quot;) || die &quot;Couldn't open \&quot;./missing.txt\&quot; ($!).\n&quot;;

</PRE>

</BLOCKQUOTE>

<P>

The <TT>||</TT> here is the Boolean <TT>or</TT> operator, which

is covered in &quot;Flow Control&quot; later in this chapter.

<TT>die</TT> causes Perl to terminate after printing the string

given to <TT>die</TT> as an argument.

<P>

If the file does not exist, Perl terminates after displaying something

like this:

<BLOCKQUOTE>

<PRE>

Couldn't open &quot;./missing.txt&quot; (No such file or directory).

</PRE>

</BLOCKQUOTE>

<P>

The form and content of error messages vary from one system to

the next.

<H2><A NAME="FlowControl"><FONT SIZE=5 COLOR=#FF0000>

Flow Control</FONT></A></H2>

<P>

The examples that you have seen so far have been quite simple,

with little or no logical structure beyond a linear sequence of

steps. We managed to sneak in the occasional <TT>while</TT> and

<TT>foreach</TT>; think of those as being sneak previews. Perl

has all the flow-control mechanisms that you'd expect to find

in a high-level language, and this section takes you through the

basics of each mechanism.

<H3><A NAME="LogicalOperators">

Logical Operators</A></H3>

<P>

Two operators-<TT>||</TT> (<TT>or</TT>) and <TT>&amp;&amp;</TT>

(<TT>and</TT>)-are used like glue to hold Perl programs together.

They take two operands and return either true or false, depending

on the operands. In the following example, if either <TT>$Saturday

</TT>or <TT>$Sunday</TT> is true, <TT>$Weekend</TT> will be true,

too:

<BLOCKQUOTE>

<PRE>

$Weekend = $Saturday || $Sunday;

</PRE>

</BLOCKQUOTE>

<P>

In the next example, <TT>$Solvent</TT> is true only if <TT>$income</TT>

is greater than 3 and <TT>$debts</TT> is less than 10:

<BLOCKQUOTE>

<PRE>

$Solvent = ($income &gt; 3) &amp;&amp; ($debts &lt; 10);

</PRE>

</BLOCKQUOTE>

<P>

Now consider the logic of evaluating one of these expressions.

It isn't always necessary to evaluate both operands of either

an <TT>&amp;&amp;</TT> or a <TT>||</TT> operator. In the first

example earlier in this section, if <TT>$Saturday</TT> is true,

you know that <TT>$Weekend</TT> will be true, regardless of whether

<TT>$Sunday</TT> is also true (the midnight condition, perhaps?).

<P>

This means that when the left side of an <TT>or</TT> expression

is evaluated as true, the right side is not evaluated. Combine

this with Perl's easy way with data types, and you can say things

like the following:

<BLOCKQUOTE>

<PRE>

$value &gt; 10 || print &quot;Oops, low value   \n&quot;;

</PRE>

</BLOCKQUOTE>

<P>

If <TT>$value</TT> <I>is</I> greater than 10, the right side of

the expression is never evaluated, so nothing is printed. If <TT>$value</TT>

<I>is not</I> greater than 10, Perl needs to evaluate the right

side, too, so as to decide whether the expression as a whole is

true or false. That means that Perl evaluates the <TT>print</TT>

statement, printing out the message.

<P>

OK, it's a trick, but it's a very useful one.

<P>

Something analogous applies to the <TT>&amp;&amp;</TT> operator.

In this case, if the left side of an expression is false, the

expression as a whole is false, so Perl does not evaluate the

right side. The <TT>&amp;&amp; </TT>operator can, therefore, be

used to produce the same kind of effect as the <TT>||</TT> trick,

but with the opposite sense, as in the following example:

<BLOCKQUOTE>

<PRE>

$value &gt; 10 &amp;&amp; print &quot;OK, value is high enough   \n&quot;;

</PRE>

</BLOCKQUOTE>

<P>

As is true of most Perl constructs, the real power of these tricks

comes when you apply a little creative thinking. Remember that

the left and right sides of these expressions can be any Perl

expressions; think of them as being conjunctions in a sentence

rather than logical operators, and you'll get a better feel for

how to use them. Expressions such as the following give you a

little of the flavor of creative Perl:

<BLOCKQUOTE>

<PRE>

$length &lt;= 80 || die &quot;Line too long.\n&quot;;

$errorlevel &gt; 3 &amp;&amp; warn &quot;Hmmm, strange error level ($errorlevel)   \n&quot;;

open ( LOGFILE, &quot;&gt;install.log&quot;) || &amp;bust(&quot;Log file&quot;);

</PRE>

</BLOCKQUOTE>

<P>

The <TT>&amp;bust</TT> in this example is a subroutine call, by

the way. Refer to &quot;Subroutines&quot; later in this chapter

for more information.

<H3><A NAME="ConditionalExpressions">

Conditional Expressions</A></H3>

<P>

The most basic kind of flow control is a simple branch. A statement

is either executed or not, depending on whether a logical expression

is true or false. You can do this by following the statement with

a modifier and a logical expression, as follows:

<BLOCKQUOTE>

<PRE>

open ( INFILE, &quot;./missing.txt&quot;) if $missing;

</PRE>

</BLOCKQUOTE>

<P>

The execution of the statement is contingent upon <I>both</I>

the evaluation of the expression and the sense of the operator.

<P>

The expression is evaluated as either true or false and can contain

any of the relational operators listed in Table 1.4 (although

it need not). Following are a few examples of valid expressions:

<BLOCKQUOTE>

<PRE>

$full

$a == $b

&lt;STDIN&gt;<BR>

</PRE>

</BLOCKQUOTE>

<P>

<CENTER><B>Table 1.4&nbsp;&nbsp;Perl's Relational Operators</B></CENTER>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=60%>

<TR VALIGN=TOP><TD><B>Operator</B></TD><TD><CENTER><B>Numeric Context</B></CENTER>

</TD><TD><CENTER><B>String Context</B></CENTER></TD>

</TR>

<TR VALIGN=TOP><TD>Equality</TD><TD><CENTER><TT>==</TT></CENTER>

</TD><TD><CENTER><TT>eq</TT></CENTER></TD></TR>

<TR VALIGN=TOP><TD>Inequality</TD><TD><CENTER><TT>!=</TT></CENTER>

</TD><TD><CENTER><TT>ne</TT></CENTER></TD></TR>

<TR VALIGN=TOP><TD>Inequality with signed result</TD><TD><CENTER><TT>&lt;=&gt;</TT></CENTER>

</TD><TD><CENTER><TT>cmp</TT></CENTER></TD></TR>

<TR VALIGN=TOP><TD>Greater than</TD><TD><CENTER><TT>&gt;</TT></CENTER>

</TD><TD><CENTER><TT>gt</TT></CENTER></TD></TR>

<TR VALIGN=TOP><TD>Greater than or equal to</TD><TD><CENTER><TT>&gt;=</TT></CENTER>

</TD><TD><CENTER><TT>ge</TT></CENTER></TD></TR>

<TR VALIGN=TOP><TD>Less than</TD><TD><CENTER><TT>&lt;</TT></CENTER>

</TD><TD><CENTER><TT>lt</TT></CENTER></TD></TR>

<TR VALIGN=TOP><TD>Less than or equal to</TD><TD><CENTER><TT>&lt;=</TT></CENTER>

</TD><TD><CENTER><TT>le</TT></CENTER></TD></TR>

</TABLE></CENTER>

<P>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

When we're comparing strings, <I>less than</I> means <I>lexically less than</I>. If <TT>$left</TT> comes before <TT>$right</TT> when the two are sorted alphabetically, <TT>$left</TT> is less than <TT>$right</TT>.

</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<P>

Perl has four modifiers, each of which behaves the way that you

might expect from the corresponding English word:

<UL>

<LI><TT>if</TT>. The statement is executed if the logical expression

is true and is not executed otherwise. Examples:<BR>

<TT>$max = 100 if $min &lt; 100;<BR>

print &quot;Empty!\n&quot; if !$full;</TT>

<LI><TT>unless</TT>. The statement is not executed if the logical

expression is true and is executed otherwise. Examples:<BR>

<TT>open (ERRLOG, &quot;test.log&quot;) unless $NoLog;<BR>

print &quot;Success&quot; unless $error&gt;2;</TT>

<LI><TT>while</TT>. The statement is executed repeatedly until

the logical expression is false. Examples:<BR>

<TT>$total -= $decrement while $total &gt; $decrement;<BR>

$n=1000;  &quot;print $n\n&quot; while

$n- &gt; 0;</TT>

<LI><TT>until</TT>. The statement is executed repeatedly until

the logical expression is true. Examples:<BR>

<TT>$total += $value[$count++] until $total &gt; $limit;<BR>

print RESULTS &quot;Next value: $value[$n++]&quot;

until $value[$n] = -1;</TT>

</UL>

<P>

Notice that the logical expression is evaluated only one time

in the case of <TT>if</TT> and <TT>unless</TT>, but multiple times

in the case of <TT>while</TT> and <TT>until</TT>. In other words,

the first two are simple conditionals, and the last two are loop

constructs.

<H3><A NAME="CompoundStatements">

Compound Statements</A></H3>

<P>

The syntax changes when you want to make the execution of multiple

statements contingent on the evaluation of a logical expression.

The modifier comes at the start of a line, followed by the logical

expression in parentheses, followed by the conditional statements

in braces. Notice that the parentheses around the logical expression

are required, although they are not required in the single statement

branching described in the preceding section.

<P>

The following example is somewhat similar to C's if syntax:

<BLOCKQUOTE>

<PRE>

if ( ( $total += $value ) &gt; $limit )  {

   print LOGFILE &quot;Maximum limit $limit exceeded. Offending value was $value.\n&quot;;

   close (LOGFILE);

  die &quot;Too many! Check the log file for details.\n&quot;;

   }

</PRE>

</BLOCKQUOTE>

<P>

The <TT>if</TT> statement is capable of a little more complexity,

with <TT>else</TT> and <TT>elsif</TT> operators, as in the following

example:

<BLOCKQUOTE>

<PRE>

if ( !open( LOGFILE, &quot;install.log&quot;) )   {

   close ( INFILE );

   die &quot;Unable to open log file!\n&quot;;

   }

elsif ( !open( CFGFILE, &quot;&gt;system.cfg&quot;) )  {

   print LOGFILE &quot;Error during install: Unable to open config file for writing.\n&quot;;

   close ( LOGFILE );

   die &quot;Unable to open config file for writing!\n&quot;;

   }

else  {

   print CFGFILE &quot;Your settings go here!\n&quot;;

   }

</PRE>

</BLOCKQUOTE>

<H3><A NAME="Loops">

Loops</A></H3>

<P>

The loop modifiers (<TT>while, until, for</TT>, and <TT>foreach</TT>)

are used with compound statements in much the same way, as the

following example shows:

<BLOCKQUOTE>

<PRE>

until ( $total &gt;= 50 )  {

   print &quot;Enter a value: &quot;;

   $value = scalar (&lt;STDIN&gt;);

   $total += $value;

   print &quot;Current total is $total\n&quot;;

   }

print &quot;Enough!\n&quot;;

</PRE>

</BLOCKQUOTE>

<P>

The <TT>while</TT> and <TT>until</TT> statements are described

in &quot;Conditional Expressions&quot; earlier in this chapter.

The <TT>for</TT> statement resembles the one in C. <TT>for</TT>

is followed by an initial value, a termination condition, and

an iteration expression, all enclosed in parentheses and separated

by semicolons, as follows:

<BLOCKQUOTE>

<PRE>

for ( $count = 0; $count &lt; 100; $count++ )  {

   print &quot;Something&quot;;

   }

</PRE>

</BLOCKQUOTE>

<P>

The <TT>foreach</TT> operator is special; it iterates over the

contents of an array and executes the statements in a statement

block for each element of the array.  Following is a simple example:

<BLOCKQUOTE>

<PRE>

@numbers = (&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;);

foreach $num ( @numbers )   {

   print &quot;Number $num   \n&quot;;

   }

</PRE>

</BLOCKQUOTE>

<P>

The variable <TT>$num</TT> first takes on the value <TT>one</TT>,

then <TT>two</TT>, and so on. That example looks fairly trivial,

but the real power of this operator lies in the fact that it can

operate on any array, as follows:

<BLOCKQUOTE>

<PRE>

foreach $arg ( @ARGV )   {

   print &quot;Argument: \&quot;$arg\&quot;.\n&quot;;

   }

foreach $namekey ( sort keys %surnames )  {

   print REPORT &quot;Surname: $value{$namekey}.\n&quot;,

                &quot;Address: $address{$namekey}.\n&quot;;

   }

</PRE>

</BLOCKQUOTE>

<H3><A NAME="Labels">

Labels</A></H3>

<P>

You can use labels with the <TT>next, last</TT>, and <TT>redo</TT>

statements to provide more control of program flow through loops.

A label consists of any word, usually in uppercase, followed by

a colon. The label appears just before the loop operator (<TT>while,

for</TT>, or <TT>foreach</TT>) and can be used as an anchor for

jumping to from within the block. The following code snippet prints

all the odd-numbered records in INFILE:

<BLOCKQUOTE>

<PRE>

RECORD:  while ( &lt;INFILE&gt; )  {

   $even = !$even;

   next RECORD if $even;

   print;

   }

</PRE>

</BLOCKQUOTE>

<P>

The three label-control statements are:

<UL>

<LI><TT>next</TT>. Jumps to the next iteration of the loop marked

by the label or to the innermost enclosing loop, if no label is

specified.

<LI><TT>last</TT>. Immediately breaks out of the loop marked by

the label or out of the innermost enclosing loop, if no label

is specified.

<LI><TT>redo</TT>. Jumps back to the loop marked by the specified

label or to the innermost enclosing loop, if no label is specified.

<TT>redo</TT> causes the loop to execute again with the same iterator

value.

</UL>

<H3><A NAME="Subroutines">

Subroutines</A></H3>

<P>

Subroutines in Perl are defined with the <TT>sub</TT> keyword,

as follows:

<BLOCKQUOTE>

<PRE>

sub Usage {

   print &quot;Usage: \n&quot;,

         &quot;twiddle [-args] infile outfile\n&quot;;

   print &quot;Copyleft 1996, Jonathan F. Squirmsby.&quot;;

 }

</PRE>

</BLOCKQUOTE>

<P>

Subroutines are called with <TT>&amp;</TT>, as follows:

<BLOCKQUOTE>

<PRE>

sub bust  {

   print &quot;Oops, some kind of error seems to have occurred.\n&quot;;

   die &quot;Fatal error, terminating.\n&quot;;

   }

open ( LOGFILE, &quot;&gt;install.log&quot;) || &amp;bust;

</PRE>

</BLOCKQUOTE>

<P>

In this example, the subroutine was defined before it was called.

You can define and call subroutines in any order in Perl; the

convention is to define them after the main routine.

<P>

<B>Passing Arguments&nbsp;&nbsp;</B>You can pass arguments to

a subroutine in the usual way, as follows:

<BLOCKQUOTE>

<PRE>

open ( LOGFILE, &quot;&gt;install.log&quot;) || &amp;bust(&quot;Failed to open log file \&quot;install.log\&quot;.&quot;);

</PRE>

</BLOCKQUOTE>

<P>

But here is where Perl's subroutine syntax starts to get a little

strange; C programmers may want to take a seat before reading

on.

<P>

All Perl subroutines receive their arguments as an arbitrarily

long array of scalars with the special name of <TT>@_</TT>. There

is no mechanism for declaring the arguments when the subroutine

is declared. There is no fixed number of arguments. Also, the

calling function can pass any mixture of scalars and arrays; they

are all treated as one big <TT>@_</TT> array when they get to

the subroutine.

<P>

In the example earlier in this section, in which <TT>bust</TT>

is called with a single argument, you can pick it up in the subroutine

and use it to provide a more sensible error message, as in the

following example:

<BLOCKQUOTE>

<PRE>

sub bust  {

   ($errortext) = @_;

   print &quot;Oops, an error occurred ($errortext).\n&quot;;

   die &quot;Fatal error, terminating.\n&quot;;

   }

</PRE>

</BLOCKQUOTE>

<P>

Notice that we went to the trouble of assigning the scalar <TT>$errortext</TT>

to the argument array <TT>@_</TT>. This assignment may seem to

be unnecessary; in fact, we could have simply used <TT>@_</TT>

instead of <TT>$errortext</TT> in the <TT>print</TT> statement.

Explicitly assigning variables to the contents of the <TT>@_</TT>

array is much clearer, though, especially when the subroutine

takes multiple arguments. Compare the example

<BLOCKQUOTE>

<PRE>

print &quot;Error $_[0] opening file $_[1].\n&quot;;

</PRE>

</BLOCKQUOTE>

<P>

with this one:

<BLOCKQUOTE>

<PRE>

($errfile, $errtext) = @_;

print &quot;Error $errtext opening file $errfile.\n&quot;;

</PRE>

</BLOCKQUOTE>

<P>

Notice, too, that when we assigned the single value <TT>$errortext</TT>

to the <TT>@_</TT> array in the <TT>bust</TT> example, we placed

it in parentheses. We did so to force an array context, so that

what gets assigned to <TT>$errortext</TT> is the first (and only)

value of the <TT>@_</TT> array, not the number of values in <TT>@_</TT>.

In effect, we're telling Perl to treat <TT>$errortext</TT> as

a single-element array. The earlier example that uses <TT>$errfile</TT>

and <TT>$errtext</TT> is a clearer example of an array-to-array

assignment.

<P>

In &quot;Variable Scope&quot; later in this chapter, you learn

how to protect local variables such as <TT>$errortext</TT> in

subroutines by using the <TT>local</TT> and <TT>my</TT> keywords.

<P>

<B>Passing Arrays&nbsp;&nbsp;</B>Perl's grouping of all subroutine

arguments makes it impossible to pass more than one array to a

Perl subroutine. Suppose that you have a subroutine call of the

following form:

<BLOCKQUOTE>

<PRE>

&amp;PrintRes( &quot;alpha&quot;, (1, 3, 5, 7), &quot;beta&quot;, (2, 4, 6, 8) );

</PRE>

</BLOCKQUOTE>

<P>

Try to unpack these arguments into the following values as they

come into the subroutine:

<BLOCKQUOTE>

<PRE>

$p1 = &quot;alpha&quot;;

@p2 = (1, 3, 5, 7);

$p3 = &quot;beta&quot;;

@p4 = (2, 4, 6, 8);

</PRE>

</BLOCKQUOTE>

<P>

A statement like

<BLOCKQUOTE>

<PRE>

( $p1, @p2, $p3, @p4 ) = @_;

</PRE>

</BLOCKQUOTE>

<P>

won't get beyond the second parameter. The following list explains

what happens:

<OL>

<LI>The first variable in the list, <TT>$p1</TT>, is assigned

the value of the first scalar in the <TT>@_</TT> argument array,

which is <TT>alpha</TT>.

<LI>Then the next variable in the list, <TT>@p2</TT>, is assigned

the value of the next argument in the <TT>@_</TT> argument array.

This is an array assignment because <TT>@p2</TT> is an array,

so the entire <TT>@_</TT> array, from its second element on, is

assigned to <TT>@p2</TT>-<TT>(1, 3, 5, 7, &quot;beta&quot;, 2,

4, 6, 8)</TT>, in other words.

<LI>The next variable to be assigned is <TT>$p3</TT>. This variable

is assigned the value of the next element in the <TT>@_</TT> argument

array-but there aren't any left, because they've all been slurped

by <TT>@p2</TT>. <TT>$p3</TT>, therefore, is null.

<LI>The final variable, <TT>@p4</TT>, suffers the same fate and

is also null.

</OL>

<P>

There's no point in trying to specify subarrays, as in the following

example, because Perl expands the array on the left to the same

thing as before:

<BLOCKQUOTE>

<PRE>

( $p1, (@p2), $p3, (@p4) ) = @_;

</PRE>

</BLOCKQUOTE>

<P>

The moral of the story is: Don't pass more than one array into

a subroutine. And if you do pass an array, make sure that it's

the last argument.

<P>

<B>Returning Values</B>&nbsp;&nbsp;Perl is just as casual about

returning values from subroutines as it is about passing arguments

to them. A subroutine returns a single value: the value of the

last assign-ment made in the subroutine. If you pass (<TT>4</TT>,

<TT>3</TT>) to this subroutine, the

value <TT>7 </TT>is returned:

<BLOCKQUOTE>

<PRE>

sub AddIt  {

   ( $a, $b ) = @_;

   $a + $b;

   }

</PRE>

</BLOCKQUOTE>

<P>

That means that the value <TT>7</TT> is substituted for the subroutine

call after evaluation. The code

<BLOCKQUOTE>

<PRE>

print &quot;Summing 4 and 3 yields &quot;, &amp;AddIt(4, 3), &quot;.\n&quot;;

</PRE>

</BLOCKQUOTE>

<P>

prints the following:

<BLOCKQUOTE>

<PRE>

Summing 4 and 3 yields 7.

</PRE>

</BLOCKQUOTE>

<P>

Notice that we had to keep the subroutine call outside the quotes

to allow Perl to recognize <TT>&amp;</TT> as a subroutine invocation.

<P>

It isn't always clear which statement is the last to be executed

in a subroutine, particularly if it contains loops or conditional

statements. One way to ensure that the correct value is returned

is to place a reference to the variable on a line by itself at

the end of the subroutine, as follows:

<BLOCKQUOTE>

<PRE>

sub Maybe  {

   # Various loops and conditionals here which set the value of &quot;$result&quot;   

   $result;

   }<BR>

</PRE>

</BLOCKQUOTE>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>CAUTION</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

Take care not to add seemingly innocuous statements near the end of a subroutine. A <TT>print</TT> statement returns a value of 1 (if successful) for example, so a subroutine that prints something just before it returns always returns 1.

</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

The return value can be a scalar, an array, or an associative

array. Listing 1.1 shows a complete example in which a subroutine

builds an associative array of names keyed by initials and then

returns the associative array. The keys of this array-the initials-are

then printed in sorted order. Take your time reading through this

example; a lot is going on in there, but it's comprehensively

commented.

<HR>

<BLOCKQUOTE>

<B>Listing 1.1&nbsp;&nbsp;INITIALS.PL: Returning an Associative

Array from a Subroutine<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#!/usr/local/bin/perl -w



# Pass the names into the subroutine.

# Store the results in an associative array called &quot;keyedNames&quot;.

%keyedNames = &amp;GetInitials(&quot;Jane Austen&quot;, &quot;Emily Bronte&quot;, &quot;Mary Shelley&quot; );



# Print out the initials, sorted:

print &quot;Initials are &quot;, join(', ', sort keys %keyedNames), &quot;.\n&quot;;



# The GetInitials subroutine.

sub GetInitials  {



   # Let's store the arguments in a &quot;names&quot; array for clarity.

   @names = @_;



   # Process each name in turn:

   foreach $name ( @names )  {



      # The &quot;split&quot; function is explained in Chapter 15, &quot;Function List&quot;.

      # In this statement, we're getting split to look for the ' ' in the name;

      # It returns an array of chunks of the original string (i.e. $name) which were

      # separated by spaces, i.e. the forename and surname respectively in our case.

      # The variables &quot;$forename&quot; and &quot;$surname&quot; are then assigned to this array

      # using parentheses to force an array assignment.

      ( $forename, $surname ) = split( ' ', $name );



      # OK, now we have the forename and surname. We use the &quot;substr&quot; function,

      # also explained in chapter 15, to extract the first character from each 

of these.

      # The &quot;.&quot; operator concatenates two strings (for example, &quot;aa&quot;.&quot;bb&quot; is &quot;aabb&quot;)

      # so the variable &quot;$inits&quot; takes on the value of the initials of the name:

      $inits = substr( $forename, 0, 1 ) . substr( $surname, 0, 1 );



      # Now we store the name in an associative array using the initials as the key:

      $NamesByInitials{$inits} = $name;

      }



   # Having built the associative array, we simply refer to it at the end of the

   # subroutine so that it's value is the last thing evaluated here. It will then 

   # be passed back to the calling function.

   %NamesByInitials;

   }

</PRE>

</BLOCKQUOTE>

<HR>

<H3><A NAME="VariableScope">

Variable Scope</A></H3>

<P>

Perl uses separate name spaces to store scalars, arrays, associative

arrays, and so on. As a result, you can use the same name for

variables of different types without fear of confusion (at least

on Perl's part; for your own sake, use unique names).<TT> </TT>This

example uses three different kinds of variables, each called <TT>name</TT>:

<BLOCKQUOTE>

<PRE>

$name = &quot;Dana&quot;;

@name = (&quot;Donna&quot;, &quot;Dana&quot;, &quot;Diana&quot;);

%name = (&quot;Donna&quot;, &quot;Elephants&quot;, &quot;Dana&quot;, &quot;Finches&quot;, &quot;Diana&quot;, &quot;Parakeets&quot;);

print &quot;I said $name{$name}, not $name{$name[0]}!\n&quot;;

</PRE>

</BLOCKQUOTE>

<P>

The bad news is that by default, Perl uses just one name space

for each data type, for all functions. So if you have a variable

called <TT>$temp</TT> in the main function, and you call a routine

that uses another variable called <TT>$temp</TT>, the value of

<TT>$temp</TT> in the main function gets clobbered. The references

to the two variables are in fact two references to the same variable,

as far as Perl is concerned.

<P>

That's where the <TT>local</TT> (Perl 4 and 5) and <TT>my</TT>

(Perl 5 only) functions come in. These functions force Perl to

treat variables as though they are local to the current code block,

whether that block is a loop, an if-block, or a subroutine.

<P>

The following example uses two variables called <TT>$temp</TT>

(one outside and one inside a <TT>while</TT> loop):

<BLOCKQUOTE>

<PRE>

$temp = &quot;Still here!\n&quot;;

print &quot;Enter a few words at a time, Ctrl+D to terminate:\n&quot;;

while (&lt;&gt;)  {

   local( $temp, @etc ) = split(' ', $_ );

   print &quot;You said $temp&quot;;

   @etc &amp;&amp; print &quot; and then you said @etc&quot;;

   print &quot;.  Enter some more, or press Ctrl+D to end:\n&quot;;

   }

print $temp;

</PRE>

</BLOCKQUOTE>

<P>

The difference between Perl 4's <TT>local()</TT> and Perl 5's

<TT>my()</TT> is that <TT>local</TT> variables are local to the

current package, whereas <TT>my</TT> variables are <I>really</I>

local. 

<H2><A NAME="Patterns"><FONT SIZE=5 COLOR=#FF0000>

Patterns</FONT></A></H2>

<P>

We'll finish this overview of Perl by discussing its pattern-matching

capabilities. The capability to match and replace patterns is

vital to any scripting language that claims to be capable of useful

text manipulation. By this stage, you probably won't be surprised

to read that Perl matches patterns better than any other general-purpose

language does. Perl 4's pattern matching is excellent, but Perl

5 introduces some significant improvements, including the capability

to match on even more arbitrary strings than before.

<P>

The basic pattern-matching operations discussed in this section

are:

<UL>

<LI><I>Matching</I>, in which we want to know whether a particular

string matches a pattern

<LI><I>Substitution</I>, in which we want to replace portions

of a string based on a pattern

</UL>

<P>

The patterns referred to here are more properly known as regular

expressions, and we'll start by looking at them.

<H3><A NAME="RegularExpressions">

Regular Expressions</A></H3>

<P>

A <I>regular expression</I> is a set of rules that describes a

generalized string. If the characters that make up a particular

string conform to the rules of a particular regular expression,

the regular expression is said to <I>match</I> that string.

<P>

A few concrete examples usually help after an overblown definition

like that one. The regular expression b. matches the strings bovine,

above, Bobby, and Bob Jones, but not the strings Bell, b, or Bob.

That's because the expression insists that the letter <I>b</I>

(lowercase) must be in the string and must be followed immediately

by another character.

<P>

The regular expression b+, on the other hand, requires the lowercase

letter <I>b</I> at least once. This expression matches b and Bob

in addition to the example matches for b. in the preceding paragraph.

The regular expression b* requires zero or more <I>b</I>s, so

it matches any string. That seems to be fairly useless, but it

makes more sense as part of a larger regular expression. Bob*y,

for example, matches all of Boy, Boby, and Bobby but not Boboby.

<P>

<B>Assertions&nbsp;</B>&nbsp;Several so-called assertions are

used to anchor parts of the pattern to word or string boundaries.

The <TT>^ </TT>assertion matches

the start of a string, so the regular expression <TT>^fool

</TT>matches <TT>fool </TT>and

<TT>foolhardy </TT>but not <TT>tomfoolery

</TT>or <TT>April fool</TT>.

Table 1.5 lists the assertions.<BR>

<P>

<CENTER><B>Table 1.5&nbsp;&nbsp;Perl's Regular-Expression Assertions</B></CENTER>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD WIDTH=85><CENTER><B>Assertion</B></CENTER></TD><TD WIDTH=144><B>Matches</B>

</TD><TD WIDTH=116><B>Example</B></TD><TD WIDTH=116><B>Matches</B>

</TD><TD WIDTH=116><B>Doesn't Match</B></TD></TR>

<TR VALIGN=TOP><TD WIDTH=85><CENTER><TT>^</TT></CENTER></TD><TD WIDTH=144>Start of string

</TD><TD WIDTH=116><TT>^fool</TT></TD><TD WIDTH=116><TT>foolish</TT>

</TD><TD WIDTH=116><TT>tomfoolery</TT>

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=85><CENTER><TT>$</TT></CENTER></TD><TD WIDTH=144>End of string

</TD><TD WIDTH=116><TT>fool$</TT></TD><TD WIDTH=116><TT>April fool</TT>

</TD><TD WIDTH=116><TT>foolish</TT></TD>

</TR>

<TR VALIGN=TOP><TD WIDTH=85><CENTER><TT>\b</TT></CENTER></TD><TD WIDTH=144>Word boundary

</TD><TD WIDTH=116><TT>be\bside</TT></TD><TD WIDTH=116><TT>be side</TT>

</TD><TD WIDTH=116><TT>beside</TT></TD>

</TR>

<TR VALIGN=TOP><TD WIDTH=85><CENTER><TT>\B</TT></CENTER></TD><TD WIDTH=144>Nonword boundary

</TD><TD WIDTH=116><TT>be\Bside</TT></TD><TD WIDTH=116><TT>beside</TT>

</TD><TD WIDTH=116><TT>be side</TT></TD>

</TR>

</TABLE></CENTER>

<P>

<P>

<B>Atoms&nbsp;&nbsp;</B>The . (period) that you saw in b. earlier

in this chapter is an example of a regular-expression atom. <I>Atoms</I>

are, as the name suggests, the fundamental building blocks of

a regular expression. A full list of atoms appears in Table 1.6.

<BR>

<P>

<CENTER><B>Table 1.6&nbsp;&nbsp;Perl's Regular-Expression Atoms</B></CENTER>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD WIDTH=103><B>Atom</B></TD><TD WIDTH=126><B>Matches</B>

</TD><TD WIDTH=114><B>Example</B></TD><TD WIDTH=104><B>Matches</B>

</TD><TD WIDTH=119><B>Doesn't Match</B></TD></TR>

<TR VALIGN=TOP><TD WIDTH=103>period (.)</TD><TD WIDTH=126>Any character except new line

</TD><TD WIDTH=114><TT>b.b</TT></TD><TD WIDTH=104><TT>bob</TT>

</TD><TD WIDTH=119><TT>bb </TT></TD></TR>

<TR VALIGN=TOP><TD WIDTH=103>List of characters in brackets </TD><TD WIDTH=126>Any one of those characters

</TD><TD WIDTH=114><TT>^[Bb]</TT></TD><TD WIDTH=104><TT>Bob, bob</TT>

</TD><TD WIDTH=119><TT>Rbob </TT></TD></TR>

<TR VALIGN=TOP><TD WIDTH=103>Regular expression in parentheses</TD><TD WIDTH=126>Anything that regular expression matches

</TD><TD WIDTH=114><TT>^a(b.b)c$</TT></TD><TD WIDTH=104><TT>abobc</TT>

</TD><TD WIDTH=119><TT>abbc </TT></TD></TR>

</TABLE></CENTER>

<P>

<P>

<B>Quantifiers&nbsp;&nbsp;</B>A <I>quantifier</I> is a modifier

for an atom. It can be used to specify that a particular atom

must appear at least once, as in b+. The atom quantifiers are

listed in Table 1.7.<BR>

<P>

<CENTER><B>Table 1.7&nbsp;&nbsp;Perl's Regular-Expression Atom

Quantifiers</B></CENTER>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD WIDTH=76><B>Quantifier</B></TD><TD WIDTH=250><B>Matches</B>

</TD><TD><B>Example</B></TD><TD><B>Matches</B>

</TD><TD><B>Doesn't Match</B></TD></TR>

<TR VALIGN=TOP><TD WIDTH=76><TT>*</TT></TD><TD WIDTH=250>Zero or more instances of  the atom

</TD><TD><TT>ab*c</TT></TD><TD><TT>ac, abc</TT>

</TD><TD><TT>abb </TT></TD></TR>

<TR VALIGN=TOP><TD WIDTH=76><TT>+</TT></TD><TD WIDTH=250>One or more instances of the atom

</TD><TD><TT>ab+c</TT></TD><TD><TT>abc</TT>

</TD><TD><TT>ac </TT></TD></TR>

<TR VALIGN=TOP><TD WIDTH=76><TT>?</TT></TD><TD WIDTH=250>Zero or one instances of the atom

</TD><TD><TT>ab?c</TT></TD><TD><TT>ac, abc</TT>

</TD><TD><TT>abbc </TT></TD></TR>

<TR VALIGN=TOP><TD WIDTH=76><TT>{n}</TT></TD><TD WIDTH=250><TT>n</TT> instances of the atom

</TD><TD><TT>ab{2}c</TT></TD><TD><TT>abbc</TT>

</TD><TD><TT>abbbc</TT></TD></TR>

<TR VALIGN=TOP><TD WIDTH=76><TT>{n,}</TT></TD><TD WIDTH=250>At least <TT>n </TT>instances of the atom

</TD><TD><TT>ab{2,}c</TT></TD><TD><TT>abbc, abbbc</TT>

</TD><TD><TT>abc </TT></TD></TR>

<TR VALIGN=TOP><TD WIDTH=76><TT>{nm}</TT></TD><TD WIDTH=250>At least <TT>n</TT>, most <TT>m</TT> instances of the atom

</TD><TD><TT>ab{2,3}c</TT></TD><TD><TT>abbc</TT>

</TD><TD><TT>abbbbc</TT>at </TD></TR>

</TABLE></CENTER>

<P>

<P>

<B>Special Characters&nbsp;&nbsp; </B>Several special characters

are denoted by backslashed letters, with <TT>\n

</TT>being especially familiar to C programmers, perhaps. Table

1.8 lists the special characters.<BR>

<P>

<CENTER><B>Table 1.8&nbsp;&nbsp;Perl's Regular-Expression Special

Characters</B></CENTER>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD WIDTH=70><CENTER><B>Symbol</B></CENTER></TD><TD WIDTH=198><B>Matches</B>

</TD><TD WIDTH=78><CENTER><B>Example</B></CENTER></TD><TD WIDTH=75><CENTER><B>Matches</B></CENTER>

</TD><TD WIDTH=114><CENTER><B>Doesn't Match</B></CENTER></TD>

</TR>

<TR VALIGN=TOP><TD WIDTH=70><CENTER><TT>\d</TT></CENTER></TD><TD WIDTH=198>Any digit

</TD><TD WIDTH=78><CENTER><TT>b\dd</TT></CENTER></TD><TD WIDTH=75><CENTER><TT>b4d</TT></CENTER>

</TD><TD WIDTH=114><CENTER><TT>bad</TT></CENTER></TD></TR>

<TR VALIGN=TOP><TD WIDTH=70><CENTER><TT>\D</TT></CENTER></TD><TD WIDTH=198>Nondigit

</TD><TD WIDTH=78><CENTER><TT>b\Dd</TT></CENTER></TD><TD WIDTH=75><CENTER><TT>bdd</TT></CENTER>

</TD><TD WIDTH=114><CENTER><TT>b4d</TT></CENTER></TD></TR>

<TR VALIGN=TOP><TD WIDTH=70><CENTER><TT>\n</TT></CENTER></TD><TD WIDTH=198>New line

</TD><TD WIDTH=78><CENTER>&nbsp;</CENTER></TD><TD WIDTH=75><CENTER>&nbsp;</CENTER>

</TD><TD WIDTH=114><CENTER>&nbsp;</CENTER></TD></TR>

<TR VALIGN=TOP><TD WIDTH=70><CENTER><TT>\r</TT></CENTER></TD><TD WIDTH=198>Carriage return

</TD><TD WIDTH=78><CENTER>&nbsp;</CENTER></TD><TD WIDTH=75><CENTER>&nbsp;</CENTER>

</TD><TD WIDTH=114><CENTER>&nbsp;</CENTER></TD></TR>

<TR VALIGN=TOP><TD WIDTH=70><CENTER><TT>\t</TT></CENTER></TD><TD WIDTH=198>Tab

</TD><TD WIDTH=78><CENTER>&nbsp;</CENTER></TD><TD WIDTH=75><CENTER>&nbsp;</CENTER>

</TD><TD WIDTH=114><CENTER>&nbsp;</CENTER></TD></TR>

<TR VALIGN=TOP><TD WIDTH=70><CENTER><TT>\f</TT></CENTER></TD><TD WIDTH=198>Form feed

</TD><TD WIDTH=78><CENTER>&nbsp;</CENTER></TD><TD WIDTH=75><CENTER>&nbsp;</CENTER>

</TD><TD WIDTH=114><CENTER>&nbsp;</CENTER></TD></TR>

<TR VALIGN=TOP><TD WIDTH=70><CENTER><TT>\s</TT></CENTER></TD><TD WIDTH=198>White-space character

</TD><TD WIDTH=78><CENTER>&nbsp;</CENTER></TD><TD WIDTH=75><CENTER>&nbsp;</CENTER>

</TD><TD WIDTH=114><CENTER>&nbsp;</CENTER></TD></TR>

<TR VALIGN=TOP><TD WIDTH=70><CENTER><TT>\S</TT></CENTER></TD><TD WIDTH=198>Non-white-space character

</TD><TD WIDTH=78><CENTER>&nbsp;</CENTER></TD><TD WIDTH=75><CENTER>&nbsp;</CENTER>

</TD><TD WIDTH=114><CENTER>&nbsp;</CENTER></TD></TR>

<TR VALIGN=TOP><TD WIDTH=70><CENTER><TT>\w</TT></CENTER></TD><TD WIDTH=198>Alphanumeric character

</TD><TD WIDTH=78><CENTER><TT>a\wb</TT></CENTER></TD><TD WIDTH=75><CENTER><TT>a2b</TT></CENTER>

</TD><TD WIDTH=114><CENTER><TT>a^b</TT></CENTER></TD></TR>

<TR VALIGN=TOP><TD WIDTH=70><CENTER><TT>\W</TT></CENTER></TD><TD WIDTH=198>Nonalphanumeric character

</TD><TD WIDTH=78><CENTER><TT>a\Wb</TT></CENTER></TD><TD WIDTH=75><CENTER><TT>aa^b</TT></CENTER>

</TD><TD WIDTH=114><CENTER><TT>aabb</TT></CENTER></TD></TR>

</TABLE></CENTER>

<P>

<P>

<B>Backslashed Tokens&nbsp;&nbsp;</B>It is essential that regular

expressions be capable of using all characters, so that all possible

strings that occur in the real word can be matched. With so many

characters having special meanings, a mechanism is required that

allows you to represent any arbitrary character in a regular expression.

<P>

This mechanism is a backslash (<TT>\</TT>), followed by a numeric

quantity. This quantity can take any of the following formats:

<UL>

<LI><B>Single or double digit:</B> matched quantities after a

match. These matched quantities are called <I>backreferences</I>

and are explained in the following section.

<LI><B>Two-or three-digit octal number:</B> the character with

that number as character code, unless it's possible to interpret

it as a backreference.

<LI><TT>x</TT><B>, followed by two hexadecimal digits:</B> the

character with that number as its character code. <TT>\x3e</TT>,

for example, is <TT>&gt;</TT>.

<LI><TT>c</TT><B>, followed by a single character:</B> the control

character. <TT>\cG</TT>, for example, matches <TT>Ctrl+G</TT>.

<LI><B>Any other character:</B> the character itself. <TT>\&amp;</TT>,

for example, matches the <TT>&amp;</TT> character.

</UL>

<H3><A NAME="Matching">

Matching</A></H3>

<P>

Now you're ready to start putting all that information together

with some real pattern matching. The match operator normally consists

of two forward slashes with a regular expression in between, and

it normally operates on the contents of the <TT>$_</TT> variable.

So if <TT>$</TT>_ is <TT>serendipity</TT>, <TT>/^ser/, /end/,</TT>

and <TT>/^s.*y$/</TT> are all true.

<P>

<B>Matching on $_&nbsp;&nbsp;</B>The <TT>$_</TT> operator is special;

see <A HREF="ch13.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch13.htm" >Chapter 13</A>, &quot;Special Variables,&quot; for full details.

In many ways, <TT>$_</TT> is the default container for data that

is being read in by Perl. The <TT>&lt;&gt;</TT> operator, for

example, gets the next line from <TT>STDIN</TT> and stores it

in <TT>$_</TT>. So the following code snippet allows you to type

lines of text and tells you when your line matches one of the

regular expressions:

<BLOCKQUOTE>

<PRE>

$prompt = &quot;Enter some text or press Ctrl+D to stop: &quot;;

print $prompt;

while (&lt;&gt;)  {

   /^[aA]/ &amp;&amp; print &quot;Starts with a or A.  &quot;;

   /[0-9]$/ &amp;&amp; print &quot;Ends with a digit.  &quot;;

   /perl/ &amp;&amp; print &quot;You said it!   &quot;;

   print $prompt;

   }

</PRE>

</BLOCKQUOTE>

<P>

<B>Bound Matches</B>&nbsp;&nbsp;Matching doesn't always have to

operate on <TT>$_</TT>, although this default behavior is quite

convenient. A special operator, <TT>=~</TT>, evaluates to either

true or false, depending on whether its first operand matches

on its second operand. So <TT>$filename =~ /dat$/</TT> is true

if <TT>$filename</TT> matches on <TT>/dat$/</TT>. You can use

<TT>=~</TT> in conditionals in the usual way, as follows:

<BLOCKQUOTE>

<PRE>

?$filename =~ /dat$/ &amp;&amp; die &quot;Can't use .dat files.\n&quot;;

</PRE>

</BLOCKQUOTE>

<P>

A corresponding operator, <TT>!~</TT>, has the opposite sense.

<TT>!~</TT> is true if the first operator does not match on the

second, as follows:

<BLOCKQUOTE>

<PRE>

$ENV{'PATH'} !~ /perl/ &amp;&amp; warn &quot;Not sure if perl is in your path   &quot;;

</PRE>

</BLOCKQUOTE>

<P>

<B>Alternative Delimiters</B>&nbsp;&nbsp;The match operator can

use characters other than <TT>//</TT>-a useful point if you're

trying to match a complex expression that involves forward slashes.

A more general form of the match operator than <TT>//</TT> is

<TT>m//</TT>. If you use the leading <TT>m</TT>, you can use any

character to delimit the regular expression. For example,

<BLOCKQUOTE>

<PRE>

$installpath =~ m!^/usr/local! || warn &quot;The path you have chosen is odd.\n&quot;;

</PRE>

</BLOCKQUOTE>

<P>

warns that &quot;The path you have chosen is <TT>odd.\n</TT>&quot;

if the variable <TT>$installpath</TT> starts with <TT>/usr/local</TT>.

<P>

<B>Match Options</B>&nbsp;&nbsp;You can apply several optional

switches to the match operator (either <TT>//</TT> or <TT>m//</TT>)

to alter its behavior. These options are listed in Table 1.9.

<BR>

<P>

<CENTER><B>Table 1.9&nbsp;&nbsp;Perl's Match-Operator Optional

Switches </B></CENTER>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=50%>

<TR VALIGN=TOP><TD WIDTH=109><CENTER><B>Switch</B></CENTER></TD><TD WIDTH=419><B>Meaning</B>

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=109><CENTER><TT>g</TT></CENTER></TD><TD WIDTH=419>Perform global matching

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=109><CENTER><TT>i</TT></CENTER></TD><TD WIDTH=419>Perform case-insensitive matching

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=109><CENTER><TT>o</TT></CENTER></TD><TD WIDTH=419>Evaluate the regular expression one time only

</TD></TR>

</TABLE></CENTER>

<P>

<P>

The <TT>g</TT> switch continues matching even after the first

match has been found. This switch is useful when you are using

backreferences to examine the matched portions of a string, as

described in the &quot;Backreferences&quot; section later in this

chapter.

<P>

The <TT>i</TT> switch forces a case-insensitive match.

<P>

Finally, the <TT>o</TT> switch is used inside loops in which a

great deal of pattern matching is taking place. This switch tells

Perl that the regular expression (the match operator's operand)

is to be evaluated one time only. The switch can improve efficiency

when the regular expression is fixed for all iterations of the

loop that contains it.

<P>

<B>Backreferences&nbsp;&nbsp;</B>As we mentioned in the &quot;Backslashed

Tokens&quot; section earlier in this chapter, pattern matching

produces quantities that are known as <I>backreferences</I>. These

quantities are the parts of your string in which the match succeeded.

You need to tell Perl to store them by surrounding the relevant

parts of your regular expression with parentheses, and you can

refer to them after the match as <TT>\1, \2</TT>, and so on. The

following example determines whether the user typed three consecutive

four-letter words:

<BLOCKQUOTE>

<PRE>

while (&lt;&gt;)  {

   /\b(\S{4})\s(\S{4})\s(\S{4})\b/ &amp;&amp; print &quot;Gosh, you said $1 $2 $3!\n&quot;;

   }

</PRE>

</BLOCKQUOTE>

<P>

The first four-letter word lies between a word boundary (<TT>\b</TT>)

and some white space (<TT>\s</TT>), and consists of four non-white-space

characters (<TT>\S</TT>). If there is a match on the expression

<TT>\b(\S{4})\s</TT>-if a four-letter word is found-the matching

substring is stored in the special variable <TT>\1</TT>, and the

search continues. When the search is complete, you can refer to

the backreferences as <TT>$1, $2</TT>, and so on.

<P>

What if you don't know in advance how many matches to expect?

Perform the match in an array context; Perl returns the matches

in an array. Consider this example:

<BLOCKQUOTE>

<PRE>

@hits = (&quot;Yon Yonson, Wisconsin&quot; =~ /(\won)/g);

print &quot;Matched on &quot;, join(', ', @hits), &quot;.\n&quot;;

</PRE>

</BLOCKQUOTE>

<P>

We'll start at the right side and work backward. The regular expression

<TT>(\won)</TT> means that we match any alphanumeric character

followed by <TT>on</TT> and store all three characters. The <TT>g</TT>

option after the <TT>//</TT> operator means that we want to do

this for the entire string, even after we find a match. The <TT>=~</TT>

operator means that we carry out this operation on a given string

(<TT>Yon Yonson, Wisconsin</TT>). Finally, the whole thing is

evaluated in an array context, so Perl returns the array of matches,

and we store it in the @hits array. Following is the output from

this example:

<BLOCKQUOTE>

<PRE>

Matched on Yon, Yon, son, con.

</PRE>

</BLOCKQUOTE>

<H3><A NAME="Substitution">

Substitution</A></H3>

<P>

When you get the hang of pattern matching, you'll find that substitutions

are quite straightforward and very powerful. The substitution

operator is <TT>s///</TT>, which resembles the match operator

but has three rather than two slashes. Just as you can do with

the match operator, you can substitute any other character for

the forward slashes, and you can use the optional <TT>i, g</TT>,

and <TT>o</TT> switches.

<P>

The pattern to be replaced goes between the first and second delimiters,

and the replacement pattern goes between the second and third

delimiters. This simple example changes $house from henhouse to

doghouse:

<BLOCKQUOTE>

<PRE>

$house = &quot;henhouse&quot;;

$house  =~ s/hen/dog/;

</PRE>

</BLOCKQUOTE>

<P>

Notice that it isn't possible to use the <TT>=~</TT> <TT>operator</TT>

with a literal string as you can when matching, because you can't

modify a literal constant. Instead, store the string in a variable

and modify that variable.

<H2><A NAME="FromHere"><FONT SIZE=5 COLOR=#FF0000>

From Here...</FONT></A></H2>

<P>

You have reached the end of your whirlwind tour of Perl. You saw

how Perl's deceptively simple constructs can be used to write

deceptively simple programs, and you got a brief look at the basic

elements of the language. At minimum, you should have a clear

idea of how the language works, and you should know where to go

for more information on Perl as the need arises throughout the

rest of this book.

<P>

This book now moves on to Web matters, but look in the following

places for more information about Perl:

<UL>

<LI>Refer to Part V of this book for comprehensive information

on Perl special variables, operators, and built-in functions.

<LI>Also refer to Part V to learn how to use modules and libraries

to compartmentalize your code for greater robustness and extensibility.

<LI>Consider buying a book that deals in detail with the Perl

language. The definitive work is the &quot;Camel book,&quot; cited

at the beginning of this chapter.

</UL>

<HR>



<CENTER><P>

<A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="index.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="ch2.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch2.htm"><IMG SRC="nc.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<HR WIDTH="100%"></P></CENTER>

</BODY>

</HTML>

