<HTML>

<HEAD>

<TITLE>Chapter 16 -- Subroutine Definition</TITLE>



<META>

</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">

<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;16</FONT></H1>

<H1><FONT SIZE=6 COLOR=#FF0000>Subroutine Definition</FONT></H1>

<P>

<I><B>by M&iacute;che&aacute;l &Oacute; Foghl&uacute;</B></I>

<HR>

<P>

<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>

<UL>

<LI><A HREF="#Subroutines">

Subroutines</A>

<UL>

<LI><A HREF="#TheSimplestFormofSubroutine">

The Simplest Form of Subroutine</A>

<LI><A HREF="#HowtoReturnValuesfromSubroutines">

How to Return Values from Subroutines</A>

<LI><A HREF="#HowtoPassValuestoSubroutines">

How to Pass Values to Subroutines</A>

<LI><A HREF="#SubroutineRecursion">

Subroutine Recursion</A>

<LI><A HREF="#SubroutinePrototypes">

Subroutine Prototypes</A>

<LI><A HREF="#IssuesofScopewithImyIandIlocalI">

Issues of Scope with <I>my()</I> and <I>local()</I></A>

</UL>

<LI><A HREF="#PerlLibraries">

Perl Libraries</A>

<UL>

<LI><A HREF="#CreationofLibraries">

Creation of Libraries</A>

<LI><A HREF="#InvocationofLibraries">

Invocation of Libraries</A>

<LI><A HREF="#StandardPerlLibrary">

Standard Perl 4.0 Library</A>

</UL>

<LI><A HREF="#ModulesPerl">

Modules (Perl 5.0)</A>

<UL>

<LI><A HREF="#StandardModuleList">

Standard Module List</A>

<LI><A HREF="#HowtoCreateaSimpleModule">

How to Create a Simple Module</A>

<LI><A HREF="#ModuleUseandInvocation">

Module Use and Invocation</A>

</UL>

<LI><A HREF="#FromHere">

From Here   </A>

</UL>



<HR>

<P>

One important factor in developing Perl programs is understanding

the different ways of sectioning Perl code into functional units.

This sectioning is important, both as a method of segmenting your

own code so that such segments can be reused in various ways and

as a method of using code developed by other people rather than

having to reinvent the wheel.

<P>

There are three basic levels of segmentation. Within a package,

Perl provides for the creation and use of subroutines. As in many

structured programming languages, segmentation allows frequently

used code, or code designed for a particular subtask, to be grouped

logically. This concept also enables the use of recursive subroutines,

which is a powerful mechanism for solving certain problems.

<P>

When you want to use subroutines that were originally developed

in one program in another program, you can do so in two ways in

Perl. The first way is to create a library, which you can subsequently

include in other programs, giving them access to the suite of

subroutines.

<P>

In Perl 5.0, this mechanism was expanded and generalized with

the introduction of the concept of modules. Although they are

more complex to create, modules are a more flexible method of

developing and distributing suites of subroutines relating to

specific tasks.

<H2><A NAME="Subroutines"><FONT SIZE=5 COLOR=#FF0000>

Subroutines</FONT></A></H2>

<P>

The basic subunit of code in Perl is a subroutine. A <I>subroutine</I>

is similar to a function in C and to a procedure or a function

in Pascal. A subroutine can be called with various parameters

and returns a value. Effectively, the subroutine groups a sequence

of statements so that they can be reused.

<H3><A NAME="TheSimplestFormofSubroutine">

The Simplest Form of Subroutine</A></H3>

<P>

Subroutines can be declared anywhere in a program. If more than

one subroutine with the same name is declared, each new version

replaces the older ones, so that only the last one is effective.

You can declare subroutines within an <TT>eval()</TT> expression.

These subroutines will not actually be declared until the run-time

execution reaches the <TT>eval()</TT> statement.

<P>

Subroutines are declared in the following syntax:

<BLOCKQUOTE>

<PRE>

sub &lt;subroutine-name&gt; {

&lt;statements&gt;

}

</PRE>

</BLOCKQUOTE>

<P>

The simplest form of subroutine is one that does not return any

value and does not access any external values. The subroutine

is called by prefixing the name with the <TT>&amp;</TT> character.

(Other ways of calling subroutines are explained in more detail

later in this chapter, in the section &quot;How to Pass Values

to Subroutines.&quot;)<TT> </TT>Following is an example of a program

that uses the simplest form of subroutine:

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl -w

# Example of subroutine which does not use external values and does not return a

value

&amp;egsub1; # Call the subroutine once

&amp;egsub1; # Call the subroutine a second time

sub egsub1 {

     print &quot;This subroutine simply prints this line.\n&quot;;

}<BR>

</PRE>

</BLOCKQUOTE>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>TIP</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

Although you can refer from a subroutine to any global variable directly, this method normally is considered to be bad programming practice. Referring to global variables from subroutines makes reusing the subroutine code more difficult. (Will the same 
global variables always exist and have relevant values?) It is best to make any such references to external values explicit by passing explicit parameters to the subroutine, as described later in this chapter, in &quot;How to Pass Values to 
Subroutines.&quot;</BLOCKQUOTE>

<BLOCKQUOTE>

Similarly, it is best to avoid programming subroutines that directly change the values of global variables. This practice could lead to unpredictable side effects if the subroutine is reused in a different program. Use explicit return values or explicit 
parameters passed by reference, as described in &quot;How to Pass Values to Subroutines&quot; later in this chapter</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<H3><A NAME="HowtoReturnValuesfromSubroutines">

How to Return Values from Subroutines</A></H3>

<P>

Subroutines can also return values, thus acting as functions.

The return value is the value of the last statement executed;

it can be a scalar or an array value. You can test whether the

calling context requires an array or a scalar value by using the

<TT>wantarray</TT> construct, thus returning different values

depending on the required context. The following example, as the

last line of a subroutine, would return the array <TT>(a,b,c)</TT>

in an array context and the scalar value <TT>0</TT> in a scalar

context:

<BLOCKQUOTE>

<PRE>

wantarray ? (a, b, c) : 0;

</PRE>

</BLOCKQUOTE>

<P>

The following example subroutine returns a value but is not passed

any values:

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl -w

# Example of subroutine which does not use external values but does return a

value

$scalar-return = &amp;egsub2; # Call the subroutine once, returning a scalar value

print &quot;Scalar return value: $scalar-return.\n&quot;;

@array-return = &amp;egsub2; # Call the subroutine a second time, returning an array

value

print &quot;Array return value:&quot;, @array-return, &quot;.\n&quot;;

sub egsub2 {

     print &quot;This subroutine prints this line and returns a value.\n&quot;;

     wantarray ? (a, b, c) : 0;

}

</PRE>

</BLOCKQUOTE>

<P>

You can return from a subroutine before the last statement by

using the <TT>return()</TT> function. The argument to the <TT>return</TT>

function is the returned value, in this case. The use of <TT>return()</TT>

is illustrated in the following example (which is not a very efficient

way to do the test but illustrates the point):

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl -w

# Example of subroutine which does not use external values but does return a

value using &quot;return&quot;

$returnval = &amp;egsub3; # Call the subroutine once

print &quot;The current time is $returnval.\n&quot;;

sub egsub3 {

     print &quot;This subroutine prints this line and returns a value.\n&quot;;

     local($sec, $min, $hour, @rest) =

          gmtime(time);

     ($min == 0) &amp;&amp; ($hour == 12) &amp;&amp; (return &quot;noon&quot;);

if ($hour &gt; 12) {

          return &quot;after noon&quot;;

      }

     else {

          return &quot;before noon&quot;;

      }

</PRE>

</BLOCKQUOTE>

<P>

Notice that any variables used within a subroutine usually are

made <TT>local()</TT> to the enclosing block, so that they do

not interfere with any variables in the calling program that have

the same name. In Perl 5.0, you can make these variables lexically

local rather than dynamically local by using <TT>my()</TT> instead

of <TT>local()</TT>. (This procedure is discussed in more detail

later in this chapter, in &quot;Issues of Scope with <TT>my()</TT>

and <TT>local()</TT>.&quot;)

<P>

When multiple arrays are returned, the result is flattened into

one list so that effectively, only one array is returned. In the

following example, all the return values are in <TT>@return-a1</TT>,

and the send array, <TT>@return-a2</TT>, is empty.

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl -w

# Example of subroutine which does not use external values returning an array

(@return-a1, @return-a2) = &amp;egsub4; # Call the subroutine once

print &quot;Return array a1&quot;,@return-a1,&quot; Return array a2 &quot;,@return-a2, &quot;.\n&quot;;

sub egsub4 {

     print &quot;This subroutine returns a1 and a2.\n&quot;;

     local(@a1) = (a, b, c);

     local(@a2) = (d, e, f);

     return(@a1,@a2);

}

</PRE>

</BLOCKQUOTE>

<P>

In Perl 4.0, you can avert this problem by passing the arrays

by reference, using a typeglob (see the following section). In

Perl 5.0, you can do the same thing and also manipulate any variable

by direct reference (see the following section).

<H3><A NAME="HowtoPassValuestoSubroutines">

How to Pass Values to Subroutines</A></H3>

<P>

The next important aspect of subroutines is the fact that the

call can pass values to the subroutine. The call simply lists

the variables to be passed, which are passed in the list <TT>@_</TT>

to the subroutine. These variables are known as the parameters

or the arguments. It is customary to assign a name to each value

at the start of the subroutine, so that it is clear what is going

on. Manipulating these copies of the arguments is equivalent to

passing arguments by value (for example, their values may be altered,

but this alteration does not alter the value of the variable in

the calling program).

<P>

The following example illustrates how to pass parameters to a

subroutine by value:

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl -w

# Example of subroutine is passed external values by value

$returnval = &amp;egsub5(45,3); # Call the subroutine once

print &quot;The (45+1) * (3+1) is $returnval.\n&quot;;

$x = 45;

$y = 3;

$returnval = &amp;egsub5($x,$y);

print &quot;The ($x+1) * ($y+1) is $returnval.\n&quot;;

print &quot;Note that \$x still is $x, and \$y still is $y.\n&quot;;

sub egsub5 { # Access $x and $y by value

     local($x, $y) = @_;

     return (++$x * ++$y);

}

</PRE>

</BLOCKQUOTE>

<P>

To pass scalar values by reference rather than by value, you can

access the elements in <TT>@_</TT> directly, which will change

their values in the calling program. In such a case, the argument

must be a variable rather than a literal value, because literal

values cannot be altered.

<P>

The following example illustrates passing parameters by reference

to a subroutine:

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl -w

# Example of subroutine is passed external values by reference

$x = 45;

$y = 3;

print &quot;The ($x+1) * ($y+1) &quot;;

$returnval = &amp;egsub6($x,$y);

print &quot;is $returnval.\n&quot;;

print &quot;Note that \$x now is $x, and \$y now is $y.\n&quot;;

sub egsub6 { # Access $x and $y by reference

     return (++$_[0] * ++$_[1]);

}

</PRE>

</BLOCKQUOTE>

<P>

You can pass array values by reference in the same way; however,

several restrictions apply. First, as is true of returned array

values, the <TT>@_</TT> list is one single flat array, so passing

multiple arrays in this way is tricky. Also, you can use this

method to alter individual elements of the subroutine; you cannot

alter the size of the array within the subroutine, so you cannot

use <TT>push()</TT> and <TT>pop()</TT>.

<P>

Therefore, another method has been provided to facilitate the

passing of arrays by reference. This method, known as <I>typeglobbing</I>,

works with Perl 4.0 or Perl 5.0. The principle is that the subroutine

declares that one or more of its parameters are typeglobbed, which

means that all the references to that identifier in the scope

of the subroutine are taken to refer to the equivalent identifier

in the namespace of the calling program.

<P>

The syntax for this declaration prefixes the identifier with an

asterisk (<TT>*</TT>) rather than an at sign (@), as in <TT>*array1</TT>

typeglobs<TT> @array1</TT>. In fact, typeglobbing links all forms

of the identifier, so the <TT>*array1</TT> typeglobs <TT>@array1,

%array1</TT>, and <TT>$array1</TT>. (Any reference to any of these

variables in the local subroutine actually refers to the equivalent

variable in the calling program's namespace.) Using this construct

within a <TT>local()</TT> list makes sense, because it effectively

creates a local alias for a set of global variables. The following

example illustrates the use of typeglobbing:

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl -w

# Example of subroutine using arrays passed by reference (type globbing)

&amp;egsub7(@a1,@a2); # Call the subroutine once

print &quot;Modified array a1&quot;,@a1,&quot; Modified array a2 &quot;,@a2, &quot;.\n&quot;;

sub egsub7 {

     local(*arr1,*arr2) = @_;

     print &quot;This subroutine modifies arr1 and arr2&quot;;

     print &quot; and thus a1 and a2 via typeglobbing.\n&quot;;

     @arr1 = (a, b, c);

     @arr2 = (d, e, f);

}

</PRE>

</BLOCKQUOTE>

<P>

In Perl 4.0, this method is the only way to use references to

variables rather than variables themselves. Perl 5.0 also has

a generalized method for dealing with references. Although this

method looks more awkward in its syntax (because of the abundance

of underscores), it actually is more precise in its meaning. Typeglobbing

automatically aliases the scalar, the array, and the hashed array

form of an identifier, even if only the array name is required.

With Perl 5.0 references, you can make this distinction explicit;

only the array form of the identifier is referenced.

<P>

The following example illustrates how to pass arrays by reference

in Perl 5.0:

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl -w

# Example of subroutine using arrays passed by reference (Perl 5 references)

&amp;egsub7(\@a1,\@a2); # Call the subroutine once

print &quot;Modified array a1&quot;,@a1,&quot; Modified array a2 &quot;,@a2, &quot;.\n&quot;;

sub egsub7 {

     local($a1ref,$a2ref) = @_;

     print &quot;This subroutine modifies a1 and a2.\n&quot;;

     @$a1ref = (a, b, c);

     @$a2ref = (d, e, f);

}

</PRE>

</BLOCKQUOTE>

<H3><A NAME="SubroutineRecursion">

Subroutine Recursion</A></H3>

<P>

One the most powerful features of subroutines is their capability

to call themselves. Many problems can be solved by repeated application

of the same procedure. You must take care to set up a termination

condition wherein the recursion stops and the execution can unravel

itself. Typical examples of this approach occur in list processing:

Process the head item and then process the tail; if the tail is

empty, do not recurse. Another neat example is the calculation

of a factorial value, as follows:

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl -w

#

# Example factorial using recursion



for ($x=1; $x&lt;100; $x++) {

        print &quot;Factorial $x is &quot;,&amp;factorial($x), &quot;\n&quot;;

}



sub factorial {

        local($x) = @_;

        if ($x == 1) {

                return 1;

        }

        else {

                return ($x*($x-1) + &amp;factorial($x-1));

        }

}

</PRE>

</BLOCKQUOTE>

<H3><A NAME="SubroutinePrototypes">

Subroutine Prototypes</A></H3>

<P>

Perl 5.002 introduces the capability to declare limited forms

of subroutine prototypes. This capability allows early detection

of errors in the number and type of parameters and generation

of suitable warnings. This is primarily to allow the declaration

of replacement subroutines for built-in commands. To use the stricter

parameter checking, however, you must make the subroutine call

by using only the subroutine name (without the <TT>&amp;</TT>

prefix). The prototype declaration syntax is concise and not as

strict as the named formal parameters mechanism is in languages

such as Pascal.

<P>

The main use for these prototypes at present is in writing modules

for wider use, allowing the modules to specify their parameter

types so as to trap errors and print diagnostic messages. Therefore,

this chapter does not discuss this mechanism in detail.

<H3><A NAME="IssuesofScopewithImyIandIlocalI">

Issues of Scope with <I>my()</I> and <I>local()</I></A></H3>

<P>

<A HREF="ch1.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch1.htm" >Chapter 1</A> &quot;Perl Overview,&quot; alluded to some issues related

to scope. These issues are very important with relation to subroutines.

In particular, all variables inside subroutines should be made

lexical local variables (via <TT>my()</TT>) or dynamic local variables

(via <TT>local()</TT>). In Perl 4.0, the only choice is <TT>local()</TT>,

because <TT>my()</TT> was introduced in Perl 5.0.

<P>

Variables declared with the <TT>my()</TT> construct are considered

to be lexical local variables. These variables are not entered

in the symbol table for the current package; therefore, they are

totally hidden from all contexts other than the local block within

which they are declared. Even subroutines called from the current

block cannot access lexical local variables in that block.Lexical

local variables must begin with an alphanumeric character (or

an underscore).

<P>

Variables declared by means of the <TT>local()</TT> construct

are considered to be dynamic local variables. The value is local

to the current block and any calls from that block. You can localize

special variables as dynamic local variables, but you cannot make

them into lexical local variables. These two differences from

lexical local variables show the two cases in Perl 5.0 in which

it is still advisable to use <TT>local()</TT> rather than <TT>my()</TT>:

<UL>

<LI>Use <TT>local()</TT> if you want the value of the local variables

to be visible to subroutines.

<LI>Use <TT>local()</TT> if you are localizing special variables.

</UL>

<P>

In general, you should be using <TT>my</TT> instead of <TT>local</TT>,

because it's faster and safer. Exceptions to this rule include

the global punctuation variables, file handles and formats, and

direct manipulation of the Perl symbol table itself. Format variables

often use <TT>local</TT>, though, as do other variables whose

current value must be visible to called subroutines.

<H2><A NAME="PerlLibraries"><FONT SIZE=5 COLOR=#FF0000>

Perl Libraries</FONT></A></H2>

<P>

The Perl 4.036 standard library has 31 files. These files have

been replaced in Perl 5.0 by a set of standard modules (see the

following section). This section describes the older system of

libraries based on <TT>require()</TT>. The package mechanism by

itself merely provides a way of segmenting the namespace into

units. When this mechanism is combined with suites of subroutines

stored in a file that can be included by means of <TT>require()</TT>,

a library is created.

<H3><A NAME="CreationofLibraries">

Creation of Libraries</A></H3>

<P>

A <I>library</I> is effectively a collection of subroutines in

a package. Setting up a file as a library file is a fairly straightforward

process. Place the subroutines in a separate file, and add a package

declaration to the top of the file. The file name of the library

file and the package name should be the same. Then add the line

<BLOCKQUOTE>

<PRE>

1;

</PRE>

</BLOCKQUOTE>

<P>

to the end of the file (so that it returns <TT>TRUE</TT> when

included by the <TT>require()</TT> function). If you want any

of the subroutines to be in the global namespace automatically,

change the name of the subroutine to explicitly name the main

package (for example, <TT>main'mysub</TT>).

<P>

The following example illustrates how to declare a Perl 4.0 library

with a single subroutine, <TT>filtest</TT>:

<BLOCKQUOTE>

<PRE>

 # Sample library file (Perl 4)

package filtest;

sub main'filtest {

     local($fil) = @_;

     -f $fil &amp;&amp; print &quot;File $fil is a normal file.\n&quot;;

     -d _ &amp;&amp; print &quot;File $fil is a directory.\n&quot;;

}

1;

</PRE>

</BLOCKQUOTE>

<P>

In Perl 5.0, the new form <TT>main::mysub</TT> is preferred to

<TT>main'mysub</TT> for specifying the package name explicitly,

but in Perl 5.0 you should consider making a module rather than

a library.

<H3><A NAME="InvocationofLibraries">

Invocation of Libraries</A></H3>

<P>

To use a library, you simply use <TT>require()</TT> to refer to

the library name. Perl searches for all directories specified

in the <TT>@INC</TT> special variable when it tries to locate

this file. To include the sample library file specified in the

preceding section, use the following code:

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl -w

#

require &quot;filtest&quot;;

&amp;filtest(&quot;/usr/bin&quot;);

&amp;filtest(&quot;/usr/etc/passwd&quot;);

</PRE>

</BLOCKQUOTE>

<H3><A NAME="StandardPerlLibrary">

Standard Perl 4.0 Library</A></H3>

<P>

Following are the files in the standard Perl 4.036 library, which

have been superseded by Perl 5.0 modules:<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=40%>

<TR VALIGN=TOP><TD WIDTH=151>abbrev.pl</TD><TD WIDTH=150>getcwd.pl</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151>assert.pl</TD><TD WIDTH=150>getopt.pl</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151>bigfloat.pl</TD><TD WIDTH=150>getopts.pl</TD>

</TR>

<TR VALIGN=TOP><TD WIDTH=151>bigint.pl</TD><TD WIDTH=150>importenv.pl</TD>

</TR>

<TR VALIGN=TOP><TD WIDTH=151>bigrat.pl</TD><TD WIDTH=150>look.pl</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151>cacheout.pl</TD><TD WIDTH=150>newgetopt.pl</TD>

</TR>

<TR VALIGN=TOP><TD WIDTH=151>chat2.pl</TD><TD WIDTH=150>open2.pl</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151>complete.pl</TD><TD WIDTH=150>perldb.pl</TD>

</TR>

<TR VALIGN=TOP><TD WIDTH=151>ctime.pl</TD><TD WIDTH=150>pwd.pl</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151>dumpvar.pl</TD><TD WIDTH=150>shellwords.pl</TD>

</TR>

<TR VALIGN=TOP><TD WIDTH=151>exceptions.pl</TD><TD WIDTH=150>stat.pl</TD>

</TR>

<TR VALIGN=TOP><TD WIDTH=151>fastcwd.pl</TD><TD WIDTH=150>syslog.pl</TD>

</TR>

<TR VALIGN=TOP><TD WIDTH=151>find.pl</TD><TD WIDTH=150>termcap.pl</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151>finddepth.pl</TD><TD WIDTH=150>timelocal.pl

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=151>flush.pl</TD><TD WIDTH=150>validate.pl</TD>

</TR>

</TABLE></CENTER>

<P>

<H2><A NAME="ModulesPerl"><FONT SIZE=5 COLOR=#FF0000>

Modules (Perl 5.0)</FONT></A></H2>

<P>

Perl 5.0 has a new structure for managing code that is designed

for reuse. Modules have many more features than the package-based

library in Perl 4.0, which simply provides a means of segmenting

the namespace into packages.

<P>

You can create a Perl 5.0 module in two main conceptual ways.

One way is to use the basic concept of a collection of subroutines,

with added features that help control which subroutines are compulsory

and which are optional. The other way is to use the new object-oriented

facilities of Perl 5.0 to make a module become a definition of

class, so that instances of that class implicitly call subroutines

(methods) in the library. You can mix these two basic approaches

to produce hybrid modules.

<P>

The object-oriented features expand the idea of a package to incorporate

the idea of a class. Special subroutines act as constructors and

destructors, creating objects that are members of the class and

deleting the objects when the last reference to the object is

gone. Other subroutines provide other ways of manipulating objects

of that class. So a package can be simply a package, or it can

be a class if it provides the associated subroutines to act as

methods for the class objects. When you use the special <TT>@ISA</TT>

array, one package class can inherit methods from another package

class. The methods are simply subroutines written to deal with

objects in the class.

<P>

Explaining the conceptual background of object-oriented programming

is beyond the scope of this book, but these concepts need to be

mentioned so as to put the descriptions of the standard modules

in context, because many of them use these features.

<H3><A NAME="StandardModuleList">

Standard Module List</A></H3>

<P>

This section lists the standard modules and pragmatic modules

(<I>Pragmas</I>) in Perl 5.002. All these modules should be located

in the Perl library path (<TT>@INC</TT>), should have the extension

.PM, and should include their own documentation. Pragmas do not

contain subroutines or classes, but act as compile-time directives

through side effects that occur when they are referenced.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

Many other modules exist. See Appendix B, &quot;Perl Web Reference,&quot; for information on other nonstandard Perl modules</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<P>

Some Perl modules are developed in C rather than in Perl. These

modules are called <I>extension modules</I>. Because of the problems

involved in ensuring that these modules work under all operating

systems, they are not as well standardized as the standard modules

listed in the following table.<BR>



<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD WIDTH=181><B>Module Name</B></TD><TD WIDTH=409><B>Description</B>

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>AnyDBM_File</TT></TD><TD WIDTH=409>Provides access to external databases

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>AutoLoader</TT></TD><TD WIDTH=409>Special way of loading subroutines on demand

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>AutoSplit</TT></TD><TD WIDTH=409>Special way to set up modules for the use of <TT>AutoLoader</TT>

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>Benchmark</TT></TD><TD WIDTH=409>Time code for benchmarking

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>Carp</TT></TD><TD WIDTH=409>Reports errors across modules

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>Config</TT></TD><TD WIDTH=409>Reports compiler options used when Perl was installed

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>Cwd</TT></TD><TD WIDTH=409>Functions to manipulate current directory

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>DB_File</TT></TD><TD WIDTH=409>Provides access to Berkeley DB files

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>Devel::SelfStubber</TT></TD><TD WIDTH=409>Allows correct inheritance of autoloaded methods

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>diagnostics</TT></TD><TD WIDTH=409>Pragma enables diagnostic warnings

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>DynaLoader</TT></TD><TD WIDTH=409>Used by modules that link to C libraries

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>English</TT></TD><TD WIDTH=409>Pragma allows the use of long special variable names

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>Env</TT></TD><TD WIDTH=409>Allows access to environment variables

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>Exporter</TT></TD><TD WIDTH=409>Standard way for modules to export subroutines

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>ExtUtils::Liblist</TT></TD><TD WIDTH=409>Examines C libraries

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>ExtUtils::MakeMaker</TT></TD><TD WIDTH=409>Creates makefiles for extension modules

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>ExtUtils::Manifest</TT></TD><TD WIDTH=409>Helps maintain a MANIFEST file

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>ExtUtils::Miniperl</TT></TD><TD WIDTH=409>Used by makefiles generated by <TT>ExtUtils::MakeMaker</TT>

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>ExtUtils::Mkbootstrap</TT></TD><TD WIDTH=409>Used by makefiles generated by <TT>ExtUtils::MakeMaker</TT>

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>Fcntl</TT></TD><TD WIDTH=409>Provides access to C <TT>fcntl.h</TT>

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>File::Basename</TT></TD><TD WIDTH=409>Parses file names according to various operating systems' rules

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>File::CheckTree</TT></TD><TD WIDTH=409>Performs multiple file tests

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>File::Find</TT></TD><TD WIDTH=409>Finds files according to criteria

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>File::Path</TT></TD><TD WIDTH=409>Creates/deletes directories

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>FileHandle</TT></TD><TD WIDTH=409>Allows object syntax for file handles

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>Getopt::Long</TT></TD><TD WIDTH=409>Allows POSIX-style command-line options

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>Getopt::Std</TT></TD><TD WIDTH=409>Allows single-letter command-line options

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>I18N::Collate</TT></TD><TD WIDTH=409>Allows POSIX locale rules for sorting 8-bit strings

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>integer</TT></TD><TD WIDTH=409>Pragma uses integer arithmetic

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>IPC::Open2</TT></TD><TD WIDTH=409>Inter Process Communications (process with read/write)

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>IPC::Open3</TT></TD><TD WIDTH=409>Inter Process Communications (process with read/write/error)

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>less</TT></TD><TD WIDTH=409>Pragma unimplemented

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>Net::Ping</TT></TD><TD WIDTH=409>Tests network node

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>overload</TT></TD><TD WIDTH=409>Allows overloading of operators (for example, special behavior, depending on object type)

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>POSIX</TT></TD><TD WIDTH=409>Allows POSIX standard identifiers

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>Safe</TT></TD><TD WIDTH=409>Can evaluate Perl code in safe memory compartments

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>SelfLoader</TT></TD><TD WIDTH=409>Allows specification of code to be autoloaded in module (alternative to the <TT>AutoLoader</TT> procedure)

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>sigtrap</TT></TD><TD WIDTH=409>Pragma initializes some signal handlers

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>Socket</TT></TD><TD WIDTH=409>Provides access to C <TT>socket.h</TT>

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>strict</TT></TD><TD WIDTH=409>Pragma forces safe code

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>subs</TT></TD><TD WIDTH=409>Pragma predeclares specified subroutine names

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>Text::Abbrev</TT></TD><TD WIDTH=409>Creates abbreviation table

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=181><TT>Test::Harness</TT></TD><TD WIDTH=409>Runs the standard Perl tests

</TD></TR>

</TABLE></CENTER>

<P>

<H3><A NAME="HowtoCreateaSimpleModule">

How to Create a Simple Module</A></H3>

<P>

Creating a module that is made up of a series of subroutines,

in place of an old-style Perllibrary, is relatively simple. It

is slightly more complicated to create the other style of module-which

is made up completely of methods associated with an object class-if

only because you need to understand the object-oriented approach

better. Even the simpler style of modules use one of the object-oriented

features. Every module should use an <TT>import()</TT> method

inherited from the <TT>Exporter</TT> class or define its own <TT>import()</TT>

method.

<P>

The following example converts the example library used earlier

in this chapter (in &quot;Creation of Libraries&quot;) to a module:

<BLOCKQUOTE>

<PRE>

package FilTest;



=head1 NAME



FilTest - test a file printing status



=head1 SYNOPSYS



     use FilTest;

     filtest1(&quot;/tmp/file&quot;);



     use FilTest qw(filtest2);

     filtest2(&quot;/tmp/file&quot;);



=head1 DESCRIPTION



This is an example module which provides one subroutine which tests a file. 

filtest1() is exported by default, filtest2() must be explicitly imported.



=cut



# Sample module



require Exporter;

@ISA = qw(Exporter);



@EXPORT = (filtest1);

@EXPORT_OK = qw(filtest2);



sub filtest1 {

     my($fil) = @_;

     -f $fil &amp;&amp; print &quot;File $fil is a normal file.\n&quot;;

     -d _ &amp;&amp; print &quot;File $fil is a directory.\n&quot;;

}

sub filtest2 {

     my($fil) = @_;

     -f $fil &amp;&amp; print &quot;File $fil is a normal file.\n&quot;;

     -d _ &amp;&amp; print &quot;File $fil is a directory.\n&quot;;

}

1;

</PRE>

</BLOCKQUOTE>

<P>

The documentation for modules normally is built into the .PM file

in POD format (as illustrated by the bare-bones documentation

in the preceding example, from the first <TT>=head1</TT> to the

<TT>=cut</TT>) but is not necessary for the module to work.

<P>

The module specifies that it is prepared to have the <TT>filtest2()</TT>

subroutine imported by those who use the module, but because it

is in the <TT>@EXPORT_OK</TT> list rather than the <TT>@EXPORT</TT>

list, it will not be exported by default, but must be explicitly

included. However, <TT>filtest1()</TT> is exported by default.

<H3><A NAME="ModuleUseandInvocation">

Module Use and Invocation</A></H3>

<P>

The standard way to include a module is with the <TT>use()</TT>

function. Later, you can disable the effect of pragmatic functions

(Pragmas) that act as compiler directives by using the <TT>no()</TT>

syntax. The following example enables the use of the integer pragma

and then disables it:

<BLOCKQUOTE>

<PRE>

use integer;

....

no integer;

</PRE>

</BLOCKQUOTE>

<P>

Normal modules import symbols into the current package or provide

access to symbols in the module. If you do not specify any arguments

after the module name, the default behavior is to import all symbols

specified in the module as <TT>EXPORT</TT>. If you specify the

null list as an argument, no symbols are imported. The following

paragraphs describe the various ways to import from the sample

module.

<P>

The following defines <TT>filtest1()</TT> in the global namespace:

<BLOCKQUOTE>

<PRE>

use FilTest;

filtest1(&quot;/etc/passwd&quot;);

</PRE>

</BLOCKQUOTE>

<P>

The following explicitly asks to use <TT>filtest2()</TT> as well:

<BLOCKQUOTE>

<PRE>

use FilTest qw(filtest2);

filtest1(&quot;/etc/passwd&quot;);

filtest2(&quot;/etc/passwd&quot;);

</PRE>

</BLOCKQUOTE>

<P>

The following imports neither subroutine name to the current namespace:

<BLOCKQUOTE>

<PRE>

use FilTest ();

</PRE>

</BLOCKQUOTE>

<P>

Even when the null list is used to avoid importing any names,

the subroutines in the module are still accessible via an explicit

reference to the <TT>FilTest</TT> package in the subroutine name.

 The following example illustrates how to access the subroutines

directly:

<BLOCKQUOTE>

<PRE>

use FilTest ();

FilTest::filtest1(&quot;/etc/passwd&quot;);

FilTest::filtest2(&quot;/etc/passwd&quot;);

</PRE>

</BLOCKQUOTE>

<H2><A NAME="FromHere"><FONT SIZE=5 COLOR=#FF0000>

From Here   </FONT></A></H2>

<P>

This chapter forms one part of the reference section of this book.

The chapter attempts to describe all the features of the language

in a way that can serve as an easy reference. You can see the

other reference chapters as forming one unit with this chapter.

You also may want to refer to the portion of Appendix B, &quot;Perl

Web Reference,&quot; that deals with other nonstandard Perl modules-in

particular, the CGI module.

<P>

The other chapters that comprise the reference section are:

<UL>

<LI><A HREF="ch13.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch13.htm" >Chapter 13</A>, &quot;Special Variables,&quot; provides detailed

descriptions of the Perl special variables.

<LI><A HREF="ch14.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch14.htm" >Chapter 14</A>, &quot;Operators,&quot; provides detailed descriptions

of the Perl operators.

<LI><A HREF="ch15.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch15.htm" >Chapter 15</A>, &quot;Function List,&quot; provides detailed descriptions

of the Perl functions.

</UL>

<HR>



<CENTER><P><A HREF="ch15.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch15.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="index.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="ch17.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch17.htm"><IMG SRC="nc.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<HR WIDTH="100%"></P></CENTER>

</BODY>

</HTML>

