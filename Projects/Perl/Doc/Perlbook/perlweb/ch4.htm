<HTML>

<HEAD>

<TITLE>Chapter 4 -- Advanced Page Output</TITLE>



<META>

</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">

<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;4</FONT></H1>

<H1><FONT SIZE=6 COLOR=#FF0000>Advanced Page Output</FONT></H1>

<P>

<I><B>by David Harlan</B></I>

<HR>

<P>

<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>

<UL>

<LI><A HREF="#ParsingtheDBMFileandPrintingPages">

Parsing the DBM File and Printing Pages</A>

<UL>

<LI><A HREF="#PrintingaStandardPage">

Printing a Standard Page</A>

<LI><A HREF="#PrintingUserDesignedPages">

Printing User-Designed Pages</A>

</UL>

<LI><A HREF="#ReturningDatatoaFormforFurtherRevision">

Returning Data to a Form for Further Revision</A>

<UL>

<LI><A HREF="#FillinginTextFieldsandSelectingListItems">

Filling in Text Fields and Selecting List Items</A>

<LI><A HREF="#SavingandEditingUserDesignedPages">

Saving and Editing User-Designed Pages</A>

</UL>

<LI><A HREF="#FromHere">

From Here   </A>

</UL>



<HR>

<P>

You may have sensed that something important was missing from

the preceding chapter, which explained in detail how to get and

save data but did not explain how to get that information from

your data files back to an HTML page. This chapter fills in those

gaps.

<H2><A NAME="ParsingtheDBMFileandPrintingPages"><FONT SIZE=5 COLOR=#FF0000>

Parsing the DBM File and Printing Pages</FONT></A></H2>

<P>

Saving your experiment data as you did in <A HREF="ch3.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch3.htm" >Chapter 3</A>is all well

and good, but without a suitable output method, all that data

is useless. You certainly don't want to waste all the work that

you just finished. This section discusses some good ways to use

the data that you're gathering from those scripts and forms.

<H3><A NAME="PrintingaStandardPage">

Printing a Standard Page</A></H3>

<P>

The most obvious thing that you can to do with the experiment

data is print an up-to-date summary of a user's data after that

user enters a new weekly data set. The result might look something

like figure 4.1.

<P>

<A HREF="f4-1.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/f4-1.gif"><B> Figure 4.1 : </B><I>The user can view a summary of his or her survey data in this format.



</I></A><P>

<P>

This page is fairly simple. The first thing that you see is a

simple thank-you/introduction line; then you see a table that

shows all the data to date for the user. The script that creates

this page, shown in Listing 4.1, is correspondingly simple.

<HR>

<BLOCKQUOTE>

<B>Listing 4.1&nbsp;&nbsp;Script to Print a Summary of User-Survey

Data (PRINTDATA1.PL)<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl

require &quot;process_cgi.pl&quot;;



$period[1]=&quot;Aug 5-11&quot;;

$period[2]=&quot;Aug 12-18&quot;;

$period[3]=&quot;Aug 19-25&quot;;

$period[4]=&quot;Aug 26-Sep 1&quot;;

$period[5]=&quot;Sep 1-7&quot;;

$period[6]=&quot;Sep 8-14&quot;;

$period[7]=&quot;Sep 15-21&quot;;

$period[8]=&quot;Sep 22-28&quot;;



$email=&amp;path_info;



&amp;print_header;

print &quot;&lt;title&gt;Web Use for $email&lt;/title&gt;\n&quot;;

print '&lt;body bgcolor=&quot;#FFFFFF&quot;&gt;';

print &quot;Following is the up-to-date web use survey data for $email. Thank you for

   your continued support. See you in another week or so.&lt;p&gt;\n&quot;;

print &quot;&lt;table border=1&gt;&lt;tr&gt;&lt;td valign=bottom&gt;Period&lt;td&gt;Total&lt;br&gt;Hours&lt;td&gt;Web&lt;br&gt;

   Hours&lt;td&gt;Phone

   &lt;br&gt;Hours&lt;td&gt;e-mail&lt;br&gt;Sent&lt;td&gt;e-mail&lt;br&gt;Received&lt;td valign=bottom&gt;Ways Used\n\n&quot;;



for ($i=1; $i&lt;9; $i++) {

   open (data, &quot;printdatasup period$i $email |&quot;);

   $data=&lt;data&gt;;

   $data=~s/::::/::n\/a::/g;

   $data=~s/::::/::n\/a::/g;

   $data=~s/::$/::n\/a/;

   $data=~s/^::/n\/a::/;

   $data=~s/::/&lt;td&gt;/g;

   print &quot;&lt;tr&gt;&lt;td&gt;$period[$i]&lt;td&gt;&quot;,$data,&quot;\n&quot; if $data ne '';

}

print &quot;&lt;/table&gt;&quot;;

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The following paragraphs examine how <TT>printdata</TT> works.

The first two lines constitute the familiar header, common to

most of the scripts in this book, that tells the operating system

where to find the interpreter and that tells the interpreter that

you want to include some code from an outside file. The next section

of code defines an array of strings that you'll use to put labels

on the period data later in the script.

<P>

Next comes the line <TT>$email=&amp;path_info</TT>. If you read

chapters 2 and 3, you know that this statement is calling the

subroutine <TT>&amp;path_info</TT> and placing the result in the

variable <TT>$email</TT>. As you see in Listing 4.1, this program

has no <TT>path_info</TT> subroutine. I added another useful function

to PROCESS_CGI.PL. As you learned in <A HREF="ch2.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch2.htm" >Chapter 2</A> &quot;Introduction

to CGI&quot; (specifically, in Listing 2.5), the <TT>PATH_INFO</TT>

environment variable is a useful way to pass information to a

CGI script. I use this method with some frequency, so I decided

that the code that gets this variable was a good candidate to

reside in PROCESS_CGI.PL. As Listing 4.2 shows, the subroutine

is as simple as subroutines come. This code contains no new Perl.

<HR>

<BLOCKQUOTE>

<B>Listing 4.2&nbsp;&nbsp;Subroutine to Return the PATH_INFO Environment

Variable<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

sub path_info {

   $path=$ENV{'PATH_INFO'};

   $path= s/\///;

   $return=$path;

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

After assigning <TT>$ENV{'PATH_INFO'}</TT> to <TT>$path</TT>,

the script removes the leading slash. The final assignment ensures

that the appropriate information is returned to the script. This

is easy enough that you could put this code into each script that

required it, but why bother if you're going to be using the library

anyway? Write the code once, and get the information that you

need with one line of code instead of three.

<P>

In Listing 4.1, after getting the e-mail address from the <TT>&amp;path_info</TT>

subroutine, the script prints the HTTP header and the beginning

of the page, setting the page background color to white, printing

the introductory text, starting a table, and printing the first

row of the table.

<P>

The next (and most important) section of code is a loop that prints

the data that the user entered into the survey database. You may

recall from the preceding chapter that some versions of Perl are

limited to one <TT>dbmopen</TT> statement per script. Therefore,

you have to call an outside program each time you want to access

the DBM file for a new time period. <A HREF="ch3.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch3.htm" >Chapter 3</A>used the <TT>system</TT>

function for that purpose. Listing 4.1 uses a version of the <TT>open</TT>

command that you saw in <A HREF="ch2.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch2.htm" >Chapter 2</A>(refer to Listing 2.8). This

syntax calls the listed program-in this case, <TT>printdatasup</TT>-and

puts the resulting output in the file handle listed in the first

argument (<TT>data</TT>).

<P>

<TT>printdatasup</TT> is not a built-in function; you probably

have guessed that it's a Perl program that I wrote for this specific

purpose. Listing 4.3 shows the code.

<HR>

<BLOCKQUOTE>

<B>Listing 4.3&nbsp;&nbsp;Listing of printdatasup (PRINTDATASUP.PL)

<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl

dbmopen (%data, $ARGV[0], 0666);

print $data{$ARGV[1]};

</PRE>

</BLOCKQUOTE>

<HR>

<P>

This program is as straightforward as it looks; all it does is

open the DBM file provided in the first argument and then print

the data from that file that corresponds to the key provided in

the second argument. The first time through the loop, <TT>printdata</TT>

calls this command with the arguments <TT>period1</TT> and <TT>harlan@3rdplanet.com</TT>,

so <TT>printdatasup</TT> simply prints the appropriate data from

the <TT>period1</TT> DBM file. <TT>printdata</TT> then saves this

data in the variable <TT>$data</TT> (appropriately enough) for

processing later in the script. Each time through the loop, <TT>$i</TT>

is incremented, so each time through the loop, the next period's

DBM file is queried for data for the given e-mail address.

<P>

The rest of the loop processes the information in <TT>$data</TT>

before printing it. For the sake of clarity in output, I made

sure that any empty fields were replaced by <TT>n/a</TT>. The

successive <TT>s/::::/::n\/a::/g</TT> commands ensure that any

lines of data that contain several null fields in succession (such

as the last line of fig. 4.1) print with the appropriate number

of <TT>n/a</TT> fields. With only one of these substitutions,

alternating fields would be blank.

<P>

The following two lines make sure that blank fields at the beginning

or the end of the data also contain <TT>n/a</TT>. Finally, the

script substitutes <TT>&lt;td&gt;</TT> tags for the <TT>::</TT>

field delimiters in <TT>$data</TT>.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>TIP</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

Tables and other complex HTML structures sometimes cause problems when you're trying to debug a CGI program. To make this process easier, I sometimes print an <TT>&lt;xmp&gt;</TT> tag after the HTML header during the debugging phase.

</BLOCKQUOTE>

<BLOCKQUOTE>

When you run a script such as this, the HTML tags after the <TT>&lt;xmp&gt;</TT> tag are printed rather than interpreted, so you can quickly see what's going on. You can forgo this method and view the source every time, but this method is more convenient 
if you are doing extensive debugging. (Don't forget to remove the <TT>&lt;xmp&gt;</TT> tag before you put the script online.)

</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<P>

With all the processing done, the script then prints the row in

the table, beginning with the appropriate data from the <TT>@period</TT>

array, followed by the fully processed information in <TT>$data</TT>.

The conditional at the end of the line ensures that nothing will

print if <TT>$data</TT> is empty. This variable is blank for any

periods that the user did not supply data for. You can see that

even though the script checked periods one through eight, only

the first six periods have rows in the table. Data was not entered

for the final two periods of the survey, so those rows don't appear

in the table. When the loop is finished, the script simply prints

the closing table tag and exits.

<H3><A NAME="PrintingUserDesignedPages">

Printing User-Designed Pages</A></H3>

<P>

The preceding example is a good starting point for presenting

the survey data, but it's really only the beginning of what you

can do with it. You can imagine any number of ways that you may

want to view this kind of data, and perhaps your users can, too,

so give them an opportunity to see the data exactly as they want

to. Consider the form shown in figure 4.2.

<P>

<A HREF="f4-2.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/f4-2.gif"><B> Figure 4.2 : </B><I>The user uses this form to choose the data to be displayed.



</I></A><P>

<P>

As you can see, the form in figure 4.2 presents a multitude of

choices. Figure 4.3 shows the page that was produced when I submitted

the form as shown. The script that processed this form and created

the page is by far the most complex that you've seen so far in

this book.

<P>

<A HREF="f4-3.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/f4-3.gif"><B> Figure 4.3 : </B><I>The page results from the submission of the form in figure 4.2.



</I></A><P>

<P>

You must deal with many issues when you design a script such as

this to create a user-designed page. You might be tempted to use

conditionals, hard-coding the form fields into the script. This

method would work, but it would make the script large and difficult

to adapt to changes in the data. Instead, through careful form

design and the use of some interesting Perl, you can make this

script relatively short and fairly adaptable. Listing 4.4 shows

the code.

<HR>

<BLOCKQUOTE>

<B>Listing 4.4&nbsp;&nbsp;Part 1 of the printcustomdata Script

(PRINTCUSTOMDATA.PL)<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl

require &quot;process_cgi.pl&quot;;

require &quot;check_pass.pl&quot;;



@fieldorder=('hours','webhours','webhourratio','phonehours',

   'phonehourratio','sentmail','receivedmail','waysused');



@fieldtitles=('Total&lt;br&gt;Hours','Web&lt;br&gt;Hours',

   'Web Hours /&lt;br&gt;Total Hours','Phone&lt;br&gt;Hours',

   'Phone Hours /&lt;br&gt;Total Hours','E-mail&lt;br&gt;Sent',

   'E-mail&lt;br&gt;Received','Ways Used');



@graphgifs=('hoursbar.gif','webhoursbar.gif','webhourratiobar.gif',

   'phonehoursbar.gif','phonehourratiobar.gif','sentmailbar.gif',

   'receivedmailbar.gif');



@period=('',&quot;Aug 5-11&quot;,&quot;Aug 12-18&quot;,&quot;Aug 19-25&quot;,

   &quot;Aug 26-Sep 1&quot;,&quot;Sep 1-7&quot;,&quot;Sep 8-14&quot;,&quot;Sep 15-21&quot;,

   &quot;Sep 22-28&quot;);



&amp;parse_input(*fields);

&amp;print_header;

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The code shown in Listing 4.4 presents nothing new but is important

nonetheless. After requiring two outside files (you should recognize

one and should be able to guess the function of the other), the

script defines some arrays. The <TT>@fieldorder</TT> array does

exactly what its name suggests; it establishes a field order for

the data from the form. Each of the strings in the array is the

name of one of the fields in the table section of the form. Recall

that a comma-separated list of scalar data enclosed in parentheses

is the equivalent of an array. This syntax is similar to the shorthand

used in previous examples to extract array-type data from functions;

it just goes in the other direction. (The importance of the <TT>@fieldorder</TT>

array will become clear soon.)

<P>

The next two arrays establish two additional sets of string data.

Notice that the data in these arrays follows the same order as

the data in <TT>@fieldorder</TT>. Again, this is quite important,

as you soon will see. The definition of the <TT>@period</TT> array

is functionally identical to the way that this array is defined

in Listing 4.1; this method simply requires less typing. Notice

that a null string is the first element of this array. This is

necessary because Perl arrays begin at index 0, and you want your

data to start at 1.

<P>

Finally, the script parses the form input into the <TT>%fields</TT>

array and prints the page header. This section of code sets the

stage for a little fancy footwork, as you see in the following

sections.

<P>

<B>Creating Code On-the-Fly&nbsp;&nbsp;</B>The short section of

code shown in Listing 4.5 begins the actual processing of the

form. After setting <TT>$j</TT> (which will keep track of the

script's progress through the loop in the following listing),

the script defines a series of strings. You should notice that

each string (up to <TT>$graphkey</TT>) is the beginning of a Perl

statement.

<HR>

<BLOCKQUOTE>

<B>Listing 4.5&nbsp;&nbsp;Part 2 of the printcustomdata Script

(PRINTCUSTOMDATA.PL)<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

$j=0;

if (&amp;check_pass($fields{'email'},$fields{'pass'})) {



   #Begin writing our 'mini-programs'



   $printtop='print &quot;&lt;tr&gt;&lt;td&gt;Period';

   $printrow='print &quot;&lt;tr&gt;&lt;td&gt;$period[$i]';

   $printtot='print &quot;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Total&lt;/b&gt;';

   $printavg='print &quot;&lt;tr&gt;&lt;td&gt;&lt;b&gt;Average&lt;/b&gt;';

   $graph='$return=\'';

   $calchght='$return=&quot;';

   $printgraph = 'print &quot;&lt;table border=0&gt;&lt;tr&gt;';

   $graphkey='print &quot;';



   $tableit='n';

   $graphit='n';

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The comment near the top of this block in Listing 4.5 says, &quot;Begin

writing our 'mini-programs,'&quot; which is exactly what the code

in Listings 4.6, 4.7, 4.8, and 4.9 does. By the end of these sections,

the script will have created several strings that contain Perl

statements for use later in the program. Why you're doing this

will become clear soon.

<P>

Also notice that the first line of Listing 4.5 checks the subroutine

<TT>&amp;check_pass</TT> before moving on. This routine, which

resides in the file CHECK_PASS.PL, checks that the user information

submitted with the form is correct. Listing 4.6 shows the code.

<HR>

<BLOCKQUOTE>

<B>Listing 4.6&nbsp;&nbsp;A Subroutine to Check User and Password

Information </B> <B>(CHECK_PASS.PL)<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl



sub check_pass {

   $email=$_[0];

   $pass=$_[1];

   dbmopen (%users,&quot;users&quot;,0666);

   if (!defined($users{$email})) {

     print &quot;The email address you entered does not exist in our

        database. Please hit the back button on your browser,

        correct your entry and re-submit the form.&quot;;

     return 0;

   }

   else {

     $temp=$users{$email};

     dbmclose(%users);

     $temp=~/([a-zA-Z0-9]{5,10})$/;

     $actualpass=$1;

     if ($actualpass eq '') {

        print &quot;There is no password entered for this e-mail

          address. Please enter one

          &lt;a href=/userpassword.html&gt;here&lt;/a&gt;

          before you view your data.&quot;;

        return 0;

      }

     elsif ($pass ne $actualpass) {

        print &quot;The password you entered is incorrect. Please

           return to the previous screen and try again.&quot;;

        return 0;

     }

     else {

        return 1;

     }

   }

}

return 1;

</PRE>

</BLOCKQUOTE>

<HR>

<P>

CHECK_PASS.PL should look familiar; the code is nearly identical

to the section of code that performs the same function in Listing

3.8 (refer to <A HREF="ch3.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch3.htm" >Chapter 3</A> &quot;Advanced Form Processing and Data

Storage&quot;). The first difference that you should notice is

that whenever the test fails-that is, when the address does not

exist in the database, or when the password doesn't exist or doesn't

match-the subroutine returns a value of 0. When the password test

passes, the subroutine returns a value of 1. This allows you to

use the syntax <TT>if (&amp;check_pass()) {</TT> to make sure

that the user is authorized to execute the rest of the script.

<P>

You should also notice that because <TT>&amp;check_pass</TT> prints

the appropriate error message, the script doesn't need to do anything

if this test fails. In fact, the last line of <TT>printcustomdata</TT>

is the bracket that closes the block that starts at the top of

Listing 4.5. Other than initialization, nothing happens if the

<TT>&amp;check_pass</TT> test fails.

<P>

Now that the password checking is finished and the various strings

are initialized, you can move on to the meat of the program, shown

in Listing 4.7. This section of the script is the first section

of a loop over the <TT>@fieldorder</TT> array. You'll recall that

a <TT>foreach</TT> loop starts processing at the first item of

the given list or array. Because this particular loop has no scalar

variable before the array, the loop places each successive item

in the Perl special variable <TT>$_</TT>.

<HR>

<BLOCKQUOTE>

<B>Listing 4.7&nbsp;&nbsp;Part 3 of the printcustomdata Script

<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

foreach (@fieldorder) {

     $findmax .= &quot;\$max$_=\$$_ if \$$_ &gt; \$max$_;\n&quot;;

     $calctotal .= &quot;\$tot$_ += \$$_;\n&quot;;

     if (/ratio/) {

        $calcavg .= &quot;\$avg$_ = sprintf ('%.2f', \$tot$_ / \$rationum) if

           \$rationum != 0;\n&quot;;

      }

      else {

         $calcavg .= &quot;\$avg$_ = sprintf ('%.2f', \$tot$_ / \$num) if \$num != 0;\n&quot;;

      }

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The remainder of the loop occupies itself with appending appropriate

text to the various strings that were initialized in Listing 4.5.

Take a closer look at the first of those lines:

<BLOCKQUOTE>

<PRE>

$findmax .= &quot;\$max$_=\$$_ if \$$_ &gt; \$max$_;\n&quot;;

</PRE>

</BLOCKQUOTE>

<P>

What does this line do? You saw the <TT>.=</TT> assignment operator

previously; it simply appends the string on the right to the variable

on the left. What the string on the right will turn out to be

may not be entirely clear at first; I'll explain.

<P>

Because the string is enclosed in double quotes, you are asking

Perl to interpolate any variables or special escape sequences

in the string. Right off the bat, though, you want the string

to include a dollar sign before <TT>max</TT>. Putting a backslash

before the dollar sign tells Perl that you want the actual dollar

sign to be included in the string. Without the backslash, Perl

would have looked for the variable <TT>$max</TT> and, finding

nothing, replaced it with the null string.

<P>

Next comes the variable <TT>$_</TT>. Remember that this string

is interpolated, so this variable is replaced by whatever <TT>$_</TT>

contains at that point in the execution of the script.

<P>

Following the equal sign, another <TT>\$</TT> sequence tells the

interpreter that you want another dollar sign. That sequence is

followed by <TT>$_</TT> (no backslash).

<P>

You should have the idea by now. Each time through the loop, another

line is added to <TT>$findmax</TT>. At the end, the contents of

the string would look something like this:

<BLOCKQUOTE>

<PRE>

$maxhours=$hours if $hours &gt; $maxhours;

$maxwebhours=$webhours if $webhours &gt; $maxwebhours;

$maxwebhourratio=$webhourratio if $webhourratio &gt; $maxwebhourratio;

$maxphonehours=$phonehours if $phonehours &gt; $maxphonehours;

$maxphonehourratio=$phonehourratio if $phonehourratio &gt; $maxphonehourratio;

$maxsentmail=$sentmail if $sentmail &gt; $maxsentmail;

$maxreceivedmail=$receivedmail if $receivedmail &gt; $maxreceivedmail;

$maxwaysused=$waysused if $waysused &gt; $maxwaysused;

</PRE>

</BLOCKQUOTE>

<P>

You should be able to figure out what the next line does to its

variable. One line of <TT>$calctotal</TT>'s final form looks like

<TT>$tothours += $hours;</TT>. Next, a conditional provides two

options for <TT>$calcavg</TT>. As a result, two successive lines

in the final contents of <TT>$calcavg</TT> will appear as follows:

<BLOCKQUOTE>

<PRE>

$avgwebhours = sprintf ('%.2f', $totwebhourrs / $num) if $num != 0;

$avgwebhourratio = sprintf ('%.2f', $totwebhourratio / $rationum) if $rationum != 0;

</PRE>

</BLOCKQUOTE>

<P>

These statements will be executed later in the script. First,

I'll explain the two new pieces of Perl that you see in the preceding

examples.

<P>

The first new element is the <TT>+=</TT> assignment operator.

Much like the <TT>.=</TT> operator, <TT>+=</TT> is a shortcut

for a commonly performed task. In this case, <TT>$a += $b</TT>

is the functional equivalent of <TT>$a = $a + $b</TT>. Perl has

several &quot;shortcut&quot; assignment operators.

<P>

The second new element is the function <TT>sprintf</TT>, which

is used to set the average variables. This function takes a string

representing a format and a list of values. The format contains

a list of symbols and flags that tell the function how to deal

with the listed values. In this case, the format tells the script

to print the first value in the list as a floating-point number

rounded to two decimal places. 

<P>

The next section of code from <TT>printcustomdata</TT>, shown

in Listing 4.8, builds the actual statements that print the table

shown in figure 4.3. The initial conditional ensures that the

script will print data only for those fields that the user requested

on the form. Remember that <TT>@fieldorder</TT> contains the exact

names of the fields from the table section of the form shown in

figure 4.2.

<HR>

<BLOCKQUOTE>

<B>Listing 4.8&nbsp;&nbsp;Part 4 of the printcustomdata Script

<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

if ($fields{$_} eq 'y') {

        $tableit='y';

        $printtop .= &quot;&lt;td&gt;$fieldtitles[$j]&quot;;

        $printrow .= &quot;&lt;td&gt;\$$_&quot;;

        $printavg .= &quot;&lt;td&gt;\$avg$_&quot;;

        if (/ratio/) {

          $printtot .= &quot;&lt;td&gt;&quot;;

        }

        else {

          $printtot .= &quot;&lt;td&gt;\$tot$_&quot;;

        }

     }

</PRE>

</BLOCKQUOTE>

<HR>

<P>

Each time through the loop, <TT>$_</TT> contains one of these

key fields. By checking to see whether <TT>$fields{$_}</TT> is

<TT>y</TT>, the script is checking to see whether the user wanted

that particular field in his table. After the loop finishes, <TT>$printrow</TT>

contains the following:

<BLOCKQUOTE>

<PRE>

print &quot;&lt;tr&gt;&lt;td&gt;$period[$i]&lt;td&gt;$hours&lt;td&gt;$webhours&lt;td&gt;$webhourratio&lt;td&gt;$sentmail

   &lt;td&gt;$receivedmail;

</PRE>

</BLOCKQUOTE>

<P>

The purpose of this line should be clear: it prints one row of

the table shown in figure 4.3. The line does not contain the variables

<TT>$phonehours, $phonehourratio</TT>, and <TT>$waysused</TT>,

because they were not checked on the form (the user didn't want

them to be included in the resulting table).

<P>

<TT>$printtop, $printavg</TT>, and <TT>$printtot</TT> end up containing

similar data. The major difference is that because a total would

make no sense for a ratio, the conditional <TT>if (/ratio/) {</TT>

is used to make the appropriate adjustments. If this conditional

is <TT>true</TT>, the script appends the appropriate code to <TT>$printot</TT>

so that it prints an empty table cell; otherwise, text is appended

that puts the appropriate variable in the next cell.

<P>

The final section of the <TT>foreach(@fieldorder)</TT> loop shown

in Listing 4.9 prepares the statements that print the graph that

the user designed. These statements are somewhat more complex

than the ones in the preceding section.

<HR>

<BLOCKQUOTE>

<B>Listing 4.9&nbsp;&nbsp;Part 5 of the printcustomdata Script

<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

if ($fields{&quot;gr$_&quot;} eq 'y') {

        $graphit='y';

        $graph .= &quot;\$gr${_}['.\&quot;\$i\&quot;.']=\&quot;&lt;td valign=bottom&gt;&lt;img src=\/bars\/

          ${_}bar.gif width=15 height=\$${_}hght['.\&quot;\$i\&quot;.'] &gt;\&quot;;&quot;;

        $calchght .= &quot;if (\\\$max${_} != 0) {\\\$${_}hght[\$i] = int((\$$_

          / \\\$max${_})*200);} else {\\\$${_}hght[\$i] = 0;}\n&quot;;

        $printgraph .= &quot;\$gr${_}[\$i]\n&quot;;

        $graphkey .= &quot;&lt;tr&gt;&lt;td align=right&gt;$fieldtitles[$j]=&lt;td&gt;

          &lt;img src=\\\&quot;\/bars\/$graphgifs[$j]\\\&quot;&gt;&quot;;

     }

     $j++;

   }

</PRE>

</BLOCKQUOTE>

<HR>

<P>

Like the code shown in Listing 4.8, Listing 4.9 first determines

whether the user wants to display a given piece of data in the

graph. This is where careful form design comes into play. When

I created this form, I made sure to name the check boxes for the

graph portion of the form identically to those in the table portion,

but I appended <TT>gr</TT> to the beginning of each name. By doing

this, I have to loop through only 8 values, rather than 15.

<P>

The opening conditional in Listing 4.8 checks to see whether <TT>$fields{&quot;gr$_&quot;}</TT>

is equal to <TT>y</TT>. If so, the user wants that data to be

used in the graph. The first time through the loop, <TT>$fields{&quot;grhours&quot;}</TT>

would be checked. Because <TT>grhours</TT> is a piece of data

that the user indicated on the form that he wanted to see on the

graph, <TT>$fields{&quot;grhours&quot;}</TT> does indeed equal

<TT>y</TT>, and we execute the block of statements.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>TIP</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

Form design is a key step in the creation of a CGI application that programmers often overlook. If you are working with a form that has poorly named variables or strange values for check boxes or menu items, writing the program is more difficult. I 
recommend that you spend significant time getting the form right before you get too deep into your programming; you'll save time in the long run. Also, it frequently makes more sense to change the form than to go through some programming magic to make the 
form do what you need it to do.</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<P>

The first thing that this block does is set <TT>$graphit</TT>

to <TT>y</TT>. This variable tells later code that the script

has at least one graph element. Then you reach what has to be

one of the ugliest statements I've ever written in Perl:

<BLOCKQUOTE>

<PRE>

$graph .= &quot;\$gr${_}['.\&quot;\$i\&quot;.']=\&quot;&lt;td valign=bottom&gt;&lt;img src=\/bars\/${_}bar.gif width=15

height=\$${_}hght['.\&quot;\$i\&quot;.'] &gt;\&quot;;&quot;;

</PRE>

</BLOCKQUOTE>

<P>

To make this statement a little easier to understand, examine

what <TT>$graph</TT> will contain after the first time through

the loop:

<BLOCKQUOTE>

<PRE>

$return='$grhours['.&quot;$i&quot;.']=&quot;&lt;td valign=bottom&gt;&lt;img src=/bars/hoursbar.gif width=15

   height=$hourshght['.&quot;$i&quot;.']&gt;&quot;;

</PRE>

</BLOCKQUOTE>

<P>

Okay, the statement probably isn't much more clear immediately,

but let's press on. Remember that in Listing 4.5, <TT>$graph</TT>

was initialized with the string <TT>$return= \'</TT>. When you

append the string to <TT>$graph</TT> as shown, you have the start

of a new assignment statement. As you can see, you're going to

be assigning a big string to <TT>$return</TT>.

<P>

When this statement is executed, the script won't be just assigning

one long string enclosed in quotes; it actually will perform several

append operations, using the <TT>.</TT> operator. The two instances

of <TT>$i</TT> are enclosed in double quotes; thus, they will

be interpolated when this statement is executed. The rest of the

strings are enclosed in single quotes specifically to prevent

interpolation when this statement is executed. The reason is that

this step is actually two steps away from the final piece of code.

<TT>$calchght</TT> also is two steps away from the final piece

of code.

<P>

The last two variables-<TT>$printgraph</TT> and <TT>$graphkey</TT>-are

similar to the <TT>print</TT> variables in Listing 4.8 and should

be easy for you to figure out.

<P>

Listing 4.10 shows the final piece of code needed to complete

this section. This code completes all the strings that will be

executed as statements later in the script.

<HR>

<BLOCKQUOTE>

<B>Listing 4.10&nbsp;&nbsp;Part 6 of the printcustomdata Script

<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

$printtop .= '\n&quot;;';

   $printrow .= '\n&quot;;';

   $printtot .= '\n&quot;;';

   $printavg .= '\n&quot;;';

   $graph .= '\';';

   $calchght .= '&quot;;';

   $calctop .= '&quot;;';

   $graphkey .= '\n&quot;;';

   $printgraph .= '&lt;/table&gt;&quot;;';

</PRE>

</BLOCKQUOTE>

<HR>

<P>

<B>Using <I>eval()</I> to Execute Dynamic Code Sections&nbsp;&nbsp;</B>By

now, you're probably wondering how the script is going to use

all the mini-programs discussed in the preceding sections. The

listings in this section should answer that question nicely. Listing

4.11 begins the answering process.

<HR>

<BLOCKQUOTE>

<B>Listing 4.11&nbsp;&nbsp;Part 7 of the printcustomdata Script

<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#print out the top of the page.



   print &quot;&lt;title&gt;Web Use for $fields{'email'}&lt;/title&gt;&quot;;

   print '&lt;body bgcolor=&quot;#FFFFFF&quot;&gt;';

   print &quot;Following is the data you requested. Thank you for your continued support.

   See you in another week or so.&lt;p&gt;&quot;;



   #Run the first mini-program to print out the top of the table.



   if ($tableit eq 'y'){

     print &quot;&lt;table border=1&gt;\n&quot;;

     eval($printtop);

   }

</PRE>

</BLOCKQUOTE>

<HR>

<P>

Listing 4.11 begins by printing the top of the page, starting

with a title and the <TT>&lt;body&gt;</TT> tag; it then prints

a brief greeting message before executing the conditional <TT>if

($tableit eq 'y') {</TT>. If the <TT>$tableit</TT> variable is

<TT>y</TT>, you know that you have at least one field requested

for the table (refer to Listing 4.8), and you want to initialize

the table. After the <TT>print</TT> statement that outputs the

tag to open a table, you see the command that is going to take

care of all the mini-programs: <TT>eval()</TT>.

<P>

Just as you would expect, this command takes the string that you

give it and executes the string as though the lines that it contains

were typed at that point in the program. In Listing 4.11, this

<TT>eval()</TT> command prints the top row of the table, which

contains the column titles for the user-requested data. Listing

4.12 continues the process of printing the table.

<HR>

<BLOCKQUOTE>

<B>Listing 4.12&nbsp;&nbsp;Part 8 of the printcustomdata Script

<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

$num=0;

   $rationum=0;



   #Loop through the data.



   for ($i=1; $i&lt;9; $i++) {

     open (data, &quot;printdatasup period$i $fields{'email'} |&quot;);

     $data=&lt;data&gt;;

     if ($data ne '') {

        $num++;

        $data=~s/::::/::0::/g;

        $data=~s/::::/::0::/g;

        $data=~s/^::/0::/;

        $data=~s/::$/::n\/a/;

        ($hours,$webhours,$phonehours,

        $sentmail,$receivedmail,$waysused)=split(/::/,$data);

        if ($hours != 0) {

          $rationum++;

          $webhourratio=sprintf('%.2f', $webhours/$hours);

          $phonehourratio=sprintf('%.2f', $phonehours/$hours);

        }

        else {

          $webhourratio='0';

          $phonehourratio='0';

        }

</PRE>

</BLOCKQUOTE>

<HR>

<P>

Listing 4.12 begins by initializing two counter variables-<TT>$num</TT>

and <TT>$rationum</TT>-that will be used to calculate averages;

then it starts a loop from 1 to 8. This loop is the same loop

that was used to scan the data in Listing 4.1. The beginning of

this loop uses the support script from Listing 4.2 to grab the

appropriate data from the DBM file. After checking for data, the

script performs a couple of substitutions on the data to make

sure that the data contains zeroes instead of blank fields; then

it splits the data into separate variables.

<P>

Notice that the variable names used here are the names of the

fields in the original form. The mini-programs created earlier

in the script depend on these variable names. After splitting

the data, the script calculates the ratios (notice the use of

<TT>sprintf()</TT>) for Web hours and phone hours. You could have

created a string to run through an <TT>eval()</TT> to perform

this calculation. You may want to see whether you can figure out

what that would look like.

<P>

After the data is split into the appropriate variables and the

ratio calculations are made, Listing 4.13 shows a series of <TT>eval()</TT>

statements. As the comment at the top of this section of code

indicates, this code performs several key steps.

<HR>

<BLOCKQUOTE>

<B>Listing 4.13&nbsp;&nbsp;Part 9 of the printcustomdata Script

<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#Run the mini-programs to print a row

        #recalculate totals and find the maximum

        #value of a column.



        eval ($printrow) if $tableit eq 'y';

        eval ($calctotal);

        eval ($findmax);

        $finalgraph .= eval($graph);

        $finalcalchght .= eval($calchght);

        $graphbottom .= &quot;&lt;td align=center&gt;$period[$i]&quot;;

     }

   }

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The first <TT>eval()</TT> prints a row of the table. Remember

that <TT>$printrow</TT> contains the following:

<BLOCKQUOTE>

<PRE>

print &quot;&lt;tr&gt;&lt;td&gt;$period[$i]&lt;td&gt;$hours&lt;td&gt;$webhours&lt;td&gt;$webhourratio&lt;td&gt;$sentmail

&lt;td&gt;$receivedmail;

</PRE>

</BLOCKQUOTE>

<P>

When the script evaluates this string the first time through the

loop, it prints the following:

<BLOCKQUOTE>

<PRE>

&lt;tr&gt;&lt;td&gt;Aug 5-11&lt;td&gt;50&lt;td&gt;45&lt;td&gt;0.90&lt;td&gt;30&lt;td&gt;200

</PRE>

</BLOCKQUOTE>

<P>

The next two statements evaluate two strings that amount to a

series of assignment statements. The first string adds the current

value of each variable to the appropriate running total; the second

string makes sure that the maximum value for each variable is

still the maximum.

<P>

The functionality of the next two statements isn't as clear. Earlier

in this chapter, I said that <TT>$graph</TT> and <TT>$calchght</TT>

are two steps away from the final code. The next few paragraphs

discuss the first step. If you use <TT>eval()</TT> on the right

side of an assignment, it works just like a subroutine. The last

value of the last assignment statement in the block of statements

(a string, in the case of an <TT>eval</TT>) is returned to the

variable on the left side of the assignment.

<P>

If you look at Listing 4.5, you'll notice that <TT>$graph</TT>

and <TT>$calchght</TT> each contain a single assignment statement.

Thus, when the script executes the <TT>$finalgraph .= ...</TT>

statement in Listing 4.13, it repeatedly appends the data from

<TT>$graph</TT>.

<P>

Remember that parts of <TT>$graph</TT> were single-quoted and

other parts were not. If you look at what <TT>$graph</TT> contained,

you see that by the time the script gets through this loop, the

final graph contains a series of assignment statements that look

like the following:

<BLOCKQUOTE>

<PRE>

$grhours[1]= &quot;&lt;td valign=bottom&gt;&lt;img src=/bars/hoursbar.gif width=15 height=$hourshght[1]&gt;&quot;;

$grwebhours[1]= &quot;&lt;td valign=bottom&gt;&lt;img 

src=/bars/webhoursbar.gif width=15 height=$webhourshght[1]&gt;&quot;;

</PRE>

</BLOCKQUOTE>

<P>

Each variable that the user requested for the graph is represented

by an array that contains as many members as the user has entries

in the database. Similarly, <TT>$finalcalchght</TT> contains a

series of statements that create the <TT>hght</TT> arrays for

each variable. When each of these new strings is evaluated later

(in Listing 4.15), the arrays are created, and all the appropriate

data is assigned to the appropriate places.

<P>

This may not be entirely clear on first reading, but it's worth

taking the time to wrap your brain around this concept. The <TT>eval()</TT>

function is an extremely useful tool in high-end form processing.

<P>

After all that complexity, Listing 4.14 is a nice change of pace.

This section of code starts with a conditional to make sure that

the code executes only if some table data was selected in the

original form. If the code passes that test, it prints a totals

line, if the user selected it. The script then calculates the

averages and prints the averages line, if needed. Then the script

closes the table and prints a paragraph mark to separate the table

from the graph that follows.

<HR>

<BLOCKQUOTE>

<B>Listing 4.14&nbsp;&nbsp;Part 10 of the printcustomdata Script

<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

if ($tableit eq 'y') {

     eval ($printtot) if $fields{'total'} eq 'y';

     eval ($calcavg);

     eval ($printavg) if $fields{'average'} eq 'y';

     print &quot;&lt;/table&gt;&quot;;

     print &quot;&lt;p&gt;&quot;;

   }

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The last section of <TT>printcustomdata</TT>, shown in Listing

4.15, prints the graph portion of the page. Not surprisingly,

the code first checks to make sure that the user actually requested

a graph. With that task out of the way, the script opens the table.

Then the script evaluates the <TT>$finalcalchght</TT> and <TT>$finalgraph</TT>

strings, creating the arrays that the <TT>eval($printgraph)</TT>

statement will use to print the graph.

<HR>

<BLOCKQUOTE>

<B>Listing 4.15&nbsp;&nbsp;Part 11 of the printcustomdata Script

<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

if ($graphit eq 'y') {

     print &quot;&lt;table border=0&gt;&lt;tr&gt;&quot;;

     eval ($finalcalchght);

     eval ($finalgraph);

     for ($i=1; $i&lt;9; $i++) {

        print &quot;\n&lt;td valign=bottom align=center&gt;&quot;;

        eval ($printgraph);

     }

     print &quot;\n&lt;tr&gt;$graphbottom&quot;;

     print &quot;&lt;/table&gt;&lt;p&gt;&quot;;

     $graphkey=~s/&lt;br&gt;/ /g;

     print &quot;&lt;table&gt;&quot;;

     print &quot;&lt;tr&gt;&lt;td colspan=2 align=center&gt;&lt;b&gt;Key&lt;/b&gt;&lt;hr&gt;&quot;;

     eval ($graphkey);

     print &quot;&lt;/table&gt;&quot;;

   }

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

You may be curious about why I had to go through the bother of

creating two <TT>eval</TT>s for this section of code when everything

else could be done in the loop started in Listing 4.12. The difficulty

lay in the fact that I needed a maximum for each variable to set

a scale for each section of the graph. Netscape scales images

to the size indicated in the <TT>&lt;img&gt;</TT> tag to make

the bars of the graph. The actual GIFs that make up the bars are

14 pixels high by 14 pixels wide. By calculating a height for

each bar relative to the maximum for that variable over all of

the periods, I am able to scale each bar appropriately. The Aug.

26-Sep. 1 total hours bar, for example, is all the way to the

top. That period happened to have the highest number of hours,

so all the rest of the hours bars were set relative to it. This

method seemed to be the best way to present the data in one graph.

<P>

After finishing the loop, the script prints the labels for each

period and closes the table. The final act that this script performs

is to print a key so that the user knows what each bar means.

By now, you should be able to figure out how this procedure works.

<P>

As you've seen, the <TT>eval()</TT> function is a useful tool

for interpreting some kinds of form data into truly advanced dynamic

pages. The following sections introduce some other high-end page-output

options.

<H2><A NAME="ReturningDatatoaFormforFurtherRevision"><FONT SIZE=5 COLOR=#FF0000>

Returning Data to a Form for Further Revision</FONT></A></H2>

<P>

Beginning CGI programmers often get stuck in the mindset that

forms are a data source, not an output option. This is not always

the case. Almost certainly, a user will need to change some data

that he entered at your site. The ability to take data from your

data files and return it to a form for editing is an important

tool to have in your CGI toolbox.

<H3><A NAME="FillinginTextFieldsandSelectingListItems">

Filling in Text Fields and Selecting List Items</A></H3>

<P>

Consider the periodic data-entry field shown in figure 3.5. Not

every user is going to get his data correct right off the bat,

so you should allow users to select and edit a line of data. I

changed two of the scripts that appear earlier in this chapter

for this purpose. Now, after a user enters data, a screen like

the one shown in figure 4.4 appears.

<P>

<A HREF="f4-4.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/f4-4.gif"><B> Figure 4.4 : </B><I>This form enables the user to edit previously entered periodic data.



</I></A><P>

<P>

<A HREF="f4-5.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/f4-5.gif"><B> Figure 4.5 : </B><I>The periodic data-entry form is generated on the fly for editing previously entered data.



</I></A><P>

<P>

As you can see in the Location box in figure 4.4, this page was

produced by a modified version of the printdata script shown in

Listing 4.1. The new version of the script adds some code that

makes the original table into an HTML form. The new code (PRINTDATA.PL)

is on the CD-ROM that accompanies this book. To automatically

direct the user to this script after entering data, I changed

the postperioddata script (refer to Listing 3.8 in <A HREF="ch3.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch3.htm" >Chapter 3</A>

to redirect the browser instead of printing a page directly; see

POSTPERIODDATA.PL on the CD-ROM.

<P>

When a user selects one of the periods and clicks the Edit Data

   button in figure 4.4, a screen like the one shown in figure

4.5 appears. Notice that all the text boxes contain appropriate

data and that the appropriate items in the Uses menu box are selected.

<P>

Listing 4.16 shows the first key part of the code that creates

this form. This block follows a straightforward initialization

section that prints the header and initializes some variables.

<HR>

<BLOCKQUOTE>

<B>Listing 4.16&nbsp;&nbsp;Partial Listing of editperiod (EDITPERIOD.PL)

<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

if (&amp;check_pass($fields{'email'},$fields{'pass'})) {

   open (data, &quot;printdatasup period$fields{'period'} $fields{'email'} |&quot;);

   $data=&lt;data&gt;;

   ($hours,$webhours,$phonehours,

   $sentmail,$receivedmail,$waysused)=split(/::/,$data);

   @waysused=split(/,/,$waysused);

   foreach (@waysused) {

     $dowaysused .= &quot;\$${_}selected=\&quot;SELECTED\&quot;;&quot;;

   }

   eval ($dowaysused);

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The first thing that you should notice about Listing 4.16 is that

it again uses the <TT>&amp;check_pass()</TT> subroutine and <TT>printdatasup</TT>

program. When the script gets the data back from the DBM file,

it splits the data into the now-familiar variables. This time,

however, the script splits one of those variables-<TT>$waysused</TT>-again.

The script uses the resulting array in a <TT>foreach</TT> loop

that builds a string that is evaluated in the last statement of

Listing 4.16.

<P>

A closer look at <TT>$dowaysused</TT> clarifies what's happening.

After the loop is complete, <TT>$dowaysused</TT> looks similar

to this:

<BLOCKQUOTE>

<PRE>

$webselected=&quot;SELECTED&quot;;

$emailselected=&quot;SELECTED&quot;;

$ftpselected=&quot;SELECTED&quot;;

</PRE>

</BLOCKQUOTE>

<P>

When this string is evaluated, all the Web uses that the user

selected have a corresponding selected variable set to <TT>SELECTED</TT>.

When this process is complete, the script prints the actual form,

as shown in Listing 4.17.

<HR>

<BLOCKQUOTE>

<B>Listing 4.17&nbsp;&nbsp;Part 2 of editperiod<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

	print &lt;&lt;EOF

&lt;title&gt;Internet Use Survey Data Entry&lt;/title&gt;

&lt;body bgcolor=#FFFFFF&gt;

&lt;h2&gt;Internet Use Survey&lt;/h2&gt;

&lt;form method=post action=/cgi-bin/harlan/postperioddata&gt;

&lt;table&gt;

&lt;tr&gt;&lt;td colspan=2&gt;&lt;p&gt;Please enter your password.

&lt;tr&gt;&lt;td align=right&gt;e-mail address:&lt;td&gt;$fields{'email'}&lt;input type=hidden name=email 

           value=&quot;$fields{'email'}&quot; size=30&gt;

&lt;tr&gt;&lt;td align=right&gt;password:&lt;td&gt;&lt;input type=password name=pass size=10 maxlength=10&gt;

&lt;tr&gt;&lt;td align=right&gt;entry period:&lt;td&gt;$period[$fields{'period'}]

&lt;input type=hidden name=period value=$fields{'period'}&gt;

&lt;tr&gt;&lt;td colspan=2&gt;&lt;p&gt;How many hours did you spend on the Net during the indicated period?

&lt;tr&gt;&lt;td align=right&gt;hours:&lt;td&gt;&lt;input type=text name=hours value=&quot;$hours&quot; size=4&gt;

&lt;tr&gt;&lt;td colspan=2&gt;&lt;p&gt;What did you use the Net for during the indicated period? 

          (Shift or Ctrl+click to select more than one value.)

&lt;tr&gt;&lt;td align=right valign=top&gt;uses:&lt;td&gt;&lt;select name=uses multiple size=3&gt;

&lt;option value=Web $webselected&gt;World Wide Web

&lt;option value=e-mail $emailselected&gt;email

&lt;option value=FTP $ftpselected&gt;File Transfer

&lt;option value=Gopher $gopherselected&gt;Gopher

&lt;option value=IRC $ircselected&gt;Internet Relay Chat

&lt;option value=talk $talkselected&gt;Talk (text based)

&lt;option value=phone $phoneselected&gt;Internet Phone (voice)

&lt;option value=other $otherselected&gt;Other uses

&lt;/select&gt;

&lt;tr&gt;&lt;td colspan=2&gt;&lt;p&gt;If you used the Net for e-mail,

              how many messages did you receive and send during this period?

&lt;tr&gt;&lt;td align=right&gt;received:&lt;td&gt;&lt;input type=text name=receive value=&quot;$receivedmail&quot; size=4&gt;

&lt;tr&gt;&lt;td align=right&gt;sent:&lt;td&gt;&lt;input type=text name=send value=&quot;$sentmail&quot; size=4&gt;

&lt;tr&gt;&lt;td colspan=2&gt;&lt;p&gt;If you used the Web, 

              how many hours did you do so during this period?

&lt;tr&gt;&lt;td align=right&gt;hours:&lt;td&gt;&lt;input type=text name=webhours value=&quot;$webhours&quot; size=4&gt;

&lt;tr&gt;&lt;td colspan=2&gt;&lt;p&gt;If you used an Internet phone,

              how many hours did you talk during this period?

&lt;tr&gt;&lt;td align=right&gt;hours:&lt;td&gt;&lt;input type=text name=phonehours value=&quot;$phonehours&quot; size=4&gt;

&lt;tr&gt;&lt;td colspan=2&gt;&lt;p&gt;&lt;input type=submit value=&quot;submit data&quot;&gt;

&lt;/table&gt;

&lt;/form&gt;

EOF

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

This listing presents a new piece of Perl syntax. The <TT>&lt;&lt;EOF</TT>

after the <TT>print</TT> command tells the interpreter to print

everything that follows until it runs into the label <TT>EOF</TT>.

The next few lines are then treated as though they were a string-in

this case, a double-quoted string. The primary advantage of this

syntax in this application is that you don't have to worry about

putting backslashes before any double quotes that you want to

print. Variables are still interpolated, however. You can print

single-quoted strings with this syntax by enclosing the label

in single quotes. Had the script used the command <TT>print &lt;&lt;'EOF'</TT>

instead, the variable references would not be interpreted, and

instead of getting numbers in the form, the script would have

printed the variable <I>names</I>.

<P>

Putting the values in the appropriate places in the form is easy.

I put the values of text boxes after the appropriate <TT>value=</TT>

attribute. When you set a selected variable for each Web use that

occurs in the data, preselecting the list items is as simple as

putting each selected variable next in the appropriate tag. If

a particular Web use occurs in the data, the <TT>&lt;option&gt;</TT>

tag ends up containing <TT>SELECTED</TT>, so that use shows up

in the browser as being selected.

<P>

Although this block of text looks as though it may have been copied

directly from the form's original HTML file, the code contains

some significant changes. First, the code took away the user's

capability to change the e-mail address and the period for which

the data is being entered. Notice that the user sees these two

pieces of information as straight text. In this new form, the

appropriate data is also coded into a hidden field. Had the code

allowed users to change this information, it would have created

potential for confusion and perhaps lost data.

<P>

Also notice that the code requires the user to type his e-mail

address again. Although I could have hard-coded the data into

the form in a hidden field, I felt that the small inconvenience

of having the user type the password again was offset by the added

security. If this form resided on a site that had user authentication,

I might have been able to prevent this repetitious password typing.

<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>TIP</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

One of the most important concepts for a CGI programmer to remember is the fact that Web applications are essentially stateless. The server makes no attempt to track a user's progress through a certain function, so if a function for your Web application 
is going to require three forms, you have to figure out a way to transmit the state of that function from one form to the next. The best CGI programmers understand this concept and develop an arsenal of tools (many of which are discussed in this chapter) 
to overcome this limitation.</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<H3><A NAME="SavingandEditingUserDesignedPages">

Saving and Editing User-Designed Pages</A></H3>

<P>

With some knowledge of editing previously entered data under your

belt, now you can look for other kinds of data to store, retrieve,

and edit. How about those user-designed pages that you created

at the beginning of the chapter? Web users really appreciate sites

that keep track of what they want to see. This section shows you

a way to save a user's pages and enable the user to view and edit

those pages.

<P>

<B>Saving the Custom Layout&nbsp;&nbsp;</B>As you can see in figures

4.6 and 4.7, I have created scripts to store, retrieve, and edit

the custom layouts that you spent so much time looking at earlier

in this chapter.

<P>

<A HREF="f4-6.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/f4-6.gif"><B> Figure 4.6 : </B><I>The bottom of a user-designed page gives the user the option to save this layout.



</I></A><P>

<P>

<A HREF="f4-7.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/f4-7.gif"><B> Figure 4.7 : </B><I>This listing of saved layouts is the result of selecting the link in figure 4.6.



</I></A><P>

<P>

Figure 4.6 shows a good way to allow the user to save a layout.

This link was a simple addition to the <TT>printcustomdata</TT>

script that you examined in detail in Listings 4.4 through 4.15.

I added the following line at the bottom of the script:

<BLOCKQUOTE>

<PRE>

print &quot;&lt;p&gt;&lt;a href=\&quot;/cgi-bin/harlan/savedataset/$fields{'email'}::$saveit\&quot;&gt;

   save this layout.&lt;/a&gt;&quot; if $direct ne 'y';

</PRE>

</BLOCKQUOTE>

<P>

As you can see, the URL calls the script <TT>savedataset</TT>.

You should also be able to tell that the script is going to get

its data from the <TT>PATH_INFO</TT> variable. The variable <TT>$fields{'email'}</TT>

should be familiar; <TT>$saveit</TT> should not. This new variable

contains a list of the selections on the form. I built this variable

in the same loop that built the dynamic code in <TT>printcustomdata</TT>.

You can see exactly how this process works by looking at the code

on the CD-ROM that accompanies this book (PRINTCUSTOMDATA.PL).

I'll explain more about the conditional that controls this line

later in the chapter.

<P>

When the user selects the link shown in figure 3.6, the <TT>savedataset</TT>

script saves the layout and prints the page shown in figure 4.7.

Listing 4.18 shows the code.

<HR>

<BLOCKQUOTE>

<B>Listing 4.18&nbsp;&nbsp;A Script to Save a User-Designed Page

(SAVEDATASET.PL)<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl

require &quot;process_cgi.pl&quot;;



if (&amp;parse_input(*fields)) {

   $email=$fields{'email'};

   $pass= $fields{'pass'};

   $id= $fields{'layout'};

   delete($fields{'email'});

   delete($fields{'pass'});

   delete($fields{'layout'});

   foreach (keys(%fields)) {

     $data .= &quot;$_,&quot;;

   }

   $data=~s/,$//;

   $data=&quot;NULL&quot; if $data eq '';

}

else {

   $temp=&amp;path_info;

   ($email,$data)=split (/::/,$temp);

}



dbmopen (%users,&quot;users&quot;,0666);

if (!defined($users{$email})) {

   &amp;print_header;

   print &quot;The email address you entered does not exist in our

     database. Someone may be trying to fool us...&quot;;

}

else {

   system (&quot;savegraph $email $data $id&quot;);

   &amp;print_header (&quot;http://192.0.0.1/cgi-bin/harlan/showsaveddatasets/$email&quot;);

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The first thing that you should notice in Listing 4.18 is the

fact that this script checks for form input (<TT>if (&amp;parse_input(*fields))...</TT>)

before looking to the <TT>PATH_INFO</TT> variable for its data.

I added this flexibility to avoid having to write another script

to put edited data back into the database. When called from the

link shown in figure 4.6, the script learns all that it needs

to know from the <TT>PATH_INFO</TT> variable. The script splits

the data into an e-mail address and the rest of the data: a list

of fields that belong in this layout. The script then makes sure

that the e-mail address exists in the user database. If the address

doesn't exist, something has gone wrong, or someone is trying

to fool the script.

<P>

You don't really need to check the password in this case, because

the only way to get to this script is from scripts that check

the password. A user could easily type some garbage to see what

kind of result he would get. But because this data isn't very

sensitive and the user can easily edit out any offending data,

I didn't feel that the extra protection was necessary. By now,

you probably can figure out how to add this protection on your

own anyway.

<P>

After the script determines that the user exists, it makes a call

to an outside program, <TT>savegraph</TT> (remember the limit

of one <TT>dbmopen()</TT> call per script) to actually save the

data. Listing 4.19 shows <TT>savegraph</TT>.

<HR>

<BLOCKQUOTE>

<B>Listing 4.19&nbsp;&nbsp;Script to Save User Page Data to a

DBM File (SAVEGRAPH.PL)<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl



$email=$ARGV[0];

$data=$ARGV[1];

$id=$ARGV[2];

dbmopen (%graphs, savedgraphs, 0666);

if ($id ne '') {

   if ($data ne 'NULL'){

     $graphs{$email}=~s/\!\![\w,]+::$id/!!${data}::$id/;

   }

   else {

     $graphs{$email}=~s/\!\![\w,]+::$id//;

   }

}

else {

   $temp=$graphs{$email};

   $temp=~/(\d+)$/;

   if ($1 ne '') {

     $id=$1+1;

   }

   else {

     $id=1;

   }

   $graphs{$email} .= &quot;!!${data}::$id&quot;

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

Like its big brother in Listing 4.18, <TT>savegraph</TT> serves

two purposes; it can deal with new data or edited data. The first

thing that this script does is store the command-line arguments

in <TT>$email</TT>,<TT> $data</TT>, and <TT>$id</TT>. The conditional

<TT>if ($id eq '')...</TT> looks to see whether the script was

called with a layout ID number on the command line. If not, the

data that the script is given is for a new layout, and that processing

takes place in the <TT>else</TT> section of the conditional.

<P>

This block begins by getting the current data for the given e-mail

address from the DBM file <TT>savedgraphs</TT>, which was opened

at the top of the script. The script then executes the command

<TT>$temp=~/(\d+)$/;</TT>. This line of code places the number

from the end of the data that the script just retrieved in the

special variable <TT>$1</TT>. The script then checks for a number.

If the script finds no number, this layout is the first saved

layout, so the ID is set to 1. If the script does find a number,

it adds 1 to that number to get an ID for the new saved layout.

The script then appends the new data-with appropriate delimiters-to

the data in the DBM file and exits, returning to <TT>savedataset</TT>.

<P>

As you can see in Listing 4.18, only one command is left in the

parent script: a call to the <TT>&amp;print_header</TT> subroutine,

with a location to direct the browser. The script at this location

finally prints the form that you see in figure 4.7. The script,

<TT>showsaveddatasets</TT>, is available on the CD-ROM that comes

with this book (SHOWSAVEDDATASETS.PL). This script is a simple

piece of code that you should be able to decipher without difficulty.

<P>

<B>Viewing and Editing the Saved Layouts&nbsp;&nbsp;</B>With the

data now safely stored, you need to act on the user's actions

on the form shown in figure 4.7. Listing 4.20 shows the initial

script that acts on the submission of this form.

<HR>

<BLOCKQUOTE>

<B>Listing 4.20&nbsp;&nbsp;Script to Edit or View Selected Saved

Layouts (EDITSAVEDLAYOUT.PL)<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl



require &quot;process_cgi.pl&quot;;

require &quot;check_pass.pl&quot;;



&amp;parse_input(*fields);

&amp;print_header;

if (&amp;check_pass($fields{'email'},$fields{'pass'})) {

   open (data, &quot;getlayoutdata $fields{'email'} $fields{'layout'} |&quot;);

   $data=&lt;data&gt;;

   if ($fields{'action'} eq 'edit') {

     open (out, &quot;editlayout $fields{'email'} $fields{'layout'} $data |&quot;);

     @out=&lt;out&gt;;

     print @out;

   }

   else {

     open (out, &quot;printcustomdata $fields{'email'} $data |&quot;);

     @out=&lt;out&gt;;

     print @out;

   }

}

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The basic format of the <TT>editsavedlayout</TT> script should

be quite familiar to you by now. The script starts by requiring

the CGI library and the password-checking script. The script then

reads the input from the form, prints the header, and checks the

password, just like many of the scripts in this chapter. When

the password is confirmed, the script uses yet another support

script (<TT>getlayoutdata</TT>, on the CD-ROM) to get the data

for the chosen layout. If the user chose the Edit radio button,

the script calls a new script called <TT>editlayout</TT>.

<P>

Listing 4.21 shows a partial listing of this script. Notice that

the script again uses the <TT>eval</TT> function to create the

variables that check the appropriate boxes on the form. Also,

the script uses the <TT>print &lt;&lt;</TT> syntax to ease the

output of the on-the-fly form. The form that results from the

submission of this form is almost identical to the original layout

selection form shown in figure 4.2. The only differences are that

the e-mail address is in plain text and that this version points

to a different supporting script. Also, the layout number and

the e-mail address are stored in hidden fields.

<HR>

<BLOCKQUOTE>

<B>Listing 4.21&nbsp;&nbsp;A Partial Listing of editlayout (EDITLAYOUT.PL)

<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl

$email=$ARGV[0];

$number=$ARGV[1];

@data=split(/,/,$ARGV[2]);

foreach (@data) {

   eval (&quot;\$${_}checked='CHECKED';&quot;)

}

print &lt;&lt;EOF;

&lt;title&gt;Data Display Choices&lt;/title&gt;

</PRE>

</BLOCKQUOTE>

<HR>

<P>

When the user makes the desired changes to this layout, he can

submit the form. The data is sent to the <TT>savedataset</TT>

script (refer to Listing 4.18). I explained earlier how this script

works with new data (and the <TT>PATH_INFO</TT> variable). With

the edited data from this form submission, the information comes

in through the normal <TT>POST</TT>-method channels, and the script

accesses it through the <TT>&amp;parse_input</TT> routine.

<P>

When the data is in the <TT>%fields</TT> hash, the script finds

and saves the e-mail, password, and layout ID information. The

script then uses a function that you haven't seen before-<TT>delete()</TT>-to

delete those pieces from the <TT>%fields</TT> array. <TT>delete()</TT>

does exactly what its name implies; it removes the indicated element

from a hash. This function is useful in this case because you

want to build your <TT>$data</TT> string from the remaining elements

of the array. You use a <TT>foreach</TT> loop for this purpose,

iterating over the keys of <TT>$fields</TT>. When <TT>$data</TT>

is built, the script removes the extra comma from the end and

then calls the <TT>savegraph</TT> script (refer to Listing 4.19).

<P>

Because the script calls <TT>savegraph</TT> with three command-line

arguments this time, it knows that you are editing an existing

layout. In most cases, the script performs a straight substitution,

using the <TT>s///</TT> operator. Notice, however, that if the

<TT>$data</TT> string is <TT>NULL</TT>, the script actually deletes

the layout. If you refer to Listing 4.18, you'll notice that <TT>$data</TT>

is set to <TT>NULL</TT> if it is empty at the end of the <TT>foreach</TT>

loop that builds the string. This syntax provides a simple means

of deleting unwanted layouts from the data file.

<P>

Why do I explicitly set <TT>$data</TT> to <TT>NULL</TT> instead

of just allowing it to be empty? The problem is that if <TT>$data</TT>

is empty, the script ends up calling <TT>savegraph</TT> with only

two command-line arguments. The program would think that the ID

is the data; it would see no ID, so it would create a new layout

in the data file with bogus data.

<P>

When the processing of the edited data is complete, the program

sends the user back to the listing of saved layouts.

<P>

If the user chose the View radio button in figure 4.7, the script

calls <TT>printcustomdata</TT>, with the e-mail address and layout

data as command-line arguments. The original version of this script

did not account for dealing with command-line arguments, so I

had to modify it slightly from what you saw in &quot;Returning

Data to a Form for Further Revision&quot; earlier in this chapter.

Listing 4.22 shows the most significant change.

<HR>

<BLOCKQUOTE>

<B>Listing 4.22&nbsp;&nbsp;A Partial Listing of the New Version

of printcustomdata<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

if (!(&amp;parse_input(*fields))){

   $fields{'email'}=$ARGV[0];

   @layout=split(/,/,$ARGV[1]);

   foreach(@layout){

     $fields{$_}='y';

   }

   $pass=&quot;good&quot;;

   $direct='y';

}

else {

   &amp;print_header;

   if (&amp;check_pass($fields{'email'},$fields{'pass'})) {

     $pass=&quot;good&quot;;

   }

}

$j=0;

if ($pass eq 'good') {

</PRE>

</BLOCKQUOTE>

<HR>

<P>

As you can see in the listing, the modification was fairly simple.

If <TT>&amp;parse_input</TT> returned <TT>false</TT>, I knew that

the script had been called directly. With that fact in mind, I

put all the data in the appropriate places, building the <TT>%fields</TT>

hash that would have come from <TT>&amp;parse_input</TT>. Again,

notice that careful form design and variable naming throughout

this application helped immensely.

<P>

When <TT>%fields</TT> is built properly, the script sets two new

variables. The first-<TT>$pass</TT>-substitutes for checking the

password. Because the user has already authenticated to get this

far, you needn't check again. The second variable- <TT>$direct</TT>-is

used to prevent the <TT>Save this layout</TT> line from being

printed at the end of the script. This option isn't necessary,

and it would potentially cause confusion.

<P>

The <TT>else</TT> section of the conditional in Listing 4.22 performs

password checking like the original version of the script and

sets <TT>pass</TT> to <TT>good</TT>, if appropriate. The <TT>if

($pass eq 'good') {</TT> conditional replaces the password-checking

line that you see at the top of Listing 4.5. If the password didn't

pass muster, the script essentially stops at that point.

<H2><A NAME="FromHere"><FONT SIZE=5 COLOR=#FF0000>

From Here...</FONT></A></H2>

<P>

In the preceding two chapters, you got a detailed view of a relatively

complex, user-driven Web application. Although you may not need

a Web survey application, the concepts are applicable to a wide

variety of programming chores. A good example is a companywide

schedule book. Users would need to enter and edit data, and they

would want to be able to view that data as flexibly as possible.

<P>

Now you're ready to find some new concepts to add to this knowledge.

Following are some suggestions for further reading:

<UL>

<LI><A HREF="ch5.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch5.htm" >Chapter 5</A> &quot;Searching.&quot; These days, a Web site that

doesn't have a search feature is almost sacrilegious. In this

chapter, you find out how to implement your own search routines.

<LI><A HREF="ch15.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch15.htm" >Chapter 15</A>, &quot;Function List.&quot; By now, you should

be thinking about things that you could do with Perl and CGI.

If you're ready to branch out on your own, this chapter tells

you everything that you ever wanted to know about Perl functions.

</UL>

<HR>



<CENTER><P><A HREF="ch3.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch3.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="index.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="ch5.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch5.htm"><IMG SRC="nc.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<HR WIDTH="100%"></P></CENTER>

</BODY>

</HTML>
