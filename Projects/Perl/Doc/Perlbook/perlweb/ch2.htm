<HTML>

<HEAD>

<TITLE>Chapter 2 -- Introduction to CGI</TITLE>



<META>

</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">

<H1><FONT SIZE=6 COLOR=#FF0000>Chapter&nbsp;2</FONT></H1>

<H1><FONT SIZE=6 COLOR=#FF0000>Introduction to CGI</FONT></H1>

<P>

<I><B>by David Harlan</B></I>

<HR>

<P>

<CENTER><B><FONT SIZE=5><A NAME="CONTENTS">CONTENTS</A></FONT></B></CENTER>

<UL>

<LI><A HREF="#JustifyingtheUseofCGI">

Justifying the Use of CGI</A>

<UL>

<LI><A HREF="#ReasonsforUsingPerl">

Reasons for Using Perl</A>

<LI><A HREF="#HowtoMakePerlDoCGI">

How to Make Perl Do CGI</A>

</UL>

<LI><A HREF="#UnderstandingCGI">

Understanding CGI</A>

<UL>

<LI><A HREF="#CallingaScriptfromaForm">

Calling a Script from a Form</A>

<LI><A HREF="#GettingInformationtotheScript">

Getting Information to the Script</A>

<LI><A HREF="#ProcessingIQUERYSTRINGIintoUsefulChunks">

Processing <I>QUERY_STRING</I> into Useful Chunks</A>

<LI><A HREF="#UsingRegularExpressionsItrIandIsI">

Using Regular Expressions <I>tr///</I> and <I>s///</I></A>

<LI><A HREF="#PrintingthePage">

Printing the Page</A>

<LI><A HREF="#CreatingaScriptonYourWebServer">

Creating a Script on Your Web Server</A>

<LI><A HREF="#CallingaCGIScriptDirectly">

Calling a CGI Script Directly</A>

<LI><A HREF="#LimitingDataFileSize">

Limiting Data-File Size</A>

<LI><A HREF="#UsingtheLocationHeader">

Using the Location Header</A>

<LI><A HREF="#UsingCGIinServerSideIncludes">

Using CGI in Server-Side Includes</A>

</UL>

<LI><A HREF="#FromHere">

From Here   </A>

</UL>



<HR>

<P>

Perl and the World Wide Web are a natural team. A good Web site

is, by definition, in constant flux. Users will not want to come

back to a boring site too often, so all Webmasters are looking

for any possible means to liven up their sites. The liveliest

sites are dynamic sites-sites that show users different content

from visit to visit. These types of sites also enable users to

interact or create content on-the-fly.

<P>

Because you're reading this book, you're probably wondering just

how to create a dynamic Web site. You're in the right place. Basically,

the Webmaster has to become a programmer and use some of the great

built-in features of the Web protocol to their fullest. To this

end, a programmer has to have a language that facilitates quick

programming, easy debugging, and fast revision. Perl fits this

role perfectly.

<H2><A NAME="JustifyingtheUseofCGI"><FONT SIZE=5 COLOR=#FF0000>

Justifying the Use of CGI</FONT></A></H2>

<P>

When you started looking at Web sites, one of the first items

that you probably were curious about was the .htmL extension on

the files. Soon, you found out that <I>HTML</I> stands for <I>Hypertext

Markup Language</I>, and you discovered that HTML is the foundation

on which the Web is built. If you were interested in building

your own Web site, you probably looked next at the source of a

few Web sites to see how they were built. At that point, you may

have exhausted your resources. But that's OK, because you discovered

that HTML is not difficult to use. Strangely, this fact may be

the Web's greatest advantage, as well as its major shortcoming.

<P>

Almost anyone can throw together some HTML and hang a home page

out on the Web. But most sites are, quite frankly, boring. Why?

Most sites are built as a simple series of HTML documents that

never change; the sites are completely static. No one is likely

to visit a static page more than once or twice. Think about the

sites that you visit most often. Those sites have interesting

content, certainly, but more important, they also have dynamic

and interactive content.

<P>

What's a Webmaster to do? None of us has the time to update a

Web site by hand every day. Fortunately, the people who developed

the Web protocol thought of this problem and gave us the <I>Common

Gateway Interface</I>, or <I>CGI</I>. CGI, which is the standard

programming interface to Web servers, gives us a way to make our

sites dynamic and interactive. To be specific, CGI is a set of

standards (in Internet lingo, a set of protocols) that allows

Web servers to communicate with external programs.

<H3><A NAME="ReasonsforUsingPerl">

Reasons for Using Perl</A></H3>

<P>

The reason why I use Perl for my CGI programming is simple: it

is the best tool for the job.

<P>

Perl is the de facto standard for CGI programming for several

reasons, but perhaps the most important are the language's flexibility

and ease of use. The primary reason why Perl is so easy to use

is that it is an interpreted language-which means that every time

you run a Perl program, a separate program called (appropriately

enough) an <I>interpreter</I> starts and processes the code in

your Perl script. An interpreted language differs from a compiled

language, such as C, in which you have to (not surprisingly) compile

your code into an executable file before you can run it.

<P>

Why is the Perl way better? In some cases, C may be preferable

to Perl. At times, you may not want the overhead of the interpreter

and prefer a stand-alone executable. (I haven't run into those

situations yet, but I'm sure that they exist.) The advantage of

using an interpreted language in CGI applications is the language's

simplicity in development, debugging, and revision. With the compilation

step removed, you and I can move more quickly from task to task

without the frustration that sometimes arises from debugging compiled

programs.

<P>

Not just any interpreted language will do, of course. Perl has

the distinct advantage of having an extremely rich and capable

functionality.

<H3><A NAME="HowtoMakePerlDoCGI">

How to Make Perl Do CGI</A></H3>

<P>

When I started programming CGI scripts, few resources were available

to help me. Unlike viewing the HTML source of a document, you

cannot get a browser to show you the script that produced any

given result on your browser. (For security reasons, this situation

is good; it just makes learning a little more difficult.) So,

like many CGI programmers, I learned by trial and error. The next

few pages should help you avoid this frustrating process and move

quickly to more advanced topics.

<P>

You need a few basic pieces of information before you successfully

program a CGI script:

<UL>

<LI>How the script gets information from the user

<LI>How Perl can process that information

<LI>How the script returns information to the user

</UL>

<H2><A NAME="UnderstandingCGI"><FONT SIZE=5 COLOR=#FF0000>

Understanding CGI</FONT></A></H2>

<P>

Unlike normal HTML files that are simply called up by a browser,

a CGI script can be used in several ways. The most common use

of CGI is for processing user input. (You probably have seen other

uses of CGI without even knowing it.) This section takes a detailed

look at that most common use of CGI: the fill-out form. In the

next few pages, you'll see a form application being built from

the ground up.

<H3><A NAME="CallingaScriptfromaForm">

Calling a Script from a Form</A></H3>

<P>

Undoubtedly, one of the first uses of CGI that you experienced

was filling out and submitting a form. Perhaps that form looked

something like the Guestbook sign-in form shown in figure 2.1.

<P>

<A HREF="f2-1.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/f2-1.gif"><B> Figure 2.1 : </B><I>This form allows a user to sign a Guestbook on a Web site.



</I></A><P>

<P>

When the proper script support this simple form, it performs its

function easily. You may be wondering how to call a script from

this form. Listing 2.1 contains the source for this form and shows

you where the script is referenced.

<HR>

<BLOCKQUOTE>

<B>Listing 2.1&nbsp;&nbsp;Calling a CGI Script (GUESTBOOK.htmL)

<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

&lt;html&gt;

&lt;body bgcolor=&quot;#FFFFFF&quot;&gt;

&lt;title&gt;Guestbook&lt;/title&gt;

&lt;h2&gt;Please Sign My Guestbook&lt;/h2&gt;

&lt;form method=get action=&quot;/cgi-bin/harlan/guestbook&quot;&gt;

&lt;dt&gt;Name:&lt;br&gt;

&lt;dd&gt;&lt;input type=text name=name size=30&gt;

&lt;dt&gt;Comment:&lt;br&gt;

&lt;dd&gt;&lt;textarea name=comment rows=5 cols=50&gt;&lt;/textarea&gt;&lt;p&gt;

&lt;input type=submit value=&quot;Sign In&quot;&gt;

&lt;/form&gt;

&lt;/html&gt;

</PRE>

</BLOCKQUOTE>

<HR>

<P>

In line 4 of the HTML code in Listing 2.1, you see the following:

<BLOCKQUOTE>

<PRE>

...action=&quot;/cgi-bin/harlan/guestbook&quot;...

</PRE>

</BLOCKQUOTE>

<P>

This line tells the form what script to call to process the entered

information.

<P>

The location /CGI-BIN/HARLAN/GUESTBOOK is what's called a <I>virtual

path</I>. The actual location of the script on the Web server

computer depends on the configuration of the server software and

the type of computer that is being used. In this case, the computer

uses the Linux operating system and is running the NCSA Web server

in a standard configuration. The physical path to the script in

this case is /USR/LOCAL/ETC/HTTPD/CGI-BIN/HARLAN. Although a nearly

infinite number of combinations of operating systems and Web servers

is possible, the Linux/NCSA combination is relatively common.

If you install and administer the Web server yourself, you know

exactly where to place your scripts. If you are using a service

provider's Web server, you may have to ask the server's administrator

where to put your scripts and how to reference them from your

documents.

<P>

What happens if you sign this Guestbook? In its simplest form,

the result of signing the book looks like figure 2.2.

<P>

<A HREF="f2-2.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/f2-2.gif"><B> Figure 2.2 : </B><I>This screen shows the result of the Guestbook form submission.



</I></A><P>

<H3><A NAME="GettingInformationtotheScript">

Getting Information to the Script</A></H3>

<P>

To understand how submitting the form in figure 2.1 produces the

result shown in figure 2.2, you first need to know how information

is passed from the form to your Perl script.

<P>

Perl provides a special variable called <TT>%ENV</TT>. This variable

is an <I>associative array</I>, or <I>hash</I>-essentially, a

list of identifiers or keys and their associated values. I'll

explain the syntax of a Perl hash later in this chapter. For now,

look at the contents of <TT>%ENV</TT>. This particular hash contains

information about the script's environment. If you have UNIX experience,

you may have heard of environment variables. A UNIX user can set

certain options, such as a default editor or default shell, by

using environment variables.

<P>

A Perl script also has an environment. Much of the environment

is inherited from the server that's running the script, but a

CGI script gets some additional goodies. The CGI specification

tells Web server software to provide a wealth of useful information

to CGI scripts.

<P>

<B>Using <I>QUERY_STRING&nbsp;&nbsp;</I></B>Perhaps the most-used

CGI environment variable is <TT>QUERY_STRING</TT>. When a form

is submitted, the Web server software processes the information

that the user provided in the form and passes that information

to the script specified in the form. The processing isn't too

complex. Spaces in the data are replaced by plus signs, and special

characters are translated into a code that is related to their

ASCII value; then all the data is put together in one long string.

<P>

When the script is called with the <TT>GET</TT> method (as the

Guestbook script is; see line 5 of Listing 2.1), the server places

the string described earlier in the <TT>QUERY_STRING</TT> variable.

Because this variable becomes part of the script's environment,

you can access it through <TT>%ENV</TT>, as you'll see later in

this chapter.

<P>

<B>Using Other CGI Variables&nbsp;&nbsp;</B>Several variables

in addition to <TT>QUERY_STRING</TT> are provided in the CGI specification.

Some of the descriptions may not make much sense to you right

now. But if you refer to Table 2.1 periodically as you continue

to read this book, you'll discover just how useful some of this

information is.<BR>

<P>

<CENTER><B>Table 2.1&nbsp;&nbsp;CGI Environment Variables</B></CENTER>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD WIDTH=182><B>Variable Name</B></TD><TD WIDTH=394><B>Description</B>

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=182><TT>AUTH_TYPE</TT></TD><TD WIDTH=394>The authentication protocol that is currently being used. This variable is defined only if the server supports authentication and if authentication is required for access to the script.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=182><TT>CONTENT_LENGTH</TT></TD><TD WIDTH=394>The length, in bytes, of the content provided to the script in <TT>STDIN</TT>. This variable is used particularly in <TT>POST</TT>-method form processing.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=182><TT>CONTENT_TYPE</TT></TD><TD WIDTH=394>The type of content contained in <TT>STDIN</TT>. This variable is used for <TT>POST</TT>-method form processing.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=182><TT>GATEWAY_INTERFACE</TT></TD><TD WIDTH=394>The version of CGI supported by the Web server.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=182><TT>HTTP_ACCEPT</TT></TD><TD WIDTH=394>A comma-separated list of MIME types that the browser software accepts. You might check this variable to see whether the client will accept a certain kind of graphic file.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=182><TT>HTTP_USER_AGENT</TT></TD><TD WIDTH=394>The browser software and version number.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=182><TT>PATH_INFO</TT></TD><TD WIDTH=394>Extra path information from the request.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=182><TT>PATH_TRANSLATED</TT></TD><TD WIDTH=394>Maps the script's virtual path (from the root of the server directory, for example) to a physical path that could be used to call the script.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=182><TT>QUERY_STRING</TT></TD><TD WIDTH=394>A string containing the data from a form submission.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=182><TT>REMOTE_ADDR</TT></TD><TD WIDTH=394>The IP address of the client machine.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=182><TT>REMOTE_HOST</TT></TD><TD WIDTH=394>The host name of the client machine.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=182><TT>REMOTE_USER</TT></TD><TD WIDTH=394>The authenticated user ID of the user who is requesting the script. This variable is defined only if the server supports authentication and if authentication is required for access to the 
script.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=182><TT>REQUEST_METHOD</TT></TD><TD WIDTH=394>The method by which the script was called (most often, <TT>GET</TT> or <TT>POST</TT>).

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=182><TT>SCRIPT_NAME</TT></TD><TD WIDTH=394>The virtual path to the script.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=182><TT>SERVER_NAME</TT></TD><TD WIDTH=394>The configured host name for the server (usually, www.something.com).

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=182><TT>SERVER_PORT</TT></TD><TD WIDTH=394>The number of the port on which the server software is &quot;listening&quot; (usually, 80, the default Web port).

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=182><TT>SERVER_PROTOCOL</TT></TD><TD WIDTH=394>The version of the Web protocol that this server uses.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=182><TT>SERVER_SOFTWARE</TT></TD><TD WIDTH=394>The name and version of the Web server software.

</TD></TR>

</TABLE></CENTER>

<P>

<H3><A NAME="ProcessingIQUERYSTRINGIintoUsefulChunks">

Processing <I>QUERY_STRING</I> into Useful Chunks</A></H3>

<P>

Now that you know where the information comes from, you're ready

to learn how you might use Perl to process this information. The

script that performs the transformation from figure 2.1 to figure

2.2 actually is quite simple and is shown in Listing 2.2.

<HR>

<BLOCKQUOTE>

<B>Listing 2.2&nbsp;&nbsp;The First Guestbook Script (GUESTBOOK1.PL)

<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl

$temp=$ENV{'QUERY_STRING'};

@pairs=split(/&amp;/,$temp);

foreach $item(@pairs) {

	($key,$content)=split (/=/,$item,2);

	$content=~tr/+/ /;

	$content=~ s/%(..)/pack(&quot;c&quot;,hex($1))/ge;

	$fields{$key}=$content;

}

print &quot;Content-type: text/html\n\n&quot;;

print &quot;&lt;body bgcolor=\&quot;#FFFFFF\&quot;&gt;\n&quot;;

print &quot;&lt;h2&gt;$fields{'name'}&lt;/h2&gt;\n&quot;;

print &quot;&lt;pre&gt;$fields{'comment'}&lt;/pre&gt;\n&quot;;

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The next few pages examine this script line by line.

<P>

Line 1 is a line that you need to use in every Perl script that

you write for your Web site. This line tells the operating system

that the script must be processed by the program listed after

the exclamation point. In this example, /USR/BIN/PERL is the location

of the Perl interpreter on my Web server computer.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

The <TT>#!/usr/bin/perl</TT> line in Listing 2.2 is needed only for UNIX and UNIX-variant versions of Perl. If your Web server is running another operating system (such as Windows NT or Macintosh System software), you need to check your Web server 
documentation for information on how to invoke CGI scripts.

</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<P>

When the user submits the form, the Web server software passes

the information to the script in the <TT>$ENV{'QUERY_STRING'}</TT>

variable. Line 2 of the script copies this information to the

variable <TT>$temp</TT>. The Perl syntax is straightforward; this

line is a simple assignment of one variable to another. <TT>$temp</TT>

is a <I>scalar variable</I>-the most common Perl variable. A scalar

variable can contain almost any kind of data you can imagine.

<TT>$ENV{'QUERY_STRING'}</TT> refers to an element in the associative

array <TT>%ENV</TT>, which is described in &quot;Getting Information

to the Script&quot; earlier in this chapter.

<P>

An associative array (designated in Perl with a leading <TT>%</TT>)

contains a series of scalar values. Each value is associated with

a key. In this example, the key is <TT>QUERY_STRING</TT>, and

the value is the encoded data from the form. (I performed this

assignment for purposes of readability; the step is not strictly

necessary.)

<P>

Line 3 of the script splits the data from the script into an array

of strings: <TT>@pairs</TT>. Notice that this kind of array is

different from <TT>%ENV</TT>. The <TT>@pairs</TT> array is a standard

array that uses integers (starting at 0) to designate each separate

element. Each element is a string that contains the variable name

from the form, followed by an equal sign, followed by the text

that the user entered at that spot in the form.

<P>

<TT>split()</TT> is a standard Perl function that takes two required

parameters and one optional one. The first parameter is the string

that separates the values that are to be split. The CGI protocol

specification states that key/value pairs are separated by an

ampersand (<TT>&amp;</TT>), so in this example, the ampersand

character is the first parameter. The second parameter is the

string that you want to split (<TT>$temp</TT>). The optional third

parameter (not present in this example) is a number that indicates

the maximum number of times that the string should be split.

<P>

Lines 4 through 9 of the script run through the newly created

<TT>@pairs</TT> array, processing the information from the form

into a new associative array to be used in the following lines.

<P>

Line 4 starts a loop structure. This particular loop-a <TT>foreach</TT>

loop-iterates through the <TT>@pairs</TT> array, placing each

value in turn in the <TT>$item</TT> scalar variable. The commands

between the brace on line 4 and the one on line 8 are executed

one time for each item in the array.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>Using Shortcuts and Writing Readable Perl Code</B>

</TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

When reading another programmer's code, an inexperienced programmer sometimes finds various incarnations of <TT>foreach</TT> loops to be confusing. Many Perl programmers pride themselves on writing the shortest code possible. Perl provides numerous 
shortcuts and options that cut the length of a script-but that have the unfortunate side effect of making the script much more difficult to read and understand.

</BLOCKQUOTE>

<BLOCKQUOTE>

The <TT>foreach</TT> structure requires a list between the parentheses. Most commonly, this list is simply an array. Sometimes, however, you see something like <TT>foreach(1..10), foreach (1,2,3,4,5,6,'blah')</TT>, or <TT>foreach (keys(%foobar))</TT>. 
Each of the expressions inside the parentheses represents a list. The first expression is a range of integers ranging from 1 to 10. The second should be obvious. The third uses the <TT>keys()</TT> function to get the list of keys for the <TT>%foobar</TT> 
hash. If you remember that <TT>foreach</TT> always requires a list between the parentheses, you will always have a basis from which you can figure out exactly what the loop does.

</BLOCKQUOTE>

<BLOCKQUOTE>

More obscure, however, is the fact that the loop doesn't actually require you to provide a variable to contain each successive list item. If a variable isn't provided, the list item is assigned to the special variable <TT>$_</TT>. Therefore, I could have 
written lines 4 and 5 this way:

</BLOCKQUOTE>

<BLOCKQUOTE>

<TT>foreach (@pairs) {<BR>

($key,$content)=split (/=/,$_,2);</TT>

</BLOCKQUOTE>

<BLOCKQUOTE>

This syntax would have done nothing to the functionality of the script but certainly would have obscured the meaning of the code.</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<P>

In line 5, <TT>split()</TT> is used again, this time to separate

the key and value. Notice that the left side of the assignment

in this line is not an array, as it was in line 3, but two scalars

enclosed in parentheses. This syntax tells Perl that you want

the enclosed list of scalars to be treated as an array for assignment

purposes.

<P>

Lines 6 and 7 decode the information in the value portion of the

key/value pair. This decoding is necessary, because the Web server

software encodes the data (according to a standard scheme that

is part of the CGI protocol specification) before placing the

information in the <TT>$ENV{'QUERY_STRING'}</TT> variable. Therefore,

you have to decode the information before you can present it to

the user.

<H3><A NAME="UsingRegularExpressionsItrIandIsI">

Using Regular Expressions <I>tr///</I> and <I>s///</I></A></H3>

<P>

If you have no experience in Perl or UNIX, lines 6 and 7 of Listing

2.2 are likely to be the least understandable in the entire script.

This section examines those lines one at a time to help you figure

them out.

<P>

Line 6 uses the <TT>tr///</TT> operator. This command takes two

lists of characters as arguments. The first list (between the

first two slashes) contains a list of characters to search for.

The second list (between the second and third slashes) contains

a list of replacement characters. The first character in the search

list is replaced by the first character in the replacement list.

The second character in the search list is replaced by the second

character in the replacement list, and so on through the two lists.

Thus, this syntax tells <TT>tr///</TT> to perform this translation

on <TT>$content</TT>, using the binding operator <TT>=~</TT>.

So if you look at line 6 again, you see that the plus signs in

<TT>$content</TT> are being translated into spaces.

<P>

Line 7 looks similar to its predecessor but is a little more complex.

This line uses the <TT>s///</TT> operator to perform further translation

on <TT>$content</TT> (as designated by the <TT>=~</TT> binding

operator). This command takes a text pattern or regular expression

between the first two slashes. Text that matches the first pattern

is replaced by text designated by the replacement text between

the second and third slashes. Some options for this command are

designated by letters that follow the third slash.

<P>

What text pattern is the command searching for? This functionality

looks benign and simple enough in this example, but Perl's pattern

matching is so rich and useful that I'm going to explain the syntax

briefly.

<P>

Regular expressions are familiar to veteran UNIX users, but they

are likely to be Greek to everyone else. In its simplest form,

a <I>regular expression</I> is a group of letters between two

slashes, as in <TT>/word/</TT>. You might use a regular expression

as follows:

<BLOCKQUOTE>

<PRE>

if ($var=~/word/) { #do something here }

</PRE>

</BLOCKQUOTE>

<P>

The conditional in this statement evaluates to <TT>true</TT> if

<TT>$var</TT> contains the string <TT>word</TT>. This use of regular

expressions is useful but very simple; Perl offers so much more.

<P>

First, Perl regular expressions, like normal UNIX regular expressions,

provide a set of characters called <I>metacharacters</I>, which

have special meaning within a search pattern. These characters

are listed in Table 2.2.<BR>

<P>

<CENTER><B>Table 2.2&nbsp;&nbsp;Perl Regular-Expression Metacharacters</B></CENTER>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD WIDTH=96><B>Character</B></TD><TD WIDTH=480><B>Meaning</B>

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><TT>^</TT></TD><TD WIDTH=480>Matches the start of the line or variable that is being searched.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><TT>$</TT></TD><TD WIDTH=480>Matches the end of the line.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><TT>.</TT> (period)</TD><TD WIDTH=480>Matches any character except a new-line character.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><TT>\</TT></TD><TD WIDTH=480>When followed by another metacharacter, the two metacharacters combined match the second character.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><TT>()</TT></TD><TD WIDTH=480>Groups the enclosed pattern for later reference. The first such grouping is saved in <TT>$1</TT>; the second, in <TT>$2</TT>; and so on.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><TT>[]</TT></TD><TD WIDTH=480>Encloses a list of characters, any one of which you want to match.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96>|</TD><TD WIDTH=480>Provides <TT>or</TT> functionality.

</TD></TR>

</TABLE></CENTER>

<P>

<P>

In addition to metacharacters, Perl provides a set of predefined

character classes, which are very useful; they are shown in Table

2.3. Each class is designated by a string containing a backslash

followed by a single character.<BR>

<P>

<CENTER><B>Table 2.3&nbsp;&nbsp;Predefined Character Classes</B></CENTER>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><B>String</B></CENTER></TD><TD WIDTH=480><B>Meaning</B>

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>\d</TT></CENTER></TD><TD WIDTH=480>Matches any digit; same as <TT>[0..9]</TT> or <TT>[0123456789]</TT>

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>\D</TT></CENTER></TD><TD WIDTH=480>Matches any nondigit character

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>\s</TT></CENTER></TD><TD WIDTH=480>Matches any white-space character (for example, space and tab)

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>\S</TT></CENTER></TD><TD WIDTH=480>Matches any non-white-space character

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>\w</TT></CENTER></TD><TD WIDTH=480>Matches a word character: letters, digits, and underscore characters (_)

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>\W</TT></CENTER></TD><TD WIDTH=480>Matches a nonword character

</TD></TR>

</TABLE></CENTER>

<P>

<P>

Finally, Perl defines a set of quantifiers (shown in Table 2.4)

that you can use to modify your pattern.<BR>

<P>

<CENTER><B>Table 2.4&nbsp;&nbsp;Regular-Expression Character Quantifiers</B></CENTER>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD WIDTH=96><B>String</B></TD><TD WIDTH=480><B>Meaning</B>

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><TT>*</TT></TD><TD WIDTH=480>Matches the preceding character zero or more times

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><TT>+</TT></TD><TD WIDTH=480>Matches the preceding character one or more times

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><TT>?</TT></TD><TD WIDTH=480>Matches the preceding character zero times or one time

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><TT>{x}</TT></TD><TD WIDTH=480>Matches the preceding character exactly x times

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><TT>{x,y}</TT></TD><TD WIDTH=480>Matches the preceding character at least x times and at most y times

</TD></TR>

</TABLE></CENTER>

<P>

<P>

A couple of examples may help make all this information a little

clearer. The pattern <TT>/w..d/</TT>, for example, would match

<I>word</I> and <I>wand</I>; it would also match <I>forwarding</I>

and even <I>how odd</I>. So in the end, this pattern wouldn't

be very useful. If you want to look in a string for four-letter

words that start with <I>w</I> and end with <I>d</I>, you might

use something like <TT>/\sw\w\wd\s/</TT>. If you want to find

these occurrences and also save only the word (without the surrounding

white space), you would modify this pattern to <TT>/\s(w\w\wd)\s/</TT>.

So whenever this pattern matched, you would be able to find the

word in <TT>$1</TT>.

<P>

You can also search for more complex patterns. Consider this pattern:

<TT>/[ ^]\w(\w{2}) \w$1 \w$1[ $]/</TT>. You might use this pattern

to find the name of a certain canine cop and similar three-word

phrases. This pattern would match <I>rin tin tin</I>, <I>fun gun

run</I>, or even <I>six six six</I>; I think you get the idea.

<P>

In the Guestbook script, the search text is <TT>%(..)</TT>. The

percentage sign is a normal character. You're looking for a percentage

sign, which is why <TT>%</TT> is in the pattern. All of the following

four characters are metacharacters. You're not actually looking

for two periods enclosed in parentheses; the period stands for

any character. Therefore, you're looking for any two characters.

The parentheses mean that you want to save the text that matches

the enclosed portion of the pattern for later use.

<P>

This pattern will match something like <TT>%0D</TT>, placing <TT>0D</TT>

in the variable <TT>$1</TT>. The entire matched string then is

replaced by the replacement text. Because the <TT>e</TT> option

is specified after the last slash, the replacement text is evaluated

as an expression before replacement.

<P>

The replacement expression contains two functions. The innermost

function <TT>hex($1)</TT> is evaluated first. This function takes

the two characters following any percentage sign and converts

them from a hexadecimal number to a decimal number. That decimal

number then acts as the second argument of the <TT>pack()</TT>

function. <TT>pack()</TT> is used to pack the second argument

into a binary value, as in the method designated by the first

value. In this case, the <TT>c</TT> in the first argument tells

<TT>pack</TT> to transform the number in the second argument into

a character. Basically, this method is a fancy way of translating

an integer into its corresponding ASCII character.

<P>

In the Location box in figure 2.2, the comma after <TT>Hey</TT>

is translated into <TT>%2C</TT> by the Web server. The hexadecimal

number 2C is the decimal number 44; the comma is ASCII character

number 44.

<P>

The final piece of information that you should know about line

7 in Listing 2.2 is that in addition to the <TT>e</TT> option,

the <TT>g</TT> option is specified. This option indicates that

the specified pattern should be replaced every time it occurs

in the <TT>$content</TT> variable. Without the <TT>g</TT> option,

the command would end immediately after the first time that the

pattern matched and the text was replaced.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>TIP</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

A common mistake that beginners make with <TT>tr///</TT> or <TT>s///</TT> is to accidentally use the plain <TT>=</TT> operator instead of the binding <TT>=~</TT> operator. If you run into a strange problem with a script and think that the problem is 
related to <TT>s///</TT> or <TT>tr///</TT>, but can't figure it out, check to see whether you're using the proper operator between the sides of the expression. The mistake is an easy one to make-and an easy one to miss when you're looking for problems.

</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<P>

Line 8 simply associates each key and freshly translated value

in the <TT>%fields</TT> hash.

<P>

Now look at a short example to make sure that all the preceding

information makes some sense. The name in figure 2.1 is entered

in the text-entry field created with this code:

<BLOCKQUOTE>

<PRE>

&lt;dd&gt;&lt;input type=text name=name size=30&gt;

</PRE>

</BLOCKQUOTE>

<P>

Because this field is the first field in the form, the first element

in <TT>@pairs</TT> contains <TT>name=Joe+User</TT> after the information

in figure 2.1 is submitted. So you can see that the names of the

fields in the form are passed directly to the script. If you process

the provided data properly, you end up with an associative array

with keys that correspond to the names of the fields in the form.

Thus, in this example <TT>$fields{'name'}</TT> equals <TT>Joe

User</TT>.

<H3><A NAME="PrintingthePage">

Printing the Page</A></H3>

<P>

Now that the form data is properly translated, you want to output

data to the user. Line 10 prints a header. Whenever you print

information from your script back to the user, you have to print

this line (or a similar one). The header tells the browser the

type of information contained in the document that the script

is about to produce (thus, <TT>&quot;Content-type&quot;</TT>).

Notice the <TT>\n\n</TT> at the end of the quoted string. The

backslash is an escape sequence. In a string enclosed in double

quotes in a Perl script, escape sequences are translated into

special characters that you would not otherwise be able to include

in a string (see Table 2.5). In this case, <TT>\n</TT> translates

into a new line. The two new lines after the header are required,

according to the HTTP specification.

<P>

In addition to <TT>\n</TT>, several escape sequences in Perl allow

programmers to output special characters. Table 2.5 describes

the escape sequences.<BR>

<P>

<CENTER><B>Table 2.5&nbsp;&nbsp;Escape Sequences for Special Characters

in Interpolated (Double-Quoted) Strings</B></CENTER>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><B>String</B></CENTER></TD><TD WIDTH=480><B>Translation</B>

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>\a</TT></CENTER></TD><TD WIDTH=480>Produces a bell character.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>\cX</TT></CENTER></TD><TD WIDTH=480>Produces a control character. <TT>\cM,</TT> for example, translates into Ctrl+M or a carriage return.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>\e</TT></CENTER></TD><TD WIDTH=480>Produces an escape character.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>\E</TT></CENTER></TD><TD WIDTH=480>Ends a case modification started with <TT>\L</TT> or <TT>\U</TT>.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>\f</TT></CENTER></TD><TD WIDTH=480>Produces a form feed.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>\l</TT></CENTER></TD><TD WIDTH=480>Makes the next character lowercase.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>\L</TT></CENTER></TD><TD WIDTH=480>Makes all succeeding characters until the next <TT>\E</TT> lowercase.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>\n</TT></CENTER></TD><TD WIDTH=480>Produces a new line.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>\Onn</TT></CENTER></TD><TD WIDTH=480>Produces the character with the octal ASCII character code <TT>nn</TT>.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>\Q</TT></CENTER></TD><TD WIDTH=480>Puts backslashes before any regular-expression metacharacters until the next <TT>\E</TT>.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>\r</TT></CENTER></TD><TD WIDTH=480>Produces a return.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>\t</TT></CENTER></TD><TD WIDTH=480>Produces a tab.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>\u</TT></CENTER></TD><TD WIDTH=480>Makes the next character uppercase.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>\U</TT></CENTER></TD><TD WIDTH=480>Makes all succeeding characters uppercase until the next <TT>\E</TT>.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><CENTER><TT>\v</TT></CENTER></TD><TD WIDTH=480>Produces a vertical tab.

</TD></TR>

</TABLE></CENTER>

<P>

<P>

The final three lines of the script print the necessary HTML to

make a simple page for the user to view. Notice that the script

is still printing double-quoted strings. The double quotes tell

Perl not only to translate the escape sequences, but also to print

the contents of any variable referenced in the string. If you

mistakenly enclosed this string in single quotes, instead of the

value of <TT>$fields{'name'}</TT>, enclosed in some HTML tags

and followed by a new line, the script would have printed the

string literally-<TT>&quot;&lt;h2&gt;$fields{'name'}&lt;/h2&gt;\n.&quot;</TT>

Clearly, that result is not what you want.

<P>

Always remember that double-quoted strings are parsed and that

variables and escape sequences are translated appropriately. Single-quoted

strings are not parsed and are interpreted literally.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>TIP</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

When you're creating HTML forms, remember that you will be using the names of your various input fields as keys for associative arrays. For ease of programming, you'll want to keep the names as short as possible.</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<H3><A NAME="CreatingaScriptonYourWebServer">

Creating a Script on Your Web Server</A></H3>

<P>

Now that you know some basic Perl, you'll want to know how you

create a Perl script on your computer. The procedure isn't difficult.

Perl scripts are just simple text files. If you have a favorite

way of creating HTML files on your server, you can use the same

method to program in Perl.

<P>

Some people edit their scripts on their desktop computers (using

something like Wordpad in Windows 95 or SimpleText on a Macintosh),

save the scripts as text files, and then transfer them to the

server with FTP. Using this method to write a large number of

scripts, however, would be tedious, so most people find a file-editor

program to use on the Web server computer.

<P>

Many UNIX veterans swear by an editor called vi. In fact, many

of these people say that if you don't use vi as your only editor,

you must be a UNIX dabbler. Don't listen to them. I'm sure that

vi is a wonderful text editor, but I discovered early in my experience

with UNIX that its command structure was so counterintuitive that

it was useless for me. So I looked around until I found an editor

called joe, which is the only text editor that I use now. joe's

commands are based on the commands in an early DOS-based word

processor called Wordstar, which I used to use, so joe's commands

were a snap for me to pick up. (Don't tell anyone; they might

not respect me as a programmer.) You also have other options.

If you have experience with the UNIX mail program pine, you may

want to try pico, an editor that uses the same commands as the

message editor in pine.

<P>

My point in this little digression is that you should find and

editor that is quick and easy for you to use. Most CGI scripts

are short and simple, so you don't need many advanced features.

<P>

One final note about script-file creation: when you first make

a file on a UNIX computer, the file has a default set of file

permissions. A file's <I>permissions</I> tell the operating system

what a user can do with that file. Usually, default permissions

do not allow that file to be executed as a program, so you'll

have to change them. The command that you use for this purpose

is <TT>chmod</TT>. In most cases, you want to issue the command

<TT>chmod 755 scriptname</TT> after you create your Perl scripts;

this command gives the file proper permissions for execution by

the Web server. For more information about the <TT>chmod</TT>

command, type <B>man chmod</B> at the command prompt on your UNIX

server.

<H3><A NAME="CallingaCGIScriptDirectly">

Calling a CGI Script Directly</A></H3>

<P>

With the information provided in the preceding few pages, and

with a little knowledge of your Web server and operating system,

you should now be able to use a Perl CGI script to process information

from a form and print a simple page. This knowledge is a good

start; now you learn how to build on it.

<P>

In addition to processing form input, CGI can be used to create

and display documents on-the- fly. To start this example, I modified

Listing 2.2 slightly to come up with the script shown in Listing

2.3.

<HR>

<BLOCKQUOTE>

<B>Listing 2.3&nbsp;&nbsp;Revised Guestbook Script (GUESTBOOK2.PL)

<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl

$temp=$ENV{'QUERY_STRING'};

@pairs=split(/&amp;/,$temp);

foreach $item(@pairs) {

($key,$content)=split (/=/,$item,2);

$content=~tr/+/ /;

$content=~ s/%(..)/pack(&quot;c&quot;,hex($1))/ge;

$fields{$key}=$content;

}

$fields{'comment'}=~s/\cM//g;

$fields{'comment'}=~s/\n\n/&lt;p&gt;/g;

$fields{'comment'}=~s/\n/&lt;br&gt;/g;



($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);

if (length ($min) == 1) {$min = '0'.$min;}

$date=&quot;$mon/$mday/$year, $hour:$min&quot;;



open (gbfile, &quot;&gt;&gt; guestbook.txt&quot;);

print gbfile $date,&quot;::$fields{'name'}::$fields{'comment'}\n&quot;;

close (gbfile);

print &quot;Content-type: text/html\n\n&quot;;

print &quot;&lt;body bgcolor=\&quot;#FFFFFF\&quot;&gt;\n&quot;;

print &quot;&lt;h2&gt;$fields{'name'}&lt;/h2&gt;\n&quot;;

print &quot;$fields{'comment'}\n&quot;;

</PRE>

</BLOCKQUOTE>

<HR>

<P>

This script functions exactly like the original from the user's

standpoint. A couple of key differences exist, however.

<P>

First, immediately after processing the data as in the original

version of the script, the script performs three additional substitutions

on the <TT>$fields{'comment'}</TT> variable. The first of these

three lines removes any carriage returns that the browser inserts

into the <TT>comment</TT> field. The escape character <TT>\c</TT>

tells Perl that the next character in the pattern should be taken

as a control character. Thus, <TT>\cM</TT> matches Ctrl+M, which

is a carriage return.

<P>

The next two lines substitute a <TT>&lt;p&gt;</TT> HTML tag wherever

two new lines appear in a row. The second line substitutes a <TT>&lt;br&gt;</TT>

tag for a single new line. These new tags replace the <TT>&lt;pre&gt;</TT>

tags that were used in Listing 2.2, making the output prettier.

<P>

Next, you see a call to the <TT>localtime()</TT> function. This

function returns a nine-element array that contains various portions

of the current time. I used fairly standard descriptive variables

on the left side of the equation; these variables do a good job

of showing what each element of the returned array is.

<P>

After getting the time information, the script uses the <TT>length()</TT>

function to determine whether <TT>$min</TT> is a single digit.

If so, the script adds <TT>0</TT> on the left, using the dot operator;

otherwise, <TT>$min</TT> is used as is. The script creates a date/time

string from the data returned from <TT>localtime()</TT>.

<P>

This string is used in the final new section of the script. The

first line opens a file handle (<TT>gbfile</TT>) that points to

a file called guestbook.txt. The <TT>&gt;&gt;</TT> characters

before the file name indicate that I want to append to the file.

The following <TT>print</TT> command writes the data from the

form into a single line in the Guestbook file. Notice that this

<TT>print</TT> statement has two arguments. The first argument

is the handle of the file that you're writing to; the second is

the expression to be printed. In all the other <TT>print</TT>

statements used so far, no file handle is specified. In these

cases, the output defaults to <TT>STDOUT</TT>, which is the standard

output on UNIX systems.In CGI scripts, <TT>STDOUT</TT> is ultimately

redirected back to the browser.

<P>

All these changes to the form-processing script are carried out

in such a way that you can save and, later, access all Guestbook

entries. You'll use a CGI script to access the entries. Figure

2.3 shows what simple output might look like.

<P>

<A HREF="f2-3.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/f2-3.gif"><B> Figure 2.3 : </B><I>This screen shows a display of multiple Guestbook entries.



</I></A><P>

<P>

Listing 2.4 shows the Perl script that created the output shown

in figure 2.3.

<HR>

<BLOCKQUOTE>

<B>Listing 2.4&nbsp;&nbsp;Guestbook Display Script (SHOWGUESTBOOK1.PL)

<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl

print &quot;Content-type: text/html\n\n&quot;;

print &quot;&lt;body bgcolor=\&quot;#FFFFFF\&quot;&gt;\n&quot;;

print &quot;&lt;title&gt;Guestbook&lt;/title&gt;\n&quot;;

open (gbfile, &quot;guestbook.txt&quot;);

while (defined($line=&lt;gbfile&gt;)) {

     ($date,$name,$comment)=split(/::/,$line);

     print &quot;&lt;b&gt;$name&lt;/b&gt;, $date&lt;p&gt;\n&quot;;

     print &quot;$comment&lt;hr&gt;&quot;;

}

close (gbfile);

</PRE>

</BLOCKQUOTE>

<HR>

<P>

This script contains only one new concept: the <TT>while</TT>

loop. This loop simply runs through each line of the file referenced

by the <TT>gbfile</TT> file handle. First, the script opens the

file. The <TT>open</TT> command is the same as in the Guestbook

script, with one key difference: the <TT>&gt;&gt;</TT> characters

are missing. When a file is opened with no symbol before the file

name, the file is opened for reading. Then the script in Listing

2.4 starts the <TT>while</TT> loop.

<P>

The conditional for the <TT>while</TT> loop works as follows.

When a file handle is enclosed in angle brackets and evaluated

in a scalar context, it returns the next line of the file. Perl's

<TT>defined()</TT> function evaluates as <TT>true</TT> if the

expression is defined. The expression <TT>$line=&lt;gbfile&gt;</TT>

is undefined (and the loop exits) when all the lines in the file

have been processed. The statements in the loop are fairly simple.

The first line splits the data into three separate variables;

the next two lines print the data.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

Looping through and processing each line in a file is one of the most common operations in Perl. For that reason, a common shortcut is used for that operation. That shortcut looks like this:</BLOCKQUOTE>

<BLOCKQUOTE>

<TT>while (&lt;gbfile&gt;) {<BR>

#process gbfile info here<BR>

}</TT>

</BLOCKQUOTE>

<BLOCKQUOTE>

In a <TT>while</TT> loop, if a file handle enclosed in angle brackets is the only conditional in the loop, the current line from the file is assigned to <TT>$_</TT> each time through the loop. The expression <TT>&lt;gbfile&gt;</TT> is <TT>true</TT> until 
all lines in the file have been read.

</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<P>

At this point, you may be curious about why I didn't just write

the Guestbook information to a straight HTML file in the first

place, so that the user could just call up that file to look at

the Guestbook list. Certainly, that method is an option, and many

guestbook programs do just that. But this method provides some

additional flexibility that straight HTML can't offer.

<P>

If, for example, you want to display only x number of lines on

any given page and limit the total number of entries in the file,

the result would look like figures 2.4, 2.5, and 2.6. Figure 2.4

shows the result of the initial call to this new script. Figure

2.5 shows the page that is returned after the user selects the

<TT>Show next two entries</TT> link in figure 2.4. The URL in

the Location box in figure 2.6 also has a number, but the text

does not include a <TT>Show next...</TT> link.

<P>

<A HREF="f2-4.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/f2-4.gif"><B> Figure 2.4 : </B><I>The screen in this figure shows a new way of displaying the entries.



</I></A><P>

<P>

<A HREF="f2-5.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/f2-5.gif"><B> Figure 2.5 : </B><I>Two more entries are displayed after the user selects the link in  figure 2.4.



</I></A><P>

<P>

<A HREF="f2-6.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/f2-6.gif"><B> Figure 2.6 : </B><I>The final entry is displayed after the user selects the link in figure 2.5. Notice the absence of the final link.



</I></A><P>

<P>

To figure out how this output is produced, examine Listing 2.5,

which contains the SHOWGUESTBOOK2 script.

<HR>

<BLOCKQUOTE>

<B>Listing 2.5&nbsp;&nbsp;Revision of the Guestbook Display Script

(SHOWGUESTBOOK2.PL)<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl

$filepos=$ENV{'PATH_INFO'};

$filepos=~s/^\///;

$filepos=0 if $filepos eq '';

print &quot;Content-type: text/html\n\n&quot;;

print &quot;&lt;body bgcolor=\&quot;#FFFFFF\&quot;&gt;\n&quot;;

print &quot;&lt;title&gt;Guestbook&lt;/title&gt;\n&quot;;

open (gbfile, &quot;guestbook.txt&quot;);

seek (gbfile,$filepos,0);

$i=1;

while (&lt;gbfile&gt;) {

     ($date,$name,$comment)=split(/::/,$_);

     print &quot;&lt;b&gt;$name&lt;/b&gt;, $date&lt;p&gt;\n&quot;;

     print &quot;$comment&lt;hr&gt;&quot;;

     $i++;

     last if $i==3;

}

$newfilepos=tell(gbfile);

if (&lt;gbfile&gt;) {

     print &quot;&lt;a href=/cgi-bin/harlan/showguestbook2/$newfilepos&gt;Show next two

      &aring;entries&lt;/a&gt;\n&quot;;}

close (gbfile);

</PRE>

</BLOCKQUOTE>

<HR>

<P>

The changes in this script introduce one new CGI concept and a

couple of new Perl commands. As pointed out earlier in this section,

the URL in the Location box shown in figures 2.5 and 2.6 has additional

information tacked on at the end. At first glance, this information

might seem to be a bit odd. In figure 2.5, it appears that you're

calling a script called 232 in the /CGI-BIN/HARLAN/SHOWGUESTBOOK2

directory. Clearly, that's not what's happening, though.

<P>

The CGI specification includes an environment variable called

<TT>PATH_INFO</TT>. All CGI-compliant Web servers can translate

any URL appropriately. If the URL that points to a script includes

any information after the script name, all that information is

passed to the script in the <TT>PATH_INFO</TT> environment variable.

<P>

When you click the link at the bottom of figure 2.4, <TT>/232</TT>

is passed to <TT>showguestbook2</TT>. Line 1 of the script assigns

this value to <TT>$filepos</TT>; line 2 removes the leading slash.

To make the script work the first time through (that is, when

<TT>PATH_INFO</TT> contains no information), line 3 makes <TT>$filepos</TT>

zero when it contains the null string. After printing the top

of the document to be sent back to the user and opening the GUESTBOOK.TXT

data file, line 9 performs the key action in the new script.

<P>

Perl's <TT>seek()</TT> function takes three arguments: a file

handle, a position, and a number that indicates what this position

is relative to. In this script, the third argument is zero. This

argument indicates that you want the change in position to be

relative to the top of the file. Because <TT>$filepos</TT> is

232, the <TT>seek()</TT> command in line 9 moves the position

pointer to 232 bytes from the top of the file. This position is

where the script will start reading lines from GUESTBOOK.TXT after

the user clicks the link in figure 2.4, producing the result shown

in figure 2.5. When the user selects the link in figure 2.5, the

script starts reading 582 bytes into the file, producing the output

shown in figure 2.6.<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>TIP</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

<TT>$ENV{'PATH_INFO'}</TT> is an extremely effective means of passing information to scripts. Many times, you can avoid using a trivial form by using <TT>PATH_INFO</TT> instead of the form to pass information.

</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<P>

All this should make sense now, although you might be curious

about where the numbers that end up in the <TT>PATH_INFO</TT>

variable come from. Look at line 16:

<BLOCKQUOTE>

<PRE>

     last if $i==3;

</PRE>

</BLOCKQUOTE>

<P>

The last command is something that you haven't seen before. The

command breaks the script out of a loop when the condition of

the loop otherwise would tell the script to continue. In this

case, you want the loop to end if the counter variable <TT>$i</TT>

equals 3, because if it has reached 3, the script has printed

two Guestbook entries, and you don't want to print any more.

<P>

So you exit the loop and end up at line 18, where you get the

magic number that tells the script where in the file to start

the next time around. The <TT>tell()</TT> command returns the

current file position of the provided file handle. By saving this

value at this point in the script, you know exactly where the

last Guestbook entry that you printed ends and where the next

one begins.

<P>

All you have to do now is print the link at the bottom of the

page. The <TT>if</TT> statement in line 19 makes sure that the

script prints the link only if some entries in the GUESTBOOK.TXT

file haven't been printed.

<H3><A NAME="LimitingDataFileSize">

Limiting Data-File Size</A></H3>

<P>

Now that you have an effective means of printing the Guestbook

entries, you want to make more changes to the Guestbook entry

script, as shown in Listing 2.6.

<HR>

<BLOCKQUOTE>

<B>Listing 2.6&nbsp;&nbsp;The Further-Revised Guestbook Script

(GUESTBOOK3.PL)<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

$date=&quot;$mon/$mday/$year, $hour:$min&quot;;

#revisions start here...

open (gbfile, &quot;guestbook.txt&quot;);

@gbfile=&lt;gbfile&gt;;

close (gbfile);

open (gbfile, &quot;&gt; guestbook.txt&quot;);

print gbfile $date,&quot;::$fields{'name'}::$fields{'comment'}\n&quot;;

$i=1;

foreach (@gbfile) {

     print gbfile $_;

     last if $i==9;

     $i++;

}

close (gbfile);

print &quot;Location: http://192.0.0.1/cgi-bin/harlan/showguestbook2\n\n&quot;;

</PRE>

</BLOCKQUOTE>

<HR>

<P>

Listing 2.6 makes two major changes in the Guestbook entry script.

In line 3, the script opens the GUESTBOOK.TXT file. The script

reads the entire file into an array in line 4 and closes the file

in line 5.

<P>

To reopen the file in line 6, I used the <TT>&gt;</TT> character

to tell Perl that I want to overwrite the file. (Recall that in

the preceding version of this script, I used the <TT>&gt;&gt;</TT>

symbol because I wanted to append to the file.) Why would I want

to overwrite the file? Displaying the entries in reverse chronological

order makes more sense, so I overwrite the file each time to accomplish

this task.

<P>

In line 7, the script writes the new entry to the file. In line

9, the script starts a loop that writes the rest of the old entries

back into the file. Line 11 terminates the loop after 9 entries

have been written to the file, discarding the last entry. This

line limits the file to the 10 most recent entries.

<H3><A NAME="UsingtheLocationHeader">

Using the Location Header</A></H3>

<P>

Now that the output has been refined, you want to send the user

straight to the Guestbook display script after he signs in. That

task is exactly what the last line of Listing 2.6 accomplishes.

<P>

When a browser receives a properly formatted Location header,

it knows to retrieve the document specified after the colon. This

feature can save a programmer a great deal of time. Instead of

reinventing the wheel that displays the data by churning out HTML

in the form-processing script, the programmer can write output

code only once, in some cases. This function isn't a cure-all,

but you should keep it in mind.

<H3><A NAME="UsingCGIinServerSideIncludes">

Using CGI in Server-Side Includes</A></H3>

<P>

If you have done extensive HTML development, you may know about

<I>server-side includes</I>, or <I>SSI</I>-a set of functions

built into some Web servers that allow a developer to use special

HTML directives to insert some data into documents on the fly.

<P>

The information that you can insert can take the form of a local

file or a file referenced by a URL. You can also include information

from a limited set of variables. Finally, you can execute scripts

to output the data that will be inserted into the document; for

details, see the sidebar titled &quot;What Else Can You Do with

SSI?&quot;

<P>

One thing that you may notice about the page shown in figure 2.7

is the fact that the file name has changed to GUESTBOOK.SHTML.

The change in the file extension tells the server that it should

check the file for SSI commands. The file extension depends on

server configuration, but .SHTML is a common choice.

<P>

<A HREF="f2-7.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/f2-7.gif"><B> Figure 2.7 : </B><I>This new Guestbook form includes a quote to spice up the page a little.



</I></A><P><BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>What Else Can You Do with SSI?</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

When they're available, server-side includes are a good way to make simple pages more interesting. In this chapter, you see an example of executing CGI to create dynamic sections in otherwise-static documents. This sidebar describes what else SSI can 
do.</BLOCKQUOTE>

<BLOCKQUOTE>

The format for any SSI command is as follows:</BLOCKQUOTE>

<BLOCKQUOTE>

<TT>&lt;!-#command option=value-&gt;</TT>

</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<P>

Table 2.6 lists the SSI commands and their options.<BR>

<P>

<CENTER><B>Table 2.6&nbsp;&nbsp;SSI Commands and Options</B></CENTER>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD WIDTH=96><B>Command</B></TD><TD WIDTH=96><B>Options</B>

</TD><TD WIDTH=384><B>Explanation</B></TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><TT>config</TT></TD><TD WIDTH=96><TT>errmsg</TT>

</TD><TD WIDTH=384>Sets the value that will be sent if an error occurs when future SSI commands are parsed in a document.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96>&nbsp;</TD><TD WIDTH=96><TT>timefmt</TT></TD>

<TD WIDTH=384>Sets the format for outputting dates from SSI commands. See the <TT>strftime()</TT> UNIX manual page for details on how to format dates with this command.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96>&nbsp;</TD><TD WIDTH=96><TT>sizefmt</TT></TD>

<TD WIDTH=384>Sets the manner in which file sizes are displayed. Set this option to <TT>bytes</TT> (to display SSI file-size command results in bytes) or <TT>abbrev</TT> (to display sizes in kilobytes or mega-bytes, as appropriate).

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><TT>Echo</TT></TD><TD WIDTH=96><TT>var</TT></TD>

<TD WIDTH=384>Prints the specified variable. All CGI environment variables and the following SSI variables can be echoed: <TT>DATE_GMT, DATE_LOCAL, DOCUMENT_NAME, DOCUMENT_URI, LAST_MODIFIED</TT>, and <TT>QUERY_STRING_UNESCAPED</TT>.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><TT>Exec</TT></TD><TD WIDTH=96><TT>cmd</TT></TD>

<TD WIDTH=384>Executes the specified command, using /BIN/SH, and includes the resulting output on the page. Requires a physical path to the command.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96>&nbsp;</TD><TD WIDTH=96><TT>cgi</TT></TD><TD WIDTH=384>Executes the specified CGI script. Takes a virtual path to the script (for example, /CGI-BIN/HARLAN/FORTUNE rather than /USR/LOCAL/ETC/HTTPD/CGI-BIN/HARLAN/FORTUNE).

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><TT>Flastmod</TT></TD><TD WIDTH=96><TT>file</TT>

</TD><TD WIDTH=384>Includes the last modification date of the indicated file in the document. Requires a physical path to the document.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96>&nbsp;</TD><TD WIDTH=96><TT>virtual</TT></TD>

<TD WIDTH=384>Same as <TT>file</TT>, except that it takes a virtual path.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><TT>Fsize</TT></TD><TD WIDTH=96><TT>file</TT>

</TD><TD WIDTH=384>Includes the size of the indicated file in the document. Requires a physical path to the document. 

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96>&nbsp;</TD><TD WIDTH=96><TT>virtual</TT></TD>

<TD WIDTH=384>Same as <TT>file</TT>, except that it takes a virtual path.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96><TT>Include</TT></TD><TD WIDTH=96><TT>file</TT>

</TD><TD WIDTH=384>Includes the text of the indicated file in the document. Requires a physical path to the document.

</TD></TR>

<TR VALIGN=TOP><TD WIDTH=96>&nbsp;</TD><TD WIDTH=96><TT>virtual</TT></TD>

<TD WIDTH=384>Same as <TT>file</TT>, except that it takes a virtual path.

</TD></TR>

</TABLE></CENTER>

<P>

<P>

As you can see, SSI provides a fairly rich set of features to

the programmer. You might use SSI if you have an existing set

of documents to which you want to add modification dates. You

also could have a file that you want to appear on several of your

pages. You could use the SSI include command on each of those

pages instead of copying the document into each page individually.

<P>

One problem is the fact that SSI may not be available on all Web

servers; it opens some security holes that some site administrators

are not willing to risk. If you administer your own site and trust

all the page designers on your site, however, SSI is a useful

tool in your Web development arsenal.

<P>

The following paragraphs focus on the <TT>exec</TT> command. Refer

to figure 2.7, which appears earlier in this section. This figure

shows the familiar Guestbook entry form, with a twist: a &quot;quote

of the moment&quot; appears at the top of the form. Knowing what

you do from having read this far, you probably could write a CGI

script that would read a quote from a file, print that quote,

and then print the HTML for the form.

<P>

But that's not how I created this page. Listing 2.7 shows the

source for the page in figure 2.7.

<HR>

<BLOCKQUOTE>

<B>Listing 2.7&nbsp;&nbsp;Source for GUESTBOOK.SHTML<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

&lt;HTML&gt;

&lt;body bgcolor=&quot;#FFFFFF&quot;&gt;

&lt;title&gt;Guestbook&lt;/title&gt;

&lt;h2&gt;Please Sign My Guestbook&lt;/h2&gt;

&lt;b&gt;...but first, the quote of the moment:&lt;/b&gt;&lt;p&gt;

&lt;!--#exec cgi=&quot;/cgi-bin/harlan/fortune&quot;--&gt;

&lt;b&gt;...We now return you to our regularly scheduled guestbook.&lt;/b&gt;&lt;p&gt;

&lt;form method=get action=&quot;/cgi-bin/harlan/guestbook&quot;&gt;

&lt;dt&gt;Name:&lt;br&gt;

&lt;dd&gt;&lt;input type=text name=name size=30&gt;

&lt;dt&gt;Comment:&lt;br&gt;

&lt;dd&gt;&lt;textarea name=comment rows=5 cols=50&gt;&lt;/textarea&gt;&lt;p&gt;

&lt;input type=submit value=&quot;Sign In&quot;&gt;

&lt;/form&gt;

&lt;/html&gt;

</PRE>

</BLOCKQUOTE>

<HR>

<P>

You can see that I added three lines to the document. Two lines

are straight HTML. The third line-the one that you may not recognize-is

an SSI command. The syntax is straightforward; it says, &quot;Execute

the CGI script /CGI-BIN/HARLAN/FORTUNE.&quot; Easy, right?<BR>

<P>

<CENTER>

<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>

<TR VALIGN=TOP><TD><B>NOTE</B></TD></TR>

<TR VALIGN=TOP><TD>

<BLOCKQUOTE>

If you point your browser at GUESTBOOK.SHTML and then use your browser's View Source command, you do not see the code in Listing 2.7. When you use SSI, the commands inside the <TT>&lt;!-- ... --&gt;</TT> tags are translated into straight HTML before they 
get to the browser.

</BLOCKQUOTE>



</TD></TR>

</TABLE></CENTER>

<P>

<P>

The <TT>fortune</TT> CGI script isn't difficult, either. Listing

2.8 shows the code.

<HR>

<BLOCKQUOTE>

<B>Listing 2.8&nbsp;&nbsp;Code Listing for fortune (FORTUNE.PL)

<BR>

</B>

</BLOCKQUOTE>

<BLOCKQUOTE>

<PRE>

#!/usr/bin/perl

open (fortune,&quot;/usr/games/fortune |&quot;);

print &quot;Content-type: text/html\n\n&quot;;

print &quot;&lt;pre&gt;\n&quot;;

while (&lt;fortune&gt;){

     print &quot;     $_&quot;;

}

print &quot;&lt;/pre&gt;&quot;;

</PRE>

</BLOCKQUOTE>

<HR>

<P>

This script presents only one new concept. Look at line 2. You

saw the o<TT>pen()</TT> command earlier in this chapter, but this

time, it uses a new option. The pipe (|) at the end of <TT>/usr/games/fortune

</TT>| tells Perl to run the operating-system command /USR/GAMES/FORTUNE

(on the server machine) and to provide (or pipe) the information

in the given file handle as though the result of the command was

being read from a file.

<P>

<TT>fortune</TT> is a common UNIX command that spits out a random

quote, so if you look at the rest of the script, you can see what

happens. First, the script prints the standard HTML header; then

it outputs the opening <TT>&lt;pre&gt;</TT> tag. Next, the script

simply loops through the lines of output from the command. Then

the script prints each line of output back to the browser with

five leading spaces, indenting the output on the resulting page.

Finally, the script prints the closing <TT>&lt;/pre&gt;</TT> tag.

<P>

The result is the page shown in figure 2.7. Of course, the next

user (or you, if you reload) will see a different quote at the

top of the page.

<H2><A NAME="FromHere"><FONT SIZE=5 COLOR=#FF0000>

From Here...</FONT></A></H2>

<P>

You now have basic knowledge of CGI and Perl. In this chapter,

you learned how to process data from a form and print a properly

formatted page. You also learned how to call Perl scripts directly

and how to use Perl in server-side includes. Finally, you were

exposed to a useful subset of Perl. Regular expressions, saving

and retrieving data in text files, printing, and looping should

all be within your grasp now.

<P>

For further information, read the following chapters:

<UL>

<LI><A HREF="ch3.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch3.htm" >Chapter 3</A> &quot;Advanced Form Processing and Data Storage.&quot;

Look in this chapter for more advanced information on form processing.

<LI><A HREF="ch6.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch6.htm" >Chapter 6</A> &quot;Using Dynamic Pages.&quot; Head to this chapter

for more examples of SSI and on-the-fly pages.

<LI><A HREF="ch15.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch15.htm" >Chapter 15</A>, &quot;Function List.&quot; If you want to strike

out on your own, you'll find extensive Perl syntax information

in this chapter.

</UL>

<HR>



<CENTER><P><A HREF="ch1.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch1.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="index.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<A HREF="ch3.htm" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/ch3.htm"><IMG SRC="nc.gif" tppabs="http://www.mcp.com/818726400/0-7897/0-7897-0659-8/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A>

<HR WIDTH="100%"></P></CENTER>

</BODY>

</HTML>
