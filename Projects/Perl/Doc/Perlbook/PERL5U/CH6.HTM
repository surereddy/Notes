<HTML>

<HEAD>
   <TITLE>Chapter 6 -- Binding Variables to Objects</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT COLOR=#FF0000>Chapter 6</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Binding Variables to Objects</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#ThetieFunction" >The tie() Function</A>
<LI><A HREF="#TyingScalars" >Tying Scalars</A>
<LI><A HREF="#TyingtoanArray" >Tying to an Array</A>
<LI><A HREF="#TyingtoanAssociativeArray" >Tying to an Associative Array</A>
<LI><A HREF="#ForMoreInformation" >For More Information</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
This chapter is dedicated to describing how the <TT><FONT FACE="Courier">tie()</FONT></TT>
function works in Perl. The <TT><FONT FACE="Courier">tie()</FONT></TT>
function enables you to create variables that are tied to specific
methods called when a variable is written to or read from. Using
the <TT><FONT FACE="Courier">tie()</FONT></TT> function, you can
eliminate the need for calling methods designed specifically for
certain types of variables.
<H2><A NAME="ThetieFunction"><FONT SIZE=5 COLOR=#FF0000>The </FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">tie()</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Function</FONT></A></H2>
<P>
The <TT><FONT FACE="Courier">tie()</FONT></TT> function is used
to bind a variable to an object class. Here's the syntax:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">tie ($<I>variable,</I>$<I>classname,</I>@<I>list</I>);</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">tie()</FONT></TT> function binds
a variable to a class that then provides the methods for the variable.
The <TT><FONT FACE="Courier">$<I>variable</I></FONT></TT> has
to be set to the name of the variable to be tied. The <TT><FONT FACE="Courier">$<I>classname</I></FONT></TT>
is the name of the class implementing objects to which you want
the variable tied. The <TT><FONT FACE="Courier">@<I>list</I></FONT></TT>
is the list of arguments that may be required for this variable's
class methods.
<P>
The object returned by the <TT><FONT FACE="Courier">tie()</FONT></TT>
function is just like the <TT><FONT FACE="Courier">new()</FONT></TT>
function for an object. You can use the returned value from the
<TT><FONT FACE="Courier">tie()</FONT></TT> function to access
other methods in the class you just tied the object to.
<P>
Once you tie a variable to a class, the class's behavior is reflected
in the way you access the variable. Each of the methods for the
type of object is called when the type of action for the variable
is seen by Perl. Three types of objects can be tied to classes:
scalars, arrays, and associative arrays.
<P>
It's often necessary to disassociate an object from a class. This
is done with the use of the <TT><FONT FACE="Courier">untie()</FONT></TT>
function. Simply call the <TT><FONT FACE="Courier">untie($<I>object</I>)</FONT></TT>
function and you're done. The <TT><FONT FACE="Courier">untie()</FONT></TT>
function works whether you are tied to a scalar, array, or hash
object. The next three sections illustrate how to use <TT><FONT FACE="Courier">tie()</FONT></TT>
on each of these objects.
<H2><A NAME="TyingScalars"><FONT SIZE=5 COLOR=#FF0000>Tying Scalars</FONT></A>
</H2>
<P>
A class implementing a scalar object that can be tied to must
implement these four methods:
<UL>
<LI><TT><FONT FACE="Courier">TIESCALAR classname, LIST</FONT></TT>
<LI><TT><FONT FACE="Courier">FETch this</FONT></TT>
<LI><TT><FONT FACE="Courier">STORE this, value</FONT></TT>
<LI><TT><FONT FACE="Courier">DESTROY this</FONT></TT>
</UL>
<P>
Think of these methods as events for the class. When a variable
is first tied to a class, the <TT><FONT FACE="Courier">TIESCALAR</FONT></TT>
method is called. Every time the tied variable is read from, the
value from the <TT><FONT FACE="Courier">FETch</FONT></TT> method
is returned. When the tied variable is assigned to, the <TT><FONT FACE="Courier">STORE</FONT></TT>
method is called. Finally, when the tied variable loses scope,
the <TT><FONT FACE="Courier">DESTROY</FONT></TT> method is called.
<P>
Listing 6.1 contains a script that uses the <TT><FONT FACE="Courier">tie()</FONT></TT>
function for the <TT><FONT FACE="Courier">Knot</FONT></TT> class.
<HR>
<BLOCKQUOTE>
<B>Listing 6.1. Using the </B><TT><B><FONT FACE="Courier">tie()</FONT></B></TT><B>
function.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2<BR>
&nbsp;3 push(@Inc,&quot;.&quot;);
<BR>
&nbsp;4 use Knot;<BR>
&nbsp;5<BR>
&nbsp;6 #<BR>
&nbsp;7 # From now on the
variable $currentTime<BR>
&nbsp;8 # will behave as defined in functions in Knot.pm<BR>
&nbsp;9 #<BR>
10 tie $currentTime, 'Knot';<BR>
11<BR>
12 #<BR>
13 # Test the FETch method<BR>
14 #<BR>
15 $x = $currentTime;<BR>
16 print &quot; x= $x\n&quot;;<BR>
17 print &quot; current = $currentTime\n&quot;;<BR>
18<BR>
19 #<BR>
20 # Test the STORE method<BR>
21 #<BR>
22 # In Knot.pm we have defined the $currentTime<BR>
23 # variable to behave as a readonly object.<BR>
24 # The following message will bail out with an error message.
<BR>
25 #<BR>
26 $currentTime = $x;<BR>
27<BR>
28<BR>
29 #<BR>
30 # As soon as we drop out of the script here, the DESTROY<BR>
31 # method will be called on $currentTime.<BR>
32 #</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Let's examine the code in Listing 6.1 to see where the methods
for <TT><FONT FACE="Courier">Knot.pm</FONT></TT> are invoked.
In line 3, the address of the current directory is added to search
for included modules. In line 4, the <TT><FONT FACE="Courier">Knot.pm</FONT></TT>
module is requested with the <TT><FONT FACE="Courier">use</FONT></TT>
statement. The <TT><FONT FACE="Courier">Knot.pm</FONT></TT> file
contains the module code for the class that allows variables to
be tied.
<P>
In line 10, the variable <TT><FONT FACE="Courier">$currentTime</FONT></TT>
is tied to the class <TT><FONT FACE="Courier">Knot</FONT></TT>.
The <TT><FONT FACE="Courier">TIESCALAR</FONT></TT> function in
<TT><FONT FACE="Courier">Knot.pm</FONT></TT> is called at this
point. There are no additional arguments to be passed to the <TT><FONT FACE="Courier">TIESCALAR</FONT></TT>
function, so only two parameters, the variable number and the
class name, are sent.
<P>
In line 15, the <TT><FONT FACE="Courier">$currentTime</FONT></TT>
variable is read from and the value of <TT><FONT FACE="Courier">$currentTime</FONT></TT>
is assigned to <TT><FONT FACE="Courier">$x</FONT></TT>. Instead
of treating <TT><FONT FACE="Courier">$currentTime</FONT></TT>
as a normal variable, Perl uses the <TT><FONT FACE="Courier">FETch</FONT></TT>
method of the tied class. The <TT><FONT FACE="Courier">FETch</FONT></TT>
method returns the current date in this example. You can write
your own function. In line 17, the <TT><FONT FACE="Courier">$currentTime</FONT></TT>
variable is accessed again. This time, the <TT><FONT FACE="Courier">FETch</FONT></TT>
method is called again.
<P>
The program must not attempt to assign a value to the <TT><FONT FACE="Courier">$currentTime</FONT></TT>
variable. See line 26 in Listing 6.1. The <TT><FONT FACE="Courier">Knot.pm</FONT></TT>
module is implemented to allow only read-only variables; therefore,
the <TT><FONT FACE="Courier">FETch</FONT></TT> function will print
an error message when the code at line 26 is executed.
<P>
Finally, the <TT><FONT FACE="Courier">DESTROY</FONT></TT> method
is called when the <TT><FONT FACE="Courier">$currentTime</FONT></TT>
variable is destroyed. The destruction is done automatically by
Perl when the <TT><FONT FACE="Courier">$currentTime</FONT></TT>
variable goes out of scope. In this example, the <TT><FONT FACE="Courier">DESTROY</FONT></TT>
method simply prints an error message.
<P>
Here is the output from Listing 6.1.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;x= Sat Jun&nbsp;&nbsp;1 12:54:25
CDT 1996<BR>
<BR>
&nbsp;current = Sat Jun&nbsp;&nbsp;1
12:54:25 CDT 1996<BR>
<BR>
Hey dude! We are making this readonly!<BR>
&nbsp;at Knot.pm line 54<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">Knot::STORE
called at ./6_1.pl line 26<BR>
<BR>
Knot::&nbsp;&nbsp;unknotted!</FONT></TT>
</BLOCKQUOTE>
<P>
Now let's look at the <TT><FONT FACE="Courier">Knot.pm</FONT></TT>
file in Listing 6.2.
<HR>
<BLOCKQUOTE>
<B>Listing 6.2. The </B><TT><B><FONT FACE="Courier">Knot.pm</FONT></B></TT><B>
file.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2<BR>
&nbsp;3 # ----------------------------------------------------------------
<BR>
&nbsp;4 # Sample file that shows how to tie variables to classes.
<BR>
&nbsp;5 #<BR>
&nbsp;6 # This library is hereby placed in the public domain.
Copy freely<BR>
&nbsp;7 # as long as you
give me credit for it!<BR>
&nbsp;8 # Kamran Husain. khusain@ikra.com<BR>
&nbsp;9 # ----------------------------------------------------------------
<BR>
10 package Knot;<BR>
11 use Carp;<BR>
12 use strict;<BR>
13<BR>
14 #<BR>
15 # TIESCALAR classname, argument-list-here<BR>
16 #&nbsp;&nbsp;&nbsp;&nbsp; This is the constructor for the class.&nbsp;&nbsp;It
returns a reference<BR>
17 #&nbsp;&nbsp;&nbsp;&nbsp; to a new object for the class name.
<BR>
18 #<BR>
19 sub TIESCALAR {<BR>
20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $class
= shift;<BR>
21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $this
= {};<BR>
22&nbsp;&nbsp;&nbsp;&nbsp; #<BR>
23&nbsp;&nbsp;&nbsp;&nbsp; # print &quot;\n $class, $this&quot;;
<BR>
24&nbsp;&nbsp;&nbsp;&nbsp; #<BR>
25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
bless \$this, $class;<BR>
26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
27<BR>
28 #<BR>
29 # FETch this<BR>
30 # The FETch method will be triggered every time the tied variable
<BR>
31 # is accessed.<BR>
32 # The only argument to this function is the object itself.
<BR>
33 # In this case, we just return the date.<BR>
34 #<BR>
35 sub FETch {<BR>
36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my $self = shift;<BR>
37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
confess &quot;wrong type&quot; unless ref $self;<BR>
38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
croak &quot;usage error&quot; if @_;<BR>
39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my $override;<BR>
40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
$override = 'date';<BR>
41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return $override;<BR>
42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<BR>
43<BR>
44 #<BR>
45 # STORE this, value<BR>
46 # This method will be triggered every time the tied variable
is<BR>
47 # written to. It expects only two arguments: a reference to
itself<BR>
48 # and a value that is being assigned.<BR>
49 #<BR>
50 sub STORE {<BR>
51&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$self = shift;<BR>
52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;confess
&quot;wrong type&quot; unless ref $self;<BR>
53&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$value = shift;<BR>
54&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;confess
&quot;Hey dude! We are making this readonly!\n&quot;;<BR>
55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
$value;<BR>
56&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
57<BR>
58 #<BR>
59 # DESTROY this<BR>
60 # This method will be triggered when the tied variable needs
to be<BR>
61 # destructed. This method can be just empty for most classes
since<BR>
62 # Perl's garbage collection will.<BR>
63 #<BR>
64<BR>
65 sub DESTROY {<BR>
66&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$self = shift;<BR>
67&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;confess
&quot;wrong type&quot; unless ref $self;<BR>
68&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print
&quot;\nKnot::&nbsp;&nbsp;unknotted!\n&quot;;<BR>
69&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
70<BR>
71 #<BR>
72 # The obligatory ending true statement.<BR>
73 #<BR>
74 1;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
<TT><FONT FACE="Courier">Knot.pm</FONT></TT> defines the package
in line 10 and imports the <TT><FONT FACE="Courier">Carp</FONT></TT>
and <TT><FONT FACE="Courier">strict</FONT></TT> packages in lines
11 and 12, respectively. Line 74 terminates the module.
<P>
Lines 19 through 26 define the <TT><FONT FACE="Courier">TIESCALAR</FONT></TT>
function. The <TT><FONT FACE="Courier">TIESCALAR</FONT></TT> function
behaves a lot like the constructor of an object in Perl. It creates
an associative array and returns a reference to this array after
a call to the <TT><FONT FACE="Courier">bless()</FONT></TT> function.
(<A HREF="ch5.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch5.htm" >See Chapter 5</A>, &quot;Object-Oriented Programming
in Perl,&quot; for more information on <TT><FONT FACE="Courier">bless</FONT></TT>-ing
objects.)
<P>
The <TT><FONT FACE="Courier">FETch</FONT></TT> method starts at
line 35. The <TT><FONT FACE="Courier">FETch</FONT></TT> method
is called every time the tied variable is read from. The only
argument to the <TT><FONT FACE="Courier">FETch</FONT></TT> method
is a reference to the object itself. At line 37, the class type
is confirmed, although it's not absolutely necessary to do this.
Lines 39 through 41 return the current date and time for the value
of the tied variable.
<P>
The <TT><FONT FACE="Courier">STORE</FONT></TT> method is defined
from line 50 through 56. In this case, we do not let values of
the arguments that are passed in be assigned to anything because
we want to make this value a read-only variable. You can easily
modify this function to take some other action than what's shown
in this example. The <TT><FONT FACE="Courier">FETch</FONT></TT>
method takes only two arguments: a reference to itself and a value
that is being assigned. The <TT><FONT FACE="Courier">confess()</FONT></TT>
call is from within the <TT><FONT FACE="Courier">Carp</FONT></TT>
module.
<P>
The <TT><FONT FACE="Courier">DESTROY</FONT></TT> method is called
when the tied variable is destroyed. Normally, this function is
empty. For this example, there is a <TT><FONT FACE="Courier">print</FONT></TT>
statement to show where the <TT><FONT FACE="Courier">DESTROY</FONT></TT>
function is called.
<H2><A NAME="TyingtoanArray"><FONT SIZE=5 COLOR=#FF0000>Tying
to an Array</FONT></A></H2>
<P>
An array variable can be tied to a class in the same manner as
a scalar can be tied to a class. The real difference is that the
input parameters to the methods now need an index used to address
a value in array. A class implementing an ordinary array must
have these methods:
<UL>
<LI><TT><FONT FACE="Courier">TIEARRAY classname, LIST</FONT></TT>
<LI><TT><FONT FACE="Courier">FETch this, key</FONT></TT>
<LI><TT><FONT FACE="Courier">STORE this, key, value</FONT></TT>
<LI><TT><FONT FACE="Courier">DESTROY this</FONT></TT>
</UL>
<P>
The <TT><FONT FACE="Courier">FETch</FONT></TT>, <TT><FONT FACE="Courier">DESTROY</FONT></TT>,
and <TT><FONT FACE="Courier">STORE</FONT></TT> methods have the
same names as those for scalars. However, the name of the constructor
is different-it's called <TT><FONT FACE="Courier">TIEARRAY</FONT></TT>.
Let's define a new array type called <TT><FONT FACE="Courier">Cuboid</FONT></TT>,
which has its first five indexes provide special functions. The
first three indexes are written to as the height, width, and depth
of a cuboid. The next two indexes contain the volume and surface
area of the cuboid and are made read-only. The rest of the array
can be made into a bounded array to allow a user to store his
or her own values. As soon as a value is stored in the <TT><FONT FACE="Courier">Cuboid</FONT></TT>
array, the values of items at index <TT><FONT FACE="Courier">3</FONT></TT>
and <TT><FONT FACE="Courier">4</FONT></TT> are recalculated to
provide the latest volume and surface area of a cuboid.
<P>
Listing 6.3 illustrates how to use this array. 
<HR>
<BLOCKQUOTE>
<B>Listing 6.3. Using the </B><TT><B><FONT FACE="Courier">Cuboid.pm</FONT></B></TT><B>
module.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2<BR>
&nbsp;3 push(@Inc,&quot;.&quot;);
<BR>
&nbsp;4 use Cuboid;<BR>
&nbsp;5<BR>
&nbsp;6 tie @myCube, 'Cuboid', 3;<BR>
&nbsp;7<BR>
&nbsp;8 $myCube[0] = 2;<BR>
&nbsp;9 $myCube[1] = 3;<BR>
10 $myCube[2] = 4;<BR>
11<BR>
12 for ($i=0; $i &lt; 5; $i++) {<BR>
13&nbsp;&nbsp;&nbsp;&nbsp; print &quot; myCube[$i] = $myCube[$i]
\n&quot;;<BR>
14 }<BR>
15</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Here is the output of this code.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">array will be 8 elements long<BR>
[STORE 2 at 0]<BR>
[STORE 3 at 1]<BR>
[STORE 4 at 2]<BR>
&nbsp;myCube[0] = 2<BR>
&nbsp;myCube[1] = 3<BR>
&nbsp;myCube[2] = 4<BR>
&nbsp;myCube[3] = 24<BR>
&nbsp;myCube[4] = 52</FONT></TT>
</BLOCKQUOTE>
<P>
Now let's examine the <TT><FONT FACE="Courier">Cuboid.pm</FONT></TT>
module, which is presented in Listing 6.4.
<HR>
<BLOCKQUOTE>
<B>Listing 6.4. The </B><TT><B><FONT FACE="Courier">Cuboid.pm</FONT></B></TT><B>
module.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 # ------------------------------------------------------------
<BR>
&nbsp;2 package Cuboid;<BR>
&nbsp;3 use Carp;<BR>
&nbsp;4 use strict;<BR>
&nbsp;5<BR>
&nbsp;6 #<BR>
&nbsp;7 # The constructor
for this class.<BR>
&nbsp;8 # ------------------------------------------------------------
<BR>
&nbsp;9 # Array[0] = ht;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
read write<BR>
10 # Array[1] = wd;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
read write<BR>
11 # Array[2] = dp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
read write<BR>
12 # Array[3] = volume;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read
only<BR>
13 # Array[4] = surfaceArea;&nbsp;&nbsp;read only<BR>
14 # Array[5...maxsize] = read/write values for the user;<BR>
15 # ------------------------------------------------------------
<BR>
16<BR>
17 my $SACRED = 5;<BR>
18<BR>
19 sub TIEARRAY {<BR>
20<BR>
21&nbsp;&nbsp;&nbsp;&nbsp; my $class = shift;<BR>
22&nbsp;&nbsp;&nbsp;&nbsp; my $maxsize = shift;<BR>
23<BR>
24&nbsp;&nbsp;&nbsp;&nbsp; #<BR>
25&nbsp;&nbsp;&nbsp;&nbsp; # Bailout if the array is not tied
correctly.<BR>
26&nbsp;&nbsp;&nbsp;&nbsp; #<BR>
27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;confess
&quot;usage: tie(\@ary, 'Cuboid', maxsize)&quot;<BR>
28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
@_ || $maxsize =~ /\D/;<BR>
29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$maxsize
+= $SACRED;<BR>
30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print
&quot;array will be $maxsize elements long\n&quot;;<BR>
31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
bless {<BR>
32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MAXSIZE
=&gt; $maxsize,<BR>
33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ARRAY
=&gt; [0,0,0,0,0],<BR>
34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},
$class;<BR>
35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
36<BR>
37 # FETch this, index<BR>
38 # This method will be triggered every time an individual element
the tied<BR>
39 # array is accessed (read). It takes one argument beyond its
self<BR>
40 # reference: the index whose value we're trying to fetch.<BR>
41 #<BR>
42 sub FETch {<BR>
43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my($self,$ndx)
= @_;<BR>
44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
($ndx &gt; $self-&gt;{MAXSIZE}) {<BR>
45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;confess
&quot;Error Out of Bounds: $ndx &gt; $self-&gt;{MAXSIZE}&quot;;
<BR>
46&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
47&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
$self-&gt;{ARRAY}[$ndx];<BR>
48&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
49<BR>
50 # STORE this, index, value<BR>
51 # This method will be called whenever an element in the tied
array<BR>
52 # is written to. It takes three arguments: a reference to itself,
<BR>
53 # the index to store stuff at, and the value to store at the
index.<BR>
54 #<BR>
55 # The items at [3] and [4] are not allowed to be written to.
<BR>
56 #<BR>
57 sub STORE {<BR>
58&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my($self,
$ndx, $value) = @_;<BR>
59&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print
&quot;[STORE $value at $ndx]\n&quot;;<BR>
60&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
($ndx &gt; $self-&gt;{MAXSIZE} ) {<BR>
61&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;confess
&quot;Error Out Of Bounds: $ndx &gt; $self-&gt;{MAXSIZE}&quot;;
<BR>
62&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (($ndx ==
3) || ( $ndx == 4))&nbsp;&nbsp;{<BR>
64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;confess
&quot;Cannot store in read only area: $ndx&quot;;<BR>
65&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
66&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$self-&gt;{ARRAY}[$ndx]
= $value;<BR>
67&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
$self-&gt;{ARRAY}[3]&nbsp;&nbsp;=<BR>
68&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;($self-&gt;{ARRAY}[0]
* $self-&gt;{ARRAY}[1] * $self-&gt;{ARRAY}[2]) ;<BR>
69&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
$self-&gt;{ARRAY}[4] =<BR>
70&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;($self-&gt;{ARRAY}[0]
* $self-&gt;{ARRAY}[1])&nbsp;&nbsp;+<BR>
71&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;($self-&gt;{ARRAY}[1]
* $self-&gt;{ARRAY}[2])&nbsp;&nbsp;+<BR>
72&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;($self-&gt;{ARRAY}[0]
* $self-&gt;{ARRAY}[2]);<BR>
73<BR>
74&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
$self-&gt;{ARRAY}[4] *=&nbsp;&nbsp;2;<BR>
75 <BR>
76&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
$self-&gt;{ARRAY}[$ndx] ;<BR>
77&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
78<BR>
79 # DESTROY<BR>
80<BR>
81 sub DESTROY { }<BR>
82<BR>
83 1;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT><FONT FACE="Courier">Cuboid</FONT></TT> package is started
at line 2 and ends at line 83 with a required statement. The package
uses <TT><FONT FACE="Courier">Carp</FONT></TT> and <TT><FONT FACE="Courier">strict</FONT></TT>
packages at lines 3 and 4, respectively. Lines 9 through 14 describe
the structure of this object. The size of the sacrosanct indexes
is set at line 17.
<P>
The <TT><FONT FACE="Courier">TIEARRAY</FONT></TT> constructor
starts at line 19. Note how the constructor takes two parameters:
one for the class and one for the maximum size the array can take.
Line 27 contains some error-checking routines using the <TT><FONT FACE="Courier">confess()</FONT></TT>
function in the <TT><FONT FACE="Courier">Carp</FONT></TT> module.
The maximum size is adjusted for the sacrosanct indexes, and an
appropriate message is printed out at line 30.
<P>
A reference to the newly created object is returned in lines 31
through 34. Note how the array is initialized and the member <TT><FONT FACE="Courier">MAXSIZE</FONT></TT>
set at line 33.
<P>
The <TT><FONT FACE="Courier">FETch</FONT></TT> method for the
array behaves in the same manner as for a scalar. The <TT><FONT FACE="Courier">FETch</FONT></TT>
method is called every time an individual element in the tied
array is read from. The <TT><FONT FACE="Courier">FETch</FONT></TT>
method takes two arguments: a reference to itself and the index
whose value is being fetched. Look at line 43 where these two
values are assigned to <TT><FONT FACE="Courier">$self</FONT></TT>
and <TT><FONT FACE="Courier">$ndx</FONT></TT>. Bounds are checked
at line 44, and we bail out in case of an error at line 45. If
the bounds are correct, the value is returned at the request index
via code at line 47.
<P>
The <TT><FONT FACE="Courier">STORE</FONT></TT> method starts at
line 50 and takes three arguments: a reference to itself, the
index at which to store, and the value to store. In the <TT><FONT FACE="Courier">STORE</FONT></TT>
method, the extracted values are printed at lines 58 and 59. Bounds
checking is done at line 60 with a bailout at line 61 in case
of errors. Lines 63 through 65 do not permit storing values at
index <TT><FONT FACE="Courier">3</FONT></TT> or <TT><FONT FACE="Courier">4</FONT></TT>.
<P>
At line 66 the input value is assigned. At this point, you could
make the code faster by checking whether only indexes <TT><FONT FACE="Courier">0</FONT></TT>
to <TT><FONT FACE="Courier">1</FONT></TT> are modified, but you'll
need to do that on your own. The area and volume results are stored
at index <TT><FONT FACE="Courier">3</FONT></TT> and <TT><FONT FACE="Courier">4</FONT></TT>.
The assigned value is returned in line 76.
<P>
The <TT><FONT FACE="Courier">DESTROY</FONT></TT> method is just
a dummy function that doesn't do much. You really don't need to
have a <TT><FONT FACE="Courier">DESTROY</FONT></TT> method. The
one shown here is for illustration only.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD ><B>Caution</B></TD></TR>
<TR VALIGN=TOP><TD >
<BLOCKQUOTE>
Only the <TT><FONT FACE="Courier">read</FONT></TT> and <TT><FONT FACE="Courier">write</FONT></TT> operations of an array are affected by the <TT><FONT FACE="Courier">tie()</FONT></TT> operation. The functions <TT><FONT FACE="Courier">$#</FONT></TT>, 
<TT><FONT FACE="Courier">push()</FONT></TT>, <TT><FONT FACE="Courier">pop()</FONT></TT>, and so on of an array are not affected by the <TT><FONT FACE="Courier">tie()</FONT></TT> function.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<H2><A NAME="TyingtoanAssociativeArray"><FONT SIZE=5 COLOR=#FF0000>Tying
to an Associative Array</FONT></A></H2>
<P>
An associative array is more complicated to implement than either
a scalar or an array because of the extra functions that have
to be added to it. A class that can be tied to an associative
array should have the following methods:
<UL>
<LI><TT><FONT FACE="Courier">TIEHASH classname, LIST</FONT></TT>
<LI><TT><FONT FACE="Courier">FETch this, key</FONT></TT>
<LI><TT><FONT FACE="Courier">STORE this, key, value</FONT></TT>
<LI><TT><FONT FACE="Courier">DELETE this, key</FONT></TT>
<LI><TT><FONT FACE="Courier">EXISTS this, key</FONT></TT>
<LI><TT><FONT FACE="Courier">FIRSTKEY this</FONT></TT>
<LI><TT><FONT FACE="Courier">NEXTKEY this, lastkey</FONT></TT>
<LI><TT><FONT FACE="Courier">DESTROY this</FONT></TT>
</UL>
<P>
The next example is a simpler version of the one presented by
Tom Christiansen in his <TT><FONT FACE="Courier">perltie.html</FONT></TT>
file, which is available on <TT><FONT FACE="Courier">www.perl.com</FONT></TT>.
The example presented by Tom is a bit dangerous to use because
you can wipe out your <TT><FONT FACE="Courier">.profile</FONT></TT>,
<TT><FONT FACE="Courier">.history</FONT></TT>, <TT><FONT FACE="Courier">.elm</FONT></TT>,
<TT><FONT FACE="Courier">.term</FONT></TT>, and other &quot;dot&quot;
files. I wrote this example to map the text versions of the <TT><FONT FACE="Courier">perltie.html</FONT></TT>
file into a hashed array to generate a table of contents for this
book based on the first line of each heading. The example presented
here simply lists the first line of each heading. There is no
reason why you cannot print other information in the file, however.
<P>
Listing 6.5 shows the script that uses the <TT><FONT FACE="Courier">tie()</FONT></TT>
function on a hash. The module used for mirroring the contents
of each chapter file is called <TT><FONT FACE="Courier">Mirror.pm</FONT></TT>.
It's used in line 4 of this code.
<HR>
<BLOCKQUOTE>
<B>Listing 6.5. Using the </B><TT><B><FONT FACE="Courier">tie()</FONT></B></TT><B>
function on a hash.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2<BR>
&nbsp;3 push(@Inc,&quot;.&quot;);
<BR>
&nbsp;4 use Mirror;<BR>
&nbsp;5<BR>
&nbsp;6 tie %chapters, 'Mirror', chaps;<BR>
&nbsp;7<BR>
&nbsp;8 foreach $k (keys %chapters) {<BR>
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;
print &quot;$k is&nbsp;&nbsp;$chapters{$k}&quot;;<BR>
10&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
11 print &quot; End of script\n&quot;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Here is sample input and output from the code in Listing 6.6.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$ <B>test3<BR>
</B>ch25.txt is&nbsp;&nbsp;(a) Chapter 25<BR>
ch08.txt is&nbsp;&nbsp;(a) Chapter 8<BR>
ch28.txt is&nbsp;&nbsp;(a) Chapte 28<BR>
ch02.txt is&nbsp;&nbsp;(a) Chapter 2<BR>
ch29.txt is&nbsp;&nbsp;(a) Chapter 29<BR>
ch12.txt is&nbsp;&nbsp;(a) Chapter 12<BR>
ch15.txt is&nbsp;&nbsp;(a) Chapter 15<BR>
ch06.txt is&nbsp;&nbsp;(a) Chapter 6<BR>
<BR>
&nbsp;All done!<BR>
&nbsp;End of script<BR>
$</FONT></TT>
</BLOCKQUOTE>
<P>
What you see above is the first line of every file listed in the
hash instead of the filename! Had we not tied our own functions
to the <TT><FONT FACE="Courier">%chapters</FONT></TT> hash, we
would be seeing the names of the file, such as <TT><FONT FACE="Courier">ch29.txt</FONT></TT>,
<TT><FONT FACE="Courier">ch12.txt</FONT></TT>, and so forth. Instead
of these names, when each element in the <TT><FONT FACE="Courier">%chapters</FONT></TT>
hash is accessed, our own function is called and prints out the
first line in every file. 
<P>
Of course, in your code, you would probably be using different
functions to implement your own strategy and functions with a
hash. For example, each access to a hash is tied to a record in
a file. The function behind the access to each element in the
hash would somehow take the record and format it to suit your
needs. The example shown here in Listing 6.6 is simple enough
to modify to fit into your own particular application.
<P>
Let's now look at how the code for <TT><FONT FACE="Courier">Mirror.pm</FONT></TT>
is written. By examining this code, you will be able to see how
each function is defined for each type of action that you can
tie a function to.
<HR>
<BLOCKQUOTE>
<B>Listing 6.6. The </B><TT><B><FONT FACE="Courier">Mirror.pm</FONT></B></TT><B>
file.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;&nbsp;1 # This file is hereby put
in the public domain. Copy freely.<BR>
&nbsp;&nbsp;2 # Just give me some credit for it ;-) if you like.
Kamran.<BR>
&nbsp;&nbsp;3 package Mirror;
<BR>
&nbsp;&nbsp;4 use Carp;<BR>
&nbsp;&nbsp;5<BR>
&nbsp;&nbsp;6 # TIEHASH classname, $list<BR>
&nbsp;&nbsp;7 #&nbsp;&nbsp;This
is the constructor for the class. That means it is expected to
<BR>
&nbsp;&nbsp;8 #&nbsp;&nbsp;return a blessed reference of a new
object.<BR>
&nbsp;&nbsp;9 #<BR>
&nbsp;10 sub TIEHASH {<BR>
&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$self = shift;<BR>
&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$dir&nbsp;&nbsp;= shift || 'pwd';<BR>
&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$node = {<BR>
&nbsp;14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HOME&nbsp;&nbsp;&nbsp;&nbsp;=&gt;
$dir,<BR>
&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LIST&nbsp;&nbsp;&nbsp;&nbsp;=&gt;
{},<BR>
&nbsp;16<BR>
&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
<BR>
&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
<BR>
&nbsp;19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
print &quot; Directory = $dir\n&quot;;<BR>
&nbsp;20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
<BR>
&nbsp;21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opendir(DIR,
$dir) || croak &quot;Cannot open $dir: $!&quot;;<BR>
&nbsp;22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach
$item ( grep /\.*txt/, readdir(DIR)) {<BR>
&nbsp;23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$node-&gt;{LIST}{$item}
= 'head -1 $dir/$item';<BR>
&nbsp;24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print
&quot;$node-&gt;{LIST}{$item} \n&quot; if $debug;<BR>
&nbsp;25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closedir
DIR;<BR>
&nbsp;27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
bless $node, $self;<BR>
&nbsp;28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;29<BR>
&nbsp;30<BR>
&nbsp;31 # FETch this, key
<BR>
&nbsp;32 # This method is called whenever an element in the tied
hash is<BR>
&nbsp;33 # being read. It
takes two arguments: a reference to itself and the<BR>
&nbsp;34 # key whose value is being asked.<BR>
&nbsp;35<BR>
&nbsp;36 sub FETch {<BR>
&nbsp;37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$self = shift;<BR>
&nbsp;38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$fname = shift;<BR>
&nbsp;39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$dir = $self-&gt;{HOME};<BR>
&nbsp;40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$file = &quot;$dir/$fname&quot;;<BR>
&nbsp;41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unless
(exists $self-&gt;{LIST}-&gt;{$fname} || -f $file) {<BR>
&nbsp;42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;carp
&quot;ERROR: no such file $fname &quot;;<BR>
&nbsp;43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
undef;<BR>
&nbsp;44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(defined $self-&gt;{LIST}-&gt;{$fname}) {<BR>
&nbsp;46&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
$self-&gt;{LIST}-&gt;{$fname};<BR>
&nbsp;47&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
else {<BR>
&nbsp;48&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
$self-&gt;{LIST}-&gt;{$fname} = 'head -1 $file';<BR>
&nbsp;49&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;50<BR>
&nbsp;51&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;52<BR>
&nbsp;53<BR>
&nbsp;54 # STORE this, key, value<BR>
&nbsp;55 #&nbsp;&nbsp;&nbsp;&nbsp;
This method is called whenever an element in the hash is<BR>
&nbsp;56 #&nbsp;&nbsp;&nbsp;&nbsp; written to.&nbsp;&nbsp;It takes
three arguments: a reference to itself, the<BR>
&nbsp;57 #&nbsp;&nbsp;&nbsp;&nbsp;
index to store at, and the value to store.<BR>
&nbsp;58<BR>
&nbsp;59 sub STORE {<BR>
&nbsp;60&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$self = shift;&nbsp;&nbsp;# this<BR>
&nbsp;61&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$fname = shift;&nbsp;&nbsp;&nbsp;&nbsp;# the key<BR>
&nbsp;62&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$value = shift; # the value<BR>
&nbsp;63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$dir = $self-&gt;{HOME};<BR>
&nbsp;64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$file = &quot;$dir/$fname&quot;;<BR>
&nbsp;65&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print
&quot;Storing $fname, $value $file \n&quot;;<BR>
&nbsp;66&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
($value eq &quot;done&quot;) {<BR>
&nbsp;67&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
print &quot;Storing $fname, $value $file \n&quot;;<BR>
&nbsp;68&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
$self-&gt;{LIST}-&gt;{$fname} = 'head -1 $file';<BR>
&nbsp;69&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<BR>
&nbsp;70&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;71&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
$self-&gt;{LIST}-&gt;{$fname} =&nbsp;&nbsp;$value;<BR>
&nbsp;72&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<BR>
&nbsp;73&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;74<BR>
&nbsp;75 # DELETE this, key
<BR>
&nbsp;76 #<BR>
&nbsp;77 #&nbsp;&nbsp;&nbsp;&nbsp;This
method is called when an item is deleted from the hash.<BR>
&nbsp;78 #<BR>
&nbsp;79 sub DELETE&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;80<BR>
&nbsp;81&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$self = shift;<BR>
&nbsp;82&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$fname = shift;<BR>
&nbsp;83&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$dir = $self-&gt;{HOME};<BR>
&nbsp;84&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$file = &quot;$dir/$fname&quot;;<BR>
&nbsp;85&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete
$self-&gt;{LIST}-&gt;{$fname};<BR>
&nbsp;86&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;87<BR>
&nbsp;88 # CLEAR this<BR>
&nbsp;89 #&nbsp;&nbsp;&nbsp;&nbsp;
This method is called when the whole hash is set to an empty list.
<BR>
&nbsp;90 #<BR>
&nbsp;91 sub CLEAR&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;92&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$self = shift;<BR>
&nbsp;93&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$fname;<BR>
&nbsp;94&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach
$fname ( keys %{$self-&gt;{LIST}}) {<BR>
&nbsp;95&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$self-&gt;DELETE($fname);
<BR>
&nbsp;96&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;97&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;98<BR>
&nbsp;99 #<BR>
100 # EXISTS this, key<BR>
101 #&nbsp;&nbsp;&nbsp;&nbsp; This method is called when the exists()
is called on a hash.<BR>
102 #<BR>
103 sub EXISTS&nbsp;&nbsp;&nbsp;{<BR>
104&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$self = shift;<BR>
105&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$dir = $self-&gt;{HOME};<BR>
106&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$fname = shift;<BR>
107&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$file = &quot;$dir/$fname&quot;;<BR>
108&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
exists $self-&gt;{LIST}-&gt;{$file};<BR>
109&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
110<BR>
111 # FIRSTKEY this<BR>
112 #&nbsp;&nbsp;&nbsp;&nbsp; This method is called when you start
to iterate a list.<BR>
113 #<BR>
114 sub FIRSTKEY {<BR>
115&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$self = shift;<BR>
116&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$x&nbsp;&nbsp;= keys %{$self-&gt;{LIST}};<BR>
117&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;each
%{$self-&gt;{LIST}}<BR>
118&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
119<BR>
120<BR>
121 #<BR>
122 # NEXTKEY this, lastkey<BR>
123 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is called
during a keys() or each() iteration. The<BR>
124 # first argument is the object itself. The second argument
is the last<BR>
125 # key that was accessed.<BR>
126<BR>
127 sub NEXTKEY&nbsp;&nbsp;{<BR>
128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my
$self = shift;<BR>
129&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
each %{ $self-&gt;{LIST} }<BR>
130&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
131<BR>
132<BR>
133 #<BR>
134 # DESTROY&nbsp;&nbsp;the infamous epitaph!<BR>
135 #<BR>
136 sub DESTROY&nbsp;&nbsp;{ print &quot;\n All done!&quot;; }
<BR>
137<BR>
138 1;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT><FONT FACE="Courier">TIEHASH</FONT></TT> function definition
begins at line 10. The constructor takes two values as arguments:
the first is the name of the class, and the second is an optional
directory to work in. If the second parameter is not specified,
the current working directory is used. The <TT><FONT FACE="Courier">$node</FONT></TT>
hash is used to store two parameters: <TT><FONT FACE="Courier">HOME</FONT></TT>
for the working directory and <TT><FONT FACE="Courier">LIST</FONT></TT>
for the list of items in this hash.
<P>
At line 21, the required information is collected for the hash
and is stored away in <TT><FONT FACE="Courier">LIST</FONT></TT>
at line 23. The <TT><FONT FACE="Courier">debug</FONT></TT> statement
at line 24 is a very valuable tool while debugging. At line 27,
the class is blessed and the reference to the <TT><FONT FACE="Courier">$node</FONT></TT>
is returned.
<P>
The <TT><FONT FACE="Courier">FETch</FONT></TT> method is called
whenever an element in the tied hash is being read. It takes two
arguments: a reference to itself and the key whose value is being
asked for. See lines 37 and 38, where the two parameters are extracted.
It would be prudent to add some error correction here lest we
look at the wrong path-this is done at line 41. At line 45 the
returned value as cached in the <TT><FONT FACE="Courier">init</FONT></TT>
stages is returned. Had a new item to the hash been added with
an undefined value, the code at line 45 would assign it a value.
<P>
The assignment-handling function is the <TT><FONT FACE="Courier">STORE</FONT></TT>
function. This function is called whenever an element in the hash
is written to. It takes three arguments: a reference to itself,
the index at which to store, and the value to store. The three
arguments are extracted at lines 60 through 62. The third argument
may be null, in which case the head of the file in the <TT><FONT FACE="Courier">HOME</FONT></TT>
directory is used. (Look at lines 66 through 72.)
<P>
The <TT><FONT FACE="Courier">DELETE</FONT></TT> function is called
when an item is deleted from the hash. The function is defined
at line 81. There are two arguments to this function: a reference
to the object and the index to remove. The <TT><FONT FACE="Courier">delete()</FONT></TT>
function is called to remove the indexed item from the <TT><FONT FACE="Courier">LIST</FONT></TT>
hash at <BR>
line 85.
<P>
The <TT><FONT FACE="Courier">CLEAR</FONT></TT> function is called
when the whole hash is removed, possibly by assigning an empty
list to it. (The tied array has no such callback!) There is only
one argument to this function, and that is a reference to itself.
The <TT><FONT FACE="Courier">CLEAR</FONT></TT> function is set
to call the <TT><FONT FACE="Courier">DELETE</FONT></TT> function
in this example (see line 95). This call saves some code, but
we could have just as easily used the <TT><FONT FACE="Courier">delete()</FONT></TT>
function in the same manner as <TT><FONT FACE="Courier">DELETE</FONT></TT>.
<P>
The <TT><FONT FACE="Courier">EXISTS</FONT></TT> function is called
to check whether an item exists in a hash (see line 103). There
are two arguments to this function: a reference to the object
and the index to remove. It simply re-creates the key and uses
this key to return a value from within the <TT><FONT FACE="Courier">LIST</FONT></TT>
hash.
<P>
The <TT><FONT FACE="Courier">FIRSTKEY</FONT></TT> and <TT><FONT FACE="Courier">NEXTKEY</FONT></TT>
methods are called when the <TT><FONT FACE="Courier">each()</FONT></TT>
and <TT><FONT FACE="Courier">keys()</FONT></TT> methods are called.
The <TT><FONT FACE="Courier">FIRSTKEY</FONT></TT> method is called
when you start to iterate a list. The <TT><FONT FACE="Courier">NEXTKEY</FONT></TT>
method gets called during a <TT><FONT FACE="Courier">keys()</FONT></TT>
or <TT><FONT FACE="Courier">each()</FONT></TT> iteration. The
first argument to <TT><FONT FACE="Courier">NEXTKEY</FONT></TT>
is a reference to the object itself. The second argument is the
last that was accessed.
<P>
For the file in Listing 6.6, you should now be able to derive
your own classes for mapping hashes to functions. The <TT><FONT FACE="Courier">tie()</FONT></TT>
function, when used with hashes, provides more flexibility in
defining methods than what the <TT><FONT FACE="Courier">tie()</FONT></TT>
function for arrays provides. However, using the hash is more
complex than the array function because you have to define more
methods with the hashing method.
<P>
There is supposedly some relief, though, with the use of the <TT><FONT FACE="Courier">TieHash</FONT></TT>
module provided with the Perl distribution. The <TT><FONT FACE="Courier">TieHash</FONT></TT>
module has predefined methods for you to pick and choose whatever
functions you want to implement, and the rest are defaulted. There
is a <TT><FONT FACE="Courier">man</FONT></TT> page for the module
in the Perl distribution, but it did not provide much information
on how to actually use the module. Perhaps we'll see more documentation
on this tool in later releases.
<H2><A NAME="ForMoreInformation"><FONT SIZE=5 COLOR=#FF0000>For
More Information</FONT></A></H2>
<P>
This chapter has provided only some basic information on the use
of the <TT><FONT FACE="Courier">tie()</FONT></TT> function. There
is an excellent document, called <TT><FONT FACE="Courier">perltie.html</FONT></TT>,
by Tom Christiansen that is available at most of the Perl archive
sites. The <TT><FONT FACE="Courier">perltie.html</FONT></TT> document
has more detailed information on how to use the <TT><FONT FACE="Courier">tie()</FONT></TT>
functions. The <TT><FONT FACE="Courier">tie()</FONT></TT> function
is also used in modules distributed with Perl. Two interesting
modules to look at are the <TT><FONT FACE="Courier">Config</FONT></TT>
and <TT><FONT FACE="Courier">DBM</FONT></TT> file modules, which
show interesting uses of the <TT><FONT FACE="Courier">tie()</FONT></TT>
function. The <TT><FONT FACE="Courier">DBM</FONT></TT> file modules
provide detailed examples of mapping records to disk with the
use of <TT><FONT FACE="Courier">tie()</FONT></TT> functions on
hashes.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
This chapter has provided the basic information on how to use
the <TT><FONT FACE="Courier">tie()</FONT></TT> function to provide
an association between a Perl variable and executable functions.
Scalars, arrays, and hashes can be associated with methods having
special names such as <TT><FONT FACE="Courier">FETch</FONT></TT>,
<TT><FONT FACE="Courier">STORE</FONT></TT>, and so on. By designing
classes that provide methods these names, you can provide extra
functionality to map scalar, array, or hash objects to other objects,
processes, or disk files.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch5.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch5.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch7.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch7.htm"><IMG 
SRC="nc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>
