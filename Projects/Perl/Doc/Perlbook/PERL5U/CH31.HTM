<HTML>

<HEAD>
   <TITLE>Chapter 31 -- Generating Code</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT COLOR=#FF0000>Chapter 31</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Generating Code</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#Introduction" >Introduction</A>
<LI><A HREF="#ChoosingtheInputFile" >Choosing the Input File</A>
<LI><A HREF="#ParsingRecords" >Parsing Records</A>
<LI><A HREF="#WritingthecheaderFiles" >Writing the C Header Files</A>
<LI><A HREF="#WritingtheEncoderSourceFile" >Writing the Encoder Source File</A>
<LI><A HREF="#WritingtheDecoder" >Writing the Decoder</A>
<LI><A HREF="#PuttingItTogether" >Putting It Together</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
This chapter introduces you to using Perl to solve real-world
problems. The ideas you'll gain from this chapter pertain to applying
Perl to solve coding problems. The sample problem chosen is complicated
enough to be encountered during your programming endeavors. Remember
to concentrate on <I>how</I> the problem is solved, not on for
what the final solution is being used.
<H2><A NAME="Introduction"><B><FONT SIZE=5 COLOR=#FF0000>Introduction</FONT></B></A>
</H2>
<P>
The main concepts introduced in this chapter have nothing to do
with navigation and seismic fields. However, the problem that
I address in this chapter is related to writing a seismic navigation
record parser. This parser was crucial in getting a delayed project
up and running in the field. Rather than spend days writing a
parser in C, we were up in a few hours of coding effort. Plus
the concepts gained during this experience helped me write parsers
for other data formats for the same project with just as little
effort.
<P>
Basically, I'll be covering ways to use Perl to generate C code
for a parser. Instead of writing another phone book manager or
a database for music or home inventory records, it's probably
better that we deal with a real-world example. Perhaps after reading
this chapter and seeing how this problem was tackled, you can
draw parallel solutions for your current problems.
<P>
The sample project involves writing a parser to read FORTRAN-based
records for a seismic survey. Most seismic navigation data, believe
it or not, is based on an archaic standard based on the use of
FORTRAN programs to read it. The standard is known as the UKOOA
P2/86 standard. Sometimes this format is simply referred to as
<I>P286</I>. This format was developed for old FORTRAN programs,
and a huge amount of data still exists in this format. Now with
the wide acceptance of C for most of the code being developed
for graphical interfaces and numeric processing, it's only natural
to look for ways to read these files without requiring the FORTRAN
executable.
<P>
Of course, the decode and encode functions for P286 had to be
done yesterday. Given the options of getting another job or writing
100+ functions and structure declarations, I tried tackling this
problem with the lazy programmer's approach: Let Perl do the grunt
work.
<P>
Here is what we were dealing with. Each record of data in a P286
data file is exactly 80 characters long with a trailing newline
or null character. Fields within a record are based on character
column positions and lengths in the record. Columns are numbered
from 1 up. Because white spaces and commas can be part of the
data, there are no &quot;field separators&quot; as such.
<P>
The first few characters of a record identify the type of data
in the record. For example, records begin as <TT><FONT FACE="Courier">H0001</FONT></TT>,
<TT><FONT FACE="Courier">H0002</FONT></TT>, and so on, with the
rest of the characters as fields within the record. There are
52 such records in all. Records in a file are not in sequential
order. The first identifying characters are between three and
five characters long. The only guarantees are that there will
always be only one record per line and that there will be no blank
lines.
<P>
By reading the specification I discovered these things that would
make the coding process programmable:
<UL>
<LI><FONT COLOR=#000000>The only variables that could be defined
in all records were either integers, doubles, or character strings.
This implied a closed set of variables to check for.</FONT>
<LI><FONT COLOR=#000000>The specification of all the headers was
explicit about where each data item began in a line and where
it ended. The lack of delimiters between fields was no longer
a problem since a line could be chopped into substrings quite
easily.</FONT>
<LI><FONT COLOR=#000000>These were text files instead of packed
binary files. This made debugging a little easier because no special
routines were required to display the data.</FONT>
</UL>
<P>
Voil&agrave;! The two important criteria (consistency and working
with a closed set) made it possible to do the encoding and decoding
functions manually. By using a Perl program to do the coding for
me, I reduced the possibility of errors. Any one error would be
propagated to all functions and would be easy to catch and fix.
<P>
The most obvious question was, <I>Why not use Perl to do all the
decoding and encoding?</I> The encoding and decoding routines
were to be incorporated into a C program running on different
platforms running DOS or another lower operating system. Embedding
Perl within the C program would involve installing and maintaining
Perl on these platforms. Most of the platforms the final code
would run on did not support Perl.
<H2><A NAME="ChoosingtheInputFile"><B><FONT SIZE=5 COLOR=#FF0000>Choosing
the Input File</FONT></B></A></H2>
<P>
After reading the specification, I extracted all the header declarations
into one file called <TT><FONT FACE="Courier">P286hdrs</FONT></TT>.
The specification listed the contents of headers in plain text
in between two keywords, <TT><FONT FACE="Courier">RECORD</FONT></TT>
and <TT><FONT FACE="Courier">END</FONT></TT>. The specifications
were not consistent enough to be extracted using a program. Actually,
I extracted most of the lines defining the format using an <TT><FONT FACE="Courier">awk</FONT></TT>
script:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/RECORD/,/^ENDREC$/ { print ; }</FONT></TT>
</BLOCKQUOTE>
<P>
This script removes all the lines between the lines containing
<TT><FONT FACE="Courier">RECORD</FONT></TT> and <TT><FONT FACE="Courier">END</FONT></TT>.
I still had to do some editing after extracting all these records
to get the correct input format.
<P>
The case presented in this example had a text file with the following
format:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">RECORD TypeOfRecord StringToUse<BR>
&nbsp;&nbsp;&nbsp;&nbsp;variableName&nbsp;&nbsp;&nbsp;&nbsp;varType&nbsp;&nbsp;&nbsp;&nbsp;startCol
endCol [format]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;variableName&nbsp;&nbsp;&nbsp;&nbsp;varType&nbsp;&nbsp;&nbsp;&nbsp;startCol
endCol [format]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;variableName&nbsp;&nbsp;&nbsp;&nbsp;varType&nbsp;&nbsp;&nbsp;&nbsp;startCol
endCol [format]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[REPEAT count
st1 st2 ... ]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;variableName&nbsp;&nbsp;&nbsp;&nbsp;varType&nbsp;&nbsp;&nbsp;&nbsp;startCol
endCol [format]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;variableName&nbsp;&nbsp;&nbsp;&nbsp;varType&nbsp;&nbsp;&nbsp;&nbsp;startCol
endCol [format]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;variableName&nbsp;&nbsp;&nbsp;&nbsp;varType&nbsp;&nbsp;&nbsp;&nbsp;startCol
endCol [format]<BR>
ENDREC</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">variableName</FONT></TT> would be
the name of a variable in a structure; the <TT><FONT FACE="Courier">VarType</FONT></TT>
would be <TT><FONT FACE="Courier">int</FONT></TT>, <TT><FONT FACE="Courier">double</FONT></TT>,
or <TT><FONT FACE="Courier">char</FONT></TT>. The <TT><FONT FACE="Courier">startCol</FONT></TT>
and <TT><FONT FACE="Courier">endCol</FONT></TT> values defined
the locations in the string where the data could be picked up.
The first column was still numbered 1 instead of 0. It's easier
to increment by 1 in a program than to change so many declarations.
<P>
Some blocks of variables in some records were repeated. These
were defined after the option <TT><FONT FACE="Courier">REPEAT</FONT></TT>
keyword. The syntax for the <TT><FONT FACE="Courier">REPEAT</FONT></TT>
keyword was this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">REPEAT count st1 st2 ... stN</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">st1</FONT></TT> to <TT><FONT FACE="Courier">stN</FONT></TT>
are the starting offsets for all the fields that follow the <TT><FONT FACE="Courier">REPEAT</FONT></TT>
word. The count specified the number of times to repeat these
blocks.
<P>
For example, the following record is interpreted as &quot;Record
H0001, with one variable starting at column 29 up to column 80.&quot;
<BLOCKQUOTE>
<TT><FONT FACE="Courier">RECORD H0001<BR>
&nbsp;&nbsp;&nbsp;&nbsp;SurveyType  char 29 80<BR>
ENDREC</FONT></TT>
</BLOCKQUOTE>
<P>
Another example of a record using more than one field is shown
here:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">RECORD H011<BR>
&nbsp;&nbsp;&nbsp;&nbsp;datumId&nbsp;&nbsp;&nbsp;&nbsp;int 5 5
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;spheroidName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char
6 23<BR>
&nbsp;&nbsp;&nbsp;&nbsp;datumName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char
24 41<BR>
&nbsp;&nbsp;&nbsp;&nbsp;semimajorAxis&nbsp;&nbsp;&nbsp;&nbsp;double
42 53&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12.3<BR>
&nbsp;&nbsp;&nbsp;&nbsp;conversionFactor double 66 77&nbsp;&nbsp;&nbsp;&nbsp;12.8
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;inverseFlattening double 66 77&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12.7
<BR>
ENDREC</FONT></TT>
</BLOCKQUOTE>
<P>
Note how only the first four characters are relevant in identifying
the record. Also, the integers and characters don't have a floating
point string, whereas the numbers defining the double type do
have a floating point specification of the form: <TT><FONT FACE="Courier">length.decimals</FONT></TT>.
The <TT><FONT FACE="Courier">length</FONT></TT><I> </I>is the
total number of columns in the number including the decimal point,
the <TT><FONT FACE="Courier">decimals</FONT></TT> portion is the
number of digits to the right of the decimal point. For example,
12.8 will occupy 12 character spaces in one column, 3 digits to
the left of the decimal point and 8 digits to the right of the
decimal point. The format for the floating point number is the
same as that for a <TT><FONT FACE="Courier">printf()</FONT></TT>
statement in C.
<P>
Another example is a record using <TT><FONT FACE="Courier">REPEAT</FONT></TT>
fields, as shown here:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">RECORD E3100<BR>
&nbsp;&nbsp;&nbsp;&nbsp;velprop&nbsp;&nbsp;double 6 12 7.2<BR>
&nbsp;&nbsp;&nbsp;&nbsp;REPEAT&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;13
26 39 52 65<BR>
&nbsp;&nbsp;&nbsp;&nbsp;srcNdx&nbsp;&nbsp;&nbsp;int 13 15<BR>
&nbsp;&nbsp;&nbsp;&nbsp;dstNdx&nbsp;&nbsp;&nbsp;int 16 18<BR>
&nbsp;&nbsp;&nbsp;&nbsp;slant&nbsp;&nbsp;&nbsp;&nbsp;double 19
25 7.2<BR>
ENDREC</FONT></TT>
</BLOCKQUOTE>
<P>
In this record type, the block <TT><FONT FACE="Courier">{srcNdx,dstNdx,slant}</FONT></TT>
is repeated at columns 13, 26, 39, 52, and 65. This implies that
each of these variables can be interpreted as arrays of five elements
each.
<P>
The entire file for parsing these records is about 520 lines long.
A shorter sample file is shown in Listing 31.1. Note how comment
lines in that listing are inserted in this input file with the
use of the <TT><FONT FACE="Courier">#</FONT></TT> character. Actually,
any lines could be used for comments as long as the comments are
outside the confines of <TT><FONT FACE="Courier">RECORD</FONT></TT>
and <TT><FONT FACE="Courier">ENDREC</FONT></TT> statements. The
reason to use the hash is to maintain some consistency with Perl.
<HR>
<BLOCKQUOTE>
<B>Listing 31.1. The input file.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #<BR>
&nbsp;2 # Comment lines are permitted in the usual Perl style.
<BR>
&nbsp;3 #<BR>
&nbsp;4 RECORD H0001<BR>
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SurveyType&nbsp;&nbsp;char
29 80<BR>
&nbsp;6 ENDREC<BR>
&nbsp;7<BR>
&nbsp;8 RECORD H0010<BR>
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numPatterns int 6 7<BR>
10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sblInUse&nbsp;&nbsp;&nbsp;&nbsp;int
8 8<BR>
11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sattInUse&nbsp;&nbsp;&nbsp;int
9 9<BR>
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numVessels&nbsp;&nbsp;int 10 10
<BR>
13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numDatum&nbsp;&nbsp;&nbsp;&nbsp;int
11 11<BR>
14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offsetMode&nbsp;&nbsp;int 12 12
<BR>
15 ENDREC<BR>
16<BR>
17 RECORD H011<BR>
18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;datumId&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
5 5<BR>
19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spheroidName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char
6 23<BR>
20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;datumName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char
24 41<BR>
21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;semimajorAxis&nbsp;&nbsp;&nbsp;&nbsp;double
42 53&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12.3<BR>
22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conversionFactor double 66 77&nbsp;&nbsp;&nbsp;&nbsp;12.8
<BR>
23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inverseFlattening double 66 77&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12.7
<BR>
24 ENDREC<BR>
25<BR>
26 RECORD E3100<BR>
27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;velprop&nbsp;&nbsp;double 6 12
7.2<BR>
28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;REPEAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;13
26 39 52 65<BR>
29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;srcNdx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
13 15<BR>
30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dstNdx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
16 18<BR>
31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slant&nbsp;&nbsp;&nbsp;&nbsp;double
19 25 7.2<BR>
32 ENDREC</FONT></TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="ParsingRecords"><B><FONT SIZE=5 COLOR=#FF0000>Parsing
Records</FONT></B></A></H2>
<P>
Now that we have an input file, let's tackle parsing the records
within this file. The most likely way to tackle this problem is
to generate three files from the input file: one header, one file
with all source code for the decoder, and one source file for
the encoder.
<P>
The pseudocode looks something like this:
<BLOCKQUOTE>
<TT><I><FONT FACE="Courier">open file for input<BR>
open files for output<BR>
while&nbsp;&nbsp;(more records)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></I><FONT FACE="Courier">&nbsp;<I>if
recognized start of record<BR>
&nbsp;&nbsp;&nbsp;&nbsp;start structure definitions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;start encoder function preamble<BR>
&nbsp;&nbsp;&nbsp;&nbsp;start decoder function preamble<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</I>&nbsp;<I>if recognized
end of record<BR>
&nbsp;&nbsp;&nbsp;&nbsp;terminate structure definitions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;terminate encoder function preamble<BR>
&nbsp;&nbsp;&nbsp;&nbsp;terminate decoder function preamble<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if within record<BR>
&nbsp;&nbsp;&nbsp;&nbsp;generate structure variable definitions
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;generate encoder function parsing for
variable<BR>
&nbsp;&nbsp;&nbsp;&nbsp;generate decoder function parsing for
variable<BR>
close all files</I></FONT></TT>
</BLOCKQUOTE>
<P>
Perl has the capability to have more than one file open at once.
By running the input file through one parser, you can generate
three files simultaneously. All you do is send the output to its
respective file. In this case, three files are opened for output:
<TT><FONT FACE="Courier">HDRS</FONT></TT> for the header declarations,
<TT><FONT FACE="Courier">EncD</FONT></TT> for the encoding output,
and <TT><FONT FACE="Courier">DECD</FONT></TT> for the decoding
output. The <TT><FONT FACE="Courier">SAFE</FONT></TT> handle is
used to read in the input records from the <TT><FONT FACE="Courier">P286hdrs</FONT></TT>
file. The lines to open the file are
<BLOCKQUOTE>
<TT><FONT FACE="Courier">open (SAFE, &quot;P286hdrs&quot;) ||
die &quot;Cannot open Input file&nbsp;&nbsp;$!\n&quot;;<BR>
open (HDRS, &quot;&gt;P286.h&quot;)&nbsp;&nbsp;|| die &quot;Cannot
open&nbsp;&nbsp;Header $!\n&quot;;<BR>
open (EncD, &quot;&gt;P286enc.c&quot;)&nbsp;&nbsp;|| die &quot;Cannot
open&nbsp;&nbsp;Encoder $!\n&quot;;<BR>
open (DECD, &quot;&gt;P286dec.c&quot;)&nbsp;&nbsp;|| die &quot;Cannot
open&nbsp;&nbsp;Decoder $!\n&quot;;</FONT></TT>
</BLOCKQUOTE>
<P>
After the files are opened, some preamble stuff is required for
each source and header file. The calls to the these functions
provide the initialization. The contents of each file are destroyed
when the files are opened, so you have to initialize each file:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&amp;startHeaderFile();<BR>
&amp;startEncoderFile();<BR>
&amp;startDecoderFile();</FONT></TT>
</BLOCKQUOTE>
<P>
Then, a <TT><FONT FACE="Courier">while</FONT></TT> loop simply
reads in all the input, one record at a time.
<P>
After chopping off the terminating newline, the incoming line
is examined to see whether there are any comments or if it's a
blank line. If either case is true, the line is discarded. Look
at the following code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">while (&lt;SAFE&gt;) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;chop($_);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (/^#/) { next; }<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if (/^\s*$/) { next; }</FONT></TT>
</BLOCKQUOTE>
<P>
If the line appears to be non-empty, it's split into the <TT><FONT FACE="Courier">@names</FONT></TT>
array and examined for the tokens <TT><FONT FACE="Courier">RECORD</FONT></TT>,
<TT><FONT FACE="Courier">ENDREC</FONT></TT>, and <TT><FONT FACE="Courier">REPEAT</FONT></TT>.
The default case is to process variable types and generate either
structure variable declarations or code for encoding and decoding
their values.
<P>
If it's a <TT><FONT FACE="Courier">RECORD</FONT></TT> token, a
new declaration is started for a structure. The name of the record
is in <TT><FONT FACE="Courier">$rname</FONT></TT>, with the <TT><FONT FACE="Courier">$rtype</FONT></TT>
as the type of record. Note how the <TT><FONT FACE="Courier">$_</FONT></TT>
is used twice when splitting the record. The value of <TT><FONT FACE="Courier">$_</FONT></TT>
is not modified with a call to the <TT><FONT FACE="Courier">split()</FONT></TT>
function nor is any function called that will modify the value
of <TT><FONT FACE="Courier">$_</FONT></TT>. The three functions,
<TT><FONT FACE="Courier">&amp;startHeaderRecord($rtype)</FONT></TT>,
<TT><FONT FACE="Courier">&amp;startEncoderFunction($rtype)</FONT></TT>,
and <TT><FONT FACE="Courier">&amp;startDecoderFunction($rtype)</FONT></TT>
take the P286 record type and generate a header declaration, an
encoder function preamble, and a decoder function preamble. We
also mark the fact the we are starting a new record by setting
a flag <TT><FONT FACE="Courier">$inRecord</FONT></TT> to <TT><FONT FACE="Courier">1</FONT></TT>.
Further processing of the incoming line is halted with a call
to the <TT><FONT FACE="Courier">next()</FONT></TT> function. The
<TT><FONT FACE="Courier">$repeat</FONT></TT> flag is set to <TT><FONT FACE="Courier">0</FONT></TT>
to start a new record and to stop any previous declarations for
any previous records. The fragment of code to start each type
of data is shown here:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">if (/^RECORD/) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;($rname,$rtype,@rest) = split(' ',$_);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;startHeaderRecord($rtype);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;startEncoderFunction($rtype);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;startDecoderFunction($rtype);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;$inRecord = 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;$repeat = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;next;<BR>
&nbsp;&nbsp;&nbsp;}</FONT></TT>
</BLOCKQUOTE>
<P>
The code in <TT><FONT FACE="Courier">while</FONT></TT> also has
to check when the record has ended with the receipt of an <TT><FONT FACE="Courier">ENDREC</FONT></TT>
token. When <TT><FONT FACE="Courier">ENDREC</FONT></TT> is seen,
three functions are called to close up the structure and function
declarations started in the <TT><FONT FACE="Courier">RECORD</FONT></TT>
structure. Because we are no longer within a record, the value
of <TT><FONT FACE="Courier">$inRecord</FONT></TT> is set to <TT><FONT FACE="Courier">0</FONT></TT>
and the next function is called to skip further processing of
this record. The fragment of code to do this cleanup is shown
as this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">if (/^ENDREC/) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;stopHeaderRecord($rtype);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;closeEncoderFunction();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;closeDecoderFunction();<BR>
&nbsp;&nbsp;&nbsp;&nbsp;$inRecord = 0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;next;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">REPEAT</FONT></TT> block is hit if
the word <TT><FONT FACE="Courier">REPEAT</FONT></TT> is the first
word on a new line. Note that in <TT><FONT FACE="Courier">RECORD</FONT></TT>
and <TT><FONT FACE="Courier">ENDREC</FONT></TT> token recognition,
we looked at the start of a new line, whereas with the <TT><FONT FACE="Courier">REPEAT</FONT></TT>
keyword, we look for the <TT><FONT FACE="Courier">REPEAT</FONT></TT>
token after some white spaces from the start of a new line. The
offsets are derived in two stages. The first stage gets the number
of offsets to work within <TT><FONT FACE="Courier">$count</FONT></TT>
with the split call. The first stage puts the <TT><FONT FACE="Courier">REPEAT</FONT></TT>
line's variables into an array called <TT><FONT FACE="Courier">@allOffsets</FONT></TT>.
The next stage calls the <TT><FONT FACE="Courier">splice()</FONT></TT>
function to extract the subset of items starting from item number
2 in <TT><FONT FACE="Courier">@allOffsets</FONT></TT>. The <TT><FONT FACE="Courier">@offsets</FONT></TT>
array then has the offsets in a record where the rest of the variables
will be repeated in blocks. The next function is called to proceed
to the next line of the input file.
<P>
The fragment of code to do this is shown here:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">if (/^[\s]*REPEAT/) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;$repeat = 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;@allOffsets = split(' ',$_);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;$index = $allOffsets[0];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;$count = $allOffsets[1];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;print &quot;INDEX = $index, COUNT= $count&quot;;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;@offsets = splice(@allOffsets,2);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;next;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</FONT></TT>
</BLOCKQUOTE>
<P>
Finally, the default processing begins for a line. The first thing
to do before attempting to parse a line is to see whether we are
in the middle of a record. Because the input file may contain
free-form text, too, in the future, this is a bit of insurance
to help prevent any variables from being accidentally declared.
<P>
The incoming line is parsed to extract five values into an array.
The input string <TT><FONT FACE="Courier">$_</FONT></TT> is split
on white spaces. The call for this is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">(<I>$vname,$vtype,$from,$to,$fmt</I>)
= split(' ',$_);</FONT></TT>
</BLOCKQUOTE>
<P>
There are two ways to process a variable in our case. One is when
a variable is by itself and another is when the variable is in
a block being repeated. If a block is being repeated, it's easier
to simply declare an array and parse into it. Here's the code
to handle this part:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">if ($inRecord)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;($vname,$vtype,$from,$to,$fmt) = split('
',$_);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ($repeat == 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;makeHeaderItem($vname,$vtype,$from,$to);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;encodeVariable($vname,$vtype,$from,$to,$fmt);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;decodeVariable($vname,$vtype,$from,$to,$fmt);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;makeArrayedItem($vname,$vtype,$count,$from,$to);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$offsetLen&nbsp;&nbsp;&nbsp;=
$to - $from + 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$offsetCount =
0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach $x (@offsets)
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$offsetFrom&nbsp;&nbsp;=
$x;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$offsetTo&nbsp;&nbsp;&nbsp;&nbsp;=
$offsetLen + $x;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$offsetName
= sprintf &quot;%s[%d]&quot;, $vname,$offsetCount;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print
&quot;Name = $offsetName, COUNT= $count\n&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;encodeVariable($offsetName,$vtype,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$offsetFrom,$offsetTo,$fmt);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;decodeVariable($offsetName,$vtype,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$offsetFrom,$offsetTo,$fmt);
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$offsetCount++;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} ## end of else
clause.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
} # of while loop.</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">while</FONT></TT> loop continues
to process each line in the input file until all the record definitions
have been completed. After the <TT><FONT FACE="Courier">while</FONT></TT>
loop ends, any terminal processing that be must done is completed
and all open files are closed:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">close (SAFE);<BR>
&amp;closeHeaderFile();<BR>
close (HDRS);<BR>
close (EncD);<BR>
close (DECD);</FONT></TT>
</BLOCKQUOTE>
<P>
When the program terminates, you should have three files in the
directory: <TT><FONT FACE="Courier">P286.h</FONT></TT>, <TT><FONT FACE="Courier">P286enc.c</FONT></TT>,
and <TT><FONT FACE="Courier">P286dec.c</FONT></TT>. The headers
are declared in the <TT><FONT FACE="Courier">P286.h</FONT></TT>
file, encoding functions are declared in the <TT><FONT FACE="Courier">P286enc.c</FONT></TT>
file, and the decoding functions are declared in <TT><FONT FACE="Courier">P286dec.c</FONT></TT>.
The acid test really is to see if the code compiles. Try these
commands-you should see no errors:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">gcc -c P286enc.c<BR>
gcc -c P286dec.c</FONT></TT>
</BLOCKQUOTE>
<P>
Alas, we still have to write the code to use these functions.
But that's really beyond the scope of this book. What's important
to see is that in a few hours or so, we have created the boring
part of the application and are now ready to proceed with using
these tools.
<P>
During this discussion I have glazed over the details of how the
header and source files are created in the subroutine calls we
made. Let's take a look at the details of how these functions
work.
<H2><A NAME="WritingthecheaderFiles"><B><FONT SIZE=5 COLOR=#FF0000>Writing
the C Header Files</FONT></B></A></H2>
<P>
The first task for generating the header file is to create the
preamble to the <TT><FONT FACE="Courier">include</FONT></TT> file
being created in the file that is pointed to by the <TT><FONT FACE="Courier">HDRS</FONT></TT>
file handle. The code to do this is as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub startHeaderFile() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;print ( HDRS &quot;#ifndef P286_HDRS\n&quot;,
<BR>
&nbsp;&quot;#define P286_HDRS 1\n&quot;,<BR>
&nbsp;&quot;#define STRPTR&nbsp;&nbsp; char *\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
When the file is closed, you'll want to put in an #endif statement
to allow multiple inclusions of the header file. This is done
with a call to the subroutine sHeaderFile():
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub closeHeaderFile() {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;printf HDRS &quot;\n#endif\n&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</FONT></TT>
</BLOCKQUOTE>
<P>
The empty pair of parentheses in the function declaration is used
in Perl 5.002 or later to define a function prototype that allows
for no input parameters. When a <TT><FONT FACE="Courier">RECORD</FONT></TT>
header is received, it generates two items: a <TT><FONT FACE="Courier">#define</FONT></TT>
token for a header number and the preamble for the structure to
use. The token is helpful if you want to create a parser that
does a <TT><FONT FACE="Courier">switch()</FONT></TT> statement
on a type of structure. To make sure that each token has a unique
value, a counter is kept in <TT><FONT FACE="Courier">$recordCounter</FONT></TT>
for use in assigning a record type a unique value. The code to
do this is shown here:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub startHeaderRecord {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;my ($name) = @_;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;printf HDRS &quot;\n#define P286_%s_RECTYPE
%d &quot;, $name, $recordCounter++;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;printf HDRS &quot;\n\ntypedef struct P286_%s_type
{&quot;, $name;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
By assigning the <TT><FONT FACE="Courier">@_</FONT></TT> array
to <TT><FONT FACE="Courier">my($name)</FONT></TT> we are actually
permitting more than one argument into the function even though
only the first argument is used. The contents of the <TT><FONT FACE="Courier">@_</FONT></TT>
array are not altered in this case. Using a command like my <TT><FONT FACE="Courier">$name
= shift @_</FONT></TT> would achieve the same purpose but would
also alter the contents of the <TT><FONT FACE="Courier">@_</FONT></TT>
array.
<P>
Each structure definition being created has to be stopped. Two
variable types are constructed: <TT><FONT FACE="Courier">P286_HEADERNAME_TYPE</FONT></TT>
and a pointer type to the structure <TT><FONT FACE="Courier">*P286_HEADERNAME_PTR</FONT></TT>.
The code to do this is shown here:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub stopHeaderRecord($name) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;my $name = shift;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;my $ntype = &quot;P286_&quot; . $name
. &quot;_TYPE&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;my $nptr&nbsp;&nbsp;= &quot;*P286_&quot;
. $name . &quot;_PTR;&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;print HDRS &quot;\n}&quot; .&nbsp;&nbsp;uc($ntype)
. &quot;,&quot; . uc($nptr) .&quot; \n&quot;;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Note the syntax used for the function prototype shown previously.
The <TT><FONT FACE="Courier">$name</FONT></TT> variable declaration
in the argument list is only valid in Perl 5.002 or later. Formal
parameter lists to subroutines in Perl are not completely supported
in Perl as we go to print. It does not hurt to be prepared for
the future by including formal parameter lists if they do not
affect the underlying code in the subroutine itself. If you want
to force Perl to take only one parameter into this subroutine,
you can also declare this as
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub stopHeaderRecord($) { &#133; }</FONT></TT>
</BLOCKQUOTE>
<P>
The dollar sign in the parentheses will be used by the Perl interpreter
as an indicator that only one parameter is allowed into the subroutine.
<P>
For a non-arrayed item, three variable types are created: a <TT><FONT FACE="Courier">char</FONT></TT>
string of fixed length, an <TT><FONT FACE="Courier">int</FONT></TT>,
and a <TT><FONT FACE="Courier">double</FONT></TT>. The type of
variable to generate a declaration for is passed in as a parameter
to the <TT><FONT FACE="Courier">makeHeaderItem</FONT></TT> function.
Comments are also generated in the header file pointed to by the
<TT><FONT FACE="Courier">HDRS</FONT></TT> file handle to indicate
what columns the data points to. These comments serve as a cross-
reference for when you are debugging the generated code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub makeHeaderItem {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;my($vname,$vtype,$from,$to) = @_;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;my $len;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ($vtype eq 'char') {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;$len = $to - $from + 2 ;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;printf HDRS &quot;\n %s %s[%d]\; \/* %d
%d *\/ &quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$vtype,
$vname, $len, $from, $to;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;printf HDRS &quot;\n %s %s\; \/* %d %d
*\/&quot;, $vtype, $vname, $from,&nbsp;&nbsp;$to;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
If the variable being generated is in a <TT><FONT FACE="Courier">REPEAT</FONT></TT>
block, it's declared as an array with a call to the <TT><FONT FACE="Courier">MakeArrayedItem()</FONT></TT>
function. The call to generate this arrayed item is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub makeArrayedItem {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;my ($vname,$vtype,$count,$from,$to) =
@_;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;printf HDRS &quot;\n&nbsp;&nbsp;&nbsp;&nbsp;%s
%s[%d]; \/* from %d %d *\/ &quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$vtype,
$vname, $count, $from,&nbsp;&nbsp;$to;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This code generates the <TT><FONT FACE="Courier">P286.h</FONT></TT>
headers file. Now let's look at the files that will contain the
encode and decode functions.
<H2><A NAME="WritingtheEncoderSourceFile"><B><FONT SIZE=5 COLOR=#FF0000>Writing
the Encoder Source File</FONT></B></A></H2>
<P>
To create the C source file to create encoder for the data file,
use the <TT><FONT FACE="Courier">EncD</FONT></TT> file handle.
The subroutine <TT><FONT FACE="Courier">startEncoderFile()</FONT></TT>
starts the preamble for the file, which includes two items. The
first is the call to include the header file, which is also being
generated. The second is to write out the code to a function that
pads spaces to the right of an incoming string to make the length
equal to 80 characters plus a null character. The code to perform
this preamble is shown here:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub startEncoderFile {<BR>
print (EncD &quot;\/*** C source file to encode records.&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nDon't edit this file\n &quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;*/\n&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;'#include &quot;p286.h&quot; ',<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n/* The incoming buffer must be
81 chars! */&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nvoid padTo80(STRPTR buffer)\n{\n&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;int i,ln;\n&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;ln = strlen(buffer);\n&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;for(i=ln;i&lt;80;i++) buffer[i]
= ' '; \n &quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;buffer[81] = 0; /* NULL terminate
the string*/&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n} /* end of padding function */\n&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n&quot;);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
As each new <TT><FONT FACE="Courier">RECORD</FONT></TT> type is
encountered in the input file, its corresponding encoding function
header is created in the output file. A function header is created
that takes a string to put an encoded record in and a pointer
to a structure to unpack. Because the name of the record being
parsed is passed into the code generation function, it's easy
to derive the pointer name for it: <TT><FONT FACE="Courier">P286_HEADERNAME_PTR</FONT></TT>.
The code to accomplish this is shown here:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub startEncoderFunction {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;my($vname) = @_;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
# Pick up name of record.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;print (EncD &quot;\n/*: &quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n** Generated
by Perl script -- Avoid editing\n*/\n&quot;);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;printf EncD<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;void encode_%s_type(STRPTR
buffer,P286_%s_PTR sp)\n{&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$vname, $vname;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;print (EncD &quot;\nSTRPTR ncp; \n&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nSTRPTR
cp; \n&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;register
int i; \n&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;char tempbuffer[80];\n&quot;);
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
When an <TT><FONT FACE="Courier">ENDREC</FONT></TT> line is read,
the function has to be closed. Unmatched <TT><FONT FACE="Courier">RECORD</FONT></TT>
and <TT><FONT FACE="Courier">ENDREC</FONT></TT> lines in the input
file will cause bad, uncompilable code to be generated. The cleanup
at the end of the encode function is done by adding a call the
padding function, <TT><FONT FACE="Courier">padTo80</FONT></TT>,
and printing out the ending curly brace:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub closeEncoderFunction {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;print (EncD &quot;\npadTo80(buffer);&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n}
/* End of encoding function */ \n&quot;);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
As with structure declarations, two types of variables have to
be parsed. One is a non-arrayed element and the other is an arrayed
element. However, within the original loop the <TT><FONT FACE="Courier">$vname</FONT></TT>
being passed into this function is already set up as a variable
or a member of an array so that no further processing is necessary.
<P>
The three types of variables used by the parsing encoder are used
to generate the code. If the variable is a string, it's simply
cut and pasted into its columns in the outgoing buffer. If it's
an integer, the value of the integer is printed in the columns
in the output buffer for the integer. For a <TT><FONT FACE="Courier">double</FONT></TT>,
the <TT><FONT FACE="Courier">$fmt</FONT></TT> string contains
the format string to explicitly place the decimal point at the
right location in the columns for the output buffer. The code
to perform this parsing is shown here:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub encodeVariable {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;my($vname,$vtype,$from,$to,$fmt) = @_;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;my $len = $to - $from + 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;printf EncD &quot;\n\n&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;printf EncD &quot;/* Encode:$vtype,$vname,$from,$to,$len,$fmt
*/&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ($vtype =~ /char/) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf EncD &quot;\ncp
= (STRPTR )&amp;(buffer[%d]); &quot;,$from-1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf EncD &quot;\nfor
(i=0; i&lt; %d;i++)&quot;,$len;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf EncD &quot;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer[%d
+ i] = sp-&gt;%s[i]; &quot;,$from-1,$vname;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ($vtype =~ /double/) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (length($fmt)
&gt; 0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;printf EncD &quot;\nsprintf(tempbuffer,\&quot;%%%sf\&quot;,(sp-&gt;%s));&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$fmt,$vname;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;printf EncD &quot;\nsprintf(tempbuffer,\&quot;%%%sf\&quot;,(sp-&gt;%s));&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$len,$vname;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;printf EncD &quot;\ntempbuffer[%d]= 0;
&quot;,$len;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;printf EncD &quot;\nstrncat((STRPTR )(&amp;buffer[%d]),tempbuffer,%d);&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$from-1,$len;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ($vtype =~ /int/) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($len == 1)
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
EncD &quot;\nsp-&gt;%s %%= 10;&quot;, $vname;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
EncD &quot;\ntempbuffer[%d] = (char)('0' + sp-&gt;%s);&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$from-1,$vname;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
EncD &quot;\ntempbuffer[%d] = 0; &quot;,$from;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf EncD &quot;\nsprintf(tempbuffer,\&quot;%%d%d\&quot;,(sp-&gt;%s));&quot;,$len,$vname;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf EncD &quot;\ntempbuffer[%d]=
0; &quot;,$len;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf EncD &quot;\nstrncat((STRPTR
)(&amp;buffer[%d]),tempbuffer,%d);&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$from-1,$len;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
} # end of subroutine.</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="WritingtheDecoder"><B><FONT SIZE=5 COLOR=#FF0000>Writing
the Decoder</FONT></B></A></H2>
<P>
The decoder source file is created in almost exactly the same
way that the encoder file is created. The preamble for the decoder
file includes the <TT><FONT FACE="Courier">#include</FONT></TT>
statement for the <TT><FONT FACE="Courier">P286.h</FONT></TT>
header file, which is also being created. It also makes a reference
to the <TT><FONT FACE="Courier">padTo80</FONT></TT> function in
the encoder file (should this extra function be required).
<P>
The decoder file also generates code to extract a substring from
another string given the offset and length to extract. The function
may be used on systems that have a broken <TT><FONT FACE="Courier">strncpy</FONT></TT>
(just like my old, in-house version of the C compiler for a Motorola
6809E microprocessor).
<P>
Here's the code to generate the decoder source file preamble:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub startDecoderFile {<BR>
print (DECD &quot;\/**\n* C source file to decode records.&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot; \nDon't edit this file\n &quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;*/\n&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;'#include &quot;p286.h&quot; ',<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n/* The outgoing buffer must be
81 chars! */&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nextern void padTo80(STRPTR buffer);
\n&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n/* The outgoing buffer must also
be 81 chars! */&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nvoid substr(STRPTR buffer,STRPTR
cut,int offset, int len)\n{\n&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;int i,j; \nj = offset;\n&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;for(i=len;i&lt;80;i++) cut[i] =
buffer[j]; \n &quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;cut[len] = 0; /* NULL terminate
the string*/&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n} /* end of padding function */\n&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n&quot;);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Each <TT><FONT FACE="Courier">RECORD</FONT></TT> and <TT><FONT FACE="Courier">ENDREC</FONT></TT>
pair in the input file causes a call to the Perl subroutines <TT><FONT FACE="Courier">startDecoderFunction()</FONT></TT>
and <TT><FONT FACE="Courier">closeDecoderFunction()</FONT></TT>,
respectively. The first subroutine creates the preamble to decode
a string into a structure. The second subroutine prints the closing
brace for a function. The code for the two functions is shown
here:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub startDecoderFunction {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;my($vname) = @_;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
Pick up name of record.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;print DECD &quot;\n/*: &quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;print DECD &quot;\n** Generated by Perl
script -- Avoid editing &quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;print DECD &quot;\n** The outgoing buffer
must also be 81 chars!&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;print DECD &quot;\n*/\n&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;printf DECD&nbsp;&nbsp;&quot;void decode_%s_type(P286_%s_PTR
sp,STRPTR buffer)\n{&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$vname, $vname;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;print DECD &quot;\nSTRPTR cp; \n&quot;;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;print DECD &quot;register int i; \n&quot;;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;print DECD &quot;char tempbuffer[80];\n&quot;;
<BR>
}<BR>
<BR>
sub closeDecoderFunction {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;print DECD &quot;\n} /* End of decoding
function */ \n&quot;;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Finally, the <TT><FONT FACE="Courier">decodeVariable</FONT></TT>
function is called when a variable is encountered. The type of
variable dictates how to read the value from a substring in the
incoming buffer. The name of the variable is set to be a scalar
or the member of an array before the call is made. Therefore,
the Perl subroutine simply uses the value of <TT><FONT FACE="Courier">$vname</FONT></TT>
verbatim:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub decodeVariable {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;my ($vname,$vtype,$from,$to,$fmt) = @_;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;my&nbsp;&nbsp;$len = $to - $from + 1;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;printf DECD &quot;\n&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ($vtype =~ /char/)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf DECD &quot;\nstrncpy(sp-&gt;%s,(STRPTR
)(&amp;buffer[%d]),%d);&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$vname,$from-1,$len;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf DECD &quot;\nsp-&gt;%s[%d]=
0; &quot;,$vname,$len;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ($vtype =~ /double/)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf DECD &quot;\nstrncpy(tempbuffer,(STRPTR
)(&amp;buffer[%d]),%d);&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$from-1,$len;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf DECD &quot;\ntempbuffer[%d]=
0; &quot;,$len;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf DECD &quot;\nsscanf(tempbuffer,\&quot;%%%sf\&quot;,&amp;(sp-&gt;%s));&quot;,
$fmt,$vname;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;if ($vtype =~ /int/)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf DECD &quot;\nstrncpy(tempbuffer,(STRPTR
)(&amp;buffer[%d]),%d);&quot;,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$from-1,$len;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf DECD &quot;\ntempbuffer[%d]=
0; &quot;,$len;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf DECD &quot;\nsscanf(tempbuffer,\&quot;%%%dd\&quot;,&amp;(sp-&gt;%s));&quot;,$len,$vname;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="PuttingItTogether"><B><FONT SIZE=5 COLOR=#FF0000>Putting
It Together</FONT></B></A></H2>
<P>
Here are the input and output files generated from the code fragments
shown previously. The input file shown here has only five records
in it. The actual file had 52 record types, and I applied the
same methodology to three types of similar formats. Here is a
breakdown of the listings:
<UL>
<LI><FONT COLOR=#000000>Listing 31.2. The header file generated
from Perl.</FONT>
<LI><FONT COLOR=#000000>Listing 31.3. The encoder file </FONT><TT><FONT FACE="Courier">P286enc.c</FONT></TT>.
<LI><FONT COLOR=#000000>Listing 31.4. The encoder file </FONT><TT><FONT FACE="Courier">P286dec.c</FONT></TT>.
<LI><FONT COLOR=#000000>Listing 31.5. The full listing for the
code generator.</FONT>
</UL>
<P>
<HR>
<BLOCKQUOTE>
<B>Listing 31.2. The </B><TT><B><FONT FACE="Courier">P286.h</FONT></B></TT><B>
header file.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #ifndef P286_HDRS<BR>
&nbsp;2 #define P286_HDRS 1<BR>
&nbsp;3 #define STRPTR&nbsp;&nbsp; char *<BR>
&nbsp;4<BR>
&nbsp;5 #define P286_H0001_RECTYPE 0<BR>
&nbsp;6<BR>
&nbsp;7 typedef struct p286_H0001_type {<BR>
&nbsp;8&nbsp;&nbsp;char SurveyType[53]; /* 29 80 */<BR>
&nbsp;9 }P286_H0001_TYPE,*P286_H0001_PTR;<BR>
10<BR>
11 #define P286_H0010_RECTYPE 1<BR>
12<BR>
13 typedef struct p286_H0010_type {<BR>
14&nbsp;&nbsp;int numPatterns; /* 6 7 */<BR>
15&nbsp;&nbsp;int sblInUse; /* 8 8 */<BR>
16&nbsp;&nbsp;int sattInUse; /* 9 9 */<BR>
17&nbsp;&nbsp;int numVessels; /* 10 10 */<BR>
18&nbsp;&nbsp;int numDatum; /* 11 11 */<BR>
19&nbsp;&nbsp;int offsetMode; /* 12 12 */<BR>
20 }P286_H0010_TYPE,*P286_H0010_PTR;<BR>
21<BR>
22 #define P286_H011_RECTYPE 2<BR>
23<BR>
24 typedef struct p286_H011_type {<BR>
25&nbsp;&nbsp;int datumId; /* 5 5 */<BR>
26&nbsp;&nbsp;char spheroidName[19]; /* 6 23 */<BR>
27&nbsp;&nbsp;char datumName[19]; /* 24 41 */<BR>
28&nbsp;&nbsp;double semimajorAxis; /* 42 53 */<BR>
29&nbsp;&nbsp;double conversionFactor; /* 66 77 */<BR>
30&nbsp;&nbsp;double inverseFlattening; /* 66 77 */<BR>
31 }P286_H011_TYPE,*P286_H011_PTR;<BR>
32<BR>
33 #define P286_E3100_RECTYPE 3<BR>
34<BR>
35 typedef struct p286_E3100_type {<BR>
36&nbsp;&nbsp;double velprop; /* 6 12 */<BR>
37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int srcNdx[5]; /* from 13 15 */
<BR>
38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int dstNdx[5]; /* from 16 18 */
<BR>
39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double slant[5]; /* from 19 25
*/<BR>
40 }P286_E3100_TYPE,*P286_E3100_PTR;<BR>
41<BR>
42 #endif</FONT></TT>
</BLOCKQUOTE>
<HR>
<HR>
<BLOCKQUOTE>
<B>Listing 31.3. The encoder file </B><TT><B><FONT FACE="Courier">P286enc.c</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;&nbsp;1 /*** C source file to encode
records.<BR>
&nbsp;&nbsp;2 Don't edit this file<BR>
&nbsp;&nbsp;3&nbsp;&nbsp;*/<BR>
&nbsp;&nbsp;4 #include &quot;p286.h&quot;<BR>
&nbsp;&nbsp;5<BR>
&nbsp;&nbsp;6 /* The incoming buffer must be 81 chars! */<BR>
&nbsp;&nbsp;7 void padTo80(STRPTR buffer)<BR>
&nbsp;&nbsp;8 {<BR>
&nbsp;&nbsp;9 int i,ln;<BR>
&nbsp;10 ln = strlen(buffer);<BR>
&nbsp;11 for(i=ln;i&lt;80;i++) buffer[i] = ' ';<BR>
&nbsp;12&nbsp;&nbsp;buffer[81] = 0; /* NULL terminate the string*/
<BR>
&nbsp;13 } /* end of padding function */<BR>
&nbsp;14<BR>
&nbsp;15<BR>
&nbsp;16 /*:<BR>
&nbsp;17 ** Generated by Perl script -- Avoid editing<BR>
&nbsp;18 */<BR>
&nbsp;19 void encode_H0001_type(STRPTR buffer,P286_H0001_PTR sp)
<BR>
&nbsp;20 {<BR>
&nbsp;21 STRPTR ncp;<BR>
&nbsp;22<BR>
&nbsp;23 STRPTR cp;<BR>
&nbsp;24 register int i;<BR>
&nbsp;25 char tempbuffer[80];<BR>
&nbsp;26<BR>
&nbsp;27<BR>
&nbsp;28 /* Encode:char,SurveyType,29,80,52, */<BR>
&nbsp;29 cp = (STRPTR )&amp;(buffer[28]);<BR>
&nbsp;30 for (i=0; i&lt; 52;i++)<BR>
&nbsp;31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer[28 + i] = sp-&gt;SurveyType[i];
<BR>
&nbsp;32 padTo80(buffer);<BR>
&nbsp;33 } /* End of encoding function */<BR>
&nbsp;34<BR>
&nbsp;35 /*:<BR>
&nbsp;36 ** Generated by Perl script -- Avoid editing<BR>
&nbsp;37 */<BR>
&nbsp;38 void encode_H0010_type(STRPTR buffer,P286_H0010_PTR sp)
<BR>
&nbsp;39 {<BR>
&nbsp;40 STRPTR ncp;<BR>
&nbsp;41<BR>
&nbsp;42 STRPTR cp;<BR>
&nbsp;43 register int i;<BR>
&nbsp;44 char tempbuffer[80];<BR>
&nbsp;45<BR>
&nbsp;46<BR>
&nbsp;47 /* Encode:int,numPatterns,6,7,2, */<BR>
&nbsp;48 sprintf(tempbuffer,&quot;%d2&quot;,(sp-&gt;numPatterns));
<BR>
&nbsp;49 tempbuffer[2]= 0;<BR>
&nbsp;50 strncat((STRPTR )(&amp;buffer[5]),tempbuffer,2);<BR>
&nbsp;51<BR>
&nbsp;52 /* Encode:int,sblInUse,8,8,1, */<BR>
&nbsp;53 sp-&gt;sblInUse %= 10;<BR>
&nbsp;54 tempbuffer[7] = (char)('0' + sp-&gt;sblInUse);<BR>
&nbsp;55 tempbuffer[8] = 0;<BR>
&nbsp;56 strncat((STRPTR )(&amp;buffer[7]),tempbuffer,1);<BR>
&nbsp;57<BR>
&nbsp;58 /* Encode:int,sattInUse,9,9,1, */<BR>
&nbsp;59 sp-&gt;sattInUse %= 10;<BR>
&nbsp;60 tempbuffer[8] = (char)('0' + sp-&gt;sattInUse);<BR>
&nbsp;61 tempbuffer[9] = 0;<BR>
&nbsp;62 strncat((STRPTR )(&amp;buffer[8]),tempbuffer,1);<BR>
&nbsp;63<BR>
&nbsp;64 /* Encode:int,numVessels,10,10,1, */<BR>
&nbsp;65 sp-&gt;numVessels %= 10;<BR>
&nbsp;66 tempbuffer[9] = (char)('0' + sp-&gt;numVessels);<BR>
&nbsp;67 tempbuffer[10] = 0;<BR>
&nbsp;68 strncat((STRPTR )(&amp;buffer[9]),tempbuffer,1);<BR>
&nbsp;69<BR>
&nbsp;70 /* Encode:int,numDatum,11,11,1, */<BR>
&nbsp;71 sp-&gt;numDatum %= 10;<BR>
&nbsp;72 tempbuffer[10] = (char)('0' + sp-&gt;numDatum);<BR>
&nbsp;73 tempbuffer[11] = 0;<BR>
&nbsp;74 strncat((STRPTR )(&amp;buffer[10]),tempbuffer,1);<BR>
&nbsp;75<BR>
&nbsp;76 /* Encode:int,offsetMode,12,12,1, */<BR>
&nbsp;77 sp-&gt;offsetMode %= 10;<BR>
&nbsp;78 tempbuffer[11] = (char)('0' + sp-&gt;offsetMode);<BR>
&nbsp;79 tempbuffer[12] = 0;<BR>
&nbsp;80 strncat((STRPTR )(&amp;buffer[11]),tempbuffer,1);<BR>
&nbsp;81 padTo80(buffer);<BR>
&nbsp;82 } /* End of encoding function */<BR>
&nbsp;83<BR>
&nbsp;84 /*:<BR>
&nbsp;85 ** Generated by Perl script -- Avoid editing<BR>
&nbsp;86 */<BR>
&nbsp;87 void encode_H011_type(STRPTR buffer,P286_H011_PTR sp)
<BR>
&nbsp;88 {<BR>
&nbsp;89 STRPTR ncp;<BR>
&nbsp;90<BR>
&nbsp;91 STRPTR cp;<BR>
&nbsp;92 register int i;<BR>
&nbsp;93 char tempbuffer[80];<BR>
&nbsp;94<BR>
&nbsp;95<BR>
&nbsp;96 /* Encode:int,datumId,5,5,1, */<BR>
&nbsp;97 sp-&gt;datumId %= 10;<BR>
&nbsp;98 tempbuffer[4] = (char)('0' + sp-&gt;datumId);<BR>
&nbsp;99 tempbuffer[5] = 0;<BR>
100 strncat((STRPTR )(&amp;buffer[4]),tempbuffer,1);<BR>
101<BR>
102 /* Encode:char,spheroidName,6,23,18, */<BR>
103 cp = (STRPTR )&amp;(buffer[5]);<BR>
104 for (i=0; i&lt; 18;i++)<BR>
105&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer[5 + i] = sp-&gt;spheroidName[i];
<BR>
106<BR>
107 /* Encode:char,datumName,24,41,18, */<BR>
108 cp = (STRPTR )&amp;(buffer[23]);<BR>
109 for (i=0; i&lt; 18;i++)<BR>
110&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer[23 + i] = sp-&gt;datumName[i];
<BR>
111<BR>
112 /* Encode:double,semimajorAxis,42,53,12,12.3 */<BR>
113 sprintf(tempbuffer,&quot;%12.3f&quot;,(sp-&gt;semimajorAxis));
<BR>
114 tempbuffer[12]= 0;<BR>
115 strncat((STRPTR )(&amp;buffer[41]),tempbuffer,12);<BR>
116<BR>
117 /* Encode:double,conversionFactor,66,77,12,12.8 */<BR>
118 sprintf(tempbuffer,&quot;%12.8f&quot;,(sp-&gt;conversionFactor));
<BR>
119 tempbuffer[12]= 0;<BR>
120 strncat((STRPTR )(&amp;buffer[65]),tempbuffer,12);<BR>
121<BR>
122 /* Encode:double,inverseFlattening,66,77,12,12.7 */<BR>
123 sprintf(tempbuffer,&quot;%12.7f&quot;,(sp-&gt;inverseFlattening));
<BR>
124 tempbuffer[12]= 0;<BR>
125 strncat((STRPTR )(&amp;buffer[65]),tempbuffer,12);<BR>
126 padTo80(buffer);<BR>
127 } /* End of encoding function */<BR>
128<BR>
129 /*:<BR>
130 ** Generated by Perl script -- Avoid editing<BR>
131 */<BR>
132 void encode_E3100_type(STRPTR buffer,P286_E3100_PTR sp)<BR>
133 {<BR>
134 STRPTR ncp;<BR>
135<BR>
136 STRPTR cp;<BR>
137 register int i;<BR>
138 char tempbuffer[80];<BR>
139<BR>
140<BR>
141 /* Encode:double,velprop,6,12,7,7.2 */<BR>
142 sprintf(tempbuffer,&quot;%7.2f&quot;,(sp-&gt;velprop));<BR>
143 tempbuffer[7]= 0;<BR>
144 strncat((STRPTR )(&amp;buffer[5]),tempbuffer,7);<BR>
145<BR>
146 /* Encode:int,srcNdx[0],13,16,4, */<BR>
147 sprintf(tempbuffer,&quot;%d4&quot;,(sp-&gt;srcNdx[0]));<BR>
148 tempbuffer[4]= 0;<BR>
149 strncat((STRPTR )(&amp;buffer[12]),tempbuffer,4);<BR>
150<BR>
151 /* Encode:int,srcNdx[1],26,29,4, */<BR>
152 sprintf(tempbuffer,&quot;%d4&quot;,(sp-&gt;srcNdx[1]));<BR>
153 tempbuffer[4]= 0;<BR>
154 strncat((STRPTR )(&amp;buffer[25]),tempbuffer,4);<BR>
155<BR>
156 /* Encode:int,srcNdx[2],39,42,4, */<BR>
157 sprintf(tempbuffer,&quot;%d4&quot;,(sp-&gt;srcNdx[2]));<BR>
158 tempbuffer[4]= 0;<BR>
159 strncat((STRPTR )(&amp;buffer[38]),tempbuffer,4);<BR>
160<BR>
161 /* Encode:int,srcNdx[3],52,55,4, */<BR>
162 sprintf(tempbuffer,&quot;%d4&quot;,(sp-&gt;srcNdx[3]));<BR>
163 tempbuffer[4]= 0;<BR>
164 strncat((STRPTR )(&amp;buffer[51]),tempbuffer,4);<BR>
165<BR>
166 /* Encode:int,srcNdx[4],65,68,4, */<BR>
167 sprintf(tempbuffer,&quot;%d4&quot;,(sp-&gt;srcNdx[4]));<BR>
168 tempbuffer[4]= 0;<BR>
169 strncat((STRPTR )(&amp;buffer[64]),tempbuffer,4);<BR>
170<BR>
171 /* Encode:int,dstNdx[0],13,16,4, */<BR>
172 sprintf(tempbuffer,&quot;%d4&quot;,(sp-&gt;dstNdx[0]));<BR>
173 tempbuffer[4]= 0;<BR>
174 strncat((STRPTR )(&amp;buffer[12]),tempbuffer,4);<BR>
175<BR>
176 /* Encode:int,dstNdx[1],26,29,4, */<BR>
177 sprintf(tempbuffer,&quot;%d4&quot;,(sp-&gt;dstNdx[1]));<BR>
178 tempbuffer[4]= 0;<BR>
179 strncat((STRPTR )(&amp;buffer[25]),tempbuffer,4);<BR>
180<BR>
181 /* Encode:int,dstNdx[2],39,42,4, */<BR>
182 sprintf(tempbuffer,&quot;%d4&quot;,(sp-&gt;dstNdx[2]));<BR>
183 tempbuffer[4]= 0;<BR>
184 strncat((STRPTR )(&amp;buffer[38]),tempbuffer,4);<BR>
185<BR>
186 /* Encode:int,dstNdx[3],52,55,4, */<BR>
187 sprintf(tempbuffer,&quot;%d4&quot;,(sp-&gt;dstNdx[3]));<BR>
188 tempbuffer[4]= 0;<BR>
189 strncat((STRPTR )(&amp;buffer[51]),tempbuffer,4);<BR>
190<BR>
191 /* Encode:int,dstNdx[4],65,68,4, */<BR>
192 sprintf(tempbuffer,&quot;%d4&quot;,(sp-&gt;dstNdx[4]));<BR>
193 tempbuffer[4]= 0;<BR>
194 strncat((STRPTR )(&amp;buffer[64]),tempbuffer,4);<BR>
195<BR>
196 /* Encode:double,slant[0],13,20,8,7.2 */<BR>
197 sprintf(tempbuffer,&quot;%7.2f&quot;,(sp-&gt;slant[0]));<BR>
198 tempbuffer[8]= 0;<BR>
199 strncat((STRPTR )(&amp;buffer[12]),tempbuffer,8);<BR>
200<BR>
201 /* Encode:double,slant[1],26,33,8,7.2 */<BR>
202 sprintf(tempbuffer,&quot;%7.2f&quot;,(sp-&gt;slant[1]));<BR>
203 tempbuffer[8]= 0;<BR>
204 strncat((STRPTR )(&amp;buffer[25]),tempbuffer,8);<BR>
205<BR>
206 /* Encode:double,slant[2],39,46,8,7.2 */<BR>
207 sprintf(tempbuffer,&quot;%7.2f&quot;,(sp-&gt;slant[2]));<BR>
208 tempbuffer[8]= 0;<BR>
209 strncat((STRPTR )(&amp;buffer[38]),tempbuffer,8);<BR>
210<BR>
211 /* Encode:double,slant[3],52,59,8,7.2 */<BR>
212 sprintf(tempbuffer,&quot;%7.2f&quot;,(sp-&gt;slant[3]));<BR>
213 tempbuffer[8]= 0;<BR>
214 strncat((STRPTR )(&amp;buffer[51]),tempbuffer,8);<BR>
215<BR>
216 /* Encode:double,slant[4],65,72,8,7.2 */<BR>
217 sprintf(tempbuffer,&quot;%7.2f&quot;,(sp-&gt;slant[4]));<BR>
218 tempbuffer[8]= 0;<BR>
219 strncat((STRPTR )(&amp;buffer[64]),tempbuffer,8);<BR>
220 padTo80(buffer);<BR>
221 } /* End of encoding function */</FONT></TT>
</BLOCKQUOTE>
<HR>
<HR>
<BLOCKQUOTE>
<B>Listing 31.4. The decoder file </B><TT><B><FONT FACE="Courier">P286dec.c</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;&nbsp;1 /**<BR>
&nbsp;&nbsp;2 * C source file to decode records.<BR>
&nbsp;&nbsp;3 Don't edit this file<BR>
&nbsp;&nbsp;4&nbsp;&nbsp;*/<BR>
&nbsp;&nbsp;5 #include &quot;p286.h&quot;<BR>
&nbsp;&nbsp;6<BR>
&nbsp;&nbsp;7 /* The outgoing buffer must be 81 chars! */<BR>
&nbsp;&nbsp;8 extern void padTo80(STRPTR buffer);<BR>
&nbsp;&nbsp;9<BR>
&nbsp;10<BR>
&nbsp;11 /* The outgoing buffer must also be 81 chars! */<BR>
&nbsp;12 void substr(STRPTR buffer,STRPTR cut,int offset, int
len)<BR>
&nbsp;13 {<BR>
&nbsp;14 int i,j;<BR>
&nbsp;15 j = offset;<BR>
&nbsp;16 for(i=len;i&lt;80;i++) cut[i] = buffer[j];<BR>
&nbsp;17&nbsp;&nbsp;cut[len] = 0; /* NULL terminate the string*/
<BR>
&nbsp;18 } /* end of padding function */<BR>
&nbsp;19<BR>
&nbsp;20<BR>
&nbsp;21 /*:<BR>
&nbsp;22 ** Generated by Perl script -- Avoid editing<BR>
&nbsp;23 ** The outgoing buffer must also be 81 chars!<BR>
&nbsp;24 */<BR>
&nbsp;25 void decode_H0001_type(P286_H0001_PTR sp,STRPTR buffer)
<BR>
&nbsp;26 {<BR>
&nbsp;27 STRPTR cp;<BR>
&nbsp;28 register int i;<BR>
&nbsp;29 char tempbuffer[80];<BR>
&nbsp;30<BR>
&nbsp;31<BR>
&nbsp;32 strncpy(sp-&gt;SurveyType,(STRPTR )(&amp;buffer[28]),52);
<BR>
&nbsp;33 sp-&gt;SurveyType[52]= 0;<BR>
&nbsp;34 } /* End of decoding function */<BR>
&nbsp;35<BR>
&nbsp;36 /*:<BR>
&nbsp;37 ** Generated by Perl script -- Avoid editing<BR>
&nbsp;38 ** The outgoing buffer must also be 81 chars!<BR>
&nbsp;39 */<BR>
&nbsp;40 void decode_H0010_type(P286_H0010_PTR sp,STRPTR buffer)
<BR>
&nbsp;41 {<BR>
&nbsp;42 STRPTR cp;<BR>
&nbsp;43 register int i;<BR>
&nbsp;44 char tempbuffer[80];<BR>
&nbsp;45<BR>
&nbsp;46<BR>
&nbsp;47 strncpy(tempbuffer,(STRPTR )(&amp;buffer[5]),2);<BR>
&nbsp;48 tempbuffer[2]= 0;<BR>
&nbsp;49 sscanf(tempbuffer,&quot;%2d&quot;,&amp;(sp-&gt;numPatterns));
<BR>
&nbsp;50<BR>
&nbsp;51 strncpy(tempbuffer,(STRPTR )(&amp;buffer[7]),1);<BR>
&nbsp;52 tempbuffer[1]= 0;<BR>
&nbsp;53 sscanf(tempbuffer,&quot;%1d&quot;,&amp;(sp-&gt;sblInUse));
<BR>
&nbsp;54<BR>
&nbsp;55 strncpy(tempbuffer,(STRPTR )(&amp;buffer[8]),1);<BR>
&nbsp;56 tempbuffer[1]= 0;<BR>
&nbsp;57 sscanf(tempbuffer,&quot;%1d&quot;,&amp;(sp-&gt;sattInUse));
<BR>
&nbsp;58<BR>
&nbsp;59 strncpy(tempbuffer,(STRPTR )(&amp;buffer[9]),1);<BR>
&nbsp;60 tempbuffer[1]= 0;<BR>
&nbsp;61 sscanf(tempbuffer,&quot;%1d&quot;,&amp;(sp-&gt;numVessels));
<BR>
&nbsp;62<BR>
&nbsp;63 strncpy(tempbuffer,(STRPTR )(&amp;buffer[10]),1);<BR>
&nbsp;64 tempbuffer[1]= 0;<BR>
&nbsp;65 sscanf(tempbuffer,&quot;%1d&quot;,&amp;(sp-&gt;numDatum));
<BR>
&nbsp;66<BR>
&nbsp;67 strncpy(tempbuffer,(STRPTR )(&amp;buffer[11]),1);<BR>
&nbsp;68 tempbuffer[1]= 0;<BR>
&nbsp;69 sscanf(tempbuffer,&quot;%1d&quot;,&amp;(sp-&gt;offsetMode));
<BR>
&nbsp;70 } /* End of decoding function */<BR>
&nbsp;71<BR>
&nbsp;72 /*:<BR>
&nbsp;73 ** Generated by Perl script -- Avoid editing<BR>
&nbsp;74 ** The outgoing buffer must also be 81 chars!<BR>
&nbsp;75 */<BR>
&nbsp;76 void decode_H011_type(P286_H011_PTR sp,STRPTR buffer)
<BR>
&nbsp;77 {<BR>
&nbsp;78 STRPTR cp;<BR>
&nbsp;79 register int i;<BR>
&nbsp;80 char tempbuffer[80];<BR>
&nbsp;81<BR>
&nbsp;82<BR>
&nbsp;83 strncpy(tempbuffer,(STRPTR )(&amp;buffer[4]),1);<BR>
&nbsp;84 tempbuffer[1]= 0;<BR>
&nbsp;85 sscanf(tempbuffer,&quot;%1d&quot;,&amp;(sp-&gt;datumId));
<BR>
&nbsp;86<BR>
&nbsp;87 strncpy(sp-&gt;spheroidName,(STRPTR )(&amp;buffer[5]),18);
<BR>
&nbsp;88 sp-&gt;spheroidName[18]= 0;<BR>
&nbsp;89<BR>
&nbsp;90 strncpy(sp-&gt;datumName,(STRPTR )(&amp;buffer[23]),18);
<BR>
&nbsp;91 sp-&gt;datumName[18]= 0;<BR>
&nbsp;92<BR>
&nbsp;93 strncpy(tempbuffer,(STRPTR )(&amp;buffer[41]),12);<BR>
&nbsp;94 tempbuffer[12]= 0;<BR>
&nbsp;95 sscanf(tempbuffer,&quot;%12.3f&quot;,&amp;(sp-&gt;semimajorAxis));
<BR>
&nbsp;96<BR>
&nbsp;97 strncpy(tempbuffer,(STRPTR )(&amp;buffer[65]),12);<BR>
&nbsp;98 tempbuffer[12]= 0;<BR>
&nbsp;99 sscanf(tempbuffer,&quot;%12.8f&quot;,&amp;(sp-&gt;conversionFactor));
<BR>
100<BR>
101 strncpy(tempbuffer,(STRPTR )(&amp;buffer[65]),12);<BR>
102 tempbuffer[12]= 0;<BR>
103 sscanf(tempbuffer,&quot;%12.7f&quot;,&amp;(sp-&gt;inverseFlattening));
<BR>
104 } /* End of decoding function */<BR>
105<BR>
106 /*:<BR>
107 ** Generated by Perl script -- Avoid editing<BR>
108 ** The outgoing buffer must also be 81 chars!<BR>
109 */<BR>
110 void decode_E3100_type(P286_E3100_PTR sp,STRPTR buffer)<BR>
111 {<BR>
112 STRPTR cp;<BR>
113 register int i;<BR>
114 char tempbuffer[80];<BR>
115<BR>
116<BR>
117 strncpy(tempbuffer,(STRPTR )(&amp;buffer[5]),7);<BR>
118 tempbuffer[7]= 0;<BR>
119 sscanf(tempbuffer,&quot;%7.2f&quot;,&amp;(sp-&gt;velprop));
<BR>
120<BR>
121 strncpy(tempbuffer,(STRPTR )(&amp;buffer[12]),4);<BR>
122 tempbuffer[4]= 0;<BR>
123 sscanf(tempbuffer,&quot;%4d&quot;,&amp;(sp-&gt;srcNdx[0]));
<BR>
124<BR>
125 strncpy(tempbuffer,(STRPTR )(&amp;buffer[25]),4);<BR>
126 tempbuffer[4]= 0;<BR>
127 sscanf(tempbuffer,&quot;%4d&quot;,&amp;(sp-&gt;srcNdx[1]));
<BR>
128<BR>
129 strncpy(tempbuffer,(STRPTR )(&amp;buffer[38]),4);<BR>
130 tempbuffer[4]= 0;<BR>
131 sscanf(tempbuffer,&quot;%4d&quot;,&amp;(sp-&gt;srcNdx[2]));
<BR>
132<BR>
133 strncpy(tempbuffer,(STRPTR )(&amp;buffer[51]),4);<BR>
134 tempbuffer[4]= 0;<BR>
135 sscanf(tempbuffer,&quot;%4d&quot;,&amp;(sp-&gt;srcNdx[3]));
<BR>
136<BR>
137 strncpy(tempbuffer,(STRPTR )(&amp;buffer[64]),4);<BR>
138 tempbuffer[4]= 0;<BR>
139 sscanf(tempbuffer,&quot;%4d&quot;,&amp;(sp-&gt;srcNdx[4]));
<BR>
140<BR>
141 strncpy(tempbuffer,(STRPTR )(&amp;buffer[12]),4);<BR>
142 tempbuffer[4]= 0;<BR>
143 sscanf(tempbuffer,&quot;%4d&quot;,&amp;(sp-&gt;dstNdx[0]));
<BR>
144<BR>
145 strncpy(tempbuffer,(STRPTR )(&amp;buffer[25]),4);<BR>
146 tempbuffer[4]= 0;<BR>
147 sscanf(tempbuffer,&quot;%4d&quot;,&amp;(sp-&gt;dstNdx[1]));
<BR>
148<BR>
149 strncpy(tempbuffer,(STRPTR )(&amp;buffer[38]),4);<BR>
150 tempbuffer[4]= 0;<BR>
151 sscanf(tempbuffer,&quot;%4d&quot;,&amp;(sp-&gt;dstNdx[2]));
<BR>
152<BR>
153 strncpy(tempbuffer,(STRPTR )(&amp;buffer[51]),4);<BR>
154 tempbuffer[4]= 0;<BR>
155 sscanf(tempbuffer,&quot;%4d&quot;,&amp;(sp-&gt;dstNdx[3]));
<BR>
156<BR>
157 strncpy(tempbuffer,(STRPTR )(&amp;buffer[64]),4);<BR>
158 tempbuffer[4]= 0;<BR>
159 sscanf(tempbuffer,&quot;%4d&quot;,&amp;(sp-&gt;dstNdx[4]));
<BR>
160<BR>
161 strncpy(tempbuffer,(STRPTR )(&amp;buffer[12]),8);<BR>
162 tempbuffer[8]= 0;<BR>
163 sscanf(tempbuffer,&quot;%7.2f&quot;,&amp;(sp-&gt;slant[0]));
<BR>
164<BR>
165 strncpy(tempbuffer,(STRPTR )(&amp;buffer[25]),8);<BR>
166 tempbuffer[8]= 0;<BR>
167 sscanf(tempbuffer,&quot;%7.2f&quot;,&amp;(sp-&gt;slant[1]));
<BR>
168<BR>
169 strncpy(tempbuffer,(STRPTR )(&amp;buffer[38]),8);<BR>
170 tempbuffer[8]= 0;<BR>
171 sscanf(tempbuffer,&quot;%7.2f&quot;,&amp;(sp-&gt;slant[2]));
<BR>
172<BR>
173 strncpy(tempbuffer,(STRPTR )(&amp;buffer[51]),8);<BR>
174 tempbuffer[8]= 0;<BR>
175 sscanf(tempbuffer,&quot;%7.2f&quot;,&amp;(sp-&gt;slant[3]));
<BR>
176<BR>
177 strncpy(tempbuffer,(STRPTR )(&amp;buffer[64]),8);<BR>
178 tempbuffer[8]= 0;<BR>
179 sscanf(tempbuffer,&quot;%7.2f&quot;,&amp;(sp-&gt;slant[4]));
<BR>
180 } /* End of decoding function */</FONT></TT>
</BLOCKQUOTE>
<HR>
<HR>
<BLOCKQUOTE>
<B>Listing 31.5. The complete source file for generating parser
code.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;&nbsp;2 #<BR>
&nbsp;&nbsp;3 # Copyright (c) Kamran Husain.<BR>
&nbsp;&nbsp;4 # The following code is hereby placed in the public
domain.<BR>
&nbsp;&nbsp;5 # NO WARRANTIES OF ANY TYPE ARE IMPLIED.<BR>
&nbsp;&nbsp;6 # For entertainment use only. Contents of package
may shift<BR>
&nbsp;&nbsp;7 # during shipment.<BR>
&nbsp;&nbsp;8 # You may copy this code freely as long as you name
me as<BR>
&nbsp;&nbsp;9 # the original author.<BR>
&nbsp;&nbsp;10 #<BR>
&nbsp;&nbsp;11 # This program parses input records of this form:
<BR>
&nbsp;&nbsp;12 #<BR>
&nbsp;&nbsp;13 # RECORD TypeOfRecord StringToUse<BR>
&nbsp;&nbsp;14 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;variableName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VarType&nbsp;&nbsp;&nbsp;&nbsp;startCol
EndCol<BR>
&nbsp;&nbsp;15 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;variableName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VarType&nbsp;&nbsp;&nbsp;&nbsp;startCol
EndCol<BR>
&nbsp;&nbsp;16 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;variableName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VarType&nbsp;&nbsp;&nbsp;&nbsp;startCol
EndCol<BR>
&nbsp;&nbsp;17 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[REPEAT count st1
st2 ... ]<BR>
&nbsp;&nbsp;18 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;variableName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VarType&nbsp;&nbsp;&nbsp;&nbsp;startCol
EndCol<BR>
&nbsp;&nbsp;19 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;variableName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VarType&nbsp;&nbsp;&nbsp;&nbsp;startCol
EndCol<BR>
&nbsp;&nbsp;20 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;variableName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VarType&nbsp;&nbsp;&nbsp;&nbsp;startCol
EndCol<BR>
&nbsp;&nbsp;21 # ENDREC<BR>
&nbsp;&nbsp;22 #<BR>
&nbsp;&nbsp;23 require 5.002;<BR>
&nbsp;&nbsp;24 open (SAFE, &quot;safehdrs&quot;) || die &quot;Cannot
open Input file&nbsp;&nbsp;$!\n&quot;;<BR>
&nbsp;&nbsp;25 open (HDRS, &quot;&gt;p286.h&quot;)&nbsp;&nbsp;||
die &quot;Cannot open&nbsp;&nbsp;Header $!\n&quot;;<BR>
&nbsp;&nbsp;26 open (EncD, &quot;&gt;p286enc.c&quot;)&nbsp;&nbsp;||
die &quot;Cannot open&nbsp;&nbsp;Encoder $!\n&quot;;<BR>
&nbsp;&nbsp;27 open (DECD, &quot;&gt;p286dec.c&quot;)&nbsp;&nbsp;||
die &quot;Cannot open&nbsp;&nbsp;Decoder $!\n&quot;;<BR>
&nbsp;&nbsp;28<BR>
&nbsp;&nbsp;29 $inRecord = 0;<BR>
&nbsp;&nbsp;30 $repeat = 0;<BR>
&nbsp;&nbsp;31 $recordCounter = 0;<BR>
&nbsp;&nbsp;32<BR>
&nbsp;&nbsp;33 &amp;startHeaderFile();<BR>
&nbsp;&nbsp;34 &amp;startEncoderFile();<BR>
&nbsp;&nbsp;35 &amp;startDecoderFile();<BR>
&nbsp;&nbsp;36<BR>
&nbsp;&nbsp;37 while (&lt;SAFE&gt;) {<BR>
&nbsp;&nbsp;38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chop($_);<BR>
&nbsp;&nbsp;39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (/^#/) { next;
}<BR>
&nbsp;&nbsp;40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (/^\s*$/) { next;
}<BR>
&nbsp;&nbsp;41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@names = split(' ',$_);
<BR>
&nbsp;&nbsp;42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
&nbsp;&nbsp;43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# If not inside a
record, start one<BR>
&nbsp;&nbsp;44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
&nbsp;&nbsp;45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (/^RECORD/) {<BR>
&nbsp;&nbsp;46&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;($rname,$rtype,@rest)
= split(' ',$_);<BR>
&nbsp;&nbsp;47&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;startHeaderRecord($rtype);
<BR>
&nbsp;&nbsp;48&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;startEncoderFunction($rtype);
<BR>
&nbsp;&nbsp;49&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;startDecoderFunction($rtype);
<BR>
&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$inRecord
= 1;<BR>
&nbsp;&nbsp;51&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$repeat
= 0;<BR>
&nbsp;&nbsp;52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next;
<BR>
&nbsp;&nbsp;53&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;54&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (/^ENDREC/) {<BR>
&nbsp;&nbsp;55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;stopHeaderRecord($rtype);
<BR>
&nbsp;&nbsp;56&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;closeEncoderFunction();
<BR>
&nbsp;&nbsp;57&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;closeDecoderFunction();
<BR>
&nbsp;&nbsp;58&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$inRecord
= 0;<BR>
&nbsp;&nbsp;59&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;60&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (/^[\s]*REPEAT/)
{<BR>
&nbsp;&nbsp;61&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$repeat
= 1;<BR>
&nbsp;&nbsp;62&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@allOffsets
= split(' ',$_);<BR>
&nbsp;&nbsp;63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$index
= $allOffsets[0];<BR>
&nbsp;&nbsp;64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$count
= $allOffsets[1];<BR>
&nbsp;&nbsp;65&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print
&quot;INDEX = $index, COUNT= $count&quot;;<BR>
&nbsp;&nbsp;66&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@offsets
= splice(@allOffsets,2);<BR>
&nbsp;&nbsp;67&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
foreach $x (@offsets) { print &quot;offset = $x\n&quot;;&nbsp;}
<BR>
&nbsp;&nbsp;68&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next;
<BR>
&nbsp;&nbsp;69&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;70&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($inRecord)<BR>
&nbsp;&nbsp;71&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;72&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;($vname,$vtype,$from,$to,$fmt)
= split(' ',$_);<BR>
&nbsp;&nbsp;73&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
($repeat == 0)<BR>
&nbsp;&nbsp;74&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;75&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;makeHeaderItem($vname,$vtype,$from,$to);
<BR>
&nbsp;&nbsp;76&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;encodeVariable($vname,$vtype,$from,$to,$fmt);
<BR>
&nbsp;&nbsp;77&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;decodeVariable($vname,$vtype,$from,$to,$fmt);
<BR>
&nbsp;&nbsp;78&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;79&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
<BR>
&nbsp;&nbsp;80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;&nbsp;81&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;makeArrayedItem($vname,$vtype,$count,$from,$to);
<BR>
&nbsp;&nbsp;82&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$offsetLen&nbsp;&nbsp;&nbsp;=
$to - $from + 1;<BR>
&nbsp;&nbsp;83&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$offsetCount
= 0;<BR>
&nbsp;&nbsp;84&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach
$x (@offsets) {<BR>
&nbsp;&nbsp;85&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$offsetFrom&nbsp;&nbsp;=
$x;<BR>
&nbsp;&nbsp;86&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$offsetTo&nbsp;&nbsp;&nbsp;&nbsp;=
$offsetLen + $x;<BR>
&nbsp;&nbsp;87&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$offsetName
= sprintf &quot;%s[%d]&quot;, $vname,$offsetCount;<BR>
&nbsp;&nbsp;88&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print
&quot;Name = $offsetName, COUNT= $count\n&quot;;<BR>
&nbsp;&nbsp;89&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;encodeVariable($offsetName,$vtype,$offsetFrom,$offsetTo,$fmt);
<BR>
&nbsp;&nbsp;90&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;decodeVariable($offsetName,$vtype,$offsetFrom,$offsetTo,$fmt);
<BR>
&nbsp;&nbsp;91&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$offsetCount++;
<BR>
&nbsp;&nbsp;92&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;&nbsp;93&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
## end of else clause.<BR>
&nbsp;&nbsp;94&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} ## end of outer
if ($inRecord) clause.<BR>
&nbsp;&nbsp;95&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;96 close (SAFE);<BR>
&nbsp;&nbsp;97<BR>
&nbsp;&nbsp;98 &amp;closeHeaderFile();<BR>
&nbsp;&nbsp;99 close (HDRS);<BR>
100 close (EncD);<BR>
101 close (DECD);<BR>
102<BR>
103 exit(0);<BR>
104<BR>
105<BR>
106 # --------------------------------------------------------------------
<BR>
107 #&nbsp;&nbsp;To create the C headers file from the data file.
<BR>
108 # --------------------------------------------------------------------
<BR>
109 sub startHeaderRecord {<BR>
110&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my ($name) = @_;<BR>
111&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf HDRS &quot;\n#define P286_%s_RECTYPE
%d &quot;, $name, $recordCounter++;<BR>
112&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf HDRS &quot;\n\ntypedef
struct p286_%s_type {&quot;, $name;<BR>
113 }<BR>
114 # --------------------------------------------------------------------
<BR>
115 # Note the formal input parameter $name in this function.
<BR>
116 # --------------------------------------------------------------------
<BR>
117 sub stopHeaderRecord($name) {<BR>
118&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $name = shift;<BR>
119&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $ntype = &quot;P286_&quot;
. $name . &quot;_TYPE&quot;;<BR>
120&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $nptr&nbsp;&nbsp;= &quot;*P286_&quot;
. $name . &quot;_PTR;&quot;;<BR>
121&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print HDRS &quot;\n}&quot; .&nbsp;&nbsp;uc($ntype)
. &quot;,&quot; . uc($nptr) .&quot; \n&quot;;<BR>
122 }<BR>
123 # --------------------------------------------------------------------
<BR>
124 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create the definitions for
the header file.<BR>
125 # --------------------------------------------------------------------
<BR>
126 sub makeHeaderItem {<BR>
127&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my($vname,$vtype,$from,$to) =
@_;<BR>
128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $len;<BR>
129&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($vtype =~ /char/) {<BR>
130&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$len
= $to - $from + 2 ;<BR>
131&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
HDRS &quot;\n %s %s[%d]\; \/* %d %d *\/ &quot;,<BR>
132&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$vtype,
$vname, $len, $from, $to;<BR>
133&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
134&nbsp;&nbsp;&nbsp;&nbsp; else<BR>
135&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
136&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
HDRS &quot;\n %s %s\; \/* %d %d *\/&quot;,<BR>
137&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$vtype,
$vname, $from,&nbsp;&nbsp;$to;<BR>
138&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
139 }<BR>
140 # --------------------------------------------------------------------
<BR>
141 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create the preamble for the
header file.<BR>
142 # --------------------------------------------------------------------
<BR>
143 sub startHeaderFile() {<BR>
144&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf (HDRS &quot;#ifndef P286_HDRS\n&quot;,
<BR>
145&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;#define
P286_HDRS1\n&quot;,<BR>
146&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;#define
STRPTR&nbsp;&nbsp; char *\n&quot;);<BR>
147 }<BR>
148<BR>
149 # --------------------------------------------------------------------
<BR>
150 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Close the preprocessor definitions
for the header file.<BR>
151 # --------------------------------------------------------------------
<BR>
152 sub closeHeaderFile() {<BR>
153&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf HDRS &quot;\n#endif\n&quot;;
<BR>
154 }<BR>
155 # --------------------------------------------------------------------
<BR>
156 #&nbsp;&nbsp;&nbsp;&nbsp;Create an array item for a structure
<BR>
157 # --------------------------------------------------------------------
<BR>
158 sub makeArrayedItem {<BR>
159&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my ($vname,$vtype,$count,$from,$to)
= @_;<BR>
160&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf HDRS &quot;\n&nbsp;&nbsp;&nbsp;&nbsp;%s
%s[%d]; \/* from %d %d *\/ &quot;,<BR>
161&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$vtype,
$vname, $count, $from,&nbsp;&nbsp;$to;<BR>
162 }<BR>
163<BR>
164 # --------------------------------------------------------------------
<BR>
165 #&nbsp;&nbsp;&nbsp;&nbsp;Create the C source file to create
encoder for the data file.<BR>
166 # --------------------------------------------------------------------
<BR>
167 sub startEncoderFile {<BR>
168 print (EncD &quot;\/*** C source file to encode records.&quot;,
<BR>
169&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nDon't edit this file\n
&quot;,<BR>
170&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;*/\n&quot;,<BR>
171&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'#include &quot;p286.h&quot;
',<BR>
172&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n&quot;,<BR>
173&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n/* The incoming buffer
must be 81 chars! */&quot;,<BR>
174&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nvoid padTo80(STRPTR buffer)\n{\n&quot;,
<BR>
175&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;int i,ln;\n&quot;,<BR>
176&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;ln = strlen(buffer);\n&quot;,
<BR>
177&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;for(i=ln;i&lt;80;i++) buffer[i]
= ' '; \n &quot;,<BR>
178&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;buffer[81] = 0; /* NULL
terminate the string*/&quot;,<BR>
179&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n} /* end of padding function
*/\n&quot;,<BR>
180&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n&quot;);<BR>
181 }<BR>
182<BR>
183 # --------------------------------------------------------------------
<BR>
184 #&nbsp;&nbsp;&nbsp;&nbsp;Create the preamble for an encoder
function.<BR>
185 # --------------------------------------------------------------------
<BR>
186 sub startEncoderFunction {<BR>
187&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my($vname) = @_;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
Pick up name of record.<BR>
188&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print (EncD &quot;\n/*: &quot;,
<BR>
189&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n**
Generated by Perl script -- Avoid editing\n*/\n&quot;);<BR>
190&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf EncD<BR>
191&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;void
encode_%s_type(STRPTR buffer,P286_%s_PTR sp)\n{&quot;,<BR>
192&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$vname,
$vname;<BR>
193&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print (EncD &quot;\nSTRPTR ncp;
\n&quot;,<BR>
194&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nSTRPTR
cp; \n&quot;,<BR>
195&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;register
int i; \n&quot;,<BR>
196&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;char
tempbuffer[80];\n&quot;);<BR>
197 }<BR>
198<BR>
199 # --------------------------------------------------------------------
<BR>
200 #&nbsp;&nbsp;&nbsp;&nbsp;Create the closing brackets for an
encoder function<BR>
201 # --------------------------------------------------------------------
<BR>
202 sub closeEncoderFunction {<BR>
203&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print EncD &quot;\npadTo80(buffer);&quot;;
<BR>
204&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print EncD &quot;\n} /* End of
encoding function */ \n&quot;;<BR>
205 }<BR>
206<BR>
207 # --------------------------------------------------------------------
<BR>
208 #&nbsp;&nbsp;&nbsp;&nbsp;Add code for encoding a record.<BR>
209 # --------------------------------------------------------------------
<BR>
210 sub encodeVariable {<BR>
211&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my($vname,$vtype,$from,$to,$fmt)
= @_;<BR>
212&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $len = $to - $from + 1;<BR>
213&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf EncD &quot;\n\n&quot;;
<BR>
214&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf EncD &quot;/* Encode:$vtype,$vname,$from,$to,$len,$fmt
*/&quot;;<BR>
215&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($vtype eq 'char') {<BR>
216&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
EncD &quot;\ncp = (STRPTR )&amp;(buffer[%d]); &quot;,$from-1;
<BR>
217&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
EncD &quot;\nfor (i=0; i&lt; %d;i++)&quot;,$len;<BR>
218&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
EncD &quot;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer[%d + i] = sp-&gt;%s[i];
&quot;,$from-1,$vname;<BR>
219&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
220&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($vtype eq 'double') {<BR>
221&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (length($fmt)
&gt; 0)<BR>
222&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
223&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
EncD &quot;\nsprintf(tempbuffer,\&quot;%%%sf\&quot;,(sp-&gt;%s));&quot;,
$fmt,$vname;<BR>
224&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
225&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
<BR>
226&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
227&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
EncD &quot;\nsprintf(tempbuffer,\&quot;%%%sf\&quot;,(sp-&gt;%s));&quot;,
<BR>
228&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$len,$vname;
<BR>
229&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
230&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
EncD &quot;\ntempbuffer[%d]= 0; &quot;,$len;<BR>
231&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
EncD &quot;\nstrncat((STRPTR )(&amp;buffer[%d]),tempbuffer,%d);&quot;,
<BR>
232&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$from-1,$len;
<BR>
233&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
234&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($vtype eq 'int') {<BR>
235&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
236&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($len
== 1)<BR>
237&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
238&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
EncD &quot;\nsp-&gt;%s %%= 10;&quot;, $vname;<BR>
239&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
EncD &quot;\ntempbuffer[%d] = (char)('0' + sp-&gt;%s);&quot;,
<BR>
240&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$from-1,$vname;
<BR>
241&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
EncD &quot;\ntempbuffer[%d] = 0; &quot;,$from;<BR>
242&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
243&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
<BR>
244&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
245&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
EncD &quot;\nsprintf(tempbuffer,\&quot;%%d%d\&quot;,(sp-&gt;%s));&quot;,$len,$vname;
<BR>
246&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
EncD &quot;\ntempbuffer[%d]= 0; &quot;,$len;<BR>
247&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
248&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
EncD &quot;\nstrncat((STRPTR )(&amp;buffer[%d]),tempbuffer,%d);&quot;,
<BR>
249&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$from-1,$len;
<BR>
250&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
251&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
252&nbsp;}&nbsp;# end of subroutine.<BR>
253<BR>
254<BR>
255 # --------------------------------------------------------------------
<BR>
256 #&nbsp;&nbsp;To create the C source file to create decoder
for the data file.<BR>
257 # --------------------------------------------------------------------
<BR>
258 sub startDecoderFile {<BR>
259 print (DECD &quot;\/**\n* C source file to decode records.&quot;,
<BR>
260&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; \nDon't edit this file\n
&quot;,<BR>
261&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;*/\n&quot;,<BR>
262&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'#include &quot;p286.h&quot;
',<BR>
263&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n&quot;,<BR>
264&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n/* The outgoing buffer
must be 81 chars! */&quot;,<BR>
265&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nextern void padTo80(STRPTR
buffer); \n&quot;,<BR>
266&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n&quot;,<BR>
267&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n/* The outgoing buffer
must also be 81 chars! */&quot;,<BR>
268&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\nvoid substr(STRPTR buffer,STRPTR
cut,int offset,&nbsp;int len)\n{\n&quot;,<BR>
269&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;int i,j; \nj = offset;\n&quot;,
<BR>
270&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;for(i=len;i&lt;80;i++)
cut[i] = buffer[j]; \n &quot;,<BR>
271&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;cut[len] = 0; /* NULL terminate
the string*/&quot;,<BR>
272&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n} /* end of padding function
*/\n&quot;,<BR>
273&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n&quot;);<BR>
274 }<BR>
275<BR>
276 # --------------------------------------------------------------------
<BR>
277 #&nbsp;&nbsp;&nbsp;Create the preamble for a decoder function
<BR>
278 # --------------------------------------------------------------------
<BR>
279 sub startDecoderFunction {<BR>
280&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my($vname) = @_;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
Pick up name of record.<BR>
281&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print (DECD &quot;\n/*: &quot;,
<BR>
282&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n** Generated by Perl
script -- Avoid editing &quot;,<BR>
283&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n** The outgoing buffer
must also be 81 chars!&quot;,<BR>
284&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n*/\n&quot;;<BR>
285&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf (DECD<BR>
286&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;void decode_%s_type(P286_%s_PTR
sp,STRPTR buffer)\n{&quot;,<BR>
287&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $vname, $vname);
<BR>
288&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print (DECD &quot;\nSTRPTR cp;
\n&quot;,<BR>
289&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;register int i; \n&quot;,
<BR>
290&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;char tempbuffer[80];\n&quot;);
<BR>
291&nbsp;}<BR>
292<BR>
293&nbsp;# --------------------------------------------------------------------
<BR>
294 #&nbsp;&nbsp;&nbsp;Create the closing braces for a decoder
function<BR>
295 # --------------------------------------------------------------------
<BR>
296 sub closeDecoderFunction {<BR>
297&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print DECD &quot;\n} /* End of
decoding function */ \n&quot;;<BR>
298&nbsp;}<BR>
299<BR>
300 # --------------------------------------------------------------------
<BR>
301 #&nbsp;&nbsp;&nbsp;Create the source code for decoding a variable
<BR>
302 # --------------------------------------------------------------------
<BR>
303 sub decodeVariable {<BR>
304&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my ($vname,$vtype,$from,$to,$fmt)
= @_;<BR>
305&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my&nbsp;&nbsp;$len = $to - $from
+ 1;<BR>
306&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf DECD &quot;\n&quot;;<BR>
307&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($vtype =~ /char/)<BR>
308&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
309&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
DECD &quot;\nstrncpy(sp-&gt;%s,(STRPTR )(&amp;buffer[%d]),%d);&quot;,
<BR>
310&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
$vname,$from-1,$len;<BR>
311&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
DECD &quot;\nsp-&gt;%s[%d]= 0; &quot;,$vname,$len;<BR>
312&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
313&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($vtype =~ /double/)<BR>
314&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
315&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
DECD &quot;\nstrncpy(tempbuffer,(STRPTR )(&amp;buffer[%d]),%d);&quot;,
<BR>
316&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$from-1,$len;
<BR>
317&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
DECD &quot;\ntempbuffer[%d]= 0; &quot;,$len;<BR>
318&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
DECD &quot;\nsscanf(tempbuffer,\&quot;%%%sf\&quot;,&amp;(sp-&gt;%s));&quot;,
$fmt,$vname;<BR>
319&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
320&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($vtype =~ /int/)<BR>
321&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
322&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
DECD &quot;\nstrncpy(tempbuffer,(STRPTR )(&amp;buffer[%d]),%d);&quot;,
<BR>
323&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$from-1,$len;
<BR>
324&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
DECD &quot;\ntempbuffer[%d]= 0; &quot;,$len;<BR>
325&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
DECD &quot;\nsscanf(tempbuffer,\&quot;%%%dd\&quot;,&amp;(sp-&gt;%s));&quot;,$len,$vname;
<BR>
326&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
327 }</FONT></TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="Summary"><B><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></B></A>
</H2>
<P>
Although the example given in this chapter is for a very specialized
parse code generator, it provides examples of several ways to
apply Perl to solving problems. Here are the important points
to remember:
<UL>
<LI><FONT COLOR=#000000>The code being generated by the Perl program
was being used to parse records with a similar format. The format
of each record was general enough to have similar functions decode
it. There were no hidden surprises in terms of special cases that
would make code generation anything less than general.</FONT>
<LI><FONT COLOR=#000000>Using Perl would have been a good choice
to parse the data but the underlying platforms did not support
Perl.</FONT>
<LI><FONT COLOR=#000000>The number of variables to look for was
fixed. Only a few types of variables (</FONT><TT><FONT FACE="Courier">char</FONT></TT>,
<TT><FONT FACE="Courier">int</FONT></TT>, and <TT><FONT FACE="Courier">double</FONT></TT>)
were used. Introducing user-defined types or several other variables
would make the code generation more complicated.
<LI><FONT COLOR=#000000>The code being generated out of a Perl
program was used with C code in other programs. Once generated,
it could be optimized manually for speed.</FONT>
<LI><FONT COLOR=#000000>Because you are in control of the code
being generated, do not forget to generate comments in the native
language of the code being created. Such comments will serve as
a great cross-reference in the future or the generated code is
being debugged.</FONT>
<LI><FONT COLOR=#000000>By taking the grunt work out of the programming
cycle, a lot of typing errors were removed from the final code.
If there was one error, it would be propagated to all the generated
code dependent on that erroneous code.</FONT>
<LI><FONT COLOR=#000000>Similarly, any changes in the format,
though not very likely given the age of the format, could be accommodated
by simply modifying the Perl script and regenerating the source
code. It sure beats going through pages of code that looks the
same, doesn't it?</FONT>
<LI><FONT COLOR=#000000>The original specification was inconsistent
in defining the structures for use with the format. Had the original
specification been more consistent, Perl could have been used
to actually extract the data from the specification itself and
generated the </FONT><TT><FONT FACE="Courier">P286hdrs</FONT></TT>
file! Unfortunately, this was not possible; however, your situation
might be quite different. Keep your eyes open for such developing
patterns.
<LI><FONT COLOR=#000000>Finally, the input files in the real case
were a lot larger, with at least four files-each more than 500
lines long. Had this only been a few structures, it would have
been more practical to just code the final version without resorting
to Perl.</FONT>
</UL>
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch30.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch30.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch32.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch32.htm"><IMG 
SRC="nc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>
