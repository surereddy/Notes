<HTML>

<HEAD>
   <TITLE>Chapter 14 -- Signals, Pipes, FIFOs, and Perl</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT COLOR=#FF0000>Chapter 14</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Signals, Pipes, FIFOs, and Perl</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#Signals" >Signals</A>
<UL>
<LI><A HREF="#UsingtheConfigModule" >Using the Config Module</A>
</UL>
<LI><A HREF="#ThekillFunction" >The kill() Function</A>
<LI><A HREF="#ThewarnFunction" >The warn() Function</A>
<LI><A HREF="#Timeouts" >Timeouts</A>
<LI><A HREF="#PipesandFIFOs" >Pipes and FIFOs</A>
<LI><A HREF="#UsingopenforIpc" >Using open() for Ipc</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
The basic interprocess communication facilities available via
Perl are built on the old UNIX facilities: signals, named pipes,
pipe opens, the Berkeley socket routines, and SysV Ipc calls.
I have already covered sockets, shared memory, semaphores, and
message queues in the previous sections. I cover the use of signals
and pipes in this chapter.
<H2><A NAME="Signals"><FONT SIZE=5 COLOR=#FF0000>Signals</FONT></A>
</H2>
<P>
A <I>signal</I> is a message sent to a process that indicates
an event has occurred. The event can be something unexpected and,
in general, cause the process to terminate. Types of such signal
events include division by zero, a bus error, a segmentation fault,
or sometimes even imminent power failure. All signals are not
bad news. UNIX kernels use signals for timing. Users can send
signals by hitting keys such as Ctrl+C, Break, or Delete.
<P>
The types of signals recognized by the kernel are listed in the
standard UNIX header file <TT><FONT FACE="Courier">/usr/include/signal.h</FONT></TT>.
The names of these signals are listed in Table 14.1. Not all of
these signals may be implemented in your UNIX system, and even
fewer are usable in Perl. However, I will cover all the signals
that you definitely need to know.<BR>
<P>
<CENTER><B>Table 14.1 Signal types.</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=109><I>Signal</I></TD><TD WIDTH=73><CENTER><I>Number</I></CENTER>
</TD><TD WIDTH=250><I>Description</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGHUP</FONT></TT>
</TD><TD WIDTH=73><CENTER>1</CENTER></TD><TD WIDTH=250>On hangup
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGINT</FONT></TT>
</TD><TD WIDTH=73><CENTER>2</CENTER></TD><TD WIDTH=250>On interrupt
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGQUIT</FONT></TT>
</TD><TD WIDTH=73><CENTER>3</CENTER></TD><TD WIDTH=250>On Quit key
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGILL</FONT></TT>
</TD><TD WIDTH=73><CENTER>4</CENTER></TD><TD WIDTH=250>Illegal instruction
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGTRAP</FONT></TT>
</TD><TD WIDTH=73><CENTER>5</CENTER></TD><TD WIDTH=250>Trap instruction
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGABRT</FONT></TT>
</TD><TD WIDTH=73><CENTER>6</CENTER></TD><TD WIDTH=250>Abort message
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGIOT</FONT></TT>
</TD><TD WIDTH=73><CENTER>6</CENTER></TD><TD WIDTH=250>Input/output transfer
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGBUS</FONT></TT>
</TD><TD WIDTH=73><CENTER>7</CENTER></TD><TD WIDTH=250>Bus error
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGFPE</FONT></TT>
</TD><TD WIDTH=73><CENTER>8</CENTER></TD><TD WIDTH=250>Floating-point error
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGKILL</FONT></TT>
</TD><TD WIDTH=73><CENTER>9</CENTER></TD><TD WIDTH=250>Kill signal from system
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGUSR1</FONT></TT>
</TD><TD WIDTH=73><CENTER>10</CENTER></TD><TD WIDTH=250>User defined
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGSEGV</FONT></TT>
</TD><TD WIDTH=73><CENTER>11</CENTER></TD><TD WIDTH=250>Segmentation violation
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGUSR2</FONT></TT>
</TD><TD WIDTH=73><CENTER>12</CENTER></TD><TD WIDTH=250>User defined
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGPIPE</FONT></TT>
</TD><TD WIDTH=73><CENTER>13</CENTER></TD><TD WIDTH=250>Pipe fault (broken pipe)
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGALRM</FONT></TT>
</TD><TD WIDTH=73><CENTER>14</CENTER></TD><TD WIDTH=250>Alarm
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGTERM</FONT></TT>
</TD><TD WIDTH=73><CENTER>15</CENTER></TD><TD WIDTH=250>Termination
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGSTKFLT</FONT></TT>
</TD><TD WIDTH=73><CENTER>16</CENTER></TD><TD WIDTH=250>Stack fault
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGchLD</FONT></TT>
</TD><TD WIDTH=73><CENTER>17</CENTER></TD><TD WIDTH=250>Signal from child
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGCONT</FONT></TT>
</TD><TD WIDTH=73><CENTER>18</CENTER></TD><TD WIDTH=250>Continuing a stopped process
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGSTOP</FONT></TT>
</TD><TD WIDTH=73><CENTER>19</CENTER></TD><TD WIDTH=250>Stopping a process
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGTSTP</FONT></TT>
</TD><TD WIDTH=73><CENTER>20</CENTER></TD><TD WIDTH=250>Stopping a process from terminal
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGTTIN</FONT></TT>
</TD><TD WIDTH=73><CENTER>21</CENTER></TD><TD WIDTH=250>Stopping a process reading from controlling terminal
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGTTOU</FONT></TT>
</TD><TD WIDTH=73><CENTER>22</CENTER></TD><TD WIDTH=250>Stopping a process writing to controlling terminal
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGURG</FONT></TT>
</TD><TD WIDTH=73><CENTER>23</CENTER></TD><TD WIDTH=250>Urgent condition
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGXCPU</FONT></TT>
</TD><TD WIDTH=73><CENTER>24</CENTER></TD><TD WIDTH=250>Excessive CPU limits reached
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGXFSZ</FONT></TT>
</TD><TD WIDTH=73><CENTER>25</CENTER></TD><TD WIDTH=250>Excessive file size limits reached
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGVTALRM</FONT></TT>
</TD><TD WIDTH=73><CENTER>26</CENTER></TD><TD WIDTH=250>Virtual interval timer expired
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGPROF</FONT></TT>
</TD><TD WIDTH=73><CENTER>27</CENTER></TD><TD WIDTH=250>Profiling interval timer expired
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGWINch</FONT></TT>
</TD><TD WIDTH=73><CENTER>28</CENTER></TD><TD WIDTH=250>Window size changed by background process
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGIO</FONT></TT></TD>
<TD WIDTH=73><CENTER>29</CENTER></TD><TD WIDTH=250>Asynchronous I/O
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGPWR</FONT></TT>
</TD><TD WIDTH=73><CENTER>30</CENTER></TD><TD WIDTH=250>Power failure
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=109><TT><FONT FACE="Courier">SIGUNUSED</FONT></TT>
</TD><TD WIDTH=73><CENTER>31</CENTER></TD><TD WIDTH=250>Unused
</TD></TR>
</TABLE></CENTER>
<P>
<P>
The names of the signals available to you on your system are the
ones listed by <TT><FONT FACE="Courier">kill -l</FONT></TT> on
your system. You can also retrieve them from the <TT><FONT FACE="Courier">Config</FONT></TT>
module. The following example shows how to obtain a list of available
signals on your system:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$ <B>kill -l<BR>
</B>&nbsp;1) SIGHUP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2)
SIGINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3) SIGQUIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4)
SIGILL<BR>
&nbsp;5) SIGTRAP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
6) SIGIOT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7) SIGBUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
8) SIGFPE<BR>
&nbsp;9) SIGKILL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10) SIGUSR1&nbsp;&nbsp;&nbsp;&nbsp;
11) SIGSEGV&nbsp;&nbsp;&nbsp;&nbsp; 12) SIGUSR2<BR>
13) SIGPIPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14) SIGALRM&nbsp;&nbsp;&nbsp;&nbsp;
15) SIGTERM&nbsp;&nbsp;&nbsp;&nbsp; 17) SIGchLD<BR>
18) SIGCONT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19) SIGSTOP&nbsp;&nbsp;&nbsp;&nbsp;
20) SIGTSTP&nbsp;&nbsp;&nbsp;&nbsp; 21) SIGTTIN<BR>
22) SIGTTOU&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;23) SIGURG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;24)
SIGXCPU&nbsp;&nbsp;&nbsp;&nbsp; 25) SIGXFSZ<BR>
26) SIGVTALRM&nbsp;&nbsp;&nbsp;&nbsp;27) SIGPROF&nbsp;&nbsp;&nbsp;&nbsp;
28) SIGWINch&nbsp;&nbsp;&nbsp;&nbsp;29) SIGIO<BR>
30) SIGPWR</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="UsingtheConfigModule">Using the <TT><FONT SIZE=4 FACE="Courier">Config</FONT></TT><FONT SIZE=4>
Module</FONT></A></H3>
<P>
Another way of getting a list of signals on your system is by
using the supplied <TT><FONT FACE="Courier">Config</FONT></TT>
module, as shown in Listing 14.1. The output from this simple
script is shown following the listing. The list of signal names
in the <TT><FONT FACE="Courier">Config</FONT></TT> module is accessed
via the <TT><FONT FACE="Courier">$Config{sig_name}</FONT></TT>
variable. (The signal names are separated by white space.) By
the way, the program shown in Listing 14.1 requires Perl 5 and
will not work in Perl 4.
<HR>
<BLOCKQUOTE>
<B>Listing 14.1. Using the </B><TT><B><FONT FACE="Courier">Config</FONT></B></TT><B>
module to get a list of signals.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 #<BR>
&nbsp;3 # Use the Config
module to get list of signals<BR>
&nbsp;4<BR>
&nbsp;5 use Config;<BR>
&nbsp;6<BR>
&nbsp;7 defined $Config{sig_name}
|| die &quot;No Config Module?&quot;;<BR>
&nbsp;8<BR>
&nbsp;9 foreach $name (split('
', $Config{sig_name})) {<BR>
10&nbsp;&nbsp;&nbsp;&nbsp; $i++;<BR>
11&nbsp;&nbsp;&nbsp;&nbsp; printf &quot;%3d) %s \t&quot;, $i,
$name;<BR>
12&nbsp;&nbsp;&nbsp;&nbsp; if (($i % 5) == 0) { print &quot;\n&quot;;&nbsp;&nbsp;}
<BR>
13&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
14 print &quot;\n&quot;;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Line 5 uses the <TT><FONT FACE="Courier">Config</FONT></TT> module
to include its definitions. The existence of the <TT><FONT FACE="Courier">Config</FONT></TT>
signal names array is confirmed in line 7. Lines 9 through 14
print out a columnar output of all the signal names defined in
the <TT><FONT FACE="Courier">Config</FONT></TT> array. Here is
the output generated by the code in Listing 14.1.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$ <B>listsigs.pl<BR>
<BR>
</B>&nbsp;&nbsp;1) ZERO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2) HUP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3) INT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4)
QUIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5) ILL<BR>
&nbsp;&nbsp;6) TRAP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7) IOT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
8) BUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9) FPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
10) KILL<BR>
&nbsp;11) USR1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12)
SEGV&nbsp;&nbsp;&nbsp;&nbsp; 13) USR2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14)
PIPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15) ALRM<BR>
&nbsp;16) TERM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17) STKFLT&nbsp;&nbsp;&nbsp;18)
chLD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19) CONT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20)
STOP<BR>
&nbsp;21) TSTP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;22)
TTIN&nbsp;&nbsp;&nbsp;&nbsp; 23) TTOU&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;24)
URG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 25) XCPU<BR>
&nbsp;26) XFSZ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;27) VTALRM&nbsp;&nbsp;&nbsp;28)
PROF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;29) WINch&nbsp;&nbsp;&nbsp;&nbsp;
30) LOST<BR>
&nbsp;31) PWR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32) UNUSED</FONT></TT>
</BLOCKQUOTE>
<P>
A process does not know when a signal might occur because signals
are asynchronous events. Programmatically, you can either ignore
almost all signal messages or handle them yourself with a signal
handler. This process of handling the signal is referred to as
<I>trapping a signal</I>. A handler is simply a function that
is called when the signal arrives.
<P>
In Perl, a special hash called <TT><FONT FACE="Courier">%SIG</FONT></TT>
contains either names or references to all the signal handlers.
You have to install your own signal handler to trap a signal.
If you do install a handler, Perl uses the default handling mechanism
for that signal. Signal handlers are considered by the Perl interpreter
to be in the main module unless otherwise specified. To specify
a different module, you have to specify the package name. Therefore,
you would use something like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$SIG{'QUIT'} = 'myModule::babysitter';</FONT></TT>
</BLOCKQUOTE>
<P>
Signal handlers are basically just Perl functions. However, some
restrictions apply while you are in the handler. First of all,
signal handlers are called with an argument that is the name of
the signal that triggered it. Therefore, your handler can be written
to trap more than one signal if you want. Simply use the passed
argument to determine what to do in the handler. Next, if your
signal handler is being called when something out of the ordinary
happens, you should not attempt to do lengthy operations while
in the handler. For example, doing lengthy disk writes within
a handler is <I>not</I> a good idea. Finally, try to use references
instead of names because the code is cleaner and faster.
<P>
Another important point to keep in mind is that there is only
one <TT><FONT FACE="Courier">%SIG{}</FONT></TT> array in the Perl
script you are running. Setting an entry in <TT><FONT FACE="Courier">%SIG{}</FONT></TT>
in one subroutine sets it for all objects in your program. There
is no &quot;<TT><FONT FACE="Courier">my</FONT></TT>&quot; <TT><FONT FACE="Courier">%SIG{}</FONT></TT>
array with which you can set your own handler functions.
<P>
To set a signal handler, you use the following statement:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$SIG{INT} = \&amp;meHandleINT;</FONT></TT>
</BLOCKQUOTE>
<P>
In this statement, <TT><FONT FACE="Courier">meHandleINT</FONT></TT>
is a reference to a subroutine defined as something similar to
this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub meHandleSignals {<BR>
&nbsp;&nbsp;&nbsp;my $signame =&nbsp;&nbsp;shift;&nbsp;&nbsp;&nbsp;#Grab
signal name from passed input<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">die &quot;Caught
Signal: SIG$signame&quot;;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
You can use the signal-handling function's name instead of the
reference; however, this is no longer the preferred, cool way
of doing things because references give a faster lookup. Therefore,
avoid setting handlers with statements like this one:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$SIG{INT} = 'meHandleINTs';</FONT></TT>
</BLOCKQUOTE>
<P>
You can use anonymous functions to install signal handlers. However,
be warned that some systems will not allow you to handle this
signal more than once, especially on System V machines where the
signal handler must be reinstalled every time it's hit. Use references
instead of trying a statement like this one:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$SIG{INT} = sub { die &quot;\nBye\n&quot;
};&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;Not portable</FONT></TT>
</BLOCKQUOTE>
<P>
By modifying the value of the reference in <TT><FONT FACE="Courier">%SIG{}</FONT></TT>
entries, you can add or remove signal handlers. Listing 14.2 presents
an example. While the program is asleep, the signal handler <TT><FONT FACE="Courier">vocalHandler</FONT></TT>
can be called if the Ctrl+C key combination is pressed. However,
after the sleep session is over, the default value of <TT><FONT FACE="Courier">$SIG{INT}</FONT></TT>
is restored to allow the script to be killed via the default Ctrl+C
combination. Notice also how the hangup signal is set to be ignored
while the program is running with <TT><FONT FACE="Courier">$SIG{HUP}='IGNORE'</FONT></TT>
assignment.
<HR>
<BLOCKQUOTE>
<B>Listing 14.2. Signal handler usage.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2<BR>
&nbsp;3 sub vocalHandler
{<BR>
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp; local($sig) = @_;<BR>
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;
print &quot;Hey! Stop that! SIG$sig hurts! \n&quot;;<BR>
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp; exit(1);<BR>
&nbsp;7 }<BR>
&nbsp;8<BR>
&nbsp;9 $SIG{INT} = \&amp;vocalHandler;
<BR>
</FONT></TT>Listing 14.2. continued <BR>
<TT><FONT FACE="Courier">10<BR>
11 $SIG{HUP} ='IGNORE';<BR>
12<BR>
13 printf &quot;\n I am about to sleep&quot;;<BR>
14<BR>
15 sleep (10);<BR>
16<BR>
17 print &quot;\n Restoring. default signal handler. &quot;;<BR>
18<BR>
19 $SIG{INT} ='DEFAULT';</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The string <TT><FONT FACE="Courier">&quot;Hey!&#133;&quot;</FONT></TT>
will be printed out every time you hit the Ctrl+C key combination
during the 10-second interval that your Perl script is asleep.
<P>
There are two signal names that are reserved: <TT><FONT FACE="Courier">IGNORE</FONT></TT>
and <TT><FONT FACE="Courier">DEFAULT</FONT></TT>. When a signal
handler is set to <TT><FONT FACE="Courier">IGNORE</FONT></TT>,
Perl tries to discard the signal. When a signal handler is set
to <TT><FONT FACE="Courier">DEFAULT</FONT></TT>, Perl takes the
default action taken by functions called from within that block.
Some signals cannot be trapped or ignored (for example, the <TT><FONT FACE="Courier">KILL</FONT></TT>
and <TT><FONT FACE="Courier">STOP</FONT></TT> signals).
<P>
All modules and inherited objects affect the <TT><FONT FACE="Courier">%SIG{}</FONT></TT>
hash. However, the <TT><FONT FACE="Courier">%SIG</FONT></TT> hash
can be redeclared in a function as a local variable to completely
mask out the default <TT><FONT FACE="Courier">%SIG{}</FONT></TT>
hash. The original hash still remains, but due to scoping rules
in Perl, the local <TT><FONT FACE="Courier">%SIG{}</FONT></TT>
is used.
<P>
The <TT><FONT FACE="Courier">%SIG</FONT></TT> hash is not local
to each module unless you declare it as such. This is used to
disable signals temporarily within certain function calls. Here's
a sample fragment of code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub warpper {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;local $SIG{INT} = 'IGNORE';&nbsp;&nbsp;&nbsp;#
declare a new SIG hash.<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">&nbsp;&nbsp;&nbsp;&nbsp;&amp;localFunction;&nbsp;&nbsp;#Then
call this function.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;sub localFunction {<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">&nbsp;&nbsp;&nbsp;&nbsp;#
interrupts are still ignored in this function.<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Upon entry into the wrapper function, a local <TT><FONT FACE="Courier">%SIG</FONT></TT>
hash is created and the <TT><FONT FACE="Courier">INT</FONT></TT>
interrupt is set to be ignored. The <TT><FONT FACE="Courier">localFunction</FONT></TT>
is then undisturbed by <TT><FONT FACE="Courier">SIGINT</FONT></TT>.
On exiting from the wrapper function, the <TT><FONT FACE="Courier">%SIG</FONT></TT>
hash in the main module is the default array. Therefore, the values
in the <TT><FONT FACE="Courier">%SIG</FONT></TT> hash are inherited
by the lower modules.
<H2><A NAME="ThekillFunction"><FONT SIZE=5 COLOR=#FF0000>The </FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">kill()</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Function</FONT></A></H2>
<P>
The <TT><FONT FACE="Courier">kill()</FONT></TT> function is used
to send the <TT><FONT FACE="Courier">KILL</FONT></TT> signal to
a process or a set of processes. The first parameter of the <TT><FONT FACE="Courier">kill()</FONT></TT>
function is the signal number, followed by a list of process IDs.
The usual UNIX permissions apply. Your script must own the process
it's about to blow out of the water. That is, the effective and
real UID (user ID) must be the same for the process sending the
signal and the process receiving the signal. Here's the syntax
for the <TT><FONT FACE="Courier">kill()</FONT></TT> function:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">kill signalNumber,processID</FONT></TT>
</BLOCKQUOTE>
<P>
You can specify more than one process on the line by the command:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">kill signalNumber,processID, processID,
....</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">kill</FONT></TT> function can be
used to terminate a lot of processes at once. All processes in
a process group can be terminated by another process in the group
by sending a negative <TT><FONT FACE="Courier">processID</FONT></TT>.
Such measures are taken by daemons that terminate all child processes.
The use of the blanket <TT><FONT FACE="Courier">kill</FONT></TT>
keeps you from keeping a table of process IDs of all the child
processes for an application program. The process making the call
with the negative ID is exempt from this pillage. That is, all
the rest of the processes, except the one making the call, will
be killed. The syntax for this call would be of the following
form:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">kill(9, -$$);</FONT></TT>
</BLOCKQUOTE>
<P>
To see whether a particular task is alive, you can use signal
0 with the <TT><FONT FACE="Courier">kill</FONT></TT> function.
A non-zero return value tells you that the task is alive; a zero
value tells you that the task does not exist.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">if&nbsp;&nbsp;(kill(0,$id)) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;print &quot;Task&nbsp;&nbsp;$id is alive;
<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">}&nbsp;&nbsp;&nbsp;&nbsp;else
{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;print &quot;Task&nbsp;&nbsp;$id is dead&quot;;
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="ThewarnFunction"><FONT SIZE=5 COLOR=#FF0000>The </FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">warn()</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Function</FONT></A></H2>
<P>
Sometimes in Perl scripts you have to warn the user about certain
conditions in the system by writing to the console. Normally,
you use the <TT><FONT FACE="Courier">die()</FONT></TT> function
to print the cause of death of a Perl script just before bailing
out. If you did not want to stop right at the cause of the error
but rather limp along with an error message only, a <TT><FONT FACE="Courier">print</FONT></TT>
statement may be redirected to some file. In this case, you would
use the <TT><FONT FACE="Courier">warn</FONT></TT> function. The
<TT><FONT FACE="Courier">warn</FONT></TT> function in Perl is
the same as the <TT><FONT FACE="Courier">die</FONT></TT> function,
except that the program keeps going with the <TT><FONT FACE="Courier">warn</FONT></TT>
function instead of stopping as it would with <TT><FONT FACE="Courier">die</FONT></TT>.
<H2><A NAME="Timeouts"><FONT SIZE=5 COLOR=#FF0000>Timeouts</FONT></A>
</H2>
<P>
You can use signals to handle timeouts in UNIX. The alarm function
comes in handy for these types of signals. Here's the syntax for
the <TT><FONT FACE="Courier">alarm()</FONT></TT> function:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">alarm numberOfseconds;</FONT></TT>
</BLOCKQUOTE>
<P>
For example, the following stub of code sets up <TT><FONT FACE="Courier">SIGALRM</FONT></TT>
for a program:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub aclk {<BR>
my&nbsp;&nbsp;$is = shift;<BR>
print &quot;something&quot;;<BR>
}<BR>
<BR>
$SIG{ALRM} = \&amp;clk;</FONT></TT>
</BLOCKQUOTE>
<P>
You can wait for a child process, too, with the <TT><FONT FACE="Courier">wait</FONT></TT>
command. The <TT><FONT FACE="Courier">wait</FONT></TT> command
returns after a child process dies and returns the process ID
of the dead child process. Calling the wait function may cause
you to hang forever if the child runs away and never dies. If
there are no children, this function returns <TT><FONT FACE="Courier">-1</FONT></TT>.
To wait explicitly for a process, you can specify its process
ID in the call to<B> </B><TT><FONT FACE="Courier">waitpid</FONT></TT>.
The syntax for the call is <TT><FONT FACE="Courier">waitpid $PID
0</FONT></TT>. The zero is required.
<H2><A NAME="PipesandFIFOs"><FONT SIZE=5 COLOR=#FF0000>Pipes and
FIFOs</FONT></A></H2>
<P>
A UNIX system call to <TT><FONT FACE="Courier">pipe()</FONT></TT>
can be used to create a communications channel between two processes.
Generally you call this function just before a fork call and then
use the pipe to communicate between a parent process and its child
process. Contrast this usage of pipes with message queues, which
can be used to communication between unrelated processes. Here's
the syntax for this call:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">pipe ( READHANDLE, WRITEHANDLE);</FONT></TT>
</BLOCKQUOTE>
<P>
Listing 14.3 illustrates a sample run of a pipe communication.
<HR>
<BLOCKQUOTE>
<B>Listing 14.3. A sample run when using pipes.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 $|=1;<BR>
&nbsp;3 #<BR>
&nbsp;4 # Create a pipe with the system call<BR>
&nbsp;5 #<BR>
&nbsp;6 $smoke = pipe(PIPE_R, PIPE_W);<BR>
&nbsp;7 #<BR>
&nbsp;8 # Fork off (almost) immediately.<BR>
&nbsp;9 #<BR>
10 if ($pid = fork) {<BR>
11&nbsp;&nbsp;&nbsp;&nbsp; printf &quot;\n Parent:&quot;;<BR>
12&nbsp;&nbsp;&nbsp;&nbsp; close PIPE_R;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
&lt;-- the handle you do not need.<BR>
13&nbsp;&nbsp;&nbsp;&nbsp; #<BR>
14&nbsp;&nbsp;&nbsp;&nbsp; # now write to the child.<BR>
15&nbsp;&nbsp;&nbsp;&nbsp; #<BR>
16&nbsp;&nbsp;&nbsp;&nbsp; select PIPE_W;<BR>
17&nbsp;&nbsp;&nbsp;&nbsp; for ($i=0;$i&lt;5;$i++) {<BR>
18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep 1;<BR>
19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf PIPE_W
&quot;[Sending: %d]\n&quot;, $i;<BR>
20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
21&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
22&nbsp;&nbsp;&nbsp;&nbsp; else<BR>
23&nbsp;&nbsp;&nbsp;&nbsp; {<BR>
24&nbsp;&nbsp;&nbsp;&nbsp; printf &quot;\n Child:&quot;;<BR>
25&nbsp;&nbsp;&nbsp;&nbsp; close PIPE_W;&nbsp;&nbsp;&nbsp;# &lt;-
won't be writing to it.<BR>
26&nbsp;&nbsp;&nbsp;&nbsp; #<BR>
27&nbsp;&nbsp;&nbsp;&nbsp; # now read from parent<BR>
28&nbsp;&nbsp;&nbsp;&nbsp; #<BR>
29&nbsp;&nbsp;&nbsp;&nbsp; for ($i=0;$i&lt;5;$i++) {<BR>
30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$buf =
&lt;PIPE_R&gt;;<BR>
31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# For
fixed length records you would use:<BR>
32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# read
PIPE_R,$buf,20;<BR>
33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print
&quot;Child: Received $buf \n&quot;;<BR>
34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
35&nbsp;&nbsp;&nbsp;&nbsp; }</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Line 2 of this listing sets the output buffers to be flushed as
soon as they are written to. Line 6 creates the pipe for you to
make <TT><FONT FACE="Courier">PIPE_R</FONT></TT> and <TT><FONT FACE="Courier">PIPE_W</FONT></TT>
valid handles. We immediately do a fork in line 10.
<P>
After the fork, there are actually four handles: two <TT><FONT FACE="Courier">PIPE_R</FONT></TT>
handles and two <TT><FONT FACE="Courier">PIPE_W</FONT></TT> handles.
Because the parent does not want to read its own echo on <TT><FONT FACE="Courier">PIPE_R</FONT></TT>,
it closes <TT><FONT FACE="Courier">PIPE_R</FONT></TT>. Similarly,
the child has no reason to write to itself, so it closes <TT><FONT FACE="Courier">PIPE_W</FONT></TT>.
Then the parent writes to the <TT><FONT FACE="Courier">PIPE_W</FONT></TT>
handle while the child reads from the <TT><FONT FACE="Courier">PIPE_R</FONT></TT>
handle.
<P>
The following lines are the output from this program. Note how
the output from the child and parent process is intermixed. This
is because both processes are running at the same priority and
accessing the output device (<TT><FONT FACE="Courier">stdout</FONT></TT>)
at the same time.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">hmm.. okParent:<BR>
&nbsp;Child:Child: Received [Sending: 0]<BR>
<BR>
Child: Received [Sending: 1]<BR>
<BR>
Child: Received [Sending: 2]<BR>
<BR>
Child: Received [Sending: 3]<BR>
<BR>
Child: Received [Sending: 4]</FONT></TT>
</BLOCKQUOTE>
<P>
Pipes are great when used between related processes. However,
if you want to communicate between two different processes, you
have to use FIFOs. A <I>FIFO</I> is also referred to as a <I>named
pipe</I>. Unrelated processes use named pipes to talk to each
other. The FIFO appears like a normal filename.
<P>
In Listing 14.4, line 6 names the FIFO pathname as it would appear
in the output from an <TT><FONT FACE="Courier">ls</FONT></TT>
command. In line 7, the FIFO is created with a system call to
the command <TT><FONT FACE="Courier">mkfifo</FONT></TT> using
the <TT><FONT FACE="Courier">-m</FONT></TT> option and pathname
used in line 6. The <TT><FONT FACE="Courier">unless</FONT></TT>
clause checks to see whether such a FIFO already exists before
attempting to recreate it. The code in line 8 actually opens the
FIFO after it is created. Then, in lines 9 through 11, you create
a string with the current date and send it to the FIFO. In line
12, you close the FIFO. The FIFO is not destroyed when it is closed
at line 12. You have to unlink the pathname-that is, remove the
FIFO by name to get rid of it, which is shown in line 14.
<P>
You can use an <TT><FONT FACE="Courier">ls</FONT></TT> command
on the FIFO name to see whether it exists. A way to test whether
a filename is a FIFO is to use the option <TT><FONT FACE="Courier">-p</FONT></TT>
on the filename from within a Perl script.
<HR>
<BLOCKQUOTE>
<B>Listing 14.4. Using FIFOs.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 #<BR>
&nbsp;3 # Create a fifo and
then return the date<BR>
&nbsp;4 # back to the caller when FIFO is read.<BR>
&nbsp;5 #<BR>
&nbsp;6 $path = &quot;./ch14_fifo&quot;;<BR>
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;
unless (-p $path) { system(&quot;mkfifo -m 0666 $path&quot;);
}<BR>
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp; open(FIFO,&quot;&gt; $path&quot;)
|| die &quot;Cannot open $! \n&quot;;<BR>
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;
$date = `date`;<BR>
10&nbsp;&nbsp;&nbsp;&nbsp; chop($date);<BR>
11&nbsp;&nbsp;&nbsp;&nbsp; print FIFO &quot;[$date]&quot;;<BR>
12&nbsp;&nbsp;&nbsp;&nbsp; close FIFO;<BR>
13 # Remove when done.<BR>
14 unlink $path;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The FIFO is opened in line 8. Now the program blocks until there's
something on the other end trying to read from it. Using a command
like <TT><FONT FACE="Courier">cat ch14_fifo</FONT></TT> triggers
line 9. The program then gets the system date and prints it out
to the FIFO. Line 14 cleans up after itself.
<P>
You would probably want to have a signal handler to clean up if
a terminating signal arrives before input is read from the FIFO
and the program exits before destroying the FIFO. This is the
reason for the <TT><FONT FACE="Courier">unless</FONT></TT> clause,
which checks for any existing FIFOs before creating a new one.
The signal to catch is <TT><FONT FACE="Courier">SIGPIPE</FONT></TT>
for broken pipes. To trap <TT><FONT FACE="Courier">SIGPIPE</FONT></TT>,
you have to add this segment to your code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub pipeHandler {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;my $sig = shift @_;<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">print
&quot; Caught SIGPIPE: $sig $1 \n&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;exit(1);<BR>
}<BR>
<BR>
$SIG{PIPE} = \&amp;pipeHandler;</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="UsingopenforIpc"><FONT SIZE=5 COLOR=#FF0000>Using
</FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">open()</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
for Ipc</FONT></A></H2>
<P>
The <TT><FONT FACE="Courier">open()</FONT></TT> statement can
be used to start communication pipes. The catch is that these
pipes are unidirectional. To read the results from a process,
put <TT><FONT FACE="Courier">|</FONT></TT> at the end of the command
being executed. To write your results to the standard input of
a process, put <TT><FONT FACE="Courier">|</FONT></TT> at the start
of the command.
<P>
For example, here's how to write your results to the sendmail
mailing program:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">open(LOG, &quot;| /usr/apps/formatData
 | /usr/bin/sendmail &quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
To read the results back from a process, use a line like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">open(READINGS, &quot;/usr/apps/commProgram
|&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
As an example, consider the program in Listing 14.5, which prints
the names of the files with the string passed to them at the command-line
argument. It then lists all the files within the associative array
<TT><FONT FACE="Courier">fname</FONT></TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 14.5. Storing results of a command in an array.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Storing results from
a program in an array.<BR>
&nbsp;3 my %fname = ();<BR>
&nbsp;4 #&nbsp;&nbsp;Open all files with names ending in .pl<BR>
&nbsp;5 open(IncOMING,&quot;grep
ARGV[1] *.pl |&quot;);<BR>
&nbsp;6 while (&lt;IncOMING&gt;) {<BR>
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;
($name,@line) =&nbsp;&nbsp;split(':',$_);<BR>
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp; if (!$fname{$name}) {<BR>
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$fname{$name}
= $name;<BR>
10&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
11 }<BR>
12 close IncOMING;<BR>
13<BR>
14 while (($key,$value) = each (%fname)) {<BR>
15&nbsp;&nbsp;&nbsp;&nbsp; print &quot;File: &quot; . $key . &quot;\n&quot;;
<BR>
16 }</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
It's probably tempting to use the back ticks to run a program
for you and collect the results. For example, <TT><FONT FACE="Courier">$a
= `who`</FONT></TT> returns the entire results of the <TT><FONT FACE="Courier">who</FONT></TT>
command in variable <TT><FONT FACE="Courier">$a</FONT></TT>. It's
impractical to use this method to collect results from a verbose
command. Using a command like <TT><FONT FACE="Courier">$a=`ls
-lr`</FONT></TT> is a lot slower than actually opening a file
handle to the output of this command and then processing it one
line at a time. The problem is that the entire result of the command
is stored in variable <TT><FONT FACE="Courier">$a</FONT></TT>,
chewing up memory and time while <TT><FONT FACE="Courier">$a</FONT></TT>
is appended to. It's easier and far more efficient to simply read
from the output in manageable chunks.
<P>
Use two pipes to do bidirectional communications. Do not use a
statement with a <TT><FONT FACE="Courier">|</FONT></TT> at end
of the command. Perl does not allow commands using this syntax:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">open(HANDLE, &quot;| sort |&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
Perl gives an error message about not being able to perform bidirectional
pipes.
<P>
The <TT><FONT FACE="Courier">open()</FONT></TT> function can accept
a file argument of either <TT><FONT FACE="Courier">-|</FONT></TT>
or <TT><FONT FACE="Courier">|-</FONT></TT>. Accepting either of
these parameters forks a child connected to the file handle you've
just opened. The child is then running the same program as the
parent. The return value from the call to <TT><FONT FACE="Courier">open()</FONT></TT>
is the process ID of the child or zero for the parent. The function
dies if it cannot fork within the <TT><FONT FACE="Courier">open()</FONT></TT>
call. Here's a sample usage of <TT><FONT FACE="Courier">-|</FONT></TT>
to create a receiving child:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$| = 1;&nbsp;&nbsp;&nbsp;# Always do
unbuffered IO here.<BR>
<BR>
$pid = open(MYHANDLE, &quot;|-&quot;);<BR>
if ($pid == 0) {<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">#parent
acts as server<BR>
&nbsp;&nbsp;&nbsp;&nbsp;print MYHANDLE, &quot; something&quot;;
<BR>
} else {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;#child acts as receiver.<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">getSomething
= &lt;MYHANDLE&gt;;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
An implicit <TT><FONT FACE="Courier">fork()</FONT></TT> is possible
with the <TT><FONT FACE="Courier">open2()</FONT></TT> command.
Basically, with this call you start off two processes running
the same code. The child process ID is returned to the client.
Errors cause the function to bail out. The <TT><FONT FACE="Courier">Ipc::Open2</FONT></TT>
module is required for this to work. Also, you have to make sure
you are reading and writing continuously to this buffer. Be careful
to run only programs for which you know the input and output sequences.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$|&nbsp;&nbsp;= 1;<BR>
$pid = open('BI_R', 'BI_W', &quot;myPerlScript&quot;);<BR>
if ($pid == 0) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;#parent acts as server<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">print
B_R, &quot; something&quot;;<BR>
} else {<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">#child
acts as receiver.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;getSomething = &lt;MYHANDLE&gt;;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
There is an <TT><FONT FACE="Courier">open3()</FONT></TT> function
call, too, that adds <TT><FONT FACE="Courier">STDERR</FONT></TT>
to the list of opened files with which you may work.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
This is a very quick introduction to using UNIX pipes and signals
with Perl. Signals are a way of asynchronously telling a process
about an event. Generally, signals can only be caught and an error
message displayed about the type of signal through the use of
a subroutine, called a <I>handler</I>. The types of signals vary
depending on the type of UNIX system you use.
<P>
Using pipes is a method of communication between two processes
that is old, yet still heavily used in UNIX. If a pipe (<TT><FONT FACE="Courier">|</FONT></TT>)
is placed at the beginning of a filename in an <TT><FONT FACE="Courier">open()</FONT></TT>
call, you'll be writing to a pipe with a UNIX command, file, or
device at the other end. If <TT><FONT FACE="Courier">command |</FONT></TT>
is placed at the end of a filename to the <TT><FONT FACE="Courier">open()</FONT></TT>
call, you'll be reading the output of the command. Bi-directional
and even tridirectional pipes are possible using the <TT><FONT FACE="Courier">open2()</FONT></TT>
and <TT><FONT FACE="Courier">open3()</FONT></TT> calls.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch13.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch13.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch15.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch15.htm"><IMG 
SRC="nc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>
