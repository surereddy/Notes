<HTML>

<HEAD>
   <TITLE>Chapter 32 -- Dynamic Image Creation</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT COLOR=#FF0000>Chapter 32</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Dynamic Image Creation</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#Introduction" >Introduction</A>
<LI><A HREF="#TwoDimensionalPlots" >Two-Dimensional Plots</A>
<LI><A HREF="#ThreeDimensionalPlots" >Three-Dimensional Plots</A>
<LI><A HREF="#UsingtheOutputinCGIApplications" >Using the Output in CGI Applications</A>
<LI><A HREF="#CreatingGIFImagesDirectlyfromPerl" >Creating GIF Images Directly from Perl</A>
<UL>
<LI><A HREF="#InstallingthegdLibrary" >Installing the gd Library</A>
<LI><A HREF="#InstallingGDpm" >Installing GD.pm</A>
</UL>
<LI><A HREF="#WorkingwithGDpm" >Working with GD.pm</A>
<LI><A HREF="#UsingGDwithHTMLPages" >Using GD with HTML Pages</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
This chapter covers how to create GIF images from within a Perl
program. The output of the programs developed here can be used
in HTML pages or for other graphical applications. If you have
not already done so, please read <A HREF="ch20.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch20.htm" >Chapter 20</A>,
&quot;An Introduction to Web Pages and CGI,&quot; for some of
the background you'll need for this chapter.
<H2><A NAME="Introduction"><B><FONT SIZE=5 COLOR=#FF0000>Introduction</FONT></B></A>
</H2>
<P>
When writing Perl applications, it's often necessary to display
the results of your application graphically. One common way to
display these results is to print them in columns and pipe the
output to a display program such as <TT><FONT FACE="Courier">gnuplot</FONT></TT>.
<P>
For most applications, <TT><FONT FACE="Courier">gnuplot</FONT></TT>
works great for plotting charts or columnar data. By using <TT><FONT FACE="Courier">gnuplot</FONT></TT>,
you can print many types of charts, using different types of axes,
colors, and so on. It's possible to write a script for <TT><FONT FACE="Courier">gnuplot</FONT></TT>
to extract data from columns from within a data file. I won't
go into too much detail here. The purpose of this chapter is to
show you how to use Perl to control <TT><FONT FACE="Courier">gnuplot</FONT></TT>,
not how to program <TT><FONT FACE="Courier">gnuplot</FONT></TT>.
Type <TT><B><FONT FACE="Courier">help</FONT></B></TT> at the <TT><FONT FACE="Courier">gnuplot</FONT></TT>
prompt to get an interactive manual that contains details on how
to program in <TT><FONT FACE="Courier">gnuplot</FONT></TT>.
<P>
Though this scheme of using <TT><FONT FACE="Courier">gnuplot</FONT></TT>
works well for most applications, it does have a few drawbacks:
<UL>
<LI><FONT COLOR=#000000>There are two processes involved in the
image creation. The use of system resources for such image creation
is high for complex images. Even if you do not use an intermediate
file to store the points for display, you still have to use a
pipe to send the output to the rasterization program.</FONT>
<LI><TT><FONT FACE="Courier">Gnuplot</FONT></TT> allows non-interactive
operation through the use of scripts. Some rasterization programs
do not work in this manner. In this case, some intermediate format
has to be chosen to create the images.
<LI><FONT COLOR=#000000>The entire process of generating an image
involves creating the points for the image in a palatable format
for the rasterization program to pick. This puts the onus on the
program for massaging data into an array, if necessary, before
printing it out. Doing this makes the code harder to program but
saves you from the grunt work of managing the details of the image
yourself. It's generally easier to create the image all in one
go.</FONT>
<LI><FONT COLOR=#000000>For Web applications, using a GIF image
format for the output makes it easier to load into Web pages.
</FONT><TT><FONT FACE="Courier">Gnuplot</FONT></TT> can generate
images in many formats but does not produce images in the GIF
format.
</UL>
<P>
To extract a GIF image from a plot generated by a plotting program
such as <TT><FONT FACE="Courier">gnuplot</FONT></TT>, you can
use yet another utility, the Portable BitMap (<TT><FONT FACE="Courier">pbmutils</FONT></TT>)
package. The <TT><FONT FACE="Courier">pbmutils</FONT></TT> package
is a general-purpose image format conversion tool available from
many Ftp sites as the <TT><FONT FACE="Courier">netpbm.tar.gz</FONT></TT>
file.
<P>
Before I go too far in generating images, let's use a tool to
view the output of the images that we'll be creating. For this
chapter, we'll be using the <TT><FONT FACE="Courier">xv</FONT></TT>
(version 3.1) tool set by John Bradley. The <TT><FONT FACE="Courier">xv</FONT></TT>
tool is remarkably practical for interactively viewing images
in many formats. It also performs resizing, cropping, and color
palette modifications for images. The tool is available from <TT><FONT FACE="Courier">sunsite.unc.edu</FONT></TT>
and various other sites. Search for <I>xv</I>. The 3.1 version
was copyrighted by John Bradley in 1994. The <TT><FONT FACE="Courier">xv</FONT></TT>
tool proved to be invaluable in debugging the output of the programs
in this chapter. You can use any image-viewing tool you like,
depending on your platform.
<P>
Now that we have the means to create and display images, let's
see how to perform image plotting with Perl and <TT><FONT FACE="Courier">gnuplot</FONT></TT>.
<H2><A NAME="TwoDimensionalPlots"><B><FONT SIZE=5 COLOR=#FF0000>Two-Dimensional
Plots</FONT></B></A></H2>
<P>
First, here's a simple example of how to plot two-dimensional
data with <TT><FONT FACE="Courier">gnuplot</FONT></TT>. For the
data, we'll use the file with columnar data, part of which is
shown in Listing 32.1.
<HR>
<BLOCKQUOTE>
<B>Listing 32.1. Input data file.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">930830 32.375 31.750 32.000 3700.0 118.4000
<BR>
930831 32.250 31.625 32.125 3962.2 127.2857<BR>
930902 31.750 31.375 31.500 3721.8 117.2367<BR>
930903 31.500 31.125 31.375 3447.6 108.1685<BR>
930907 32.000 30.750 31.000 4425.0 137.1750<BR>
930908 31.625 30.125 31.500 10847.8 341.7057<BR>
930909 32.750 31.250 32.375 10338.6 334.7122<BR>
930910 33.375 32.500 32.750 9323.2 305.3348<BR>
930913 33.000 32.375 32.375 3809.2 123.3229<BR>
930915 32.500 31.375 32.438 11356.8 368.3862</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
What we'll do is plot the difference between the items in column
1 and column 2 for all the samples. The data file is a history
of stock prices, and we want to look at the fluctuation of prices
in a per-day basis. Listing 32.2 contains the Perl script used
to extract the data from the display file and to display the data
using <TT><FONT FACE="Courier">gnuplot</FONT></TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 32.2. Using Perl to generate 2D plots.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2<BR>
&nbsp;3<BR>
&nbsp;4 open( PLOTFILE, &quot;&gt;data1&quot;) || die &quot;\n
Cannot open plot file $! \n&quot;;<BR>
&nbsp;5 open( DATAFILE, &quot;INTC&quot;) || die &quot;\n Cannot
open $! \n&quot;;<BR>
&nbsp;6<BR>
&nbsp;7 $i = 0;<BR>
&nbsp;8 while (&lt;DATAFILE&gt;) {<BR>
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;($date,$hi,$lo,$cl,$vol,$other)
= split(' ',$_);<BR>
10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf PLOTFILE &quot;%6.1f %6.1f\n&quot;,
$i, $hi-$lo;<BR>
11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$i++;<BR>
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
13 close PLOTFILE;<BR>
14 close DATAFILE;<BR>
15<BR>
16 open (GNUPLOT,&quot;| gnuplot&quot;);<BR>
17<BR>
18 print GNUPLOT &lt;&lt;gnuplot_commands;<BR>
19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set term pbm color small<BR>
20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set output &quot;myoutput.pbm&quot;
<BR>
21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set title &quot;Test 1&quot;<BR>
22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plot &quot;data1&quot;<BR>
23&nbsp;gnuplot_commands<BR>
24<BR>
25<BR>
26 close GNUPLOT;<BR>
27<BR>
28 `ppmtogif myoutput.pbm &gt; myoutput.gif&nbsp;&nbsp;2&gt;/dev/null
`;<BR>
29 # The next line is used to view the output file<BR>
30 `xv myoutput.gif`;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The input data file is organized as one record per line. Each
record contains the date, followed by the high, low, and closing
prices of the day and the volume. In line 9 of the listing, we
extract the high and low prices of the day and in line 10 we print
out the maximum fluctuation of these prices along with an index
value.
<P>
<A HREF="f32-1.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/f32-1.gif" ><B>Figure 32.1 : </B><I>Using 2D plots.</I></A>
<P>
This listing does four things: From lines 4 to 14 we are extracting
the data from the input file, <TT><FONT FACE="Courier">INTC</FONT></TT>,
and creating a temporary disk file called <TT><FONT FACE="Courier">data1</FONT></TT>.
Then lines 18 through 26 render the image in PBM format. Line
28 uses the PBM utilities to convert from PBM to GIF. All functions
for the PBM utilities as well as the <TT><FONT FACE="Courier">xv</FONT></TT>
program must be located somewhere in the directories listed in
the <TT><FONT FACE="Courier">PATH</FONT></TT> environment variable.
Line 30 uses the <TT><FONT FACE="Courier">xv</FONT></TT> tools
to view the image just created. Line 30 is really not required,
but is included only as a debug line.
<P>
Look at lines 4 and 5, where the output and input files are opened.
Each line from the input file is extracted in line 9. The calculated
output is written to the output file in line 10. A value for the
horizontal axis is created for the output by auto-incrementing
the <TT><FONT FACE="Courier">$i</FONT></TT> variable. After the
input file is completely read, both the input and output files
are closed in lines 13 and 14.
<P>
At line 16, we open the <TT><FONT FACE="Courier">GNUPLOT</FONT></TT>
handle to send all output to <TT><FONT FACE="Courier">gnuplot</FONT></TT>.
You must have the program <TT><FONT FACE="Courier">gnuplot</FONT></TT>
located somewhere in the directories listed in the <TT><FONT FACE="Courier">PATH</FONT></TT>
environment variable. For line 16 to work, <TT><FONT FACE="Courier">gnuplot</FONT></TT>
must exist in a directory defined by the <TT><FONT FACE="Courier">PATH</FONT></TT>
or reside in the current directory. The following commands are
sent to the <TT><FONT FACE="Courier">gnuplot</FONT></TT> program
from lines 19 up to line 22. Line 23 terminates the input to the
<TT><FONT FACE="Courier">gnuplot</FONT></TT> program:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set term
pbm color small<BR>
20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set output &quot;myoutput.pbm&quot;
<BR>
21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set title &quot;Test 1&quot;<BR>
22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plot &quot;data1&quot;</FONT></TT>
</BLOCKQUOTE>
<P>
Here's how the commands to <TT><FONT FACE="Courier">gnuplot</FONT></TT>
work. The terminal type is set to PBM output in color using small
fonts. The output file is set to <TT><FONT FACE="Courier">myoutput.pbm</FONT></TT>
instead of the terminal. The title of the plot is set to Test
1. The plot command is used to render the image with the data
in the file <TT><FONT FACE="Courier">data1</FONT></TT>.
<P>
Finally, at line 27, we take all data from the PBM file we just
created and convert it to a GIF file using the <TT><FONT FACE="Courier">`ppmtogif`</FONT></TT>
utility. The command shown in line 28 also redirects the standard
error handle, <TT><FONT FACE="Courier">stderr</FONT></TT>, which
is <TT><FONT FACE="Courier">2</FONT></TT>, to redirect its output
to <TT><FONT FACE="Courier">/dev/null</FONT></TT>.
<P>
Line 30 is used to call the <TT><FONT FACE="Courier">xv</FONT></TT>
program to view what we have just created. The call to <TT><FONT FACE="Courier">xv</FONT></TT>
is not required, and in fact should be made only if you have already
successfully installed <TT><FONT FACE="Courier">xv</FONT></TT>
or to call whatever image-viewing software you happen to be using.
<P>
The process to generate the data plot is quite straightforward.
Simply write the data to a temp file, open a pipe to <TT><FONT FACE="Courier">gnuplot</FONT></TT>,
and then write commands directly to <TT><FONT FACE="Courier">gnuplot</FONT></TT>
to render the data. The output from <TT><FONT FACE="Courier">gnuplot</FONT></TT>
may have to go to a different rendering or image-converting utility
to get the format you want.
<H2><A NAME="ThreeDimensionalPlots"><B><FONT SIZE=5 COLOR=#FF0000>Three-Dimensional
Plots</FONT></B></A></H2>
<P>
Now let's look at how to plot 3D images using <TT><FONT FACE="Courier">gnuplot</FONT></TT>.
Rather than writing your own 3D plotting software, it's probably
better to use <TT><FONT FACE="Courier">gnuplot</FONT></TT>. In
fact, in the next section, &quot;Using the Output in CGI Applications,&quot;
we'll only draw 2D plots. For quick plots of 3D data, using <TT><FONT FACE="Courier">gnuplot</FONT></TT>
will be faster than rolling your 3D-rendering software.
<P>
Here's another example of how to use <TT><FONT FACE="Courier">gnuplot</FONT></TT>
to print the output of a Perl script. Look at Listing 32.3, which
generates the image shown in Figure 32.2. The formula in Listing
32.3 produces a nice wave form with an equation from a math textbook.
The formula is code in lines 7 and 14. The complete formula for
generating the points on a surface is:
<P>
<A HREF="f32-2.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/f32-2.gif" ><B>Figure 32.2 : </B><I>Using 3D plots.</I></A>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">z = C * sin( 2 * A * PI * sqrt($x * $x
+ $y * $y)) ;</FONT></TT>
</BLOCKQUOTE>
<P>
where <TT><FONT FACE="Courier">A</FONT></TT> and <TT><FONT FACE="Courier">C</FONT></TT>
are constants that the user can play with in order to affect the
number and <BR>
amplitude of the waves generated. The display output from the
points generated with this <BR>
formula is shown in Figure 32.2.
<HR>
<BLOCKQUOTE>
<B>Listing 32.3. Using </B><TT><B><FONT FACE="Courier">gnuplot</FONT></B></TT><B>
to generate images.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 #<BR>
&nbsp;3 # Check out the use of GNU plot.<BR>
&nbsp;4 $a=3.0;<BR>
&nbsp;5 $c=0.25;<BR>
&nbsp;6 $pi= 3.141593;<BR>
&nbsp;7 $ta = 2 * $a * $pi;<BR>
&nbsp;8<BR>
&nbsp;9 open( PLOTFILE, &quot;&gt;tdata&quot;) || die &quot;\n
Cannot open plot file $! \n&quot;;<BR>
10<BR>
11 for($x=-1;$x &lt; 1 ;$x += 0.02) {<BR>
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for($y= -1 ;$y &lt; 1.00;$y +=
0.02) {<BR>
13<BR>
14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$z = $c
* sin( $ta * sqrt($x * $x + $y * $y)) ;<BR>
15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
PLOTFILE &quot;%6.3f\n&quot;, $z;<BR>
16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print PLOTFILE &quot;\n&quot;;
<BR>
18 }<BR>
19 close PLOTFILE;<BR>
20<BR>
21<BR>
22 open (GNUPLOT,&quot;| gnuplot&quot;);<BR>
23<BR>
24 print GNUPLOT &lt;&lt;gnuplot_commands;<BR>
25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set term pbm color small<BR>
26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set output &quot;myoutput.pbm&quot;
<BR>
27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set noparametric<BR>
28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set title &quot;Test GNUPLOT&quot;
<BR>
29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splot &quot;tdata&quot;<BR>
30&nbsp;gnuplot_commands<BR>
31<BR>
32<BR>
33 close GNUPLOT;<BR>
34<BR>
35 `ppmtogif myoutput.pbm &gt; myoutput.gif&nbsp;&nbsp;2&gt;/dev/null
`;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The constants for the formula used in this program are defined
in lines 4 through 7. The plot file to hold the intermediate points
is the <TT><FONT FACE="Courier">tdata</FONT></TT> file, which
is opened in line 9. All points stored in the data file are stored
in a matrix form with a value of <TT><FONT FACE="Courier">z</FONT></TT>
for each <TT><FONT FACE="Courier">x,y</FONT></TT> location in
the matrix. This format is the nonparametric form of data for
<TT><FONT FACE="Courier">gnuplot</FONT></TT>. (The parametric
form involves writing vectors to create wire frame models and
is thankfully beyond the scope of this book.) Each line in the
input file is one row of <TT><FONT FACE="Courier">x</FONT></TT>
coordinates. All <TT><FONT FACE="Courier">y</FONT></TT> coordinate
values for the row are stored in a line. At line 22, we open a
pipe to <TT><FONT FACE="Courier">gnuplot</FONT></TT>. The commands
sent to <TT><FONT FACE="Courier">gnuplot</FONT></TT> are slightly
different here because we are plotting nonparametric data with
the height of each <TT><FONT FACE="Courier">z</FONT></TT> coordinate
given in a matrix. The <TT><FONT FACE="Courier">x</FONT></TT>
and <TT><FONT FACE="Courier">y</FONT></TT> coordinates will be
the row and column number from which the data is picked up. The
terminal type is set to PBM output in color using small fonts.
The output file is set to <TT><FONT FACE="Courier">myoutput.pbm</FONT></TT>
instead of the terminal. The title of the plot is set to <TT><FONT FACE="Courier">Test
GNUPLOT</FONT></TT>. We have to explicitly force <TT><FONT FACE="Courier">gnuplot</FONT></TT>
to the nonparametric mode for the type of data we are about to
feed it. Finally, the <TT><FONT FACE="Courier">splot</FONT></TT>
command is used to render a 3D image with the data in the file
<TT><FONT FACE="Courier">tdata</FONT></TT>.
<P>
As in Listing 32.2, the output is converted from PBM to GIF format
with this line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">35 `ppmtogif myoutput.pbm &gt; myoutput.gif
2&gt;/dev/null `;</FONT></TT>
</BLOCKQUOTE>
<P>
The output can be viewed with <TT><FONT FACE="Courier">xv</FONT></TT>,
as before, using the <TT><FONT FACE="Courier">`xv myoutput.gif`</FONT></TT>
command. Instead of doing this, let's see how the images can be
sent as GIF images for use with World Wide Web browsers.
<H2><A NAME="UsingtheOutputinCGIApplications"><B><FONT SIZE=5 COLOR=#FF0000>Using
the Output in CGI Applications</FONT></B></A></H2>
<P>
The output from both the programs shown in Listings 32.2 and 32.3
are GIF files. The output can be used in HTML pages in two steps
from the Web browser side:
<OL>
<LI>Call the Perl script to render the image.
<LI>Reload the page with the URL pointing to the image created
by the Perl script.
</OL>
<P>
There are two glaring problems with using Perl and <TT><FONT FACE="Courier">gnuplot</FONT></TT>
in this manner. First, you are creating two steps for the user
to work through. Second, reloading an image in a browser may reload
the cached version of the image at the client side and not the
image at the server side. So, unless the user flushes the images
at the browser side, he or she is not likely to see the changes
in the image.
<P>
A way out of these problems is to use the image-generating Perl
script as the URL instead of the image file itself. The Perl script
will have to be modified to print out the MIME header and the
contents of the image back to the standard output. To do this,
replace line 35 in Listing 32.2 with these three lines:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$| = 1;<BR>
&nbsp;print &quot;Content-Type: image/gif \n\n&quot;;<BR>
system('ppmtogif myoutput.pbm 2&gt;/dev/null');</FONT></TT>
</BLOCKQUOTE>
<P>
The first of the three lines shown here will force flushing of
all output to standard output immediately. This is required for
Perl scripts that are replying to Web browsers. The next line
sets the MIME header required for all GIF images being sent back
to the browser. The two carriage returns in the <TT><FONT FACE="Courier">print</FONT></TT>
line are required, so do not remove them. If you do not place
the two carriage returns, the browser requesting the image is
likely to hang up. The last line is very similar to line 35, except
that the output from the <TT><FONT FACE="Courier">pptogif</FONT></TT>
program is sent to <TT><FONT FACE="Courier">stdout</FONT></TT>
instead of a file. Since this Perl script is called to send replies
back to a browser, the GIF image just created will be sent back.
<P>
The URL for the Perl script is the filename for the Perl program
itself. See Listing 32.4 for a sample HTML page using this URL.
Note how the URL for the <TT><FONT FACE="Courier">IMG</FONT></TT>
tag is set to a Perl script. The output for the HTML file is shown
in Figure 32.3.
<P>
<A HREF="f32-3.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/f32-3.gif" ><B>Figure 32.3 : </B><I>Using plots with HTML files.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 32.4. The HTML page using GIF images.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 &lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;MPS
Inc. Home Page &lt;/TITLE&gt;<BR>
&nbsp;2 &lt;/HEAD&gt;<BR>
&nbsp;3 &lt;BODY&gt;<BR>
&nbsp;4 &lt;P&gt;<BR>
&nbsp;5 &lt;p&gt;<BR>
&nbsp;6 &lt;H2&gt;Test loading images &lt;/H2&gt;<BR>
&nbsp;7 &lt;P&gt;<BR>
&nbsp;8 &lt;FORM NAME=&quot;mineFormkh&quot;&gt;<BR>
&nbsp;9 &lt;IMG SRC=&quot;http://ikra.com/cgi-bin/my3D.pl&quot;
BORDER &gt; &lt;B&gt;Hello&lt;/B&gt;<BR>
10 &lt;/FORM<BR>
11 &lt;/BODY&gt;<BR>
12 &lt;HTML&gt;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
So far, you've learned how to create GIF files from within a Perl
script using <TT><FONT FACE="Courier">gnuplot</FONT></TT>. Next,
you'll generate GIF files directly without using external programs
by using the <TT><FONT FACE="Courier">GD.pm</FONT></TT> module.
<H2><A NAME="CreatingGIFImagesDirectlyfromPerl"><B><FONT SIZE=5 COLOR=#FF0000>Creating
GIF Images Directly from Perl</FONT></B></A></H2>
<P>
The primary motivation for using the <TT><FONT FACE="Courier">GD.pm</FONT></TT>
library is that it's easy to create GIF images directly from within
Perl programs. The module is loaded directly into a Perl program
and does not involve the use of system resources in order to convert
to a different format.
<P>
The <TT><FONT FACE="Courier">GD.pm</FONT></TT> module has been
developed and placed in the CPAN archives by Leonard Stein (<TT><FONT FACE="Courier">lstein@genome.wi.mit.edu</FONT></TT>).
You can find an HTML page with good information about this package
at
<BLOCKQUOTE>
<TT><A HREF="tppmsgs/msgs0.htm#46" tppabs="http://www-genome.wi.mit.edu/~lstein">http://www-genome.wi.mit.edu/~lstein</A></TT>
</BLOCKQUOTE>
<P>
Go to the nearest CPAN site to get the tar file with the module
and extensions. The files used in this chapter are collected from
the CPAN archive at 
<BLOCKQUOTE>
<TT><A HREF="tppmsgs/msgs0.htm#47" tppabs="http://www-genome.wi.mit.edu/ftp/pub/software/WWW/GD.html">http://www-genome.wi.mit.edu/ftp/pub/software/WWW/GD.html</A></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">GD.pm</FONT></TT> library relies
on a C function library called <TT><FONT FACE="Courier">libgd</FONT></TT>.
This library has been developed by Tom Boutell (<TT><FONT FACE="Courier">boutell@boutell.com</FONT></TT>).
There is a great detailed Web page available that you can see
at
<BLOCKQUOTE>
<TT><A HREF="tppmsgs/msgs0.htm#48" tppabs="http://www.boutell.com/gd">http://www.boutell.com/gd</A></TT>
</BLOCKQUOTE>
<P>
The version used for this book is 1.2; however, it's best if you
use the latest version.
<P>
You have to take two steps to install both these libraries. First,
install the <TT><FONT FACE="Courier">gd</FONT></TT> library, and
then install the <TT><FONT FACE="Courier">GD.pm</FONT></TT> module
and its libraries. Use only <TT><FONT FACE="Courier">gcc</FONT></TT>
for compiling all the <TT><FONT FACE="Courier">gd</FONT></TT>
code. The code hasn't been tested with many ANSI C compilers and
might not work with any other type of compiler. In the example
for this book, the code only worked and compiled cleanly with
<TT><FONT FACE="Courier">gcc</FONT></TT>, and the makefile did
not work with Visual C++. If you are using the Microsoft VC++
compiler, stop. Get a version of <TT><FONT FACE="Courier">gcc</FONT></TT>
and use it instead if you don't want to mess with the makefiles.
<H3><A NAME="InstallingthegdLibrary"><B>Installing the </B><TT><B><FONT SIZE=4 FACE="Courier">gd</FONT></B></TT><B><FONT SIZE=4>
Library</FONT></B></A></H3>
<P>
Installing the <TT><FONT FACE="Courier">gd</FONT></TT> library
and source code involves these steps:
<OL>
<LI>Uncompress the distribution file and untar the distribution
with the command <BR>
<TT><FONT FACE="Courier">tar -xvf gd1.2.tar</FONT></TT>.
<LI><TT><FONT FACE="Courier">cd</FONT></TT> to the <TT><FONT FACE="Courier">gd1.2</FONT></TT>
directory.
<LI>Run <TT><FONT FACE="Courier">make</FONT></TT> to create the
programs and the <TT><FONT FACE="Courier">libgd.a</FONT></TT>
file.
<LI>Run <TT><FONT FACE="Courier">ranlib libgd.a</FONT></TT> to
get rid of any annoying messages.
<LI>Copy the file <TT><FONT FACE="Courier">gd.h</FONT></TT> to
<TT><FONT FACE="Courier">/usr/local/include</FONT></TT> or <TT><FONT FACE="Courier">/usr/include</FONT></TT>.
<LI>Copy the file <TT><FONT FACE="Courier">libgd.a</FONT></TT>
to <TT><FONT FACE="Courier">/usr/local/lib</FONT></TT>.
</OL>
<P>
To test if you have a working version of the libraries, run the
<TT><FONT FACE="Courier">gddemo</FONT></TT> program. If you do
not get any output in the <TT><FONT FACE="Courier">demoout.gif</FONT></TT>,
you have not compiled the libraries correctly. At this point,
you can review the source files to see what kinds of functions
are available for use with the package. Now that we have the <TT><FONT FACE="Courier">libgd.a</FONT></TT>
library built, we can go ahead and install the <TT><FONT FACE="Courier">GD.pm</FONT></TT>
files.
<H3><A NAME="InstallingGDpm"><B>Installing </B><TT><B><FONT SIZE=4 FACE="Courier">GD.pm</FONT></B></TT></A>
</H3>
<P>
Version 1.00 of <TT><FONT FACE="Courier">GD.pm</FONT></TT> is
meant for use with <TT><FONT FACE="Courier">gd</FONT></TT> version
1.2. If you are not sure which version to use, check out the documentation
at
<BLOCKQUOTE>
<TT><A HREF="tppmsgs/msgs0.htm#49" tppabs="http://www-genome.wi.mit.edu/pub/software/WWW/GD.html">http://www-genome.wi.mit.edu/pub/software/WWW/GD.html</A></TT>
</BLOCKQUOTE>
<P>
The installation of <TT><FONT FACE="Courier">GD.pm</FONT></TT>
can be done in one of two ways: using static linking or using
dynamic linking. Use dynamic linking only if your operating system
supports it; otherwise, use static linking. Using static linking
does make the <TT><FONT FACE="Courier">perl.exe</FONT></TT> program
a bit larger. In systems that do not support dynamic linking,
your only course may be to use static linking. In either case,
you have to unpack the source files into the <TT><FONT FACE="Courier">ext/GD</FONT></TT>
subdirectory, where your Perl 5 distribution is unpacked.
<P>
For dynamic linking, take these steps:
<OL>
<LI><TT><FONT FACE="Courier">cd</FONT></TT> to the directory where
you unpacked your tar files. (I renamed the <TT><FONT FACE="Courier">GD-1.00</FONT></TT>
directory to <TT><FONT FACE="Courier">GD</FONT></TT> to save myself
keystrokes while typing pathnames.)
<LI>Run the command <TT><FONT FACE="Courier">perl Makefile.PL</FONT></TT>
to create the makefiles.
<LI>Run <TT><FONT FACE="Courier">make</FONT></TT>.
<LI>Run <TT><FONT FACE="Courier">make install</FONT></TT>.
</OL>
<P>
For static linking, take these steps:
<OL>
<LI><TT><FONT FACE="Courier">cd</FONT></TT> to your Perl 5 distribution
directory.
<LI>Run the <TT><FONT FACE="Courier">Configure</FONT></TT> command.
<LI>Answer <I>yes</I> to the question that asks you if you want
to statically link <TT><FONT FACE="Courier">GD.pm</FONT></TT>
files. (Configure will ask this question only if you unpacked
in the Perl distribution tree.)
<LI>Run <TT><FONT FACE="Courier">make</FONT></TT>.
<LI>Run make install.
</OL>
<P>
After you have run the <TT><FONT FACE="Courier">make install</FONT></TT>
program, test whether you have the correct version by running
the demos in <TT><FONT FACE="Courier">ext/GD/demos</FONT></TT>.
You may have to edit the first line of each script in the demo
files to point to your installation of <TT><FONT FACE="Courier">perl.exe</FONT></TT>.
<P>
Also, the script files in the <TT><FONT FACE="Courier">ext/GD
/demos</FONT></TT> directory (under the Perl distribution directory
tree) print a GIF file to standard output. If you do not redirect
this output to another file or to a viewing program like <TT><FONT FACE="Courier">xv</FONT></TT>,
your terminal settings might get mangled, so run the script like
this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">brushes.pl &gt; test.gif<BR>
xv test.gif</FONT></TT>
</BLOCKQUOTE>
<P>
Remember to include <TT><FONT FACE="Courier">xv</FONT></TT> in
your pathname or use another GIF viewer if you like. After you
have confirmed that the demos are working fine, you can start
with your own GIF files.
<H2><A NAME="WorkingwithGDpm"><B><FONT SIZE=5 COLOR=#FF0000>Working
with </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">GD.pm</FONT></B></TT></A>
</H2>
<P>
Once you have the <TT><FONT FACE="Courier">GD.pm</FONT></TT> utilities
installed, you can work with the <TT><FONT FACE="Courier">GD.pm</FONT></TT>
file by using the <TT><FONT FACE="Courier">use GD</FONT></TT>
statement. Basically, you create an image object, write a bunch
of drawing commands to it, and then print it out. A small example
is shown in Listing 32.5. The output of this listing is shown
in Figure 32.4.
<P>
<A HREF="f32-4.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/f32-4.gif" ><B>Figure 32.4 : </B><I>Using  the GD.pm module.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 32.5. Using the </B><TT><B><FONT FACE="Courier">GD.pm</FONT></B></TT><B>
module.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2<BR>
&nbsp;3 use GD;<BR>
&nbsp;4<BR>
&nbsp;5 $im = new GD::Image(300,200);<BR>
&nbsp;6<BR>
&nbsp;7 $white = $im-&gt;colorAllocate(255, 255, 255);<BR>
&nbsp;8 $black = $im-&gt;colorAllocate(0, 0, 0);<BR>
&nbsp;9 $red = $im-&gt;colorAllocate(255, 0, 0);<BR>
10 $blue = $im-&gt;colorAllocate(0,0,255);<BR>
11 $yellow = $im-&gt;colorAllocate(255,250,205);<BR>
12<BR>
13 $im-&gt;transparent($white);&nbsp;&nbsp;&nbsp;&nbsp;# white
color is transparent<BR>
14 $im-&gt;interlaced(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
cool venetian blinds effect<BR>
15<BR>
16 # Create a flat square paintbrush<BR>
17 $brush = new GD::Image(5,5);<BR>
18 $brush-&gt;colorAllocate(255,255,255); # white<BR>
19 $brush-&gt;colorAllocate(0,0,0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
black<BR>
20 $brush-&gt;transparent($white);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
white is transparent<BR>
21 $brush-&gt;filledRectangle(0,0,5,2,$black); # a black rectangle
<BR>
22<BR>
23 #<BR>
24 # Draw some text<BR>
25 #<BR>
26 $im-&gt;string(gdLargeFont,150,10,&quot;Large Font!&quot;,$red);
<BR>
27 $im-&gt;string(gdSmallFont,150,28,&quot;The small font!&quot;,$blue);
<BR>
28 $im-&gt;stringUp(gdTinyFont,280,150,&quot;Vertical Text!&quot;,$black);
<BR>
29 #<BR>
30 # Draw some arcs<BR>
31 #<BR>
32<BR>
33 $im-&gt;setBrush($brush);<BR>
34 $im-&gt;arc(50,100,50,50,0,90,gdBrushed);<BR>
35 $im-&gt;arc(100,100,50,50,0,180,gdBrushed);<BR>
36 $im-&gt;arc(150,100,50,50,0,270,gdBrushed);<BR>
37 $im-&gt;arc(200,100,50,50,0,360,gdBrushed);<BR>
38 $im-&gt;fill(210,110,$blue);<BR>
39<BR>
40<BR>
41 $poly = new GD::Polygon;<BR>
42 $poly-&gt;addPt(10,10);<BR>
43 $poly-&gt;addPt(50,10);<BR>
44 $poly-&gt;addPt(150,50);<BR>
45 $poly-&gt;addPt(10,100);<BR>
46 $im-&gt;polygon($poly,gdBrushed);<BR>
47<BR>
48 $im-&gt;fill(40,40,$yellow);<BR>
49<BR>
50 # print the image to stdout<BR>
51 print $im-&gt;gif;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
At line 3, we include the <TT><FONT FACE="Courier">GD.pm</FONT></TT>
module with the <TT><FONT FACE="Courier">use</FONT></TT> statement.
Line 5 starts a new image that is 300 pixels wide and 200 pixels
high. Lines 7 through 11 allocate colors in a color map for the
image. The first color allocated for the map is the background
for the image. Line 13 forces <TT><FONT FACE="Courier">white</FONT></TT>
to be transparent; that is, colors written over white will be
seen as though written over a transparent background.
<P>
The interlaced method (line 14) lets the image be constructed
in stages, with each stage enhancing the focus a little instead
of being rendered in one slow step.
<P>
At line 17, we create a brush to draw with. This brush is a mini-image
in itself and has to be allocated its own color maps. Line 21
creates the filled rectangle to make it a solid brush.
<P>
In lines 26 through 28 we draw some text using different fonts.
Note how easy it is to draw vertical text. In each of the text-drawing
routines you have to specify the font, the <TT><FONT FACE="Courier">x,y</FONT></TT>
location to start at, the text to write, and the color to use.
The font types are listed in the <TT><FONT FACE="Courier">GD.pm</FONT></TT>
file.
<P>
<TT><FONT FACE="Courier">GD.pm</FONT></TT> allows you to draw
various shapes. The <TT><FONT FACE="Courier">arc()</FONT></TT>
function can be used to draw portions of an arc. The parameters
to the call are the location to start drawing, its width and height,
the angle to draw, and the paint brush to use, if any. The <TT><FONT FACE="Courier">paintbrush</FONT></TT>
parameter is optional and if left out will use the default paint
brush. At line 38, we fill in the circle with the color blue.
(Note that a circle is simply an arc drawn for 360 degrees with
its height equal to its width.)
<P>
At line 41 we draw a polygon and in the subsequent lines add points.
The polygon is drawn on the image area at line 46. In line 48
we fill the inside of the polygon with a yellow background color.
<P>
At line 51 we print the image to the standard output from where
it can be piped to a viewing program or stored on disk. Actually,
what we do in the next section is to pipe the output to the standard
output as a response to a Web page request.
<H2><A NAME="UsingGDwithHTMLPages"><B><FONT SIZE=5 COLOR=#FF0000>Using
GD with HTML Pages</FONT></B></A></H2>
<P>
Listing 32.6 presents another program which creates a tree of
sorts and prints it to the standard output as a GIF file. This
program recursively creates the branches of a tree. At the end
of each recursion it draws a little, green rectangle. Admittedly,
it's not a pretty tree, but with a few random number tricks, you
can make this script generate a new tree every time it's called.
This regeneration feature makes the script excellent for use in
scripts. For example, you can make the output of the script be
the source URL to an HTML image tag. Whenever the HTML page is
loaded, a new tree image is displayed.
<HR>
<BLOCKQUOTE>
<B>Listing 32.6. Using the tree-generation program.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;&nbsp;2<BR>
&nbsp;&nbsp;3<BR>
&nbsp;&nbsp;4 $PI=3.1415926;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
no need to use a jillion digits<BR>
&nbsp;&nbsp;5 $PIBY2 = $PI/2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
Use a fanout of -pi/2 to +pi/2<BR>
&nbsp;&nbsp;6 $NPIBY2 = -1. * $PI/2;<BR>
&nbsp;&nbsp;7<BR>
&nbsp;&nbsp;8 sub deg2rad {<BR>
&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $deg = shift;<BR>
&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$deg %= 360;<BR>
&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return $rad = $deg * $PI
/ 180.0;<BR>
&nbsp;12 }<BR>
&nbsp;13<BR>
&nbsp;14 # GLOBALS:<BR>
&nbsp;15 #&nbsp;&nbsp;&nbsp;$height = of image<BR>
&nbsp;16 #&nbsp;&nbsp;&nbsp;$width&nbsp;&nbsp;= of image<BR>
&nbsp;17 #&nbsp;&nbsp;&nbsp;$maxfans = max fanout per branch<BR>
&nbsp;18 #&nbsp;&nbsp;&nbsp;$fanAngle = angle per fanout<BR>
&nbsp;19 #&nbsp;&nbsp;&nbsp;$fanRatio = new branch length / parent
branch length<BR>
&nbsp;20 #<BR>
&nbsp;21 # INPUT PARAMETERS:<BR>
&nbsp;22 #&nbsp;&nbsp;&nbsp;$h = current depth<BR>
&nbsp;23 #&nbsp;&nbsp;&nbsp;$x = current x<BR>
&nbsp;24 #&nbsp;&nbsp;&nbsp;$y = current y<BR>
&nbsp;25 #&nbsp;&nbsp;&nbsp;$theta = angle to start from<BR>
&nbsp;26 #&nbsp;&nbsp;&nbsp;$flen&nbsp;&nbsp;= length of parent
branch<BR>
&nbsp;27 #<BR>
&nbsp;28 # LOCAL PARAMETERS:<BR>
&nbsp;29 #&nbsp;&nbsp;&nbsp;$nx,$ny = offsets from current $x,$y
<BR>
&nbsp;30 #&nbsp;&nbsp;&nbsp;$i = angle to draw<BR>
&nbsp;31 #&nbsp;&nbsp;&nbsp;$incr = increment<BR>
&nbsp;32 #&nbsp;&nbsp;&nbsp;$maxAngle = up to this angle.<BR>
&nbsp;33<BR>
&nbsp;34 sub tree {<BR>
&nbsp;35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my ($h,$x,$y,$theta,$flen)
= @_; # local variables<BR>
&nbsp;36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my ($nx,$ny,$nlen,$mycolor);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
for drawing to.<BR>
&nbsp;37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my ($i,$incr,$startAngle,$maxAngle);
# for the fanout<BR>
&nbsp;38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my ($randFans);<BR>
&nbsp;39<BR>
&nbsp;40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
&nbsp;41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Stopping conditions first.
<BR>
&nbsp;42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
&nbsp;43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($h &lt; 1) {<BR>
&nbsp;44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$im-&gt;filledRectangle($x-1,$base_y+$y-1,$x+2,$base_y+$y+2,$leaf);
<BR>
&nbsp;45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
0; }<BR>
&nbsp;46&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$nlen = $flen * $fanRatio;
<BR>
&nbsp;47&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($nlen &lt; 1) { return
0;}<BR>
&nbsp;48<BR>
&nbsp;49&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$mycolor = $brown;<BR>
&nbsp;50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($h == 2) { $mycolor
= $color3; }<BR>
&nbsp;51&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($h == 3) { $mycolor
= $color2; }<BR>
&nbsp;52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($h == 4) { $mycolor
= $color1; }<BR>
&nbsp;53&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($h == 5) { $mycolor
= $color0; }<BR>
&nbsp;54&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
&nbsp;55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Important!!!<BR>
&nbsp;56&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
&nbsp;57&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$h -= 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
for recursion<BR>
&nbsp;58<BR>
&nbsp;59<BR>
&nbsp;60&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$maxAngle = $theta + $fanAngle;
<BR>
&nbsp;61&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$incr = ($maxAngle)/($maxfans
+ int(rand() * 3));<BR>
&nbsp;62<BR>
&nbsp;63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$startAngle = $theta - ($fanAngle/2);
<BR>
&nbsp;64<BR>
&nbsp;65&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($startAngle &lt; $NPIBY2)
{ $startAngle = $NPIBY2; }<BR>
&nbsp;66&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($startAngle &gt; $NPIBY2)
{ $startAngle = $PIBY2;&nbsp;}<BR>
&nbsp;67<BR>
&nbsp;68&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# printf &quot;\n From %5.1f
--&gt; %5.1f, incr %5.1f&quot;,<BR>
&nbsp;69&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$startAngle,$maxAngle,
$incr;<BR>
&nbsp;70<BR>
&nbsp;71&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ($i = $startAngle ;
$i &lt; $maxAngle; $i += $incr)<BR>
&nbsp;72&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
&nbsp;73&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$nx
= $nlen * sin($i);<BR>
&nbsp;74&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ny
= $nlen * cos($i);<BR>
&nbsp;75&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
<BR>
&nbsp;76&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
<BR>
&nbsp;77&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
<BR>
&nbsp;78&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$im-&gt;line($x,$base_y+$y,$nx+$x,$base_y+$ny+$y,$mycolor);
<BR>
&nbsp;79&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tree($h,$nx+$x,$ny+$y,$i,$nlen);
<BR>
&nbsp;80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;81&nbsp;}<BR>
&nbsp;82<BR>
&nbsp;83 $height = 300;<BR>
&nbsp;84 $width&nbsp;&nbsp;= 300;<BR>
&nbsp;85 $maxfans = 3;<BR>
&nbsp;86 $maxdepth = 6;<BR>
&nbsp;87 $fanAngle = deg2rad(120);&nbsp;&nbsp;&nbsp;# Maximum
120 degrees<BR>
&nbsp;88 $fanRatio = 0.65;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
Each new branch is 4/5 of old.<BR>
&nbsp;89 $base_y = $height / 2;<BR>
&nbsp;90 #<BR>
&nbsp;91 #<BR>
&nbsp;92 #<BR>
&nbsp;93 $start_x = $width/2;<BR>
&nbsp;94 $start_y = 25;<BR>
&nbsp;95 $start_length = 80;<BR>
&nbsp;96 $start_angle = deg2rad(80);<BR>
&nbsp;97<BR>
&nbsp;98 srand(time);<BR>
&nbsp;99<BR>
100 use GD;<BR>
101<BR>
102 $im = new GD::Image(300,300);<BR>
103 $backgd = $im-&gt;colorAllocate(154,192,205);<BR>
104 $white = $im-&gt;colorAllocate(255, 255, 255);<BR>
105 $black = $im-&gt;colorAllocate(0, 0, 0);<BR>
106 $brown = $im-&gt;colorAllocate(188,130, 130);<BR>
107 $leaf&nbsp;&nbsp;= $im-&gt;colorAllocate(157,255,12);<BR>
108 $color0 = $im-&gt;colorAllocate(245,196,90);<BR>
109 $color1 = $im-&gt;colorAllocate(95,158,60);<BR>
110 $color2 = $im-&gt;colorAllocate(46,139,87);<BR>
111 $color3 = $im-&gt;colorAllocate(152,251,152);<BR>
112 $red = $im-&gt;colorAllocate(255,0,0);<BR>
113 $blue = $im-&gt;colorAllocate(0,0,255);<BR>
114 $im-&gt;transparent($white);&nbsp;&nbsp;&nbsp;&nbsp;# white
color is transparent<BR>
115 $im-&gt;interlaced(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
cool venetian blinds effect<BR>
116<BR>
117 tree ($maxdepth,$start_x,$start_y,$start_angle,$start_length);
<BR>
118<BR>
119<BR>
120 $text_y = $base_y / 2 + $width / 2;<BR>
121 $text_x = $width / 5;<BR>
122 $infoStr = &quot;Welcome to Kamran's Home Page&quot;;<BR>
123 $dateStr = &quot;Today is &quot; . `date`;<BR>
124 $message = &quot;&nbsp;&nbsp;http://www.ikra.com/index.html&quot;;
<BR>
125<BR>
126 $im-&gt;string(gdLargeFont,$text_x,$text_y,$infoStr,$red);
<BR>
127 $im-&gt;string(gdSmallFont,$text_x,$text_y + 30,$dateStr,$blue);
<BR>
128 $im-&gt;stringUp(gdLargeFont,10,$height - 10,$message,$blue);
<BR>
129<BR>
130<BR>
131 # print the image to stdout<BR>
132<BR>
133 $|=1;<BR>
134<BR>
135 print &quot;Content-type: image/gif \n\n&quot;;<BR>
136 print $im-&gt;gif;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Lines 4 through 12 define some of the constants for using degrees
and radians. The script uses the following global variables:
<UL>
<LI><TT><FONT FACE="Courier">$height</FONT></TT> and <TT><FONT FACE="Courier">$width</FONT></TT>
are the extents of the image.
<LI><TT><FONT FACE="Courier">$maxfans</FONT></TT> is the maximum
number of sub-branches allowed per branch.
<LI><TT><FONT FACE="Courier">$fanAngle</FONT></TT> is the angle
where each new sub-branch is created.
<LI><TT><FONT FACE="Courier">$fanRatio</FONT></TT> is the ratio
of the length of the new branch to the length of its parent branch.
</UL>
<P>
Each call to the recursive function, <TT><FONT FACE="Courier">tree()</FONT></TT>,
uses the following variables:
<UL>
<LI><TT><FONT FACE="Courier">$h</FONT></TT> is the current depth
in recursion.
<LI><TT><FONT FACE="Courier">$x</FONT></TT> is the current <TT><FONT FACE="Courier">x</FONT></TT>
to draw from.
<LI><TT><FONT FACE="Courier">$y</FONT></TT> is the current <TT><FONT FACE="Courier">y</FONT></TT>
to draw from.
<LI><TT><FONT FACE="Courier">$theta</FONT></TT> is the angle to
start drawing from.
<LI><TT><FONT FACE="Courier">$flen</FONT></TT>is the length of
the current branch.
</UL>
<P>
If the depth is <TT><FONT FACE="Courier">1</FONT></TT> or less,
the <TT><FONT FACE="Courier">tree()</FONT></TT> function draws
a rectangle at the current location and backs out of the recursion.
See lines 43 and 44. It also backs out without drawing a leaf
if the new branch is too small to draw.
<P>
Different colors are used based on the depth of the recursion
in lines 49 through 53.
<P>
Line 57 is where the depth of the recursion is marked off. The
value of <TT><FONT FACE="Courier">$h</FONT></TT> is decremented
before a recursive call to <TT><FONT FACE="Courier">tree()</FONT></TT>
is made. Lines 60 to 66 make sure that the <I>fanout</I> (maximum
number of degrees between the outer most branches) and number
of sub-branches is set in the correct <TT><FONT FACE="Courier">-PI/2</FONT></TT>
to <TT><FONT FACE="Courier">+PI/2</FONT></TT> range. You may want
to customize these lines to see how you want your tree to &quot;grow.&quot;
<P>
At line 71 we use a <TT><FONT FACE="Courier">for</FONT></TT> loop
to make a recursive call to the <TT><FONT FACE="Courier">tree()</FONT></TT>
function with different fanout angles, locations to draw, and
colors.
<P>
The initialization of global variables is done from lines 83 to
98. The random number generator is seeded at line 98.
<P>
The image is created at line 102, with colors for its components
created in lines 103 to 115. The <TT><FONT FACE="Courier">tree()</FONT></TT>
function is called at line 117. Add more calls to <TT><FONT FACE="Courier">tree()</FONT></TT>
if you want more than one tree printed. Some text is drawn in
the image area to customize the output in the lines up to 131.
<P>
Lines 133 to 136 actually print the image to standard output as
the response to an HTTP request.
<P>
To use the previous listing in an HTML file, you can add this
tag to an HTML page:
<BLOCKQUOTE>
<TT>&lt;IMG SRC=&quot;http://www.ikra.com/cgi-bin/tree.pl&quot;&gt;</TT>
</BLOCKQUOTE>
<P>
The browser showing the HTML page will call the <TT><FONT FACE="Courier">tree.pl</FONT></TT>
script, which in turn will return the GIF image back. Therefore,
every time you reload the Web page, you'll see a new image. Neat.
Actually, you can also refer to the <TT><FONT FACE="Courier">tree.pl</FONT></TT>
in the Location prompt on your browser. Refer to Figure 32.5 to
see how it's referred to in a URL. The script is called <TT><FONT FACE="Courier">fractal.pl</FONT></TT>
in Figure 32.5.
<P>
<A HREF="f32-5.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/f32-5.gif" ><B>Figure 32.5 : </B><I>Dynamic image creating with Web pages.</I></A>
<P>
You can see how easy it is to create GIF images on-the-fly and
use them in Web pages. Using the <TT><FONT FACE="Courier">GD.pm</FONT></TT>
module, it's easy to have Perl write your output as a GIF file
for use in other applications.
<H2><A NAME="Summary"><B><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></B></A>
</H2>
<P>
In this chapter I covered two ways of creating images: using <TT><FONT FACE="Courier">gnuplot</FONT></TT>
and directly through the use of the <TT><FONT FACE="Courier">GD.pm</FONT></TT>
module. The <TT><FONT FACE="Courier">gnuplot</FONT></TT> method
is simpler to use when you have a set of data points in a logical
order that can be read directly from within <TT><FONT FACE="Courier">gnuplot</FONT></TT>.
An example for using <TT><FONT FACE="Courier">gnuplot</FONT></TT>
is when drawing charts and 3D plots. If you are drawing more than
just charts and plots, consider generating the images directly
from within Perl by using the <TT><FONT FACE="Courier">GD.pm</FONT></TT>
module. Using <TT><FONT FACE="Courier">GD.pm</FONT></TT> is a
bit more difficult because you have to manage the details of drawing
yourself, but it does eliminate the need for an external program
like <TT><FONT FACE="Courier">gnuplot</FONT></TT>.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch31.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch31.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch33.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch33.htm"><IMG 
SRC="nc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>
