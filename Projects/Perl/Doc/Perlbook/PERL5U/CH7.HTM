<HTML>

<HEAD>
   <TITLE>Chapter 7 -- String and Patterns</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT COLOR=#FF0000>Chapter 7</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>String and Patterns</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#BasicStringOperations" >Basic String Operations</A>
<UL>
<LI><A HREF="#ThechopandlengthFunctions" >The chop() and length() Functions</A>
<LI><A HREF="#HandlingtheCaseinStrings" >Handling the Case in Strings</A>
<LI><A HREF="#JoiningStringsTogether" >Joining Strings Together</A>
<LI><A HREF="#PrintingFormattedNumbers" >Printing Formatted Numbers</A>
</UL>
<LI><A HREF="#FindingSubstrings" >Finding Substrings</A>
<UL>
<LI><A HREF="#ThesubstrFunction" >The substr Function</A>
<LI><A HREF="#StringSearchingwithPatterns" >String Searching with Patterns</A>
<LI><A HREF="#SpecialCharactersinPerlPatternSearc" >Special Characters in Perl Pattern Searches</A>
<LI><A HREF="#ShortcutsforWordsinPerl" >Shortcuts for Words in Perl</A>
<LI><A HREF="#ThequotemetaFunction" >The quotemeta Function</A>
<LI><A HREF="#SpecifyingtheNumberofMatches" >Specifying the Number of Matches</A>
<LI><A HREF="#SpecifyingMoreThanOneChoice" >Specifying More Than One Choice</A>
<LI><A HREF="#SearchingaStringforMoreThanOnePat" >Searching a String for More Than One Pattern to Match</A>
</UL>
<LI><A HREF="#ReusingPortionsofPatterns" >Reusing Portions of Patterns</A>
<LI><A HREF="#PatternMatchingOptions" >Pattern-Matching Options</A>
<LI><A HREF="#SubstitutingTextThroughPatternMatchi" >Substituting Text Through Pattern Matching </A>
<LI><A HREF="#TheTranslationOperator" >The Translation Operator </A>
<LI><A HREF="#ExtendedPatternMatching" >Extended Pattern Matching </A>
<LI><A HREF="#Summary" >Summary </A>
</UL>
<HR>
<P>
This chapter covers some of the most important features of Perl:
its string- and pattern-manipulation routines. Most of the Perl
programming you do will involve strings in one form or another.
It's very important to learn how to use the string search and
replace operations efficiently in Perl. An inefficient search
pattern can slow a script down to a crawl.
<H2><A NAME="BasicStringOperations"><FONT SIZE=5 COLOR=#FF0000>Basic
String Operations</FONT></A></H2>
<P>
Let's first start with the basic operations in Perl for working
with strings. Some of this chapter will be a rehash of what was
covered in <A HREF="ch2.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch2.htm" >Chapters 2</A> through <A HREF="ch5.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch5.htm" >5</A>.
Now it's time to cover the topic in detail given the background
information in these chapters. I cover the following string utility
functions in this chapter:
<UL>
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">chop()</FONT></TT>
and <TT><FONT FACE="Courier">length()</FONT></TT> functions
<LI><FONT COLOR=#000000>Handling the case in strings</FONT>
<LI><FONT COLOR=#000000>Joining strings together</FONT>
<LI><FONT COLOR=#000000>Printing formatted numbers</FONT>
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">substr()</FONT></TT>
function
<LI><FONT COLOR=#000000>Special characters in Perl pattern searches</FONT>
<LI><FONT COLOR=#000000>Shortcuts for special words in Perl</FONT>
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">quotemeta()</FONT></TT>
function
<LI><FONT COLOR=#000000>Specifying the number of matches</FONT>
<LI><FONT COLOR=#000000>Specifying more than one choice in a pattern</FONT>
<LI><FONT COLOR=#000000>Searching a string with more than one
pattern</FONT>
</UL>
<H3><A NAME="ThechopandlengthFunctions">The <TT><FONT SIZE=4 FACE="Courier">chop()</FONT></TT><FONT SIZE=4>
and </FONT><TT><FONT SIZE=4 FACE="Courier">length()</FONT></TT><FONT SIZE=4>
Functions</FONT></A></H3>
<P>
To find the length of a string, you can call the <TT><FONT FACE="Courier">length($str)</FONT></TT>
function, which returns the number of characters in a string.
The <TT><FONT FACE="Courier">chop</FONT></TT> function removes
the last character in a string. This is useful in removing the
carriage return from a user-entered string. For an example, see
Listing 7.1.
<HR>
<BLOCKQUOTE>
<B>Listing 7.1. Using </B><TT><B><FONT FACE="Courier">length()</FONT></B></TT><B>
and </B><TT><B><FONT FACE="Courier">chop()</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 <BR>
&nbsp;3 $input = &lt;STDIN&gt;
;<BR>
&nbsp;4 <BR>
&nbsp;5 $len = length($input);
<BR>
&nbsp;6 print &quot;\nLength = $len of $input before the chopping
\n&quot;;<BR>
&nbsp;7 chop($input);<BR>
&nbsp;8 $len = length($input);<BR>
&nbsp;9 print &quot;\nLength
= $len of $input after the chopping \n&quot;;<BR>
10 <BR>
11 $ 7_1.pl<BR>
12 Hello! I am a Test!<BR>
13 <BR>
14 Length = 20 of Hello! I am a Test! before the chopping<BR>
15 <BR>
16 Length = 19 of Hello! I am a Test! after the chopping</FONT></TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="HandlingtheCaseinStrings">Handling the Case in Strings</A>
</H3>
<P>
Perl provides four functions to make your life easier when handling
the case of characters in a string:<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=177><TT><FONT FACE="Courier">lc($string)</FONT></TT>
</TD><TD WIDTH=347>Converts a string to lowercase</TD></TR>
<TR VALIGN=TOP><TD WIDTH=177><TT><FONT FACE="Courier">uc($string)</FONT></TT>
</TD><TD WIDTH=347>Converts a string to uppercase</TD></TR>
<TR VALIGN=TOP><TD WIDTH=177><TT><FONT FACE="Courier">lcfirst($string)</FONT></TT>
</TD><TD WIDTH=347>Converts the first character of a string to uppercase
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=177><TT><FONT FACE="Courier">ucfirst($string)</FONT></TT>
</TD><TD WIDTH=347>Converts the first character of a string to lowercase
</TD></TR>
</TABLE></CENTER>
<P>
<P>
Listing 7.2 presents sample code that illustrates how these functions
work.
<HR>
<BLOCKQUOTE>
<B>Listing 7.2. Using the case functions.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 $name = &quot;tis a test OF THE sYSTEm&quot; ;<BR>
&nbsp;3 $ucase = uc($name);
<BR>
&nbsp;4 $lcase = lc($name);<BR>
&nbsp;5 <BR>
&nbsp;6 print &quot;$name&nbsp;&nbsp;\n&quot;;<BR>
&nbsp;7 print &quot;$ucase
\n&quot;;<BR>
&nbsp;8 print &quot;$lcase \n&quot;;<BR>
&nbsp;9 <BR>
10 $nice = lcfirst($ucase);<BR>
11 print &quot;lcfirst on $ucase = \n\t $nice \n&quot;;<BR>
12 <BR>
13 $crooked = ucfirst($lcase);<BR>
14 print &quot;ucfirst on $lcase = \n\t$crooked \n&quot;;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Here is the output from Listing 7.2.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">tis a test OF THE sYSTEm<BR>
TIS A TEST OF THE SYSTEM<BR>
tis a test of the system<BR>
lcfirst on TIS A TEST OF THE SYSTEM =<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">
tIS A TEST OF THE SYSTEM<BR>
ucfirst on tis a test of the system =<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Tis a test of the system</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="JoiningStringsTogether">Joining Strings Together</A>
</H3>
<P>
The dot operator is great for connecting strings. For example,
the following statements will print <TT><FONT FACE="Courier">John
Hancock</FONT></TT> plus a new line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$first=&quot;John&quot;;<BR>
$last =&quot;Hancock&quot;;<BR>
print $first . &quot; &quot; . $last . &quot;\n&quot; ;</FONT></TT>
</BLOCKQUOTE>
<P>
To print the elements of an array in a string, you can use the
<TT><FONT FACE="Courier">join</FONT></TT> function to create one
long string. Here's the syntax for the <TT><FONT FACE="Courier">join</FONT></TT>
function:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">join (<I>$joinstr, @list</I>);</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">$joinstr</FONT></TT> variable is
the string to use when connecting the elements of <TT><FONT FACE="Courier">@list</FONT></TT>
together. Refer to the following statements to see how to create
a line for the <TT><FONT FACE="Courier">/etc/passwd</FONT></TT>
file:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">@list = (&quot;khusain&quot;,&quot;sdfsdew422dxd&quot;,&quot;501&quot;,&quot;100&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Kamran Husain&quot;,&quot;/home/khusain&quot;,&quot;/bin/bash&quot;);
<BR>
$passwdEntry = join (&quot;:&quot;, @list);</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="PrintingFormattedNumbers">Printing Formatted Numbers</A>
</H3>
<P>
Perl provides two functions, <TT><FONT FACE="Courier">printf</FONT></TT>
and <TT><FONT FACE="Courier">sprintf</FONT></TT>, that behave
like the <TT><FONT FACE="Courier">printf</FONT></TT> family of
functions in the C programming language. The <TT><FONT FACE="Courier">printf</FONT></TT>
function sends its output to the current file. The <TT><FONT FACE="Courier">sprintf</FONT></TT>
function takes at least two arguments, a string and a format string,
followed by any other arguments. The <TT><FONT FACE="Courier">sprintf</FONT></TT>
function sends the formatted output to the string in the first
argument. For example, the string <TT><FONT FACE="Courier">$answer</FONT></TT>
contains the result of the <TT><FONT FACE="Courier">sprintf</FONT></TT>
statement:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$a= 10;<BR>
$b= 10;<BR>
sprintf $answer, &quot;%d + %d is %d and in %x&quot;, $a,$b,$a+$b,$a+$b;</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="FindingSubstrings"><FONT SIZE=5 COLOR=#FF0000>Finding
Substrings</FONT></A></H2>
<P>
A quick way to find the location of a substring in a string is
to use the <TT><FONT FACE="Courier">index</FONT></TT> function,
which searches from left to right. To search from right to left,
use the <TT><FONT FACE="Courier">rindex</FONT></TT> function.
Here's the syntax for these functions:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">position = index ($string, $substring,
[$offset]);<BR>
position = rindex ($string, $substring, [$offset]);</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$string</FONT></TT> is the character
string to search the <TT><FONT FACE="Courier">$substring</FONT></TT>
in. The <TT><FONT FACE="Courier">$offset</FONT></TT> parameter
is optional and defaults to the start of the string when not provided
to the function. Listing 7.3 is a function that looks for the
position of the word <I>two</I> in each line of an input file
(just like <TT><FONT FACE="Courier">grep</FONT></TT> would except
that we print out the position of the character, too).
<HR>
<BLOCKQUOTE>
<B>Listing 7.3. Using the </B><TT><B><FONT FACE="Courier">index</FONT></B></TT><B>
and </B><TT><B><FONT FACE="Courier">rindex</FONT></B></TT><B>
functions.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 <BR>
&nbsp;3 %finds = ();<BR>
&nbsp;4 $line&nbsp;&nbsp;= 0;<BR>
&nbsp;5 <BR>
&nbsp;6 print &quot;\n Enter word to search for:&quot;;<BR>
&nbsp;7 $word = &lt;STDIN&gt;;
<BR>
&nbsp;8 chop ($word);<BR>
&nbsp;9 <BR>
10 print &quot;\n Enter file to search in:&quot;;<BR>
11 $fname = &lt;STDIN&gt;;<BR>
12 chop($fname);<BR>
13 open (IFILE, $fname) || die &quot;Cannot open $fname $!\n&quot;;
<BR>
14 <BR>
15 while (&lt;IFILE&gt;) {<BR>
16&nbsp;&nbsp;&nbsp;&nbsp; $position = index($_,$word);<BR>
17&nbsp;&nbsp;&nbsp;&nbsp; if ($position &gt;= 0) {<BR>
18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$finds{&quot;$line&quot;}
= $position;<BR>
19&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
20&nbsp;&nbsp;&nbsp;&nbsp; $line++;<BR>
21 }<BR>
22 close IFILE;<BR>
23 while(($key,$value) = each(%finds)) {<BR>
24&nbsp;&nbsp;&nbsp;&nbsp; print &quot; Line $key : $value \n&quot;;
<BR>
25&nbsp;&nbsp;&nbsp;&nbsp; }</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
This program searches for the first occurrence of the word in
the file specified by the user. Each line in the file is searched
for the pattern. If the pattern is found, the program prints the
location of the pattern at each line and column number. The first
<TT><FONT FACE="Courier">while</FONT></TT> loop searches in a
given file, and the second <TT><FONT FACE="Courier">while</FONT></TT>
lists all the items collected in the <TT><FONT FACE="Courier">%finds</FONT></TT>
associative array.
<P>
Listing 7.3 finds only the first occurrence of a pattern in a
line. You can use the <TT><FONT FACE="Courier">offset</FONT></TT>
argument to search for a pattern other than from the start. The
<TT><FONT FACE="Courier">offset</FONT></TT> argument is specified
from 0 and up. Listing 7.4 presents another search program that
finds more than one occurrence on a line.
<HR>
<BLOCKQUOTE>
<B>Listing 7.4. Searching more than once.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 <BR>
&nbsp;3 %finds = ();<BR>
&nbsp;4 $fname = &quot;news.txt&quot;;<BR>
&nbsp;5 $word = &quot;the&quot;;
<BR>
&nbsp;6 open (IFILE, $fname) || die &quot;Cannot open $fname $!\n&quot;;
<BR>
&nbsp;7 <BR>
&nbsp;8 print &quot;Search for :$word: \n&quot;;<BR>
&nbsp;9 while (&lt;IFILE&gt;)
{<BR>
10&nbsp;&nbsp;&nbsp;&nbsp; $thispos = 0;<BR>
11&nbsp;&nbsp;&nbsp;&nbsp; $nextpos = 0;<BR>
12&nbsp;&nbsp;&nbsp;&nbsp; while (1) {<BR>
13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$nextpos
= index($_,$word,$thispos);<BR>
14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last if
($nextpos == -1);<BR>
15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$count++;
<BR>
16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$finds{&quot;$count&quot;}
= $nextpos;<BR>
17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$thispos
= $nextpos + 1;<BR>
18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
19 }<BR>
20 close IFILE;<BR>
21 print &quot;\nLn : Column&quot;;<BR>
22 while(($key,$value) = each(%finds)) {<BR>
23&nbsp;&nbsp;&nbsp;&nbsp; print &quot; $key : $value \n&quot;;
<BR>
24&nbsp;&nbsp;&nbsp;&nbsp; }</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The output of Listing 7.4 on a sample file would be something
like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Ln : Column<BR>
&nbsp;1 : 31<BR>
&nbsp;2 : 54<BR>
&nbsp;3 : 38<BR>
&nbsp;4 : 53</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="ThesubstrFunction">The <TT><FONT SIZE=4 FACE="Courier">substr</FONT></TT><FONT SIZE=4>
Function</FONT></A></H3>
<P>
The <TT><FONT FACE="Courier">substr</FONT></TT> function is used
to extract parts of a string from other strings. Here's the syntax
for this function:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">substr ($<I>master</I>, $<I>offset</I>,
$<I>length</I>);</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$<I>master</I></FONT></TT> is the string
from which a substring is to be copied, starting at the index
specified at <TT><FONT FACE="Courier">$<I>offset</I></FONT></TT>
and up to <TT><FONT FACE="Courier">$<I>length</I></FONT></TT>
characters. Listing 7.5 illustrates the use of this function.
<HR>
<BLOCKQUOTE>
<B>Listing 7.5. Using the </B><TT><B><FONT FACE="Courier">substr</FONT></B></TT><B>
function.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 #&nbsp;&nbsp;Check out the substr function.<BR>
&nbsp;3 #<BR>
&nbsp;4 $quote = &quot;No man but a blockhead ever wrote except
for money&quot;;<BR>
&nbsp;5 #&nbsp;&nbsp;quote
by Samuel Johnson<BR>
&nbsp;6<BR>
&nbsp;7 $sub[0] = substr
($quote, 9, 6);<BR>
&nbsp;8<BR>
&nbsp;9 $name = &quot;blockhead&quot;
;<BR>
10 $pos = index($quote,$name);<BR>
11 $len = length($name);<BR>
12 $sub[1] = substr ($quote, $pos, $len);<BR>
13 $pos = index($quote,&quot;wrote&quot;);<BR>
14 $sub[2] = substr ($quote, $pos, 6);<BR>
15<BR>
16 for ($i = 0; $i &lt; 3; $i++) {<BR>
17&nbsp;&nbsp;&nbsp;&nbsp; print &quot;\$sub[$i] is \&quot;&quot;
.&nbsp;&nbsp;$sub[$i] . &quot;\&quot; \n&quot;;<BR>
18 }<BR>
19<BR>
20 #<BR>
21 # To replace a string, let's try substr on the left-hand side.
<BR>
22 #<BR>
23 # Replace the words 'a blockhead', with the words 'an altruist'.
<BR>
24 # (Sorry Sam.)<BR>
25 $name = &quot;a blockhead&quot; ;<BR>
26 $pos = index($quote,$name);<BR>
27 $len = length($name);<BR>
28<BR>
29 substr ($quote, $pos, $len) = &quot;an altruist&quot;;<BR>
30 print &quot;After substr = $quote \n&quot;;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The output from the code in Listing 7.5 is as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$sub[0] is &quot;t a bl&quot;<BR>
$sub[1] is &quot;blockhead&quot;<BR>
$sub[2] is &quot;wrote &quot;<BR>
<BR>
After substr = No man but an altruist ever wrote except for money</FONT></TT>
</BLOCKQUOTE>
<P>
You can see how the <TT><FONT FACE="Courier">substr</FONT></TT>
operator can be used to extract values from another string. Basically,
you tell the <TT><FONT FACE="Courier">substr</FONT></TT> function
how many characters you need and from where, and the chopped off
portion is returned from the function.
<P>
The <TT><FONT FACE="Courier">substr</FONT></TT> function can also
be used to make substitutions within a string. In this listing,
the words <TT><FONT FACE="Courier">&quot;a blockhead&quot;</FONT></TT>
are replaced by <TT><FONT FACE="Courier">&quot;an altruist&quot;</FONT></TT>.
The part of the string specified by <TT><FONT FACE="Courier">substr</FONT></TT>
is replaced by the value appearing to the right of the assignment
operator. Here's the syntax for these calls to <TT><FONT FACE="Courier">substr</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">substr ($<I>master</I>, $<I>offset</I>,
$<I>length</I>) = $<I>newStr</I>;</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$<I>master</I></FONT></TT> must be a
string that can be written to (that is, not a <I>tied</I> variable-<A HREF="ch6.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch6.htm" >see Chapter 6</A>,
&quot;Binding Variables to Objects,&quot; for information on using
<TT><FONT FACE="Courier">tie()</FONT></TT> on variables). <TT><FONT FACE="Courier">$<I>offset</I></FONT></TT>
is where the substitution begins for up to <TT><FONT FACE="Courier">$<I>length</I></FONT></TT>
characters. The value of <TT><FONT FACE="Courier">$<I>offset</I>
+ $<I>length</I></FONT></TT> must be less than the existing length
of the string. The <TT><FONT FACE="Courier">$<I>newStr</I></FONT></TT>
variable can be the empty string if you want to remove the substring
at the offset. To substitute the tail-end of the string starting
from the offset, do not specify the <TT><FONT FACE="Courier">$<I>length</I></FONT></TT>
argument.
<P>
For example, this line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$len = 22; substr ($quote, $pos, $len)
= &quot;an altruist&quot;;</FONT></TT>
</BLOCKQUOTE>
<P>
prints the following line in the previous example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">After substr = No man but an altruist</FONT></TT>
</BLOCKQUOTE>
<P>
The offset can be a negative number to specify counting from the
right side of the string. For example, the following line replaces
three characters at the fifth index from the right side in <TT><FONT FACE="Courier">$quote</FONT></TT>
with the word <TT><FONT FACE="Courier">&quot;cash&quot;</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">substr($quote, -5, 3) = &quot;cash&quot;;</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">substr</FONT></TT> function is great
when working with known strings that do cut and paste operations.
For more general strings, you have to work with patterns that
can be described using regular expressions. If you are familiar
with the <TT><FONT FACE="Courier">grep</FONT></TT> command in
UNIX, you already know about regular expressions. Basically, a
<I>regular expression</I> is a way of specifying strings like
&quot;all words beginning with the letter a&quot; or &quot;all
strings with an xy in the middle somewhere.&quot; The next section
illustrates how Perl can help make these types of search and replace
patterns easier.
<H3><A NAME="StringSearchingwithPatterns">String Searching with
Patterns</A></H3>
<P>
Perl enables you to match patterns within strings with the <TT><FONT FACE="Courier">=~</FONT></TT>
operator. To see whether a string has a certain pattern in it,
you use the following syntax:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$result = $variable =~ /pattern/</FONT></TT>
</BLOCKQUOTE>
<P>
The value <TT><FONT FACE="Courier">$result</FONT></TT> is <TT><FONT FACE="Courier">true</FONT></TT>
if the pattern is found in <TT><FONT FACE="Courier">$variable</FONT></TT>.
To check whether a string does not have a pattern, you have to
use the <TT><FONT FACE="Courier">!~</FONT></TT> operator, like
this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$result = $variable !~ /pattern/</FONT></TT>
</BLOCKQUOTE>
<P>
Listing 7.6 shows how to match strings literally. It prints a
message if the string <TT><FONT FACE="Courier">Apple</FONT></TT>,
<TT><FONT FACE="Courier">apple</FONT></TT>, or <TT><FONT FACE="Courier">Orange</FONT></TT>
is found, or if the strings <TT><FONT FACE="Courier">Grape</FONT></TT>
and <TT><FONT FACE="Courier">grape</FONT></TT> are not found.
<HR>
<BLOCKQUOTE>
<B>Listing 7.6. Substitution with patterns.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 <BR>
&nbsp;3 $input = &lt;STDIN&gt;
;<BR>
&nbsp;4 chop($input);<BR>
&nbsp;5 print &quot;Orange
found! \n&quot; if ( $input =~ /Orange/ );<BR>
&nbsp;6 print &quot;Apple found! \n&quot; if (&nbsp;&nbsp;$input
=~ /[Aa]pple/ );<BR>
&nbsp;7 print &quot;Grape not found! \n&quot; if (  $input !~
/[Gg]rape/ );</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
So, how did you search for <TT><FONT FACE="Courier">apple</FONT></TT>
and <TT><FONT FACE="Courier">Apple</FONT></TT> in one statement?
This involves specifying a pattern to the search string. The syntax
for the <TT><FONT FACE="Courier">=~</FONT></TT> operator is this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">[$variable =~] [m]/PATTERN/[i][o][g]</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$variable</FONT></TT> is searched for
the pattern in <TT><FONT FACE="Courier">PATTERN</FONT></TT>. The
delimiter of the text being searched is a white space or an end-of-line
character. The <TT><FONT FACE="Courier">i</FONT></TT> specifies
a case-insensitive search. The <TT><FONT FACE="Courier">g</FONT></TT>
is used as an iterator to search more than once on the same string.
The <TT><FONT FACE="Courier">o</FONT></TT> interpolates characters.
I cover all these options shortly.
<P>
Let's look at how the patterns in <TT><FONT FACE="Courier">PATTERN</FONT></TT>
are defined. If you are already familiar with the <TT><FONT FACE="Courier">grep</FONT></TT>
utility in UNIX, you are familiar with patterns.
<P>
A character is matched for the string verbatim when placed in
<TT><FONT FACE="Courier">PATTERN</FONT></TT>. For example, <TT><FONT FACE="Courier">/Orange/</FONT></TT>
matched the string <TT><FONT FACE="Courier">Orange</FONT></TT>
only. To match a character other than a new line you can use the
dot (<TT><FONT FACE="Courier">.</FONT></TT>) operator. For example,
to match <TT><FONT FACE="Courier">Hat</FONT></TT> or <TT><FONT FACE="Courier">Cat</FONT></TT>,
you would use the pattern:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/.at/</FONT></TT>
</BLOCKQUOTE>
<P>
This also matches <TT><FONT FACE="Courier">Bat</FONT></TT>, <TT><FONT FACE="Courier">hat</FONT></TT>,
<TT><FONT FACE="Courier">Mat</FONT></TT>, and so on. If you just
want to get <TT><FONT FACE="Courier">Cat</FONT></TT> and <TT><FONT FACE="Courier">Hat</FONT></TT>,
you can use a character class using the square brackets (<TT><FONT FACE="Courier">[]</FONT></TT>).
For example, the pattern
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/[ch]cat/</FONT></TT>
</BLOCKQUOTE>
<P>
will match <TT><FONT FACE="Courier">Cat</FONT></TT> or <TT><FONT FACE="Courier">Hat</FONT></TT>,
but not <TT><FONT FACE="Courier">cat</FONT></TT>, <TT><FONT FACE="Courier">hat</FONT></TT>,
<TT><FONT FACE="Courier">bat</FONT></TT>, and so on. The characters
in a class are case sensitive. So to allow the lowercase versions,
you would use the pattern:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/[cChH]cat/</FONT></TT>
</BLOCKQUOTE>
<P>
It's cumbersome to list a lot of characters in the <TT><FONT FACE="Courier">[]</FONT></TT>
class, so the dash (<TT><FONT FACE="Courier">-</FONT></TT>) operator
can define a range of characters to use. These two statements
look for a digit:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/[0-9]/<BR>
/[0123456789]/</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">[]</FONT></TT> operator can be used
with other items in the pattern. Consider these two sample statements,
which do the same thing:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/a[0123456789]/  # matches a, followed
by any digit,<BR>
/a[0-9]/  # matches a, followed by any digit,<BR>
/[a-zA-Z]/  # a letter of the alphabet.</FONT></TT>
</BLOCKQUOTE>
<P>
The range <TT><FONT FACE="Courier">[a-z]</FONT></TT> matches any
lowercase letter, and the range <TT><FONT FACE="Courier">[A-Z]</FONT></TT>
matches any uppercase letter. The following pattern matches <TT><FONT FACE="Courier">aA</FONT></TT>,
<TT><FONT FACE="Courier">bX</FONT></TT>, and so on:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/[a-z][A-Z]/</FONT></TT>
</BLOCKQUOTE>
<P>
To match three or more letter matches, it would be very cumbersome
to write something <BR>
like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/[a-zA-Z][a-zA-Z][a-zA-Z]/</FONT></TT>
</BLOCKQUOTE>
<P>
This is where the special characters in Perl pattern searching
come into play. 
<H3><A NAME="SpecialCharactersinPerlPatternSearc">Special Characters
in Perl Pattern Searches</A></H3>
<P>
Here is a list of all the special characters in search strings
(I'll go into the detail of how they work later):
<UL>
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">.</FONT></TT>
character matches one character.
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">+</FONT></TT>
character matches one or more occurrences of a character.
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">?</FONT></TT>
character matches zero or one occurrences of a character.
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">*</FONT></TT>
character matches zero or more occurrences of a character.
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">-</FONT></TT>
character is used to specify ranges in characters.
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">[]</FONT></TT>
characters define a class of characters.
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">^</FONT></TT>
character matches the beginning of a line.
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">$</FONT></TT>
character matches the end of a line.
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">{}</FONT></TT>
characters specify the number of occurrences of a character.
<LI><FONT COLOR=#000000>The</FONT> <TT><FONT FACE="Courier">|</FONT></TT>
character is the <TT><FONT FACE="Courier">OR</FONT></TT> operator
for more than one pattern.
</UL>
<P>
The plus (<TT><FONT FACE="Courier">+</FONT></TT>) character specifies
&quot;one or more of the preceding characters.&quot; Patterns
containing <TT><FONT FACE="Courier">+</FONT></TT> always try to
match as many characters they can. For example, the pattern <TT><FONT FACE="Courier">/ka+/</FONT></TT>
matches any of these strings:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">kamran&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
returns &quot;ka&quot;<BR>
kaamran&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# returns &quot;kaa&quot;
<BR>
kaaaamran&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# returns &quot;kaaaa&quot;</FONT></TT>
</BLOCKQUOTE>
<P>
Another way to use the <TT><FONT FACE="Courier">+</FONT></TT>
operator is for matching more than one space. For example, Listing
7.7 takes an input line and splits the words into an array. Items
in the array generated by this code will not include any items
generated by matching more than one consecutive space. The match
<TT><FONT FACE="Courier">/ +/</FONT></TT> specifies &quot;one
or more space(s).&quot;
<HR>
<BLOCKQUOTE>
<B>Listing 7.7. Using the pattern matching </B><TT><B><FONT FACE="Courier">+</FONT></B></TT><B>
operator.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">1 #!/usr/bin/perl<BR>
2 $input = &lt;STDIN&gt;;<BR>
3 chop ($input);<BR>
4 @words = split (/ +/, $input);<BR>
5 foreach $i (@words) {<BR>
6&nbsp;&nbsp;&nbsp;&nbsp; print $i . &quot;\n&quot;;<BR>
7&nbsp;&nbsp;&nbsp;&nbsp; }</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
If you do not use the <TT><FONT FACE="Courier">+</FONT></TT> sign
to signify more than one space in the pattern, you'll wind up
with an array item for each white space that immediately follows
a white space. The pattern <TT><FONT FACE="Courier">/ /</FONT></TT>
specifies the start of a new word as soon as it sees a white space.
If there are two spaces together, the next white space will trigger
the start of a new word. By using the <TT><FONT FACE="Courier">+</FONT></TT>
sign, you are saying &quot;one or more white space together&quot;
is the start of a new word.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD ><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD >
<BLOCKQUOTE>
If you are going to repeatedly search one scalar variable, call the <TT><FONT FACE="Courier">study()</FONT></TT> function on the scalar. The syntax is <TT><FONT FACE="Courier">study ($scalar);</FONT></TT>. Only one variable can be used with <TT><FONT 
FACE="Courier">study()</FONT></TT> at one time.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The asterisk (<TT><FONT FACE="Courier">*</FONT></TT>) special
character matches zero or more occurrences of any preceding character.
The asterisk can also be used with the <TT><FONT FACE="Courier">[]</FONT></TT>
classes:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/9*/&nbsp;&nbsp;&nbsp;&nbsp;# matches
an empty word, 9, 99, 999, ... and so on<BR>
/79*/&nbsp;&nbsp;&nbsp;# matches 7, 79, 799, 7999, ... and so
on<BR>
/ab*/&nbsp;&nbsp;&nbsp;# matches a, ab, abb, abbb, ... and so
on</FONT></TT>
</BLOCKQUOTE>
<P>
Because the asterisk matches zero or more occurrences, the pattern
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/[0-9]*/</FONT></TT>
</BLOCKQUOTE>
<P>
will match a number or an empty line! So do not confuse the asterisk
with the plus operator. Consider this statement:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">@words = split (/[\t\n ]*/, $list);</FONT></TT>
</BLOCKQUOTE>
<P>
This matches zero or more occurrences of the space, newline, or
tab character. What this translates to in Perl is &quot;match
every character.&quot; You'll wind up with an array of strings,
each of them one character long, of the all the characters in
the input line.
<P>
The <TT><FONT FACE="Courier">?</FONT></TT> character matches zero
or one occurrence of any preceding character. For example, the
following pattern will match <TT><FONT FACE="Courier">Apple</FONT></TT>
or <TT><FONT FACE="Courier">Aple</FONT></TT>, but not <TT><FONT FACE="Courier">Appple</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/Ap?le/</FONT></TT>
</BLOCKQUOTE>
<P>
Let's look at a sample pattern that searches the use of hashes,
arrays, and possibly the use of handles. The code in Listing 7.8
will be enhanced in the next two sections. For the moment, let's
use the code in Listing 7.8 to see how the asterisk operator works
in pattern matches.
<HR>
<BLOCKQUOTE>
<B>Listing 7.8. Using the asterisk operator.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 # We will finish this program in the next section.<BR>
&nbsp;3 $scalars =&nbsp;&nbsp;0;
<BR>
&nbsp;4 $hashes =&nbsp;&nbsp;0;<BR>
&nbsp;5 $arrays =&nbsp;&nbsp;0;
<BR>
&nbsp;6 $handles =&nbsp;&nbsp;0;<BR>
&nbsp;7<BR>
&nbsp;8 while (&lt;STDIN&gt;) {<BR>
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;
@words = split (/[\(\)\t ]+/);<BR>
10&nbsp;&nbsp;&nbsp;&nbsp; foreach $token (@words) {<BR>
11&nbsp;&nbsp;&nbsp;&nbsp; if ($token =~ /\$[_a-zA-Z][_0-9a-zA-Z]*/)
{<BR>
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
print (&quot;$token is a legal scalar variable\n&quot;);<BR>
13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scalars++;
<BR>
14&nbsp;&nbsp;&nbsp;&nbsp; } elsif ($token =~ /@[_a-zA-Z][_0-9a-zA-Z]*/)
{<BR>
15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
print (&quot;$token is a legal array variable\n&quot;);<BR>
16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$arrays++;
<BR>
17&nbsp;&nbsp;&nbsp;&nbsp; } elsif ($token =~ /%[_a-zA-Z][_0-9A-Z]*/)
{<BR>
18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
print (&quot;$token is a legal hash variable\n&quot;);<BR>
19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$hashes++;
<BR>
20&nbsp;&nbsp;&nbsp;&nbsp; } elsif ($token =~ /\&lt;[A-Z][_0-9A-Z]*\&gt;/)
{<BR>
21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
print (&quot;$token is probably a file handle\n&quot;);<BR>
22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$handles++;
<BR>
23&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
24&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
25 }<BR>
26<BR>
27 print &quot; This file used scalars $scalars times\n&quot;;
<BR>
28 print &quot; This file used arrays&nbsp;&nbsp;$arrays&nbsp;&nbsp;times\n&quot;;
<BR>
29 print &quot; This file used hashes $hashes times\n&quot;;<BR>
30 print &quot; This file used handles $handles times\n&quot;;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Lines 9 and 10 split the incoming stream into words. Note how
the pattern in line 9 splits words at spaces, tabs, and in between
parentheses. At line 11, we are looking for a word that starts
with a <TT><FONT FACE="Courier">$</FONT></TT>, has a non-numeric
character or underscore as the first character, and is followed
by an alphanumeric string or underscores.
<P>
At lines 14 and 17, the same pattern is applied, with the exception
of an at (<TT><FONT FACE="Courier">@</FONT></TT>) sign and a hash
(<TT><FONT FACE="Courier">#</FONT></TT>) sign are looked for instead
of a dollar (<TT><FONT FACE="Courier">$</FONT></TT>) sign in order
to search for arrays and hashes, respectively. At line 20, the
file handle is assumed to a word in all caps, not starting with
an underscore, but with alphanumeric characters in it.
<P>
The previous listing can get legal names if the pattern is anywhere
in a word. However, we want the search to be limited to word boundaries.
For example, right now the script cannot distinguish between the
following three lines of input because they all match the <TT><FONT FACE="Courier">/\$[a-zA-Z][_0-9a-zA-Z]*/</FONT></TT>
somewhere in them:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$catacomb<BR>
OBJ::$catacomb<BR>
#$catacomb#</FONT></TT>
</BLOCKQUOTE>
<P>
White spaces do not include tabs, newlines, and so on. Here are
the special characters to use in pattern matching to signify these
characters:<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=92><TT><FONT FACE="Courier">\t</FONT></TT></TD>
<TD WIDTH=134>Tab</TD></TR>
<TR VALIGN=TOP><TD WIDTH=92><TT><FONT FACE="Courier">\n</FONT></TT></TD>
<TD WIDTH=134>Newline</TD></TR>
<TR VALIGN=TOP><TD WIDTH=92><TT><FONT FACE="Courier">\r</FONT></TT></TD>
<TD WIDTH=134>Carriage return</TD></TR>
<TR VALIGN=TOP><TD WIDTH=92><TT><FONT FACE="Courier">\f</FONT></TT></TD>
<TD WIDTH=134>Form feed.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=92><TT><FONT FACE="Courier">\\</FONT></TT></TD>
<TD WIDTH=134>Backslash (\)</TD></TR>
<TR VALIGN=TOP><TD WIDTH=92><TT><FONT FACE="Courier">\Q</FONT></TT> and <TT><FONT FACE="Courier">\E</FONT></TT>
</TD><TD WIDTH=134>Pattern delimiters</TD></TR>
</TABLE></CENTER>
<P>
<P>
In general, you can escape any special character in a pattern
with the backslash (<TT><FONT FACE="Courier">\</FONT></TT>). The
backslash itself is escaped with another backslash. The <TT><FONT FACE="Courier">\Q</FONT></TT>
and <TT><FONT FACE="Courier">\E</FONT></TT> characters are used
in Perl to delimit the interpretation of any special characters.
When the Perl interpreter sees <TT><FONT FACE="Courier">\Q</FONT></TT>,
every character following <TT><FONT FACE="Courier">\Q</FONT></TT>
is not interpreted and is used literally until the pattern terminates
or Perl sees <TT><FONT FACE="Courier">\E</FONT></TT>. Here are
a few examples:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/\Q^Section$/ # match the string &quot;^Section$&quot;
literally.<BR>
/^Section$/&nbsp;&nbsp;&nbsp;# match a line with the solitary
word Section in it.<BR>
/\Q^Section$/ # match a line which ends with ^Section </FONT></TT>
</BLOCKQUOTE>
<P>
To further clarify where the variable begins and ends, you can
use these anchors:<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=42><TT><FONT FACE="Courier">\A</FONT></TT></TD>
<TD WIDTH=235>Match at beginning of string only</TD></TR>
<TR VALIGN=TOP><TD WIDTH=42><TT><FONT FACE="Courier">\Z</FONT></TT></TD>
<TD WIDTH=235>Match at end of string only</TD></TR>
<TR VALIGN=TOP><TD WIDTH=42><TT><FONT FACE="Courier">\b</FONT></TT></TD>
<TD WIDTH=235>Match on word boundary</TD></TR>
<TR VALIGN=TOP><TD WIDTH=42><TT><FONT FACE="Courier">\B</FONT></TT></TD>
<TD WIDTH=235>Match inside word</TD></TR>
</TABLE></CENTER>
<P>
<P>
Here are some examples and how they are interpreted given a string
with the word <I>hello</I> in it somewhere:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/\Ahel/&nbsp;&nbsp;&nbsp;&nbsp; # match
only if the first three characters are &quot;hel&quot;<BR>
/llo\Z/&nbsp;&nbsp;&nbsp;&nbsp; # match only if the last three
characters are &quot;llo&quot;<BR>
/llo$/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# matches only if the
last three characters are &quot;llo&quot;<BR>
/\Ahello\Z/ # same as /^hello$/ unless doing multiple line matching
<BR>
/\bhello/&nbsp;&nbsp;&nbsp;# matches &quot;hello&quot;, not &quot;Othello&quot;,
but also matches &quot;hello.&quot;<BR>
/\bhello/&nbsp;&nbsp;&nbsp;# matches &quot;$hello&quot; because
$ is not part of a word.<BR>
/hello\b/&nbsp;&nbsp;&nbsp;# matches &quot;hello&quot;, and &quot;Othello&quot;,
but not &quot;hello.&quot;<BR>
/\bhello\b/ # matches &quot;hello&quot;, and not &quot;Othello&quot;
nor &quot;hello.&quot;</FONT></TT>
</BLOCKQUOTE>
<P>
A &quot;word&quot; for use with these anchors is assumed to contain
letters, digits, and underscore characters. No other characters,
such as the tilde (<TT><FONT FACE="Courier">~</FONT></TT>), hash
(<TT><FONT FACE="Courier">#</FONT></TT>), or exclamation point
(<TT><FONT FACE="Courier">!</FONT></TT>) are part of the word.
Therefore, the pattern <TT><FONT FACE="Courier">/\bhello/</FONT></TT>
will match the string <TT><FONT FACE="Courier">&quot;$hello&quot;</FONT></TT>,
because <TT><FONT FACE="Courier">$</FONT></TT> is not part of
a word.
<P>
The <TT><FONT FACE="Courier">\B</FONT></TT> pattern anchor takes
the opposite action than that of <TT><FONT FACE="Courier">\b</FONT></TT>.
It matches only if the pattern is contained in a word. For example,
the pattern below:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/\Bhello/&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT>
</BLOCKQUOTE>
<P>
match <TT><FONT FACE="Courier">&quot;$hello&quot;</FONT></TT>
and <TT><FONT FACE="Courier">&quot;Othello&quot;</FONT></TT> but
not <TT><FONT FACE="Courier">&quot;hello&quot;</FONT></TT> nor
<TT><FONT FACE="Courier">&quot;hello.&quot;</FONT></TT> Whereas,
the pattern here: 
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/hello\B/&nbsp;&nbsp;&nbsp;</FONT></TT>
</BLOCKQUOTE>
<P>
will match <TT><FONT FACE="Courier">&quot;hello.&quot;</FONT></TT>
but not <TT><FONT FACE="Courier">&quot;hello&quot;</FONT></TT>,
<TT><FONT FACE="Courier">&quot;Othello&quot;</FONT></TT> nor<TT><FONT FACE="Courier">
&quot;$hello&quot;</FONT></TT>. Finally this pattern 
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/\Bhello\B/ </FONT></TT>
</BLOCKQUOTE>
<P>
will match <TT><FONT FACE="Courier">&quot;Othello&quot;</FONT></TT>
but not <TT><FONT FACE="Courier">&quot;hello&quot;</FONT></TT>,
<TT><FONT FACE="Courier">&quot;$hello&quot;</FONT></TT> nor <TT><FONT FACE="Courier">&quot;hello.&quot;</FONT></TT>.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/\Bhello/&nbsp;&nbsp;&nbsp;&nbsp;# match
&quot;$hello&quot; and &quot;Othello&quot; but not &quot;hello&quot;
nor &quot;hello.&quot;<BR>
/hello\B/&nbsp;&nbsp;&nbsp;&nbsp;# match &quot;hello.&quot; but
not &quot;hello&quot;, &quot;Othello&quot; nor &quot;$hello&quot;.
<BR>
/\Bhello\B/&nbsp;&nbsp;# match &quot;Othello&quot; but not &quot;hello&quot;,
&quot;$hello&quot; nor &quot;hello.&quot;.</FONT></TT>
</BLOCKQUOTE>
<P>
Listing 7.9 contains the code from Listing 7.8 with the addition
of the new word boundary functions.
<HR>
<BLOCKQUOTE>
<B>Listing 7.9. Using the boundary characters.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 <BR>
&nbsp;3 $scalars =&nbsp;&nbsp;0;
<BR>
&nbsp;4 $hashes =&nbsp;&nbsp;0;<BR>
&nbsp;5 $arrays =&nbsp;&nbsp;0;
<BR>
&nbsp;6 $handles =&nbsp;&nbsp;0;<BR>
&nbsp;7 <BR>
&nbsp;8 while (&lt;STDIN&gt;) {<BR>
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;
@words = split (/[\t ]+/);<BR>
10&nbsp;&nbsp;&nbsp;&nbsp; foreach $token (@words) {<BR>
11&nbsp;&nbsp;&nbsp;&nbsp; if ($token =~ /\$\b[a-zA-Z][_0-9a-zA-Z]*\b/)
{<BR>
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
print (&quot;$token is a legal scalar variable\n&quot;);<BR>
13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scalars++;
<BR>
14&nbsp;&nbsp;&nbsp;&nbsp; } elsif ($token =~ /@\b[a-zA-Z][_0-9a-zA-Z]*\b/)
{<BR>
15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
print (&quot;$token is a legal array variable\n&quot;);<BR>
16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$arrays++;
<BR>
17&nbsp;&nbsp;&nbsp;&nbsp; } elsif ($token =~ /%\b[a-zA-Z][_0-9A-Z]*\b/)
{<BR>
18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
print (&quot;$token is a legal hash variable\n&quot;);<BR>
19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$hashes++;
<BR>
20&nbsp;&nbsp;&nbsp;&nbsp; } elsif ($token =~ /\&lt;[A-Z][_0-9A-Z]*\&gt;/)
{<BR>
21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
print (&quot;$token is probably a file handle\n&quot;);<BR>
22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$handles++;
<BR>
23&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
24&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
25 }<BR>
26 <BR>
27 print &quot; This file used scalars $scalars times\n&quot;;
<BR>
28 print &quot; This file used arrays&nbsp;&nbsp;$arrays&nbsp;&nbsp;times\n&quot;;
<BR>
29 print &quot; This file used hashes $hashes times\n&quot;;<BR>
30 print &quot; This file used handles $handles times\n&quot;;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Here is sample input and output for this program that takes an
existing script file in <TT><FONT FACE="Courier">test.txt</FONT></TT>
and uses it as the input to the <TT><FONT FACE="Courier">test.pl</FONT></TT>
program. 
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$ <B>cat test.txt<BR>
</B>#!/usr/bin/perl<BR>
<BR>
$input = &lt;STDIN&gt;;<BR>
chop ($input);<BR>
<BR>
@words = split (/ +/, $input);<BR>
foreach $i (@words) {<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">print
&quot; [$i] \n&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
<BR>
$ <B>test.pl&nbsp;&nbsp;&lt; test.txt<BR>
</B>&nbsp;This file used
scalars 5 times<BR>
&nbsp;This file used arrays&nbsp;&nbsp;2&nbsp;&nbsp;times<BR>
&nbsp;This file used hashes
0 times<BR>
&nbsp;This file used handles 1 times</FONT></TT>
</BLOCKQUOTE>
<P>
Patterns do not have to be typed literally to be used in the <TT><I><FONT FACE="Courier">/
/</FONT></I></TT> search functions. You can also specify them
from within variables. Listing 7.10 is a modification of Listing
7.9, which uses three variables to hold the patterns instead of
specifying them in the <TT><FONT FACE="Courier">if</FONT></TT>
statement. 
<HR>
<BLOCKQUOTE>
<B>Listing 7.10. Using pattern matches in variables.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 <BR>
&nbsp;3 $scalars =&nbsp;&nbsp;0;
<BR>
&nbsp;4 $hashes =&nbsp;&nbsp;0;<BR>
&nbsp;5 $arrays =&nbsp;&nbsp;0;
<BR>
&nbsp;6 $handles =&nbsp;&nbsp;0;<BR>
&nbsp;7 <BR>
&nbsp;8 $sType = &quot;\\\$\\b[a-zA-Z][_0-9a-zA-Z]*\\b&quot;;
<BR>
&nbsp;9 $aType = &quot;@\\b[a-zA-Z][_0-9a-zA-Z]*\\b&quot;;
<BR>
10 $hType = &quot;%\\b[a-zA-Z][_0-9A-Z]*\\b/&quot;;<BR>
11 <BR>
12 while (&lt;STDIN&gt;) {<BR>
13&nbsp;&nbsp;&nbsp;&nbsp; @words = split (/[\t ]+/);<BR>
14&nbsp;&nbsp;&nbsp;&nbsp; foreach $token (@words) {<BR>
15&nbsp;&nbsp;&nbsp;&nbsp; if ($token =~ /$sType/ ) {<BR>
16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
print (&quot;$token is a legal scalar variable\n&quot;);<BR>
17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scalars++;
<BR>
18&nbsp;&nbsp;&nbsp;&nbsp; } elsif ($token =~ /$aType/ ) {<BR>
19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
print (&quot;$token is a legal array variable\n&quot;);<BR>
20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$arrays++;
<BR>
21&nbsp;&nbsp;&nbsp;&nbsp; } elsif ($token =~ /$hType/ ) {<BR>
22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
print (&quot;$token is a legal hash variable\n&quot;);<BR>
23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$hashes++;
<BR>
24&nbsp;&nbsp;&nbsp;&nbsp; } elsif ($token =~ /\&lt;[A-Z][_0-9A-Z]*\&gt;/)
{<BR>
25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
print (&quot;$token is probably a file handle\n&quot;);<BR>
26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$handles++;
<BR>
27&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
28&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
29 }<BR>
30 <BR>
31 print &quot; This file used scalars $scalars times\n&quot;;
<BR>
32 print &quot; This file used arrays&nbsp;&nbsp;$arrays&nbsp;&nbsp;times\n&quot;;
<BR>
33 print &quot; This file used hashes $hashes times\n&quot;;<BR>
34 print &quot; This file used handles $handles times\n&quot;;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
In this code, the variables <TT><FONT FACE="Courier">$aType</FONT></TT>,
<TT><FONT FACE="Courier">$hType</FONT></TT>, and <TT><FONT FACE="Courier">$sType</FONT></TT>
can be used elsewhere in the program verbatim. What you have to
do, though, is to escape the backslashes twice, once to get past
the Perl parser for the string and the other for the pattern searcher
if you are using double quotes. When using single quotes, you
can use the following line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$sType = '\$\\b[a-zA-Z][_0-9a-zA-Z]*\b';</FONT></TT>
</BLOCKQUOTE>
<P>
instead of this line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$sType = &quot;\\\$\\b[a-zA-Z][_0-9a-zA-Z]*\\b&quot;;</FONT></TT>
</BLOCKQUOTE>
<P>
Make sure that you remember to include the enclosing <TT><FONT FACE="Courier">/</FONT></TT>
characters when using a <TT><FONT FACE="Courier">$variable</FONT></TT>
for a pattern. Forgetting to do this will give erroneous results.
Also, be sure you see how each backslash is placed to escape characters
correctly.
<H3><A NAME="ShortcutsforWordsinPerl">Shortcuts for Words in Perl</A>
</H3>
<P>
The <TT><FONT FACE="Courier">[]</FONT></TT> classes for patterns
simplify searches quite a bit. In Perl, there are several shortcut
patterns that describe words or numbers. You have seen them already
in the previous examples and chapters.
<P>
Here are the shortcuts:<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=75><I><CENTER>Shortcut</I></TD><TD WIDTH=229><I>Description</I>
</TD><TD WIDTH=148><I>Pattern String</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=75><TT><FONT FACE="Courier"><CENTER>\d</FONT></TT></TD>
<TD WIDTH=229>Any digit</TD><TD WIDTH=148><TT><FONT FACE="Courier">[0-9]</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=75><TT><FONT FACE="Courier"><CENTER>\D</FONT></TT></TD>
<TD WIDTH=229>Anything other than a digit</TD><TD WIDTH=148><TT><FONT FACE="Courier">[^0-9]</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=75><TT><FONT FACE="Courier"><CENTER>\w</FONT></TT></TD>
<TD WIDTH=229>Any word character</TD><TD WIDTH=148><TT><FONT FACE="Courier">[_0-9a-zA-Z]</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=75><TT><FONT FACE="Courier"><CENTER>\W</FONT></TT></TD>
<TD WIDTH=229>Anything not a word character</TD><TD WIDTH=148><TT><FONT FACE="Courier">[^_0-9a-zA-Z]</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=75><TT><FONT FACE="Courier"><CENTER>\s</FONT></TT></TD>
<TD WIDTH=229>White space </TD><TD WIDTH=148><TT><FONT FACE="Courier">[ \r\t\n\f]</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=75><TT><FONT FACE="Courier"><CENTER>\S</FONT></TT></TD>
<TD WIDTH=229>Anything other than white space</TD><TD WIDTH=148><TT><FONT FACE="Courier">[^ \r\t\n\f]</FONT></TT>
</TD></TR>
</TABLE></CENTER>
<P>
<P>
These escape sequences can be used anywhere ordinary characters
are used. For example, the pattern <TT><FONT FACE="Courier">/[\da-z]/</FONT></TT>
matches any digit or lowercase letter.
<P>
The definition of word boundary as used by the <TT><FONT FACE="Courier">\b</FONT></TT>
and <TT><FONT FACE="Courier">\B</FONT></TT> special characters
is done with the use of <TT><FONT FACE="Courier">\w</FONT></TT>
and <TT><FONT FACE="Courier">\W</FONT></TT>. The patterns <TT><FONT FACE="Courier">/\w\W/</FONT></TT>
and <TT><FONT FACE="Courier">/\W\w/</FONT></TT> can be used to
detect word boundaries. If the pattern <TT><FONT FACE="Courier">/\w\W/</FONT></TT>
matches a pair of characters, it means that the first character
is part of a word and the second is not. This further means that
the first character is at the end of a matched word and that a
word boundary exists between the first and second characters matched
by the pattern and you are at the end of a word.
<P>
Conversely, if <TT><FONT FACE="Courier">/\W\w/</FONT></TT> matches
a pair of characters, the first character is not part of a word
and the second character is part of the word. This means that
the second character is the beginning of a word. Again, a word
boundary exists between the first and second characters matched
by the pattern. Therefore, you are at the start of a word.
<H3><A NAME="ThequotemetaFunction">The <TT><FONT SIZE=4 FACE="Courier">quotemeta</FONT></TT><FONT SIZE=4>
Function</FONT></A></H3>
<P>
The <TT><FONT FACE="Courier">quotemeta</FONT></TT> function puts
a backslash in front of any non-word character in a given string.
Here's the syntax for <TT><FONT FACE="Courier">quotemeta</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$<BR>
newstring = quotemeta($oldstring);</FONT></TT>
</BLOCKQUOTE>
<P>
The action of the <TT><FONT FACE="Courier">quotemeta</FONT></TT>
string can best be described using regular expressions as 
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$string =~ s/(\W)/\\$1/g;</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="SpecifyingtheNumberofMatches">Specifying the Number
of Matches</A></H3>
<P>
Sometimes matching once, twice, or more than once is not sufficient
for a particular search. What if you wanted to match from two
to four times? In this case you can use the <TT><FONT FACE="Courier">{
}</FONT></TT> operators in the search function. For example, in
the following pattern you can search for all words that begin
with <TT><FONT FACE="Courier">ch</FONT></TT> followed by two or
three digits followed by <TT><FONT FACE="Courier">.txt</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/ch[0-9]{2,3}.txt/</FONT></TT>
</BLOCKQUOTE>
<P>
For exactly three digits after the <TT><FONT FACE="Courier">ch</FONT></TT>
text, you can use this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/ch[0-9]{ 3}.txt/</FONT></TT>
</BLOCKQUOTE>
<P>
For three or more digits after the <TT><FONT FACE="Courier">ch</FONT></TT>
text, you can use this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/ch[0-9]{3,}.txt/</FONT></TT>
</BLOCKQUOTE>
<P>
To match any three characters following the <TT><FONT FACE="Courier">ch</FONT></TT>
text, you can use this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/ch.{3,}.txt/</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="SpecifyingMoreThanOneChoice">Specifying More Than
One Choice</A></H3>
<P>
Perl enables you to specify more than one choice when attempting
to match a pattern. The pipe symbol (<TT><FONT FACE="Courier">|</FONT></TT>)
works like an <TT><FONT FACE="Courier">OR</FONT></TT> operator,
enabling you to specify two or more patterns to match. For example,
the pattern
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/houston|rockets/</FONT></TT>
</BLOCKQUOTE>
<P>
matches the string <TT><FONT FACE="Courier">houston</FONT></TT>
or the string <TT><FONT FACE="Courier">rockets</FONT></TT>, whichever
comes first. You can use special characters with the patterns.
For example, the pattern <TT><FONT FACE="Courier">/[a-z]+|[0-9]+/</FONT></TT>
matches one or more lowercase letters or one or more digits. The
match for a valid integer in Perl is defined as this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/\b\d+\b|\b0[xX][\da-fA-F]+\b/)</FONT></TT>
</BLOCKQUOTE>
<P>
There are two alternatives to check for here. The first one is
<TT><FONT FACE="Courier">^\d+</FONT></TT> (that is, check for
one or more digits to cover both octal and decimal digits). The
second <TT><FONT FACE="Courier">^0[xX][\da-fA-F]+$</FONT></TT>
looks for <TT><FONT FACE="Courier">0x</FONT></TT> or <TT><FONT FACE="Courier">0X</FONT></TT>
followed by hex digits. Any other pattern is disregarded. The
delimiting <TT><FONT FACE="Courier">\b</FONT></TT> tags limit
the search to word boundaries.
<H3><A NAME="SearchingaStringforMoreThanOnePat">Searching a String
for More Than One Pattern to Match</A></H3>
<P>
Sometimes it's necessary to search for occurrences for the same
pattern to match at more than one location. You saw earlier in
the example for using <TT><FONT FACE="Courier">substr</FONT></TT>
how we kept the index around between successive searches on one
string. Perl offers another alternative to this problem: the <TT><FONT FACE="Courier">pos()</FONT></TT>
function. The <TT><FONT FACE="Courier">pos</FONT></TT> function
returns the location of the last pattern match in a string. You
can reuse the last match value when using the global (<TT><FONT FACE="Courier">g</FONT></TT>)
pattern matching operator. The syntax for the <TT><FONT FACE="Courier">pos</FONT></TT>
function is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$offset = pos($string);</FONT></TT>
</BLOCKQUOTE>
<P>
where <TT><FONT FACE="Courier">$string</FONT></TT> is the string
whose pattern is being matched. The returned <TT><FONT FACE="Courier">$offset</FONT></TT>
is the number of characters already matched or skipped. 
<P>
Listing 7.11 presents a simple script to search for the letter
<TT><FONT FACE="Courier">n</FONT></TT> in <TT><FONT FACE="Courier">Bananarama</FONT></TT>.
<HR>
<BLOCKQUOTE>
<B>Listing 7.11. Using the </B><TT><B><FONT FACE="Courier">pos</FONT></B></TT><B>
function.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">1 #!/usr/bin/perl<BR>
2 $string = &quot;Bananarama&quot;;<BR>
3 while ($string =~ /n/g) {<BR>
4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$offset
= pos($string);<BR>
5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Found
an n at $offset\n&quot;);<BR>
6 }</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Here's the output for this program:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Found an n at 2<BR>
Found an n at 4<BR>
Found an n at 6<BR>
Found an n at 8<BR>
Found an n at 10</FONT></TT>
</BLOCKQUOTE>
<P>
The starting position for <TT><FONT FACE="Courier">pos()</FONT></TT>
to work does not have to start at 0. Like the <TT><FONT FACE="Courier">substr()</FONT></TT>
function, you can use <TT><FONT FACE="Courier">pos()</FONT></TT>
on the right side of the equal sign. To start a search at position
6, simply type this line before you process the string:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">pos($string) = 5;</FONT></TT>
</BLOCKQUOTE>
<P>
To restart searching from the beginning, reset the value of <TT><FONT FACE="Courier">pos</FONT></TT>
to <TT><FONT FACE="Courier">0</FONT></TT>.
<H2><A NAME="ReusingPortionsofPatterns"><FONT SIZE=5 COLOR=#FF0000>Reusing
Portions of Patterns</FONT></A></H2>
<P>
There will be times when you want to write patterns that address
groups of numbers. For example, a section of comma-delimited data
from the output of a spreadsheet is of this form:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">digits,digits,digits,digits</FONT></TT>
</BLOCKQUOTE>
<P>
A bit repetitive, isn't it? To extract this tidbit of information
from the middle of a document, you could use something like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/[\d]+[,.][\d]+[,.][\d]+[,.][\d]+/</FONT></TT>
</BLOCKQUOTE>
<P>
What if there were 10 columns? The pattern would be long, and
you'd be prone to make mistakes.
<P>
Perl provides a macro substitution to allow repetitions of a known
sequence. Every pattern in a matched string that is enclosed in
memory is stored in memory in the order it is declared. To retrieve
a sequence from memory, use the special character <TT><FONT FACE="Courier">\<I>n</I></FONT></TT>,
where <TT><I><FONT FACE="Courier">n</FONT></I></TT> is an integer
representing the <I>n</I>th pattern stored in memory.
<P>
For example, you can write the previous lines using these two
repetitive patterns:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">([\d]+)<BR>
([,.])</FONT></TT>
</BLOCKQUOTE>
<P>
The string that is used for matching the pattern would look like
this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/([\d]+])([,.])\1\2\1\2\1\2/</FONT></TT>
</BLOCKQUOTE>
<P>
The pattern matched by <TT><FONT FACE="Courier">[\d]+</FONT></TT>
is stored in memory. When the Perl interpreter sees the escape
sequence <TT><FONT FACE="Courier">\1</FONT></TT>, it matches the
first matched pattern. When it sees <TT><FONT FACE="Courier">\2</FONT></TT>,
it matches the second pattern. Pattern sequences are stored in
memory from left to right. As another example, the following matches
a phone number in the United States, which is of the form ###-###-####,
where the # is a digit:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/\d{3}(\-))\d{3}\1\d{2}/</FONT></TT>
</BLOCKQUOTE>
<P>
The pattern sequence memory is preserved only for the length of
the pattern. You can access these variables for a short time,
at least until another pattern match is hit, by examining the
special variables of the form <TT><FONT FACE="Courier">$n</FONT></TT>.
The <TT><FONT FACE="Courier">$n</FONT></TT> variables contain
the value of patterns matched in parentheses right after a match.
The special variable <TT><FONT FACE="Courier">$&amp;</FONT></TT>
contains the entire matched pattern.
<P>
In the previous snippet of code, to get the data matched in columns
into separate variables, you can use something like this excerpt
in a program:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">if (/-?(\d+)\.?(\d+)/) {<BR>
$matchedPart = $&amp;;<BR>
$col_1 = $1;<BR>
$col_2 = $2;<BR>
$col_3 = $3;<BR>
$col_4 = $4;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The order of precedence when using <TT><FONT FACE="Courier">()</FONT></TT>
is higher than that of other pattern-matching characters. Here
is the order of precedence from high to low:<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">()</FONT></TT></TD>
<TD WIDTH=171>Pattern memory</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">+ * ? {}</FONT></TT>
</TD><TD WIDTH=171>Number of occurrences</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">^ $ \b \B \W \w</FONT></TT>
</TD><TD WIDTH=171>Pattern anchors</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">|</FONT></TT></TD>
<TD WIDTH=171>The <TT><FONT FACE="Courier">OR</FONT></TT> operator
</TD></TR>
</TABLE></CENTER>
<P>
<P>
The pattern-memory special characters <TT><FONT FACE="Courier">()</FONT></TT>
serve as delimiters for the <TT><FONT FACE="Courier">OR</FONT></TT>
operator. The side effect of this delimiting is that the parenthesized
part of the pattern is mapped into a <TT><FONT FACE="Courier">$n</FONT></TT>
register. For example, in the following line, the <TT><FONT FACE="Courier">\1</FONT></TT>
refers to (<TT><FONT FACE="Courier">b|d</FONT></TT>), not the
(<TT><FONT FACE="Courier">a|o</FONT></TT>) matching pattern:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/(b|d)(a|o)(rk).*\1\2\3/</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="PatternMatchingOptions"><FONT SIZE=5 COLOR=#FF0000>Pattern-Matching
Options</FONT></A></H2>
<P>
There are several pattern-matching options in Perl to control
how strings are matched. You saw these options earlier when I
introduced the syntax for pattern matching. Here are the options:
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=115><TT><FONT FACE="Courier"><center>g</FONT></TT>
</TD><TD WIDTH=243>Match all possible patterns</TD></TR>
<TR VALIGN=TOP><TD WIDTH=115><CENTER><TT><FONT FACE="Courier">i</FONT></TT></CENTER>
</TD><TD WIDTH=243>Ignore case when matching strings</TD></TR>
<TR VALIGN=TOP><TD WIDTH=115><CENTER><TT><FONT FACE="Courier">m</FONT></TT></CENTER>
</TD><TD WIDTH=243>Treat string as multiple lines</TD></TR>
<TR VALIGN=TOP><TD WIDTH=115><CENTER><TT><FONT FACE="Courier">o</FONT></TT></CENTER>
</TD><TD WIDTH=243>Only evaluate once</TD></TR>
<TR VALIGN=TOP><TD WIDTH=115><CENTER><TT><FONT FACE="Courier">s</FONT></TT></CENTER>
</TD><TD WIDTH=243>Treat string as single line</TD></TR>
<TR VALIGN=TOP><TD WIDTH=115><CENTER><TT><FONT FACE="Courier">x</FONT></TT></CENTER>
</TD><TD WIDTH=243>Ignore white space in pattern</TD></TR>
</TABLE></CENTER>
<P>
<P>
All these pattern options must be specified immediately after
the option. For example, the following pattern uses the <TT><FONT FACE="Courier">i</FONT></TT>
option to ignore case:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/first*name/i</FONT></TT>
</BLOCKQUOTE>
<P>
More than one option can be specified at one time and can be specified
in any order.
<P>
The <TT><FONT FACE="Courier">g</FONT></TT> operator tells the
Perl interpreter to match all the possible patterns in a string.
For example, if the string <TT><FONT FACE="Courier">bananarama</FONT></TT>
is searched using the following pattern:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/.a/g</FONT></TT>
</BLOCKQUOTE>
<P>
it will match <TT><FONT FACE="Courier">ba</FONT></TT>, <TT><FONT FACE="Courier">na</FONT></TT>,
<TT><FONT FACE="Courier">na</FONT></TT>, <TT><FONT FACE="Courier">ra</FONT></TT>,
and <TT><FONT FACE="Courier">ma</FONT></TT>. You can assign the
return of all these matches to an array. Here's an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">@words = &quot;bananarama&quot; =~ /.a/g;
<BR>
for $i (@words) {<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">print
&quot;$i \n&quot;;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
You can use patterns with the <TT><FONT FACE="Courier">g</FONT></TT>
option in loops. The returned value of the match is repeated until
it returns <TT><FONT FACE="Courier">false</FONT></TT>. Inside
the loop you can use the <TT><FONT FACE="Courier">&amp;#</FONT></TT>
operator. For example, in the word <TT><FONT FACE="Courier">Mississippi</FONT></TT>,
you can loop around looking for two characters together like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$string = &quot;Mississippi&quot;;<BR>
while ($string =~ /([a-z]\1/g) {<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$found
= $&amp;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print
(&quot;$found\n&quot;);<BR>
}<BR>
</FONT></TT>
</BLOCKQUOTE>
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD ><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD >
<BLOCKQUOTE>
Don't forget that you can use the <TT><FONT FACE="Courier">pos()</FONT></TT> function in a <TT><FONT FACE="Courier">while</FONT></TT> loop to see at what position the last match occurred.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
The <TT><FONT FACE="Courier">i</FONT></TT> option enables you
to perform a case-insensitive search. The match will be made regardless
of whether the string is uppercase or lowercase or a mixture of
cases.
<P>
The <TT><FONT FACE="Courier">m</FONT></TT> option allows searching
on more than one line per match. When the <TT><FONT FACE="Courier">m</FONT></TT>
option is specified, the <TT><FONT FACE="Courier">^</FONT></TT>
special character matches either the start of the string or the
start of any new line. Also, the <TT><FONT FACE="Courier">$</FONT></TT>
character can match either the new line or the end of text.
<P>
The <TT><FONT FACE="Courier">o</FONT></TT> option enables a pattern
to be evaluated only once. This is never really used in practice.
Basically, it forces Perl to disregard further matches on the
same input line.
<P>
Normally the dot (<TT><FONT FACE="Courier">.</FONT></TT>) character
does not match the new line. When you specify the <TT><FONT FACE="Courier">s</FONT></TT>
option, you allow the pattern to be matched across multiple lines
because this allows the dot character to be matched with a new
line.
<P>
The <TT><FONT FACE="Courier">x</FONT></TT> operator tells Perl
to ignore any white spaces in the pattern match unless the white
space has been preceded by a backslash. The real benefit to using
the <TT><FONT FACE="Courier">x</FONT></TT> option is to improve
readability because pattern specifications do not have to be crunched
together anymore. For example, these two patterns match the same
string:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/([\d]+])([,.])\1\2\1\2\1\2/<BR>
/([\d]+])([,.]) \1\2\ 1\2\ 1\2/x</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="SubstitutingTextThroughPatternMatchi"><FONT SIZE=5 COLOR=#FF0000>Substituting
Text Through Pattern Matching </FONT></A></H2>
<P>
You have already seen how to substitute text through the use of
the <TT><FONT FACE="Courier">substr</FONT></TT> function. The
pattern-matching function can be extended to do string substitution
with the use of the <TT><FONT FACE="Courier">s</FONT></TT> operator.
Here's the syntax:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">s/pattern/replacement/[options]</FONT></TT>
</BLOCKQUOTE>
<P>
The replacement string is interpreted literally and cannot have
a pattern. The Perl interpreter searches for the pattern specified
by the placeholder pattern. If it finds the pattern, it replaces
the pattern with the string represented by the placeholder replacement.
Here's an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$string = &quot;cabi.net&quot;;<BR>
$string =~ s/cabi/sig/;</FONT></TT>
</BLOCKQUOTE>
<P>
The contents of <TT><FONT FACE="Courier">$string</FONT></TT> will
be <TT><FONT FACE="Courier">sig.net</FONT></TT> instead of <TT><FONT FACE="Courier">cabi.net</FONT></TT>.
<P>
The good news is that all the pattern matching stuff up to this
point in the chapter applies here! So, you can use any of the
pattern special characters in the substitution operator. For example,
the following replaces all words with one or more digits with
the letter <TT><FONT FACE="Courier">X</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">s/[\d]+/X/</FONT></TT>
</BLOCKQUOTE>
<P>
Specify an empty string for the replacement if you just want to
delete a set of strings. For example, the following line replaces
all words with one or more digits in them:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">s/[\d]+//</FONT></TT>
</BLOCKQUOTE>
<P>
The pattern match memory sequence applies here. For example, to
swap the two columns of data, you can use this line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">s/(\d+)\s\1/$2 $1/</FONT></TT>
</BLOCKQUOTE>
<P>
The substitution pattern matches a sequence of one or more digits,
followed by a space, followed by another set of digits. The output
is the values of the <TT><FONT FACE="Courier">$1</FONT></TT> and
<TT><FONT FACE="Courier">$2</FONT></TT> registers swapped in sequence.
<P>
The substitution operator supports several options just like the
match operator:<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=32><CENTER><TT><FONT FACE="Courier">g</FONT></TT></CENTER>
</TD><TD WIDTH=298>Change all occurrences of the pattern</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=32><CENTER><TT><FONT FACE="Courier">i</FONT></TT></CENTER>
</TD><TD WIDTH=298>Ignore case in pattern</TD></TR>
<TR VALIGN=TOP><TD WIDTH=32><CENTER><TT><FONT FACE="Courier">e</FONT></TT></CENTER>
</TD><TD WIDTH=298>Evaluate replacement string as expression</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=32><CENTER><TT><FONT FACE="Courier">m</FONT></TT></CENTER>
</TD><TD WIDTH=298>Treat string to be matched as multiple lines
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=32><CENTER><TT><FONT FACE="Courier">o</FONT></TT></CENTER>
</TD><TD WIDTH=298>Only evaluate once</TD></TR>
<TR VALIGN=TOP><TD WIDTH=32><CENTER><TT><FONT FACE="Courier">s</FONT></TT></CENTER>
</TD><TD WIDTH=298>Treat string to be matched as single line</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=32><CENTER><TT><FONT FACE="Courier">x</FONT></TT></CENTER>
</TD><TD WIDTH=298>Ignore white space in pattern</TD></TR>
</TABLE></CENTER>
<P>
<P>
As with pattern matching, options are appended to the end of the
operator. Most of these options work the same way as they did
for matching patterns during a search.
<P>
The <TT><FONT FACE="Courier">g</FONT></TT> option changes all
occurrences of a pattern in a particular string. For instance,
the following substitution puts parentheses around all the numbers
in a line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">s/(\d+)/($1)/g</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">i</FONT></TT> option ignores case
when substituting. For example, the substitution
<BLOCKQUOTE>
<TT><FONT FACE="Courier">s/\bweb\b/WEB/gi</FONT></TT>
</BLOCKQUOTE>
<P>
replaces all occurrences of the words <TT><FONT FACE="Courier">web</FONT></TT>,
<TT><FONT FACE="Courier">WeB</FONT></TT>, <TT><FONT FACE="Courier">wEB</FONT></TT>,
and so on with the word <TT><FONT FACE="Courier">WEB</FONT></TT>.
<P>
Although you cannot put patterns in the replacement string, you
can run the <TT><FONT FACE="Courier">eval()</FONT></TT> function
on it. The <TT><FONT FACE="Courier">e</FONT></TT> option treats
the replacement string as an expression, which it evaluates before
replacing it in the original string. The results of the evaluation
are used instead. Suppose that you wanted to repeat a string twice
on a line. A common use is to redefine the values in a header
file to twice what they are. For example, the string
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$define ABX 123</FONT></TT>
</BLOCKQUOTE>
<P>
matches all the variables of the form and replaces the numeric
part of the line with twice its value. Listing 7.12 presents a
simple script to do this with a C header file.
<HR>
<BLOCKQUOTE>
<B>Listing 7.12. Using the pattern replace to do simple operations.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 <BR>
&nbsp;3 open (FILE, &quot;tt.h&quot;)
|| die $!;<BR>
&nbsp;4 $i = 0;<BR>
&nbsp;5 while (&lt;FILE&gt;)
{<BR>
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$string
= $_;<BR>
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(/define/)
{<BR>
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
$string&nbsp;&nbsp;=~ s/(\d+)/$1 * 2/e;<BR>
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
print &quot;$string \n&quot;;<BR>
10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
$i++;<BR>
11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {
<BR>
13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
print &quot;$string \n&quot;;<BR>
14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
16 <BR>
17 close FILE;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT><FONT FACE="Courier">o</FONT></TT> option tells the Perl
interpreter to replace a scalar variable only on the first match.
All subsequent pattern matches are ignored.
<P>
The <TT><FONT FACE="Courier">s</FONT></TT> option ensures that
the newline character <TT><FONT FACE="Courier">\n</FONT></TT>
is matched by the <TT><FONT FACE="Courier">.</FONT></TT> special
character:
<P>
With the <TT><FONT FACE="Courier">m</FONT></TT> option, the <TT><FONT FACE="Courier">^</FONT></TT>
and <TT><FONT FACE="Courier">$</FONT></TT> characters match the
start and end of any line as they do in pattern matches.
<P>
The <TT><FONT FACE="Courier">\A</FONT></TT> and <TT><FONT FACE="Courier">\Z</FONT></TT>
escape sequences always match only the beginning and end of the
string. The actions taken by these options are not affected by
the <TT><FONT FACE="Courier">s</FONT></TT> or <TT><FONT FACE="Courier">m</FONT></TT>
options.
<P>
The <TT><FONT FACE="Courier">x</FONT></TT> option causes the interpreter
to ignore all white spaces unless they are escaped by a backslash.
The only benefit gained from this operation is to make patterns
easier to read. See the example for using the <TT><FONT FACE="Courier">x</FONT></TT>
option shown in the pattern-matching options section earlier in
this chapter.
<P>
The forward slash (<TT><FONT FACE="Courier">/</FONT></TT>) delimiter
can be substituted with another character for showing where to
delimit text. For example, you can use <TT><FONT FACE="Courier">&lt;&gt;</FONT></TT>,
<TT><FONT FACE="Courier">#</FONT></TT> (hash), or <TT><FONT FACE="Courier">()</FONT></TT>
(parentheses) characters as delimiters, as illustrated in Listing
7.13.
<HR>
<BLOCKQUOTE>
<B>Listing 7.13. Using a different delimiter for the forward slash.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 <BR>
&nbsp;3 $name = &quot;/usr/local/lib&quot;;
<BR>
&nbsp;4 <BR>
&nbsp;5 $s1 = $name ;<BR>
&nbsp;6 $s1 =~ s#/usr/local/#/local/#;<BR>
&nbsp;7 print $s1 . &quot;\n&quot;;
<BR>
&nbsp;8 <BR>
&nbsp;9 $s2 = $name ;<BR>
10 $s2 =~ s&lt;/usr/local/&gt;&lt;/local/&gt;;<BR>
11 print $s2 . &quot;\n&quot;;<BR>
12 <BR>
13 $s3 = $name ;<BR>
14 $s3 =~ s(/usr/local/)(/local/);<BR>
15 print $s3 . &quot;\n&quot;;</FONT></TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="TheTranslationOperator"><FONT SIZE=5 COLOR=#FF0000>The
Translation Operator </FONT></A></H2>
<P>
The UNIX <TT><FONT FACE="Courier">tr</FONT></TT> command is also
available in Perl as the <TT><FONT FACE="Courier">tr</FONT></TT>
function. The <TT><FONT FACE="Courier">tr</FONT></TT> function
lets you substitute one group of characters with another. Here's
the syntax:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">tr/<I>string1</I>/<I>string2</I>/</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">where string1</FONT></TT> contains a
list of characters to be replaced, and <TT><FONT FACE="Courier">string2</FONT></TT>
contains the characters that replace them. Each character in <TT><FONT FACE="Courier">string2</FONT></TT>
is replaced with a character in the same position in <TT><FONT FACE="Courier">string1</FONT></TT>.
<P>
If <TT><FONT FACE="Courier">string1</FONT></TT> is longer than
<TT><FONT FACE="Courier">string2</FONT></TT>, the last character
of <TT><FONT FACE="Courier">string1</FONT></TT> is repeated to
pad the contents of <TT><FONT FACE="Courier">string2</FONT></TT>.
If the same character appears more than once in <TT><FONT FACE="Courier">string1</FONT></TT>,
the first replacement found will be used.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$string = &quot;12345678901234567890&quot;;
<BR>
$string =~ tr/2345/ABC/;</FONT></TT>
</BLOCKQUOTE>
<P>
Here, all characters <TT><FONT FACE="Courier">2</FONT></TT>, <TT><FONT FACE="Courier">3</FONT></TT>,
<TT><FONT FACE="Courier">4</FONT></TT>, and <TT><FONT FACE="Courier">5</FONT></TT>
in the string are replaced with <TT><FONT FACE="Courier">A</FONT></TT>,
<TT><FONT FACE="Courier">B</FONT></TT>, <TT><FONT FACE="Courier">C</FONT></TT>,
and <TT><FONT FACE="Courier">C</FONT></TT>, respectively. The
<TT><FONT FACE="Courier">C </FONT></TT>is repeated here by Perl
as it makes the length of the replacement string equal to that
of the string being replaced. So, the replacement string is <TT><FONT FACE="Courier">&quot;ABccC&quot;</FONT></TT>
for matching with <TT><FONT FACE="Courier">&quot;12345&quot;</FONT></TT>.
<P>
The most common use of the translation operator is to convert
a string from uppercase to lowercase, or vice versa.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">while ($line = &lt;STDIN&gt;) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$line =~
tr/A-Z/a-z/;<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print
($line);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
To convert all characters in a string to uppercase, here's another
sample function:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">while ($line = &lt;STDIN&gt;) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$line =~
tr/a-z/A-Z/;<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print
($line);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
There are a few things about the <TT><FONT FACE="Courier">tr</FONT></TT>
operator that you should remember:
<UL>
<LI><FONT COLOR=#000000>If you do not specify a variable name,
the </FONT><TT><FONT FACE="Courier">$_</FONT></TT> variable is
used instead.
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">tr</FONT></TT>
function returns the number of characters replaced. That is, the
statement <TT><FONT FACE="Courier">$num = $line =~ tr/a-z/A-Z/</FONT></TT>
will set the value of <TT><FONT FACE="Courier">$num</FONT></TT>
to the number of characters replaced. Using <TT><FONT FACE="Courier">tr</FONT></TT>
to get the length of a string is possible if you replace each
character by itself, but it's probably better to use <TT><FONT FACE="Courier">length</FONT></TT>
instead.
<LI><FONT COLOR=#000000>No pattern-matching special characters
are supported by </FONT><TT><FONT FACE="Courier">tr</FONT></TT>.
<LI><FONT COLOR=#000000>You can use </FONT><TT><FONT FACE="Courier">y</FONT></TT>
in place of <TT><FONT FACE="Courier">tr</FONT></TT> if you like.
That is, these two statements are the same: <TT><FONT FACE="Courier">$string
=~ y/a-z/A-Z/;</FONT></TT> and <TT><FONT FACE="Courier">$string
=~ tr/a-z/A-Z/;</FONT></TT>. Functionally, the <TT><FONT FACE="Courier">y</FONT></TT>
is the same as <TT><FONT FACE="Courier">tr</FONT></TT>. Why use
<TT><FONT FACE="Courier">y</FONT></TT>? Using the <TT><FONT FACE="Courier">y</FONT></TT>
function might impress your colleagues and get you a key to the
executive bathroom. Wow!
</UL>
<P>
The program in Listing 7.14 tallies the number of times vowels
are used in a text file.
<HR>
<BLOCKQUOTE>
<B>Listing 7.14. Tallying vowels in a text file.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 <BR>
&nbsp;3 $count = 0;<BR>
&nbsp;4 <BR>
&nbsp;5 while ($input = &lt;STDIN&gt;)
{<BR>
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chop
($input);<BR>
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$total
+= length($input);<BR>
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$_
= $input;<BR>
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$count
+= tr/aeiou/aeiou/;<BR>
10 }<BR>
11 <BR>
12 print (&quot;In this file, there are: $count vowels \n&quot;;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The translation operator supports three options. These options
are specified after the patterns using this syntax:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">tr/string1/string2/[cds]</FONT></TT>
</BLOCKQUOTE>
<P>
Here are the options for <TT><FONT FACE="Courier">tr</FONT></TT>:
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=32><CENTER><TT><FONT FACE="Courier">c</FONT></TT></CENTER>
</TD><TD WIDTH=450>Translate all characters not specified</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=32><CENTER><TT><FONT FACE="Courier">d</FONT></TT></CENTER>
</TD><TD WIDTH=450>Delete all specified characters</TD></TR>
<TR VALIGN=TOP><TD WIDTH=32><CENTER><TT><FONT FACE="Courier">s</FONT></TT></CENTER>
</TD><TD WIDTH=450>Replace multiple identical output characters with a single character
</TD></TR>
</TABLE></CENTER>
<P>
<P>
The <TT><FONT FACE="Courier">c</FONT></TT> operator stands for
<I>complement</I>. That is, it does the opposite of what the character
specifies. For example, the following line replaces all characters
that are not in <TT><FONT FACE="Courier">[a-zA-Z0-9]</FONT></TT>
with a space:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$onlyDigits =~ tr/\w/ /c;</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">d</FONT></TT> option deletes every
specified character:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$noDigits =~ tr/\d//d;</FONT></TT>
</BLOCKQUOTE>
<P>
This deletes all the digits from <TT><FONT FACE="Courier">$noDigits</FONT></TT>.
<P>
The <TT><FONT FACE="Courier">s</FONT></TT> option stands for <I>squeeze</I>.
With the <TT><FONT FACE="Courier">s</FONT></TT> option, <TT><FONT FACE="Courier">tr</FONT></TT>
translates only one character if two or more consecutive characters
translate to the same output character. For example, the following
line replaces everything that is not a digit and outputs only
one space between digits.
<H2><A NAME="ExtendedPatternMatching"><FONT SIZE=5 COLOR=#FF0000>Extended
Pattern Matching </FONT></A></H2>
<P>
Pattern-specific matching capabilities are possible with the use
of this operator:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">(?<I>ccpattern</I>)</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><I><FONT FACE="Courier">cc</FONT></I></TT><I> </I>is a single
character representing the extended pattern-matching capability
being used for the pattern. <TT><I><FONT FACE="Courier">cc</FONT></I></TT>
can be one of these values:<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=42><TT><FONT FACE="Courier">?:</FONT></TT></TD>
<TD WIDTH=548>Do not store the pattern in parentheses in memory.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=42><TT><FONT FACE="Courier">?o</FONT></TT></TD>
<TD WIDTH=548>Where <TT><FONT FACE="Courier">o</FONT></TT> can be an option to apply to the pattern and can be <TT><FONT FACE="Courier">i</FONT></TT> for case insensitive, <TT><FONT FACE="Courier">m</FONT></TT> for multiple lines, <TT><FONT 
FACE="Courier">s</FONT></TT> for single line, or <TT><FONT FACE="Courier">x</FONT></TT> for ignore white space.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=42><TT><FONT FACE="Courier">?=</FONT></TT></TD>
<TD WIDTH=548>Look ahead in buffer.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=42><TT><FONT FACE="Courier">?!</FONT></TT></TD>
<TD WIDTH=548>Look back in buffer.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=42><TT><FONT FACE="Courier">?#</FONT></TT></TD>
<TD WIDTH=548>Add comments.</TD></TR>
</TABLE></CENTER>
<P>
<P>
You have seen how <TT><FONT FACE="Courier">()</FONT></TT> stores
a pattern match in memory. By using <TT><FONT FACE="Courier">?:</FONT></TT>
you can force the pattern not to be stored in memory. In the following
two statements, <TT><FONT FACE="Courier">\1</FONT></TT> points
to <TT><FONT FACE="Courier">\d+</FONT></TT> in the first and <TT><FONT FACE="Courier">[a-z]</FONT></TT>
in the second:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/(\d+)([a-z]+/<BR>
/(?:\d+)([a-z]+/</FONT></TT>
</BLOCKQUOTE>
<P>
The string, <TT><FONT FACE="Courier">?o</FONT></TT>, specifies
a pattern-matching option within the pattern itself. The <TT><FONT FACE="Courier">o</FONT></TT>
could be <TT><FONT FACE="Courier">i</FONT></TT> for ignore case.
For example, the following patterns are the same:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/[a-z]+/i<BR>
/(?i)[a-z]+/</FONT></TT>
</BLOCKQUOTE>
<P>
You can specify different cases for different parts of the same
search pattern. Here's an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$pattern1 = &quot;[A-Z]+&quot;;<BR>
$pattern2 = &quot;(?i)[a-z0-9_]+&quot;;<BR>
if ($string =~ /$pattern1|$pattern2/) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
This pattern matches either any collection of uppercase letters
or any collection of letters with digits and an underscore.
<P>
You can use the <TT><FONT FACE="Courier">?=</FONT></TT> feature
to look ahead for a pattern. For example, the pattern
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/123(?=XYZ)/</FONT></TT>
</BLOCKQUOTE>
<P>
only matches <TT><FONT FACE="Courier">123</FONT></TT> if it is
immediately followed by <TT><FONT FACE="Courier">XYZ</FONT></TT>.
The matched string in <TT><FONT FACE="Courier">$&amp;</FONT></TT>
will be <TT><FONT FACE="Courier">123</FONT></TT>, not <TT><FONT FACE="Courier">123XYZ</FONT></TT>.
<P>
To look at the back of a string, use the <TT><FONT FACE="Courier">?!</FONT></TT>
operator. For example,
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/(?!XYZ)123/</FONT></TT>
</BLOCKQUOTE>
<P>
matches <TT><FONT FACE="Courier">123</FONT></TT> only if it immediately
follows <TT><FONT FACE="Courier">XYZ</FONT></TT>. The matched
pattern in <TT><FONT FACE="Courier">$&amp; </FONT></TT>will still
be <TT><FONT FACE="Courier">123</FONT></TT>.
<P>
Reading complicated patterns is not easy, even if you are the
author. Adding comments makes it easier to follow complicated
patterns. Finally, you can add comments about a pattern with the
<TT><FONT FACE="Courier">?#</FONT></TT> operator. Here's an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/(?i)[a-z][\d]{2,3}(?</FONT></TT>
</BLOCKQUOTE>
<P>
The above example will match two or three digits following a lowercase
letter. 
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary </FONT></A>
</H2>
<P>
With the function <TT><FONT FACE="Courier">substr</FONT></TT>
you can extract a substring from a string or replace a portion
of a string or append to the front or back end of another string.
The <TT><FONT FACE="Courier">lc</FONT></TT> and <TT><FONT FACE="Courier">uc</FONT></TT>
functions convert strings to lowercase and uppercase. The first
letter of a string can be converted to lowercase or uppercase
using either <TT><FONT FACE="Courier">lcfirst</FONT></TT> or <TT><FONT FACE="Courier">ucfirst</FONT></TT>.
The <TT><FONT FACE="Courier">quotemeta</FONT></TT> function places
a backslash in front of every nonword character in a string. New
character strings can be created using <TT><FONT FACE="Courier">join</FONT></TT>,
which creates a string from the members of a list, and <TT><FONT FACE="Courier">sprintf</FONT></TT>,
which works like <TT><FONT FACE="Courier">printf</FONT></TT> except
that the output goes to a string. Functions that search character
strings include <TT><FONT FACE="Courier">index</FONT></TT>, which
searches for a substring starting from the left of a string, and
<TT><FONT FACE="Courier">rindex</FONT></TT>, which searches for
a substring starting from the right of a string. You can retrieve
the length of a character string using <TT><FONT FACE="Courier">length</FONT></TT>.
The <TT><FONT FACE="Courier">pos</FONT></TT> function enables
you to determine or set the current pattern-matching location
in a string. The <TT><FONT FACE="Courier">tr</FONT></TT> function
replaces one set of characters with another.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch6.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch6.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch8.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch8.htm"><IMG 
SRC="nc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>
