<HTML>

<HEAD>
   <TITLE>Chapter 13 -- Messaging Facilities: The System
V Ipc Functions</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT COLOR=#FF0000>Chapter 13</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Messaging Facilities: The System
V Ipc Functions</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#AnIntroductiontotheSystemVIpc" >An Introduction to the System V Ipc</A>
<LI><A HREF="#UsingtheUNIXSystemVIpcFunctions" >Using the UNIX System V Ipc Functions</A>
<UL>
<LI><A HREF="#ThemsggetFunction" >The msgget() Function</A>
</UL>
<LI><A HREF="#TheipcsCommand" >The ipcs Command</A>
<LI><A HREF="#ThemsgsndandmsgrcvFunctions" >The msgsnd() and msgrcv() Functions</A>
<LI><A HREF="#SharedMemory" >Shared Memory</A>
<UL>
<LI><A HREF="#TheshmwriteandshmreadFunctions" >The shmwrite() and shmread() Functions</A>
</UL>
<LI><A HREF="#Semaphores" >Semaphores</A>
<LI><A HREF="#TheSysVIpcModule" >The SysV::Ipc Module</A>
<LI><A HREF="#ApplicationsofIpc" >Applications of Ipc</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
This chapter introduces you to the Interprocess Communications
(Ipc) functionality of message queues, shared memory, and semaphores.
The Ipc facilities provide a clean, consistent solution to passing
data between processes on the same machine. (Sockets can extend
across platforms and a network.)
<H2><A NAME="AnIntroductiontotheSystemVIpc"><FONT SIZE=5 COLOR=#FF0000>An
Introduction to the System V Ipc</FONT></A></H2>
<P>
The UNIX system V Ipc enables you to perform the following tasks:
<UL>
<LI><FONT COLOR=#000000>Send messages from one process to another
via a message queue. Processes can add messages to, check the
length of, and remove messages from a queue. </FONT>
<LI><FONT COLOR=#000000>Create and handle shared memory. This
includes the capability to read from and write into areas of shared
memory. </FONT>
<LI><FONT COLOR=#000000>Create and handle semaphores. This includes
the capability to read, set, and reset semaphore values. </FONT>
</UL>
<P>
Each Ipc function is available to calling processes as a system
resource. These resources are available for all processes on a
system-level basis and can be shared by many processes on the
same system. Ipc resources are limited to the system they reside
on and do not offer networking functionality. Because there are
only a limited number of Ipc resources on any UNIX system, it's
important to free up each resource after using it. This is because
each Ipc resource can exist for a long time after the process
that created it has finished executing. 
<P>
Each Ipc resource is referred to as an object in the operating
system. For working with Ipc resources, you either have to create
an object or use an existing one. Ipc objects are created via
a <TT><FONT FACE="Courier">get()</FONT></TT> function for that
object. Each <TT><FONT FACE="Courier">get()</FONT></TT> function
call requires a unique positive Ipc key as the identifier for
that object. Keys are converted by the kernel into an ID number
and returned by the <TT><FONT FACE="Courier">get()</FONT></TT>
function. Then the ID is used by other related functions to refer
to that object for all other operations.
<P>
An Ipc key is a long integer and is used to name the Ipc resource.
A key is assigned by the programmer but could also be assigned
by the system. The keys for shared memory, message queues, and
semaphores are unique in the sense that the same key number can
be assigned to Ipc objects of different types. That is, a semaphore
with a key of 11 can coexist on the same system with a message
queue with a key of 11. However, another semaphore cannot coexist
with a key of 11 on the same system. Programmers can force the
underlying operating system to assign a key by specifying the
<TT><FONT FACE="Courier">&amp;Ipc_PRIVATE</FONT></TT> flag (this
is explained shortly).
<P>
When you pass in a key number to a <TT><FONT FACE="Courier">get()</FONT></TT>
function, an ID is returned. Once an object is created and its
ID is returned, the object must then be referred to by its ID.
You can draw the analogy that a file handle is to a file as an
ID is to an Ipc resource. The returned IDs are positive if there
are no errors. (A negative ID is returned if there is an error.)
<P>
You can create a unique key by using the <TT><FONT FACE="Courier">&amp;Ipc_PRIVATE</FONT></TT>
flags if you are not imaginative enough. The kernel then creates
the ID and the key for you.
<P>
Ipc objects are global. Once created, the object is available
to all the processes in the system. In this respect, you have
to be careful how you access the available resources because any
process can overwrite your shared memory, message queue, or semaphore.
Also, your Ipc object remains in memory long after your process
has gone. You, not the kernel, are responsible for cleanup.
<P>
When you create the object, you also have to specify permissions.
The format of the permissions is very similar to that of files:
three groups of read/write for owner, group, and other. The execute
permission bits for the permissions are ignored by the Ipc calls.
To get access to an existing object, you have to specify <TT><FONT FACE="Courier">0</FONT></TT>
for permissions.
<P>
The following flags are permitted for creating objects:<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=119><I>Flag</I></TD><TD WIDTH=471><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=119><TT><FONT FACE="Courier">&amp;Ipc_CREAT</FONT></TT>
</TD><TD WIDTH=471>This flag creates an Ipc object given a key, or it attaches to an existing object with the same key.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=119><TT><FONT FACE="Courier">&amp;Ipc_EXCL</FONT></TT>
</TD><TD WIDTH=471>This flag creates an Ipc object given a key. It returns an error if the object with this key already exists. This prevents two unrelated processes from creating two objects with the same key.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=119><TT><FONT FACE="Courier">&amp;Ipc_RMID</FONT></TT>
</TD><TD WIDTH=471>Given an ID, this flag removes the object from the system. You must have the permissions on the object to be able to delete it.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=119><TT><FONT FACE="Courier">&amp;Ipc_STAT</FONT></TT>
</TD><TD WIDTH=471>Given an ID, this flag returns the values of each member of an Ipc object.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=119><TT><FONT FACE="Courier">&amp;Ipc_SET</FONT></TT>
</TD><TD WIDTH=471>Given an ID and a data structure for an object, this flag sets the values of each member of the corresponding Ipc object.
</TD></TR>
</TABLE></CENTER>
<H2><A NAME="UsingtheUNIXSystemVIpcFunctions"><FONT SIZE=5 COLOR=#FF0000>Using
the UNIX System V Ipc Functions</FONT></A></H2>
<P>
With Perl you can access all of the Ipc functions via a standard
set of library functions. The information required for the functions
is consistent with a UNIX system interface; therefore, the information
in a UNIX <TT><FONT FACE="Courier">man</FONT></TT> page will provide
enough information about the facilities available on your system.
<P>
System V Ipc functions are defined in Perl header files. For a
Perl installation on a UNIX system, the required information is
in the <TT><FONT FACE="Courier">*.ph</FONT></TT> files. (The <TT><FONT FACE="Courier">ph</FONT></TT>
stands for Perl header.) The following files will be required
by most of the Perl scripts you write to utilize the Ipc facilities:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">require &quot;ipc.ph&quot;;<BR>
require &quot;msg.ph&quot;;<BR>
require &quot;sem.ph&quot;;<BR>
require &quot;shm.ph&quot;;</FONT></TT>
</BLOCKQUOTE>
<P>
Keep in mind that this might not work as shown here. Here are
the primary reasons an error occurs when you try to include these
files with the <TT><FONT FACE="Courier">require</FONT></TT> statement:
<UL>
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">*.ph</FONT></TT>
files do not exist.
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">*.ph</FONT></TT>
files do exist but are not in the path(s) specified by the <TT><FONT FACE="Courier">@Inc</FONT></TT>
<TT><FONT FACE="Courier">include</FONT></TT> variable.
</UL>
<P>
To cure these problems, you'll have to run the <TT><FONT FACE="Courier">h2ph</FONT></TT>
script in the <TT><FONT FACE="Courier">/usr/lib/perl</FONT></TT>
directory. The <TT><FONT FACE="Courier">h2ph</FONT></TT> script
contains a line (around line 9) that has the variable <TT><FONT FACE="Courier">$perlincl</FONT></TT>
set to a directory. On my machine, this variable is set to <TT><FONT FACE="Courier">/usr/lib/perl5/i486-linux/5.002</FONT></TT>.
On your machine, this value might be different. In any event,
the value of <TT><FONT FACE="Courier">$perlincl</FONT></TT> is
the directory where the <TT><FONT FACE="Courier">*.ph</FONT></TT>
files are stored by the <TT><FONT FACE="Courier">h2ph</FONT></TT>
script.
<P>
Now go to the <TT><FONT FACE="Courier">/usr/include</FONT></TT>
directory and, as root, run the <TT><FONT FACE="Courier">h2ph</FONT></TT>
command as shown here:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">h2ph * sys/*</FONT></TT>
</BLOCKQUOTE>
<P>
The include files on your system may require that more subdirectories
be included in the paths specified to this program. For example,
on a Linux 3.0 system, the command to get most of the required
files is this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">h2ph * sys/*  asm/* linux/*</FONT></TT>
</BLOCKQUOTE>
<P>
The only clear way to know which files are required is to include
the Perl header files in a sample script. If everything goes well,
you should be able to get the script to run. The sample script
shown in Listing 13.1 gives two ignorable warnings on all three
different Linux versions. The script does manage to create the
message queue as expected. I cover the topic of message queues
in the section &quot;Shared Memory,&quot; later in this chapter.
<HR>
<BLOCKQUOTE>
<B>Listing 13.1. A sample script to test Perl header file inclusion.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 <BR>
&nbsp;3 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/sys&quot;);
<BR>
&nbsp;4 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/linux&quot;);
<BR>
&nbsp;5 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/asm&quot;);
<BR>
&nbsp;6 <BR>
&nbsp;7 print &quot;@Inc&quot;;
<BR>
&nbsp;8 <BR>
&nbsp;9 require &quot;ipc.ph&quot;;
<BR>
10 require &quot;msg.ph&quot;;<BR>
11 require &quot;shm.ph&quot;;<BR>
12 require &quot;sem.ph&quot;;<BR>
13 <BR>
14 $PERMISSIONS=0666;<BR>
15 $ipckey = &amp;Ipc_PRIVATE;<BR>
16 <BR>
17 $msgid = msgget($ipckey,&amp;Ipc_CREAT | &amp;Ipc_EXCL | $PERMISSIONS);
<BR>
18 <BR>
19 printf &quot;\n&nbsp;&nbsp;Message Id = $msgid&quot;;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The three required files in the sample script are included for
message queues, shared memory, and semaphores, respectively. Only
those that are required have to be included. That is, you do not
have to include <TT><FONT FACE="Courier">shm.ph</FONT></TT> if
you aren't going to be using shared memory. The <TT><FONT FACE="Courier">ipc.ph</FONT></TT>
file is required for any of these three features.
<P>
<TT><FONT FACE="Courier">PERMISSIONS</FONT></TT> is set to <TT><FONT FACE="Courier">0666</FONT></TT>,
meaning that any process can work with or even delete the Ipc
object in question. For a more secure system, you might consider
using <TT><FONT FACE="Courier">0600</FONT></TT> to give permissions
to the owner process only.
<H3><A NAME="ThemsggetFunction">The <TT><FONT SIZE=4 FACE="Courier">msgget()</FONT></TT><FONT SIZE=4>
Function</FONT></A></H3>
<P>
In Listing 13.1 an Ipc message queue was created. To use the System
V message-passing facility, you first create a message queue ID
for a given message queue. Here's the syntax of the <TT><FONT FACE="Courier">msgget()</FONT></TT>
function:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$msgid = msgget (<I>$key, $flag</I>);</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$key</FONT></TT> is set to either <TT><FONT FACE="Courier">&amp;Ipc_PRIVATE</FONT></TT>
or an arbitrary constant. If <TT><FONT FACE="Courier">$key</FONT></TT>
is <TT><FONT FACE="Courier">&amp;Ipc_PRIVATE</FONT></TT> or <TT><FONT FACE="Courier">$flag</FONT></TT>
has <TT><FONT FACE="Courier">&amp;Ipc_CREAT</FONT></TT> set, the
message queue is created and its queue ID is returned in <TT><FONT FACE="Courier">$msgid</FONT></TT>.
For <TT><FONT FACE="Courier">&amp;Ipc_EXCL</FONT></TT>, the object
must not already exist. If <TT><FONT FACE="Courier">msgget()</FONT></TT>
cannot create the message queue, <TT><FONT FACE="Courier">$msgid</FONT></TT>
is set to <TT><FONT FACE="Courier">undef</FONT></TT>.
<H2><A NAME="TheipcsCommand"><FONT SIZE=5 COLOR=#FF0000>The </FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">ipcs</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Command</FONT></A></H2>
<P>
After running the test script, you can see what the object created
looks like by using the <TT><FONT FACE="Courier">ipcs</FONT></TT>
command. The <TT><FONT FACE="Courier">ipcs</FONT></TT> command
lists the status of any Ipc objects in the system. Here is the
output from the <TT><FONT FACE="Courier">ipcs</FONT></TT> command
after creating the message queue.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">------ Shared Memory Segments --------
<BR>
shmid&nbsp;&nbsp;&nbsp;&nbsp; owner&nbsp;&nbsp;&nbsp;&nbsp; perms&nbsp;&nbsp;&nbsp;&nbsp;
bytes&nbsp;&nbsp;&nbsp;&nbsp; nattch&nbsp;&nbsp;&nbsp;&nbsp;status
<BR>
<BR>
------ Semaphore Arrays --------<BR>
semid&nbsp;&nbsp;&nbsp;&nbsp; owner&nbsp;&nbsp;&nbsp;&nbsp; perms&nbsp;&nbsp;&nbsp;&nbsp;
nsems&nbsp;&nbsp;&nbsp;&nbsp; status<BR>
<BR>
------ Message Queues --------<BR>
msqid&nbsp;&nbsp;&nbsp;&nbsp; owner&nbsp;&nbsp;&nbsp;&nbsp; perms&nbsp;&nbsp;&nbsp;&nbsp;
used-bytes&nbsp;&nbsp;messages<BR>
128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; khusain&nbsp;&nbsp;&nbsp;666&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0</FONT></TT>
</BLOCKQUOTE>
<P>
The output from the <TT><FONT FACE="Courier">ipcs</FONT></TT>
command on your machine may be different than the one shown here.
However, most of the information should be the same. For instance,
in this example one message queue is shown as being created. The
ID of this queue is <TT><FONT FACE="Courier">128</FONT></TT>;
it is owned by <TT><FONT FACE="Courier">khusain</FONT></TT> and
has permissions of <TT><FONT FACE="Courier">0666</FONT></TT>,
thereby allowing any process to manipulate it. The message queue
has no messages in it and is not using any memory for queuing
messages.
<H2><A NAME="ThemsgsndandmsgrcvFunctions"><FONT SIZE=5 COLOR=#FF0000>The
</FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">msgsnd()</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
and </FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">msgrcv()</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Functions</FONT></A></H2>
<P>
Use the <TT><FONT FACE="Courier">msgsnd()</FONT></TT> function
to send a message to a message queue. The syntax of the <TT><FONT FACE="Courier">msgsnd</FONT></TT>
function is this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$err  = msgsnd ($msgid, $message, $flags);</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$msgid</FONT></TT> is the message queue
ID returned by <TT><FONT FACE="Courier">msgget()</FONT></TT>;
<TT><FONT FACE="Courier">$message</FONT></TT> is the content of
what you are sending (the content does not have to be text). The
<TT><FONT FACE="Courier">$flags</FONT></TT> specifies options
to use when sending the message. The <TT><FONT FACE="Courier">msgsnd()</FONT></TT>
function returns a non-zero value if the <TT><FONT FACE="Courier">send</FONT></TT>
operation succeeds and <TT><FONT FACE="Courier">0</FONT></TT>
if an error occurs. You can check <TT><FONT FACE="Courier">$!</FONT></TT>
for the <TT><FONT FACE="Courier">errno</FONT></TT> code if you
get a value of <TT><FONT FACE="Courier">0</FONT></TT> back from
this call.
<P>
Call the <TT><FONT FACE="Courier">msgrcv()</FONT></TT> function
to read messages from a message queue. The syntax of the <TT><FONT FACE="Courier">msgrcv</FONT></TT>
function is this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$err = msgrcv ($msgid, $rcvd, $size,
$mesgtype, $flags);</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$msgid</FONT></TT> is the ID of the message
queue. <TT><FONT FACE="Courier">$rcvd</FONT></TT> is a scalar
variable in which the incoming data is stored. <TT><FONT FACE="Courier">$size</FONT></TT>
is set to the number of bytes of the incoming message plus the
size of the message type.
<P>
The message type is specified in <TT><FONT FACE="Courier">$mesgtype</FONT></TT>
by the caller. If <TT><FONT FACE="Courier">$mesgtype</FONT></TT>
is <TT><FONT FACE="Courier">0</FONT></TT>, any message on the
queue is pulled off. A positive non-zero value implies that the
first message of the type equal to the value in <TT><FONT FACE="Courier">$mesgtype</FONT></TT>
will be pulled. A negative non-zero value of <TT><FONT FACE="Courier">$mesgtype</FONT></TT>
requests to pull any message whose ID is greater than the absolute
value of <TT><FONT FACE="Courier">$mesgtype</FONT></TT>.
<P>
<TT><FONT FACE="Courier">$flags</FONT></TT> specifies options
that affect the message. If <TT><FONT FACE="Courier">&amp;Ipc_NOWAIT</FONT></TT>
is specified, the function returns immediately with the appropriate
error code. If the <TT><FONT FACE="Courier">&amp;Ipc_WAIT</FONT></TT>
flag is set, the function waits until there is a message on the
queue. The <TT><FONT FACE="Courier">msgrcv()</FONT></TT> function
returns a non-zero value if a message has arrived; otherwise it
returns <TT><FONT FACE="Courier">0</FONT></TT>. You can check<B>
</B><TT><FONT FACE="Courier">$!</FONT></TT> for the <TT><FONT FACE="Courier">errno</FONT></TT>
code if you get a value of <TT><FONT FACE="Courier">0</FONT></TT>
back from this call.
<P>
Let's see how to send a message. A message has a long integer
as the first four bytes followed by the body of the message. The
first bytes are used as identifiers for each message. It's up
to the receiver to know how many bytes to expect from the type
of the message. First, Listing 13.2 presents a script that creates
a message queue using a unique key and then sends a message on
it. 
<HR>
<BLOCKQUOTE>
<B>Listing 13.2. Creating a message queue and sending a message
on it.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/sys&quot;);
<BR>
&nbsp;3 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/linux&quot;);
<BR>
&nbsp;4 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/asm&quot;);
<BR>
&nbsp;5 require &quot;ipc.ph&quot;;
<BR>
&nbsp;6 require &quot;msg.ph&quot;;<BR>
&nbsp;7 $PERMISSIONS=0666;
<BR>
&nbsp;8 $ipckey = 42;<BR>
&nbsp;9 $msgid = msgget($ipckey,&amp;Ipc_CREAT
| $PERMISSIONS);<BR>
10 printf &quot;\n&nbsp;&nbsp;Message Id = $msgid \n&quot;;<BR>
11 $msg_type = 1;<BR>
12 $msg = pack(&quot;L a*&quot;, $msg_type, &quot;Elvis Lives!&quot;);
<BR>
13 msgsnd($msgid, &quot;$msg&quot;, &amp;Ipc_NOWAIT);</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Don't forget to replace lines 2 through 4 with your machine's
specific path!
<P>
Lines 5 and 6 include the header files for the message queue facility.
Line 7 sets the permissions to be globally vulnerable; that is,
anyone can attach to or even destroy an object created with these
permissions. The <TT><FONT FACE="Courier">$ipckey</FONT></TT>
value is set to <TT><FONT FACE="Courier">42</FONT></TT> because
it's a unique number. Had this value been left as <TT><FONT FACE="Courier">Ipc_PRIVATE</FONT></TT>,
a new message queue would be created every time this script is
run. Too many queues will eat up system resources, so use these
scripts judiciously.
<P>
The message itself is created in lines 11 and 12 using the <TT><FONT FACE="Courier">pack</FONT></TT>
statement. The <TT><FONT FACE="Courier">L</FONT></TT> parameter
to pack sets up the message type, and the <TT><FONT FACE="Courier">a*</FONT></TT>
parameter specifies a null-terminated string. The message will
be 12 bytes long, including the null terminator for the string,
but not including the four-byte message type.
<P>
Line 13 is where the message is actually sent. The <TT><FONT FACE="Courier">&amp;Ipc_NOWAIT</FONT></TT>
flag requests that the message returns immediately even if it
could not be sent. If you want to wait, use <TT><FONT FACE="Courier">&amp;Ipc_WAIT</FONT></TT>
instead. Be warned, however, that the script making the call is
suspended until the message is sent.
<P>
To see if the message made it to the message queue, check the
output from the <TT><FONT FACE="Courier">ipcs</FONT></TT> command:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">------ Shared Memory Segments --------
<BR>
shmid&nbsp;&nbsp;&nbsp;&nbsp; owner&nbsp;&nbsp;&nbsp;&nbsp; perms&nbsp;&nbsp;&nbsp;&nbsp;
bytes&nbsp;&nbsp;&nbsp;&nbsp; nattch&nbsp;&nbsp;&nbsp;&nbsp;status
<BR>
<BR>
------ Semaphore Arrays --------<BR>
semid&nbsp;&nbsp;&nbsp;&nbsp; owner&nbsp;&nbsp;&nbsp;&nbsp; perms&nbsp;&nbsp;&nbsp;&nbsp;
nsems&nbsp;&nbsp;&nbsp;&nbsp; status<BR>
<BR>
------ Message Queues --------<BR>
msqid&nbsp;&nbsp;&nbsp;&nbsp; owner&nbsp;&nbsp;&nbsp;&nbsp; perms&nbsp;&nbsp;&nbsp;&nbsp;
used-bytes&nbsp;&nbsp;messages<BR>
512&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; khusain&nbsp;&nbsp;&nbsp;666&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</FONT></TT>
</BLOCKQUOTE>
<P>
Note that there isn't a receiver to receive the message just yet.
If we do not create a receiving process, the messages in the queue
will just sit there until the queue is destroyed. Queues have
to be destroyed manually; the system will not destroy them for
you automatically.
<P>
There is one message with an ID of <TT><FONT FACE="Courier">512</FONT></TT>
and a length of 12 bytes in the queue. The message stays in the
queue until it's retrieved by something else. That something else
is the script shown in Listing 13.3.
<HR>
<BLOCKQUOTE>
<B>Listing 13.3. Receiving messages on the message queue.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/sys&quot;);
<BR>
&nbsp;3 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/linux&quot;);
<BR>
&nbsp;4 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/asm&quot;);
<BR>
&nbsp;5 require &quot;ipc.ph&quot;;
<BR>
&nbsp;6 require &quot;msg.ph&quot;;<BR>
&nbsp;7 $PERMISSIONS=0666;
<BR>
&nbsp;8 $ipckey = 42;<BR>
&nbsp;9 $msgid = msgget($ipckey,&amp;Ipc_CREAT
| $PERMISSIONS);<BR>
10 printf &quot;\n&nbsp;&nbsp;Message Id = $msgid&quot;;<BR>
11 $msg_type = 0;<BR>
12 #<BR>
13 # Keep in mind that the message packed was:<BR>
14 # $msg = pack(&quot;L a*&quot;, $msg_type, &quot;Elvis Lives!&quot;);
<BR>
15 msgrcv($msgid, $msg, 80, $mgt_type, 0);<BR>
16 printf &quot;\n Message Recvd = [%s]\n&quot;, $msg;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Again, don't forget to modify lines 2 through 4 for your machine.
Line 15 in Listing 13.3 is of importance to us. Note how the message
type is set to <TT><FONT FACE="Courier">0</FONT></TT>, even though
the message type sent was <TT><FONT FACE="Courier">1</FONT></TT>.
The message type in the <TT><FONT FACE="Courier">msgrcv()</FONT></TT>
function can take three sets of values:
<UL>
<LI><FONT COLOR=#000000>If the message type is zero (0), to pull
off the next available message on the queue.</FONT>
<LI><FONT COLOR=#000000>If the message type is greater than zero,
to pull off only messages of the type explicitly specified in
the message type.</FONT>
<LI><FONT COLOR=#000000>If the message type is less than zero,
the absolute value of the message type is used. The first message
type greater than or equal to this type of message will be pulled
off the message queue.</FONT>
</UL>
<P>
Run the receiver script. The message queue should be empty now.
Let's confirm that the message queue is empty by examining the
output of the <TT><FONT FACE="Courier">ipcs</FONT></TT> command.
In the following output, look at the information for the message
queues. You should see zero for the number of  messages and zero
bytes by the queue.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">------ Shared Memory Segments --------
<BR>
shmid&nbsp;&nbsp;&nbsp;&nbsp; owner&nbsp;&nbsp;&nbsp;&nbsp; perms&nbsp;&nbsp;&nbsp;&nbsp;
bytes&nbsp;&nbsp;&nbsp;&nbsp; nattch&nbsp;&nbsp;&nbsp;&nbsp;status
<BR>
<BR>
------ Semaphore Arrays --------<BR>
semid&nbsp;&nbsp;&nbsp;&nbsp; owner&nbsp;&nbsp;&nbsp;&nbsp; perms&nbsp;&nbsp;&nbsp;&nbsp;
nsems&nbsp;&nbsp;&nbsp;&nbsp; status<BR>
<BR>
------ Message Queues --------<BR>
msqid&nbsp;&nbsp;&nbsp;&nbsp; owner&nbsp;&nbsp;&nbsp;&nbsp; perms&nbsp;&nbsp;&nbsp;&nbsp;
used-bytes&nbsp;&nbsp;messages<BR>
512&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; khusain&nbsp;&nbsp;&nbsp;666&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0</FONT></TT>
</BLOCKQUOTE>
<P>
It's not a good idea to leave Ipc objects around in the system.
The <TT><FONT FACE="Courier">msgctl()</FONT></TT> function is
used to set options for message queues and send commands that
affect them. Generally, this function is used to delete message
queues. Here's the syntax of the <TT><FONT FACE="Courier">msgctl</FONT></TT>
function:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$err =msgctl ($msgid, $msgcmd, $msgarg);</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$msgid</FONT></TT> is the message queue
ID. The argument <TT><FONT FACE="Courier">$msgcmd</FONT></TT>
is the command to be sent to the message queue. The list of available
commands is defined in the file <TT><FONT FACE="Courier">ipc.ph</FONT></TT>.
Some of the commands that can be specified by <TT><FONT FACE="Courier">msgcmd</FONT></TT>
set the values of message queue options. If one of these commands
is specified, the new value of the option is specified in <TT><FONT FACE="Courier">msgarg</FONT></TT>.
If an error occurs, <TT><FONT FACE="Courier">msgctl</FONT></TT>
returns the undefined value. <TT><FONT FACE="Courier">msgctl()</FONT></TT>
also can return <TT><FONT FACE="Courier">0</FONT></TT> or a non-zero
value and will set <TT><FONT FACE="Courier">errno</FONT></TT>
in <TT><FONT FACE="Courier">$!</FONT></TT>.
<P>
To delete a queue, use the following command:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$ret = msgctl($msgid, &amp;Ipc_RMID,
$NULL);</FONT></TT>
</BLOCKQUOTE>
<P>
The value of the returned parameter will be <TT><FONT FACE="Courier">-1</FONT></TT>
if there is an error; otherwise, the value is <TT><FONT FACE="Courier">0</FONT></TT>.
Sometimes the message queue can be deleted in a signal handler,
like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub cleanup {<BR>
&nbsp;&nbsp;&nbsp;&nbsp; local($signalName) = @_;<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">
print &quot;\n Caught signal, removing message queue&quot;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp; $ret= msgctl($msgid,&amp;Ipc_RMID,$NULL)
;<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">
print &quot;\n System returned $ret from kill message queue&quot;;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp; exit(0);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="SharedMemory"><FONT SIZE=5 COLOR=#FF0000>Shared Memory</FONT></A>
</H2>
<P>
Message queues are great for sending messages in a LIFO order.
The major problem with message queues is that they can overflow
if no one is there to receive the messages. 
<P>
Shared memory areas have to be explicitly created before you can
use them. To do this, call the <TT><FONT FACE="Courier">shmget</FONT></TT>
function with a key as you did with message queues. Here's the
syntax of the <TT><FONT FACE="Courier">shmget</FONT></TT> function:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$shmid = shmget (<I>key, msize, flag</I>);</FONT></TT>
</BLOCKQUOTE>
<P>
As with message queues, <TT><FONT FACE="Courier">$key</FONT></TT>
is either <TT><FONT FACE="Courier">&amp;Ipc_PRIVATE</FONT></TT>
or an arbitrary constant. If the key is <TT><FONT FACE="Courier">&amp;Ipc_PRIVATE</FONT></TT>
or the flag has <TT><FONT FACE="Courier">&amp;Ipc_CREAT</FONT></TT>
set, the shared memory segment is created, and its ID is returned
in <TT><FONT FACE="Courier">$shmid</FONT></TT>. The <TT><FONT FACE="Courier">msize</FONT></TT>
is the size of the created shared memory in bytes. If <TT><FONT FACE="Courier">shmget()</FONT></TT>
cannot create the shared memory area, the returned value in  <TT><FONT FACE="Courier">$shmid</FONT></TT>
is set to <TT><FONT FACE="Courier">undef</FONT></TT>. The <TT><FONT FACE="Courier">$flags</FONT></TT>
are the same as with message queues.
<P>
Here are the actions you can perform on a shared memory segment:
<UL>
<LI><FONT COLOR=#000000>Write to it with the </FONT><TT><FONT FACE="Courier">shmwrite()</FONT></TT>
function
<LI><FONT COLOR=#000000>Read from it with the </FONT><TT><FONT FACE="Courier">shmread()</FONT></TT>
function
<LI><FONT COLOR=#000000>Delete or modify its parameters with the
</FONT><TT><FONT FACE="Courier">shmctl()</FONT></TT> function
</UL>
<H3><A NAME="TheshmwriteandshmreadFunctions">The <TT><FONT SIZE=4 FACE="Courier">shmwrite()</FONT></TT><FONT SIZE=4>
and </FONT><TT><FONT SIZE=4 FACE="Courier">shmread()</FONT></TT><FONT SIZE=4>
Functions</FONT></A></H3>
<P>
To write data to an area of shared memory, call the <TT><FONT FACE="Courier">shmwrite()</FONT></TT>
function. Here's the syntax of the <TT><FONT FACE="Courier">shmwrite</FONT></TT>
function:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">shmwrite ($shmid, $text, $pos, $size);</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$shmid</FONT></TT> is the shared memory
ID returned by <TT><FONT FACE="Courier">shmget</FONT></TT>. <TT><FONT FACE="Courier">$text</FONT></TT>
is the character string to write to the shared memory, <TT><FONT FACE="Courier">$pos</FONT></TT>
is the number of bytes to skip over in the shared memory before
writing to it, and <TT><FONT FACE="Courier">$size</FONT></TT>
is the number of bytes to write.
<P>
This function returns a value that is the number of bytes actually
written or, in the case of an error, a value of <TT><FONT FACE="Courier">0</FONT></TT>.
<P>
If the data specified by <TT><FONT FACE="Courier">$text</FONT></TT>
is longer than the value specified by size, only the first <TT><FONT FACE="Courier">$size</FONT></TT>
bytes of text are written to the shared memory. If the data specified
by <TT><FONT FACE="Courier">$text</FONT></TT> is shorter than
the value specified by <TT><FONT FACE="Courier">$size</FONT></TT>,
<TT><FONT FACE="Courier">shmwrite</FONT></TT> generally will fill
the leftover space with null characters. An error also occurs
if you attempt to write too many bytes to the shared memory area
(that is, if the value of <TT><FONT FACE="Courier">$pos</FONT></TT>
plus <TT><FONT FACE="Courier">$size</FONT></TT> is greater than
the number of bytes in the shared memory segment).
<P>
To read data from a segment of shared memory, call the <TT><FONT FACE="Courier">shmread</FONT></TT>
function. Here's the syntax of the <TT><FONT FACE="Courier">shmread</FONT></TT>
function:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">shmread ($shmid, $retval, $pos, $size);</FONT></TT>
</BLOCKQUOTE>
<P>
Here, <TT><FONT FACE="Courier">$shmid</FONT></TT> is the shared
memory ID returned by <TT><FONT FACE="Courier">shmget</FONT></TT>.
The <TT><FONT FACE="Courier">$retval</FONT></TT> variable is a
scalar variable (or array element) in which the returned data
is to be stored. The data is read from <TT><FONT FACE="Courier">$pos</FONT></TT>
number of bytes from the start of the shared memory segment, and
<TT><FONT FACE="Courier">$size</FONT></TT> is the number of bytes
to copy. This function returns a non-zero value if the read operation
succeeds, or it returns <TT><FONT FACE="Courier">0</FONT></TT>
in the case of an error.
<P>
Only the number of bytes requested are returned in <TT><FONT FACE="Courier">$retval</FONT></TT>.
An error occurs if you attempt to read too many bytes from the
shared memory area. In other words, if the value of <TT><FONT FACE="Courier">$pos</FONT></TT>
plus <TT><FONT FACE="Courier">$size</FONT></TT> is greater than
the number of bytes in the shared memory segment, you'll get an
error. On errors, the values in the <TT><FONT FACE="Courier">$retval</FONT></TT>
scalar are undefined.
<P>
See Listing 13.4 for a simple Perl script that creates a memory
segment and then puts some data in it.
<HR>
<BLOCKQUOTE>
<B>Listing 13.4. The use of </B><TT><B><FONT FACE="Courier">shmget()</FONT></B></TT><B>
and </B><TT><B><FONT FACE="Courier">shmwrite()</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 <BR>
&nbsp;3 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/sys&quot;);
<BR>
&nbsp;4 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/linux&quot;);
<BR>
&nbsp;5 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/asm&quot;);
<BR>
&nbsp;6 <BR>
&nbsp;7 require &quot;ipc.ph&quot;;
<BR>
&nbsp;8 require &quot;shm.ph&quot;;<BR>
&nbsp;9 <BR>
10 $PERMISSIONS=0666;<BR>
11 $ipckey = 42;<BR>
12 $size = 1024;<BR>
13 <BR>
14 $msgid = shmget($ipckey, $size, &amp;Ipc_CREAT | $PERMISSIONS);
<BR>
15 <BR>
16 printf &quot;\n Shared Memory Id = $msgid&quot;;<BR>
17 <BR>
18 $message = &quot;Segment #1&quot;;<BR>
19 print &quot;\n Message = &quot; . $message;<BR>
20 <BR>
21 shmwrite($msgid, $message, 0, 80);</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Note that in Listing 13.5, the shared memory segment is 1,024
bytes long. The shared memory segment is not automatically destroyed
when the creating process is killed. The values and space for
these values in the shared memory area remain there even after
the process that created the segment is long gone.
<P>
A second application can now come in and read from the shared
memory segment. This second application is shown in Listing 13.5.
<HR>
<BLOCKQUOTE>
<B>Listing 13.5. The use of </B><TT><B><FONT FACE="Courier">shmread()</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 <BR>
&nbsp;3 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/sys&quot;);
<BR>
&nbsp;4 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/linux&quot;);
<BR>
&nbsp;5 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/asm&quot;);
<BR>
&nbsp;6 <BR>
&nbsp;7 require &quot;ipc.ph&quot;;
<BR>
&nbsp;8 require &quot;shm.ph&quot;;<BR>
&nbsp;9 <BR>
10 $PERMISSIONS=0666;<BR>
11 $ipckey = 42;<BR>
12 $size = 1024;<BR>
13 <BR>
14 $msgid = shmget($ipckey, $size, &amp;Ipc_CREAT | $PERMISSIONS);
<BR>
15 <BR>
16 printf &quot;\n Shared Memory Id = $msgid&quot;;<BR>
17 <BR>
18 $retval = shmread($msgid, $message, 0, 80);<BR>
19 <BR>
20 print &quot;\n Read data:&quot;. $message. &quot;ret value=
$retval&quot; ;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
This little example brings up a very possible and potentially
dangerous scenario concerning the use of shared memory to pass
data between two applications. Take two processes, A and B, which
share data through shared memory. What if process A is in the
middle of writing some data that B is reading? There is a high
probability that the data read by B could be mangled by A. There
is nothing that prevents B from reading from the same offset to
which A is writing.
<P>
To prevent such potentially erroneous read/write situations, you
have to lock the resource from multiple use. This is where semaphores
come into play. A semaphore allows multiple processes to synchronize
access on a resource.
<H2><A NAME="Semaphores"><FONT SIZE=5 COLOR=#FF0000>Semaphores</FONT></A>
</H2>
<P>
A semaphore is simply a counter in the kernel. It can have values
of <TT><FONT FACE="Courier">0</FONT></TT>, <TT><FONT FACE="Courier">-1</FONT></TT>,
<TT><FONT FACE="Courier">-2</FONT></TT>, and so on, depending
on how many processes are using it. A value of <TT><FONT FACE="Courier">0</FONT></TT>
indicates that the resource is unavailable. When a resource is
locked by a process, the value of the semaphore is decremented.
When the resource is freed, the value of the semaphore is incremented.
A semaphore value of less than <TT><FONT FACE="Courier">0</FONT></TT>
indicates that the process must block (that is, wait until some
other process zeroes it).
<P>
A semaphore is a data structure in the kernel that contains the
process ID of the last process to perform a semaphore operation
and the number of processes waiting on the semaphore to be <TT><FONT FACE="Courier">0</FONT></TT>.
A binary semaphore uses a value of either <TT><FONT FACE="Courier">1</FONT></TT>
or <TT><FONT FACE="Courier">0</FONT></TT>.
<P>
To use a semaphore, you must first create it. To do this, call
the <TT><FONT FACE="Courier">semget</FONT></TT> function. Here's
the syntax of the <TT><FONT FACE="Courier">semget</FONT></TT>
function:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$semid = semget ($key, $num, $flag);</FONT></TT>
</BLOCKQUOTE>
<P>
The key and flag here are the same as those for shared memory
or message queues. If the key is <TT><FONT FACE="Courier">&amp;Ipc_PRIVATE</FONT></TT>
or the flag has <TT><FONT FACE="Courier">&amp;Ipc_CREAT</FONT></TT>
set, the semaphore is created and its ID is returned in <TT><FONT FACE="Courier">semid</FONT></TT>.
The <TT><FONT FACE="Courier">$num</FONT></TT> variable is the
number of semaphores created and is an index into an array of
semaphores. The first element of the array is at index <TT><FONT FACE="Courier">0</FONT></TT>.
<P>
If <TT><FONT FACE="Courier">semget</FONT></TT> is unable to create
the semaphore, <TT><FONT FACE="Courier">$semid</FONT></TT> is
set to the null string.
<P>
To perform a semaphore operation, call the <TT><FONT FACE="Courier">semop()</FONT></TT>
function. Here's the syntax of the <TT><FONT FACE="Courier">semop()</FONT></TT>
function:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">semop ($semid, $semstructs);</FONT></TT>
</BLOCKQUOTE>
<P>
Here, <TT><FONT FACE="Courier">$semid</FONT></TT> is the semaphore
ID returned by <TT><FONT FACE="Courier">semget</FONT></TT>, and
<TT><FONT FACE="Courier">$semstructs</FONT></TT> is a character
string consisting of an array of semaphore structures.
<P>
Each semaphore structure consists of the following components,
each of which is a short integer (as created by the <TT><FONT FACE="Courier">s</FONT></TT>
format character in <TT><FONT FACE="Courier">pack</FONT></TT>):
<UL>
<LI><FONT COLOR=#000000>The number of semaphores</FONT>
<LI><FONT COLOR=#000000>The semaphore operation</FONT>
<LI><FONT COLOR=#000000>The semaphore flags, if any</FONT>
</UL>
<P>
This function returns a non-zero value if the semaphore operation
is successful; otherwise, <TT><FONT FACE="Courier">0</FONT></TT>
if an error occurs.
<P>
There are three actions you can take with a semaphore. Each of
these actions happens on the elements of the array you created
in the <TT><FONT FACE="Courier">semget()</FONT></TT> function.
These actions add or subtract a value to the semaphore:
<UL>
<LI><FONT COLOR=#000000>Adjust the value </FONT>by adding <TT><FONT FACE="Courier">0</FONT></TT>
to the semaphore. This action causes the resource controlled by
the semaphore to be acquired.
<LI><FONT COLOR=#000000>Increment the value of the semaphore.
This causes the resource to be marked as &quot;released.&quot;
The calling process can now wait until the value is </FONT><TT><FONT FACE="Courier">0</FONT></TT>
again. Generally, you would increment by <TT><FONT FACE="Courier">1</FONT></TT>,
but you can use an arbitrary positive constant.
<LI><FONT COLOR=#000000>Decrement the value of the semaphore.
A decrement marks the use of a resource. This decrement may cause
the value of the semaphore to be less than </FONT><TT><FONT FACE="Courier">0</FONT></TT>.
If the value of the semaphore is less than <TT><FONT FACE="Courier">0</FONT></TT>,
the calling process will block until some other process that is
using or controlling the resource resets the value to <TT><FONT FACE="Courier">0</FONT></TT>.
</UL>
<P>
The <TT><FONT FACE="Courier">semctl</FONT></TT> function enables
you to set options for semaphores and issue commands that affect
them. Here's the syntax of the <TT><FONT FACE="Courier">semctl</FONT></TT>
function:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$err = semctl ($semid, $semcmd, $semarg);</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$semid</FONT></TT> is the semaphore ID
returned by <TT><FONT FACE="Courier">semget</FONT></TT>. <TT><FONT FACE="Courier">$semcmd</FONT></TT>
is the command that affects the semaphore; the list of available
commands includes the <TT><FONT FACE="Courier">Ipc_RMID</FONT></TT>
for removing the resource. Check the <TT><FONT FACE="Courier">ipc.ph</FONT></TT>
file for more commands on your system. Some of the commands that
can be specified by <TT><FONT FACE="Courier">semcmd</FONT></TT>
set the values of semaphore options. If one of these commands
is specified, the new value of the option is specified in <TT><FONT FACE="Courier">$semarg</FONT></TT>.
<P>
If an error occurs, <TT><FONT FACE="Courier">semctl</FONT></TT>
returns the undefined value; otherwise, it returns <TT><FONT FACE="Courier">0</FONT></TT>.
<P>
Listing 13.6 shows an example of a parent and child process sharing
a shared memory resource using semaphores.
<HR>
<BLOCKQUOTE>
<B>Listing 13.6. Using semaphores and shared memory together.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 $|=1;<BR>
&nbsp;3 #<BR>
&nbsp;4 #&nbsp;&nbsp;Get the required files.<BR>
&nbsp;5 #<BR>
&nbsp;6 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/sys&quot;);
<BR>
&nbsp;7 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/linux&quot;);
<BR>
&nbsp;8 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/asm&quot;);
<BR>
&nbsp;9 require &quot;ipc.ph&quot;;
<BR>
10 require &quot;shm.ph&quot;;<BR>
11 require &quot;sem.ph&quot;;<BR>
12 #<BR>
13 # Identify yourself and the resource parameters.<BR>
14 #<BR>
15 $ppid = $$;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
for the parent<BR>
16 $ipckey = 34;<BR>
17 $PERMISSIONS=0666;<BR>
18 $semid = semget($ipckey,1,&amp;Ipc_CREAT|$PERMISSIONS);<BR>
19 $semnum = 0;<BR>
20 $semflags = 0;<BR>
21 #<BR>
22 # Now create the shared memory segment. Note that we use the
same key.<BR>
23 #<BR>
24 $size = 1024;<BR>
25 $msgid = shmget($ipckey, $size, &amp;Ipc_CREAT | $PERMISSIONS);
<BR>
26 # printf &quot;\n Shared Memory Id = $msgid&quot;;<BR>
27 $pid = fork;<BR>
28 if ($pid == -1) {<BR>
29&nbsp;&nbsp;&nbsp;&nbsp; die &quot;\nFork failed. This is not
UNIX&quot;;<BR>
30 }<BR>
31 if ($pid)&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;# child process
<BR>
32&nbsp;&nbsp;&nbsp;&nbsp; for ($i=0;$i&lt;10;$i++) {<BR>
33&nbsp;&nbsp;&nbsp;&nbsp; $semop = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
Wait for resource<BR>
34&nbsp;&nbsp;&nbsp;&nbsp; $semopstr = pack(&quot;sss&quot;,$semnum,$semop,$semflags);
<BR>
35&nbsp;&nbsp;&nbsp;&nbsp; die &quot;Cannot get semaphore&quot;
unless semop($semid,$semopstr);<BR>
36&nbsp;&nbsp;&nbsp;&nbsp; #<BR>
37&nbsp;&nbsp;&nbsp;&nbsp; #<BR>
38&nbsp;&nbsp;&nbsp;&nbsp; printf &quot;\n Child: read from shared
memory &quot;;<BR>
39&nbsp;&nbsp;&nbsp;&nbsp; $retval = shmread($msgid, $message,
0, 80);<BR>
40<BR>
41&nbsp;&nbsp;&nbsp;&nbsp; $semop = 2;<BR>
42&nbsp;&nbsp;&nbsp;&nbsp; $semopstr = pack(&quot;sss&quot;,$semnum,$semop,$semflags);
<BR>
43&nbsp;&nbsp;&nbsp;&nbsp; die &quot;Cannot get semaphore&quot;
unless semop($semid,$semopstr);<BR>
44&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
45 }<BR>
46 else { # in parent<BR>
47&nbsp;&nbsp;&nbsp;&nbsp; for ($i=0;$i&lt;10;$i++) {<BR>
48&nbsp;&nbsp;&nbsp;&nbsp; $semop = -1;<BR>
49&nbsp;&nbsp;&nbsp;&nbsp; $semopstr = pack(&quot;sss&quot;,$semnum,$semop,$semflags);
<BR>
50&nbsp;&nbsp;&nbsp;&nbsp; die &quot;Cannot get semaphore&quot;
unless semop($semid,$semopstr);<BR>
51&nbsp;&nbsp;&nbsp;&nbsp; printf &quot;\n Parent: write to shared
memory&quot;;<BR>
52&nbsp;&nbsp;&nbsp;&nbsp; shmwrite($msgid, $message, 0, 80);
<BR>
53<BR>
54&nbsp;&nbsp;&nbsp;&nbsp; $semop = -1;<BR>
55&nbsp;&nbsp;&nbsp;&nbsp; $semopstr = pack(&quot;sss&quot;,$semnum,$semop,$semflags);
<BR>
56&nbsp;&nbsp;&nbsp;&nbsp; die &quot;Cannot get semaphore&quot;
unless semop($semid,$semopstr);<BR>
57&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
58&nbsp;&nbsp;&nbsp;&nbsp; printf &quot;\n In parent, removing
the semaphore&quot;;<BR>
59&nbsp;&nbsp;&nbsp;&nbsp; semctl($semid,0,&amp;Ipc_RMID,0);<BR>
60&nbsp;&nbsp;&nbsp;&nbsp; printf &quot;\n In parent, removing
the shared memory segment&quot;;<BR>
61&nbsp;&nbsp;&nbsp;&nbsp; shmctl($msgid,&amp;Ipc_RMID,0);<BR>
62 }</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Line 2 specifies that the buffers be flushed immediately on write.
This is a good idea when you are working with forked processes.
<P>
Lines 5 through 11 set up the include paths for the required header
files. In lines 15 through 20 the semaphore is set up and created
for parent and child processes to use. In line 24 the shared memory
segment is created.
<P>
The process forks off into two processes in line 27. The child
process waits for the semaphore by first explicitly setting the
local counter to <TT><FONT FACE="Courier">0</FONT></TT> (see line
33). Then it checks for the value of the semaphore in line 35
after packing the parameters into the semaphore structure in line
34. When it breaks out of the semaphore (that is, when the value
of the semaphore is <TT><FONT FACE="Courier">0</FONT></TT>), the
child reads data from the shared memory segment. It then sets
the value of the semaphore to <TT><FONT FACE="Courier">2</FONT></TT>.
<P>
The parent, on the other hand, decrements the semaphore by <TT><FONT FACE="Courier">1</FONT></TT>.
The value is <TT><FONT FACE="Courier">2</FONT></TT> if the child
runs first, and thus becomes <TT><FONT FACE="Courier">1</FONT></TT>,
giving the parent control. If the child is running and adding
to shared memory, then the value of the semaphore is <TT><FONT FACE="Courier">0</FONT></TT>;
therefore, decrementing by the parent forces it to <TT><FONT FACE="Courier">-1</FONT></TT>,
thus blocking the parent. Now, when the child increments by <TT><FONT FACE="Courier">2</FONT></TT>,
the semaphore is set to <TT><FONT FACE="Courier">1 (-1 + 2 = 1)</FONT></TT>
and the parent is started. The child then waits until the semaphore
becomes <TT><FONT FACE="Courier">0</FONT></TT>, which happens
when the parent decrements the semaphore one more time.
<P>
The <TT><FONT FACE="Courier">shmctl</FONT></TT> and <TT><FONT FACE="Courier">semctl</FONT></TT>
functions are used to obliterate the Ipc resources once you are
done with the application.
<H2><A NAME="TheSysVIpcModule"><FONT SIZE=5 COLOR=#FF0000>The
</FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">SysV::Ipc</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Module</FONT></A></H2>
<P>
The SysV Ipc code in Listing 13.6 was written long ago and has
been documented to death in almost all UNIX texts. Some kind folks
have tried to make the interface easier to use by providing modules
to make the interface cleaner. For the latest version of this
module, please check the CPAN sites listed in appendix B, &quot;Perl
Module Archives.&quot;
<P>
It looks simple enough already, but it can always be tweaked a
little bit more. Check out the <TT><FONT FACE="Courier">Ipc::SysV</FONT></TT>
modules written by Jack Shirazi. Unfortunately, I could not get
this module to compile and work for Perl 5.002. There was not
any documentation or follow up address for me to get more information
about the module. You can try to get it to work on your system,
but with the application interface the way it is now, you should
ask yourself this question: Will the module make it simpler? If
the answer is yes, by all means go for it!
<H2><A NAME="ApplicationsofIpc"><FONT SIZE=5 COLOR=#FF0000>Applications
of Ipc</FONT></A></H2>
<P>
There are several ways that you can apply the Ipc tools you have
available. Generally, shared memory and semaphores have to be
used together. When working with large blocks of data, use shared
memory to pass the data between two processes. Synchronize the
transfer between processes via the use of a semaphore.
<P>
What if you have a situation in which more than one process is
required to process the data? Semaphores can get clunky at this
stage if you are not careful.
<P>
In a typical scenario, you could have one process collect data
from external devices and then have the data available in shared
memory for all other processes. The shared memory area will be
divided into partitions. Each partition is used only by one process
and only written to by the data collector. The data collector
updates all the sections of shared memory and then updates a semaphore
with the number of processes that are currently waiting to work
with this data. Then it sends a message to each of the processes
via a message queue. After sending all the messages, the data
collector process waits for the semaphore to be <TT><FONT FACE="Courier">0</FONT></TT>
again, thereby getting the signal to proceed.
<P>
Each data-handling process (client) can wait for messages forever
on its message queue. As soon as it receives a message on its
queue, the client can guarantee that it will have exclusive access
to its partition. After it has processed the data, the client
can decrement the semaphore. As each client increments the semaphore,
it will go back to the top of the loop and wait on the input message
queue again.
<P>
Once all the clients have incremented the semaphore, it becomes
<TT><FONT FACE="Courier">0</FONT></TT> again. This causes the
data collector to wake up and begin the process of collecting
and updating the shared memory area.
<P>
Listings 13.7 and 13.8 show a partial application for such a system.
These listings are by no means complete because this would require
a full-blown application well beyond the scope of this chapter.
The gist of the program is to illustrate how all three types of
Ipc objects can be used with each other to create relatively complex
applications.
<P>
The server application decrements the semaphore to block (while
the clients do what they have to do) and then increments the value
of the semaphore. The processes here have to run concurrently
in the background. There are three clients for the one server.
Obviously, this example is contrived for the book-you might have
more clients to handle your tasks.
<HR>
<BLOCKQUOTE>
<B>Listing 13.7. The server of a dummy application.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/sys&quot;);
<BR>
&nbsp;3 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/linux&quot;);
<BR>
&nbsp;4 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/asm&quot;);
<BR>
&nbsp;5 require &quot;ipc.ph&quot;;
<BR>
&nbsp;6 require &quot;shm.ph&quot;;<BR>
&nbsp;7 $PERMISSIONS=0666;
<BR>
&nbsp;8 $ipckey = 42;<BR>
&nbsp;9 $size = 4096;<BR>
10 #<BR>
11 # Create the shared memory segment<BR>
12 #<BR>
13 $| = 1;<BR>
14 @messages =&nbsp;&nbsp;(<BR>
15&nbsp;&nbsp;&nbsp;&nbsp; &quot;Process 0 &quot;,<BR>
16&nbsp;&nbsp;&nbsp;&nbsp; 'Process 1 ',<BR>
17&nbsp;&nbsp;&nbsp;&nbsp; 'Process 2 ',<BR>
18 );<BR>
19 $shmid = shmget($ipckey, $size, &amp;Ipc_CREAT | $PERMISSIONS);
<BR>
20 $count = $#messages + 1;<BR>
21 $semid = semget($ipckey,$count,&amp;Ipc_CREAT|$PERMISSIONS);
<BR>
22 $semflags = 0;<BR>
23 for ($offset = 0; $offset &lt; $count; $offset++) {<BR>
24&nbsp;&nbsp;&nbsp;&nbsp; $msg = $messages[$offset];<BR>
25&nbsp;&nbsp;&nbsp;&nbsp; $msgid[$offset] = msgget($ipckey <BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">$offset,&amp;Ipc_CREAT
| $PERMISSIONS);<BR>
26&nbsp;&nbsp;&nbsp;&nbsp; print &quot;\n Server: Creating Message
Queue: &quot;<BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">.
$msgid[$offset] . &quot;\n&quot;;<BR>
27&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
28 printf &quot;\n Shared Memory Created Id = $shmid&quot;;<BR>
29 while(1)<BR>
30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$semop = $count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
Stop the clients<BR>
32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$semopstr = pack(&quot;sss&quot;,$semnum,$semop,$semflags);
<BR>
33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;die &quot;Cannot get semaphore&quot;
unless semop($semid,$semopstr);<BR>
34<BR>
35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ($offset = 0; $offset
&lt; $count; $offset++) {<BR>
36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
$semnum = $offset;<BR>
37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
$msg = $messages[$offset];<BR>
38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
print &quot;\n Server: Writing &quot; . $msg . <BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">&quot;
at &quot; . $offset * 40 . &quot;\n&quot;;<BR>
39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
shmwrite($shmid, $msg, $offset * 40, 12);<BR>
40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
$msg = pack(&quot;L a*&quot;, $offset + 1, &quot; Go for it!&quot;);
<BR>
41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
print &quot;\n Server: Sending to&quot; . $msgid[$offset] . &quot;\n&quot;;
<BR>
42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
msgsnd($msgid[$offset], &quot;$msg&quot;, &amp;Ipc_NOWAIT);<BR>
43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$semop = -$count;&nbsp;&nbsp;&nbsp;&nbsp;
# Block till semaphore is 0<BR>
45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$semopstr = pack(&quot;sss&quot;,$semnum,$semop,$semflags);
<BR>
46&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;die &quot;Cannot get semaphore
to wait&quot; unless semop($semid,$semopstr);<BR>
47&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(10);<BR>
48 }</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Listing 13.8 is the client application to pick up the messages
from the server. The messages sent can contain additional information
for the client; that is, they don't have to be just triggers for
the client to proceed with reading. The contents of the messages
can contain information about how and where to pick up data from
shared memory.
<HR>
<BLOCKQUOTE>
<B>Listing 13.8. The client of a dummy application.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 #<BR>
&nbsp;3 # Usage =&nbsp;&nbsp;client
-p ProcessIndex<BR>
&nbsp;4 #<BR>
&nbsp;5 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/sys&quot;);
<BR>
&nbsp;6 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/linux&quot;);
<BR>
&nbsp;7 unshift (@Inc,&quot;/usr/lib/perl5/i486-linux/5.002/asm&quot;);
<BR>
&nbsp;8 use Getopt::Long;<BR>
&nbsp;9 $result = GetOptions
('p=i');<BR>
10 $| = 1;<BR>
11 if (($opt_p &lt; 0) || ($opt_p &gt; 3)) {<BR>
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;die &quot;Usage: $0 -p ProcessIndex&quot;;
<BR>
13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(0);<BR>
14 }<BR>
15 require &quot;ipc.ph&quot;;<BR>
16 require &quot;shm.ph&quot;;<BR>
17 require &quot;msg.ph&quot;;<BR>
18 require &quot;sem.ph&quot;;<BR>
19 $PERMISSIONS=0666;<BR>
20 $msg_type = 0;<BR>
21 $msg_offset = $opt_p * 40;<BR>
22 $ipckey = 42;<BR>
23 $msg_key = $ipckey +&nbsp;&nbsp;$opt_p;<BR>
24 $size = 0;<BR>
25 $shmid = shmget($ipckey, $size, &amp;Ipc_CREAT | $PERMISSIONS);
<BR>
26 printf &quot;\n $$ = Shared Memory Id = $shmid&quot;;<BR>
27 $msgid = msgget($msg_key,&amp;Ipc_CREAT | $PERMISSIONS);<BR>
28 printf &quot;\n $$ =&nbsp;&nbsp;Message Id <BR>
</FONT></TT>&nbsp;&nbsp;&nbsp;<TT><FONT FACE="Courier">=
$msgid, Will read from $msg_offset, $msg_type\n&quot;;<BR>
29 $semid = semget($ipckey,3,&amp;Ipc_CREAT|$PERMISSIONS);<BR>
30 $semnum = 0;<BR>
31 $semflags = 0;<BR>
32 while (1)<BR>
33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n Read message
of type :&quot;. $msg_type;<BR>
35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msgrcv($msgid, $msg, 80,
$msg_type, 0);<BR>
36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$retval = shmread($msgid,
$message, 0, 80);<BR>
37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n Read message:&quot;.
$message. &quot;ret value= $retval&quot; ;<BR>
38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$semop = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
Clear yourself for server<BR>
39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$semopstr = pack(&quot;sss&quot;,$semnum,$semop,$semflags);
<BR>
40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;die &quot;Cannot get semaphore&quot;
unless semop($semid,$semopstr);<BR>
41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n After semaphore&quot;;
<BR>
42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The sample programs shown in Listings 13.7 and 13.8 provided the
basis for a prototype of a seismic data collection system. The
actual system was written in C for efficiency because of some
pretty lengthy mathematical calculations. However, with Perl,
we were able to use this code to get a proof-of-concept working
model up and running in just one afternoon. The prototype provided
us with enough information to consider using the Ipc model for
the application. In later models of the same application, I was
able to extend the processing to remote machines by replacing
the message queues with sockets and sending the requisite portions
of data along the sockets.
<P>
The final application was tested further by adding new Perl scripts
that share messages and simulate data using shared memory. Listings
13.7 and 13.8 are very similar to the working application and
have been created from scratch. It should be relatively painless
for you to take this code and extend it into your own prototype.
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
Perl is a very powerful tool for prototyping applications. With
the capability to access the system facilities, Perl can provide
the necessary tools for rapid prototyping. Hopefully, this chapter
has provided you with enough information to set up your own applications.
<P>
This chapter has introduced you to the System V Ipc facilities
available through Perl. The Ipc objects are global and remain
in memory long after the processes that created them are gone.
With Ipc objects, you are limited to one machine. If your application
requires network access, consider using sockets instead.
<P>
Using message queues, you can send messages between processes.
For large data items, message queues might not be very efficient.
Consider using shared memory instead. To synchronize the access
to the shared memory, you can use semaphores to prevent one process
from writing to an area where another process might be reading.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch12.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch12.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch14.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch14.htm"><IMG 
SRC="nc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>
