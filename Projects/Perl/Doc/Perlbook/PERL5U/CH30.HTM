<HTML>

<HEAD>
   <TITLE>Chapter 30 -- Using the Perl Debugger</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT COLOR=#FF0000>Chapter 30</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Using the Perl Debugger</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#ASampleSession" >A Sample Session</A>
<LI><A HREF="#SteppingThroughCode" >Stepping Through Code</A>
<LI><A HREF="#LookingatValues" >Looking at Values</A>
<LI><A HREF="#Breakpoints" >Breakpoints</A>
<LI><A HREF="#Actions" >Actions</A>
<LI><A HREF="#SearchingforPatterns" >Searching for Patterns</A>
<LI><A HREF="#Subroutines" >Subroutines</A>
<LI><A HREF="#Caveats" >Caveats</A>
<LI><A HREF="#CustomizingYourDebuggerEnvironment" >Customizing Your Debugger Environment</A>
<LI><A HREF="#ForMoreInformation" >For More Information</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
This chapter introduces you to the internal Perl debugger. Perl
has modules with debugging facilities to help you catch bugs in
your Perl scripts. The use of the debugger will prove to be invaluable
when you're debugging complicated Perl scripts, especially when
writing or working with your own Perl modules. Admittedly, the
debugging facilities in Perl are not as fancy as those found in
packages for C, C++, or BASIC; however, they can be very powerful
tools in catching nasty bugs that are not caught by the Perl compiler
or by the warning facility in Perl. 
<P>
There are two switches to Perl you should be aware of: the <TT><FONT FACE="Courier">-d</FONT></TT>
switch for turning on the debugger for a script and the <TT><FONT FACE="Courier">-w
</FONT></TT>switch for printing out warning messages when ambiguous
code is encountered. We will be covering the <TT><FONT FACE="Courier">-d</FONT></TT>
switch through most of this chapter. Warning messages are printed
by the Perl interpreter when suspect code is encountered. To turn
on the ability to print warnings in header code, add the <TT><FONT FACE="Courier">-w</FONT></TT>
to the header comment as shown below: 
<BLOCKQUOTE>
<TT><FONT FACE="Courier">#!/usr/bin/perl -w </FONT></TT>
</BLOCKQUOTE>
<P>
You will find, though, that simply getting warning messages is
not enough to debug your code. What if you need to monitor the
values of variables in a program? For such a feature, you will
have to use a debugger.
<P>
To invoke the debugger you simply invoke your script with the
<TT><FONT FACE="Courier">-d</FONT></TT> option. It's also possible
to place the <TT><FONT FACE="Courier">-d</FONT></TT> option in
the first line of script. Here's an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">#!/usr/bin/perl -d</FONT></TT>
</BLOCKQUOTE>
<P>
The debugger is invoked when the script is run. You are presented
a message about the version of the debugger and a prompt to type
your commands. You issue the cryptic one-character commands at
the prompt in order to get the debugger to execute the program,
set breakpoints, view or edit variable contents, and so on.
<P>
The debugger is a Perl module called <TT><FONT FACE="Courier">DB</FONT></TT>
and comes with the Perl 5.002 distribution files. All required
source code for the <TT><FONT FACE="Courier">DB</FONT></TT> module
is in the file <TT><FONT FACE="Courier">perl5db.pl</FONT></TT>
in your <TT><FONT FACE="Courier">/usr/lib/perl5</FONT></TT> directory.
You must have the <TT><FONT FACE="Courier">perl5db.pl</FONT></TT>
file in your <TT><FONT FACE="Courier">PERLLIBDIR</FONT></TT> path
for the debugger to work. The <TT><FONT FACE="Courier">perl5db.pl</FONT></TT>
file contains the entire list of commands available to you. (Look
in the middle of the source file around line 128 to see what commands
are available.)
<P>
When the debugger is invoked, you have a set of one- or two-character
commands that you can use. Typing the <TT><FONT FACE="Courier">h</FONT></TT>
command gives you a list of all commands available to you. Unfortunately,
unless you have a very long screen, the output scrolls by very
quickly. Therefore, if you are not familiar with the Perl debugger,
I strongly recommend at least going through the debugger commands
detailed in this chapter once before you attempt a debug session
on an important Perl program on your own.
<H2><A NAME="ASampleSession"><B><FONT SIZE=5 COLOR=#FF0000>A Sample
Session</FONT></B></A></H2>
<P>
Use the sample script shown in Listing 30.1 to run a sample debug
session. You have seen this script before in <A HREF="ch3.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch3.htm" >Chapter 3</A>,
&quot;References.&quot;
<HR>
<BLOCKQUOTE>
<B>Listing 30.1. A sample script to be debugged.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl -d<BR>
&nbsp;2 <BR>
&nbsp;3 sub xyc {<BR>
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $a = $_[0];<BR>
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print $a;<BR>
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;7 # --------------------------------------------------------------
<BR>
&nbsp;8 # Define each state as subroutine. Then create a<BR>
&nbsp;9 # reference to each subroutine. We have four states here.
<BR>
10 # --------------------------------------------------------------
<BR>
11 $s0 = sub {<BR>
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $a = $_[0];<BR>
13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;State 0 processing
$a \n&quot;;<BR>
14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($a eq '0')&nbsp;&nbsp;{ return(0);
}<BR>
15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($a eq '1')&nbsp;&nbsp;{ return(1);
}<BR>
16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($a eq '2')&nbsp;&nbsp;{ return(2);
}<BR>
17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($a eq '3')&nbsp;&nbsp;{ xyc(&quot;hello&quot;);
return(3); }<BR>
18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;<BR>
19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<BR>
20 # --------------------------------------------------------------
<BR>
21 $s1 = sub {<BR>
22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local $a = shift @_;<BR>
23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;State 1 processing
$a \n&quot;;<BR>
24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($a eq '0')&nbsp;&nbsp;{&nbsp;return(0);
}<BR>
25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($a eq '1')&nbsp;&nbsp;{&nbsp;return(1);
}<BR>
26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($a eq '2')&nbsp;&nbsp;{&nbsp;return(2);
}<BR>
27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($a eq '3')&nbsp;&nbsp;{&nbsp;return(3);
}<BR>
28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1;<BR>
29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<BR>
30 # --------------------------------------------------------------
<BR>
31 $s2 = sub {<BR>
32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local $a = $_[0];<BR>
33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;State 2 processing
$a \n&quot;;<BR>
34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($a eq '0')&nbsp;&nbsp;{&nbsp;return(0);
}<BR>
35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($a eq '1')&nbsp;&nbsp;{&nbsp;return(1);
}<BR>
36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($a eq '2')&nbsp;&nbsp;{&nbsp;return(2);
}<BR>
37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($a eq '3')&nbsp;&nbsp;{&nbsp;return(3);
}<BR>
38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 2;<BR>
39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<BR>
40 # --------------------------------------------------------------
<BR>
41 $s3 = sub {<BR>
42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local $a = shift @_;<BR>
43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;State 3 processing
$a \n&quot;;<BR>
44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($a eq '0')&nbsp;&nbsp;{ return(0);
}<BR>
45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($a eq '1')&nbsp;&nbsp;{ return(1);
}<BR>
46&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($a eq '2')&nbsp;&nbsp;{ return(2);
}<BR>
47&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($a eq '3')&nbsp;&nbsp;{ return(3);
}<BR>
48&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 3;<BR>
49&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<BR>
50 <BR>
51 # --------------------------------------------------------------
<BR>
52 # Create an array of pointers to subroutines. The index<BR>
53 # into this array is the current state.<BR>
54 # --------------------------------------------------------------
<BR>
55 @stateTable = ($s0, $s1, $s2, $s3);<BR>
56 <BR>
57 # --------------------------------------------------------------
<BR>
58 # Intialize the state to 0.<BR>
59 # --------------------------------------------------------------
<BR>
60 $this = 0;<BR>
61 <BR>
62 # --------------------------------------------------------------
<BR>
63 # Implement the state machine.<BR>
64 #&nbsp;&nbsp;&nbsp;set current state to 0<BR>
65 #&nbsp;&nbsp;&nbsp;forever<BR>
66 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get response
<BR>
67 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set current
state to next state based on response.<BR>
68 # --------------------------------------------------------------
<BR>
69 while (1)<BR>
70&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
71&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n This state is :
$this -&gt; what next? &quot;;<BR>
72&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$reply = &lt;STDIN&gt;;<BR>
73&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chop($reply);<BR>
74 <BR>
75&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
76&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Stop the machine here<BR>
77&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
78&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($reply eq 'q') { exit(0);
}<BR>
79&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot; Reply = $reply \n&quot;;
<BR>
80 <BR>
81&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
82&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Get the present state function.
<BR>
83&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
84&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$state = $stateTable[$this];<BR>
85&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
86&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Get the next state from this
state.<BR>
87&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
88&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$next = &amp;$state($reply);<BR>
89&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf &quot;Next state = $next
from this state $this\n&quot;;<BR>
90&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
91&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Now advance present state to
next state<BR>
92&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
93&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this = $next;<BR>
94&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
When you first run this program, you are presented the screen
shown in Figure 30.1. The filename, line number, and line of code
that will be executed next are shown before the prompt.
<P>
<A HREF="f30-1.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/f30-1.gif" ><B>Figure 30.1 : </B><I>Using the Perl debugger.</I></A>
<P>
The prompt has a number between the less-than and greater-than
signs to signify the calling level. As the program execution continues,
the number will indicate the number of debugger commands in the
history of commands in the debugger. For example, if you have
three commands in the debugger history list, your prompt will
look like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">DB&lt;3&gt;</FONT></TT>
</BLOCKQUOTE>
<P>
Let's first see how we can list the contents of the program we
are debugging. To list the contents of the file, you have to use
the <TT><FONT FACE="Courier">l</FONT></TT> command. By default,
10 lines of the source code are listed. Every time you type an
<TT><FONT FACE="Courier">l</FONT></TT> command, the next 10 lines
of the file are listed, as shown in Figure 30.2.
<P>
<A HREF="f30-2.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/f30-2.gif" ><B>Figure 30.2 : </B><I>Listing the source with the 1 command.</I></A>
<P>
You can look at just one specific line by specifying the line
number as a parameter to the <TT><FONT FACE="Courier">l</FONT></TT>
command. For example, the command to print the code on line 23
would be <TT><FONT FACE="Courier">l 23</FONT></TT>.
<P>
The <TT><FONT FACE="Courier">l</FONT></TT> command can also take
one set of line numbers to specify a range of parameters. The
ranges have to be specified in the following form. Lines numbers
in a range are inclusive.
<BLOCKQUOTE>
<TT><I><FONT FACE="Courier">startLine-endLine.</FONT></I></TT>
</BLOCKQUOTE>
<P>
Don't specify the <TT><I><FONT FACE="Courier">endLine</FONT></I></TT>
number as less than the <TT><I><FONT FACE="Courier">startLine</FONT></I></TT>
number. To list the source file lines from 20 through 41, try
this command:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">l 20-41</FONT></TT>
</BLOCKQUOTE>
<P>
To look at the 10 lines preceding the current command, use the
<TT><FONT FACE="Courier">-</FONT></TT> command. For example, if
you are at line 23, typing in the <TT><FONT FACE="Courier">-</FONT></TT>
command will show lines 13 to 22. 
<P>
The <TT><FONT FACE="Courier">w</FONT></TT> command will print
a window of lines of code around the current line by printing
three lines before the current line (or the line number you specify
after it as an option to the <TT><FONT FACE="Courier">w</FONT></TT>
command), followed by the code at the current line, and up to
the next six lines of code. For example, the command 
<BLOCKQUOTE>
<TT><FONT FACE="Courier">w 5 </FONT></TT>
</BLOCKQUOTE>
<P>
will print line numbers 2 through 11.
<H2><A NAME="SteppingThroughCode"><B><FONT SIZE=5 COLOR=#FF0000>Stepping
Through Code</FONT></B></A></H2>
<P>
You can step through the source code with the <TT><FONT FACE="Courier">s</FONT></TT>
command. Pressing the <TT><FONT FACE="Courier">s</FONT></TT> key
will successively walk you through each line of the code as it
executes, as shown in Figure 30.3.
<P>
<A HREF="f30-3.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/f30-3.gif" ><B>Figure 30.3 : </B><I>Using the step function.</I></A>
<P>
The <TT><FONT FACE="Courier">s</FONT></TT> command steps to the
next line of code. If the line of code is in a module whose code
is accessible, you'll go to it and stop. To step over a function,
use the <TT><FONT FACE="Courier">n</FONT></TT> command, which
goes to the next instruction at the same scope.
<P>
The <TT><FONT FACE="Courier">c</FONT></TT> command executes the
debugged program in continuous mode. That is, the program will
run until either a breakpoint is hit or the program terminates.
To run in continuous mode, simply type <TT><FONT FACE="Courier">c</FONT></TT>
at the debug prompt with no parameters. The <TT><FONT FACE="Courier">c</FONT></TT>
command can also be used to execute from the current line to another
known line number: 
<BLOCKQUOTE>
<TT><FONT FACE="Courier">c newLineNumber</FONT></TT>
</BLOCKQUOTE>
<P>
For example, if you are at line 7, to execute from the current
line number (7) to line number 12, you would issue the command
<TT><FONT FACE="Courier">c 12</FONT></TT>.
<H2><A NAME="LookingatValues"><B><FONT SIZE=5 COLOR=#FF0000>Looking
at Values</FONT></B></A></H2>
<P>
To see the values of certain variables in the program, use the
<TT><FONT FACE="Courier">V</FONT></TT> command. Used by itself,
<TT><FONT FACE="Courier">V</FONT></TT> lists all the variables
in scope at this time. Here's the syntax:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">V [<I>package</I> [<I>variable</I>]]</FONT></TT>
</BLOCKQUOTE>
<P>
To look at values in your program, you'll want to look at the
<TT><FONT FACE="Courier">main</FONT></TT> package. For example,
to print the value of <TT><FONT FACE="Courier">$reply</FONT></TT>,
use this command:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">V main reply<BR>
$reply = '1'</FONT></TT>
</BLOCKQUOTE>
<P>
Note that the dollar sign before the variable specified to <TT><FONT FACE="Courier">V</FONT></TT>
is not supplied. Therefore, if you specify the command <TT><FONT FACE="Courier">V
main $reply</FONT></TT>, you are actually asking for the value
of <TT><FONT FACE="Courier">$$reply</FONT></TT> and not <TT><FONT FACE="Courier">$reply</FONT></TT>.
<P>
The <TT><FONT FACE="Courier">trace</FONT></TT> option is available
with the <TT><FONT FACE="Courier">t</FONT></TT> toggle command.
Issuing <TT><FONT FACE="Courier">trace</FONT></TT> once turns
it on, and issuing it again turns it off. See Figure 30.4 for
a sample use of the <TT><FONT FACE="Courier">trace</FONT></TT>
command on Listing 30.2. In this example, <TT><FONT FACE="Courier">trace</FONT></TT>
is turned on, and then the <TT><FONT FACE="Courier">c</FONT></TT>
command is issued to run the debugger continuously. In <TT><FONT FACE="Courier">trace</FONT></TT>
mode, the debugger prints out each line of code that executes.
<P>
<A HREF="f30-4.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/f30-4.gif" ><B>Figure 30.4 : </B><I>Using the trace command with breakpoints.</I></A>
<P>
The <TT><FONT FACE="Courier">X</FONT></TT> command is helpful
when displaying values of variables in the current package. Remember
that the <TT><FONT FACE="Courier">main</FONT></TT> package is
the default package for a Perl script. Issued by itself with no
options, the <TT><FONT FACE="Courier">X</FONT></TT> command displays
all the variables in the current package. Avoid issuing the <TT><FONT FACE="Courier">X</FONT></TT>
command by itself because it can generate a very long listing
of all the variables in the <TT><FONT FACE="Courier">main</FONT></TT>
package. 
<P>
To see the value of a particular variable instead of all the variables,
type the name of the variable after the <TT><FONT FACE="Courier">X</FONT></TT>
command. For example, the following command 
<BLOCKQUOTE>
<TT><FONT FACE="Courier">X <I>fileNumber</I> </FONT></TT>
</BLOCKQUOTE>
<P>
will print the value of the <TT><I><FONT FACE="Courier">fileNumber</FONT></I></TT>
variable in the current package. If you have array variables and
scalar variables with the same name in the same package, the <TT><FONT FACE="Courier">X</FONT></TT>
command will display the values of both these variables. For example,
if you have a scalar variable called <TT><FONT FACE="Courier">names</FONT></TT>
and an array called <TT><FONT FACE="Courier">names</FONT></TT>,
the <TT><FONT FACE="Courier">X</FONT></TT> command will show the
values of both variables:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">DB&lt;3&gt;<B> X names<BR>
</B>$names = &quot;kamran&quot;<BR>
@names = (<BR>
&quot;kamran&quot;<BR>
&quot;joe&quot;<BR>
&quot;donald&quot;<BR>
)</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="Breakpoints"><B><FONT SIZE=5 COLOR=#FF0000>Breakpoints</FONT></B></A>
</H2>
<P>
You can place breakpoints at suspect locations in your code and
run the program until one of the specified breakpoints is hit.
Breakpoints can be specified to be hit as soon as the line of
code is about to be executed.
<P>
The <TT><FONT FACE="Courier">c</FONT></TT> command is used to
step forward until either the program stops or a specified breakpoint
is hit. To specify a breakpoint at the current line, use the <TT><FONT FACE="Courier">b</FONT></TT>
command without any parameters. To specify a specific line, use
the command of the form:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">b <I>linenumber</I></FONT></TT>
</BLOCKQUOTE>
<P>
Usually, you use <TT><FONT FACE="Courier">trace</FONT></TT> statements
to see statements between the current execution point and a breakpoint
(refer to Figure 30.4). The program is run in continuous mode
with the <TT><FONT FACE="Courier">c</FONT></TT> command until
it hits a breakpoint. There is a breakpoint in Listing 30.1 that
causes the debugger to stop. The <TT><FONT FACE="Courier">L</FONT></TT>
command is issued in the example to list the breakpoints in the
system. 
<P>
Breakpoints can also be specified to occur at the first executable
line of code within a subroutine. Simply use the <TT><FONT FACE="Courier">b</FONT></TT>
command with the name of the subroutine as the first parameter.
For example, to break at the first line of code in the <TT><FONT FACE="Courier">xyc</FONT></TT>
subroutine, try this command:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">b xyc</FONT></TT>
</BLOCKQUOTE>
<P>
You can also ask the debugger to look at a condition when a line
is hit with a breakpoint tag on it. If the breakpoint is specified
at a line and the condition is true, the debugger stops; otherwise,
it keeps on going. For example, if you want the debugger to stop
in <TT><FONT FACE="Courier">xyc</FONT></TT> only when the global
<TT><FONT FACE="Courier">$reply</FONT></TT> is <TT><FONT FACE="Courier">1</FONT></TT>,
use this command:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">b xyc ($reply == '1')</FONT></TT>
</BLOCKQUOTE>
<P>
To list all breakpoints defined during a debug session, use the
<TT><FONT FACE="Courier">L</FONT></TT> command. If you issue unconditional
breakpoints, you'll see breakpoints listed as this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">break if (1)</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">L</FONT></TT> command will also list
up to the last five executed lines of the program.
<P>
To remove a breakpoint, use the <TT><FONT FACE="Courier">d</FONT></TT>
command and specify the line number to delete. To remove all breakpoints,
use the <TT><FONT FACE="Courier">D</FONT></TT> command. For example,
to delete a breakpoint at line 12, you would issue the command
<TT><FONT FACE="Courier">d 12</FONT></TT>.
<P>
The <TT><FONT FACE="Courier">DB</FONT></TT> package uses the following
sequence to hit breakpoints and evaluate code on each line of
executable code:
<OL>
<LI>Checks to see whether the breakpoint is defined at this line
number. If there is no breakpoint defined for this line, it starts
to process the next line. If there is a break-<BR>
point at this line, the debugger prepares to stop. If the condition
for the defined breakpoint is true, the debugger stops execution
and presents a prompt to the user.
<LI>Checks to see whether the line of code is printable. If so,
it prints the entire line of code (including code spanning multiple
lines).
<LI>Checks to see whether there are any actions defined for this
line and performs these actions. (An <I>action</I> is a set of
Perl commands to be executed.)
<LI>Checks to see whether the stop was due to a breakpoint. If
the condition for the breakpoint is true and a breakpoint has
been marked in this location, the debugger stops and presents
a prompt for user interaction.
<LI>Evaluates the line and gets ready to execute it. Gets user
input if the user is stopping; otherwise, it executes the line
and returns to item 1 in order to process the next line.
</OL>
<H2><A NAME="Actions"><B><FONT SIZE=5 COLOR=#FF0000>Actions</FONT></B></A>
</H2>
<P>
You can specify actions to take when a certain line of code is
executed. This step is very important when you want to print out
values as the program executes (see Figure 30.5). Notice how the
value of <TT><FONT FACE="Courier">reply</FONT></TT> is printed
out when line 73 is reached. The action is defined with this statement:
<P>
<A HREF="f30-5.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/f30-5.gif" ><B>Figure 30.5 : </B><I>Using actions in the debugger.</I></A>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">a 73 print &quot;I am on line 73 and
reply is $reply&quot;</FONT></TT>
</BLOCKQUOTE>
<P>
Notice that you did not have to terminate the action command with
a semicolon. You need to use semicolons only if you have more
than one statement for an action. If you forget to supply the
terminating semicolon, the debugger will supply it for you. In
any event, try to keep actions simple and short. Don't write lengthy
actions unless absolutely necessary; otherwise, you'll slow down
the debugger and clutter up the output on your terminal.
<P>
Actions are not limited to displaying values. For instance, you
can use an action to reset a variable to a known value while in
a loop, using a statement like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">a 73 $reply = 1; print &quot;forced reply
to 1\n&quot;;</FONT></TT>
</BLOCKQUOTE>
<P>
To execute statements within the debugged program's space, simply
type the command at the prompt. For example, to explicitly create
and set the value of <TT><FONT FACE="Courier">$kw</FONT></TT>
to <TT><FONT FACE="Courier">2</FONT></TT> in the code, use the
following commands at the <TT><FONT FACE="Courier">DB&lt;&gt;</FONT></TT>
prompt:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">DB&lt;1&gt; $kw = 2<BR>
<I>... nothing is printed here ...<BR>
</I>DB&lt;1&gt; print $kw<BR>
2<BR>
DB&lt;1&gt; V main kw<BR>
$kw = '2'</FONT></TT>
</BLOCKQUOTE>
<P>
In this example, the variable <TT><FONT FACE="Courier">$kw</FONT></TT>
is created and defined in the program environment. You cannot
modify the source code in the original program, but you can add
items to the name space.
<P>
In some cases, your program may have redirected its output to
<TT><FONT FACE="Courier">STDOUT</FONT></TT> and therefore whatever
it is printing will not be shown on the console. To evaluate an
expression and print its value out to the console regardless of
how <TT><FONT FACE="Courier">STDOUT</FONT></TT> is redirected,
you can use the <TT><FONT FACE="Courier">p</FONT></TT> command.
The <TT><FONT FACE="Courier">p</FONT></TT> command evaluates an
expression in the current program's environment and prints it
out to the debugger console. Basically, the <TT><FONT FACE="Courier">print</FONT></TT>
command prints the output to wherever <TT><FONT FACE="Courier">STDOUT</FONT></TT>
is redirected, whereas the <TT><FONT FACE="Courier">p</FONT></TT>
command is equivalent to the following <TT><FONT FACE="Courier">print</FONT></TT>
command: 
<BLOCKQUOTE>
<TT><FONT FACE="Courier">print DB::OUT </FONT></TT>
</BLOCKQUOTE>
<P>
The command above forces output from a <TT><FONT FACE="Courier">print</FONT></TT>
command to where the <TT><FONT FACE="Courier">DB::</FONT></TT>
package prints its output.
<H2><A NAME="SearchingforPatterns"><B><FONT SIZE=5 COLOR=#FF0000>Searching
for Patterns</FONT></B></A></H2>
<P>
To look for certain strings in the source code, you can use the
forward slash command followed by the string to look for. Note
that there are no spaces between the <TT><FONT FACE="Courier">/</FONT></TT>
and the string you are looking for. The string can be specified
between two slashes, but the second slash is optional. Actually,
you can search for regular expressions, just as in Perl.
<P>
To search forward in the file, use the <TT><FONT FACE="Courier">/</FONT></TT>
operator. To search backward, use the question mark operator (<TT><FONT FACE="Courier">?</FONT></TT>).
<P>
The history of the commands you have executed is tracked in the
debugger. Only commands greater than one character long are listed
in this directory. To execute commands from the history list,
use the bang operator (<TT><FONT FACE="Courier">!</FONT></TT>)
followed by the index of the command. To execute a command from
the history, type <TT><FONT FACE="Courier">!</FONT></TT> and the
index of the command to redo. This should be familiar to Bash
and C shell programmers.
<P>
To see the current history of commands in the buffer of commands
in the debugger, type the <TT><FONT FACE="Courier">H</FONT></TT>
command. For example, in the middle of a debug session, if you
type in the <TT><FONT FACE="Courier">H</FONT></TT> command at
the <TT><FONT FACE="Courier">DB&lt;3&gt;</FONT></TT> prompt, you
should expect to see three items listed in reverse order of execution:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">DB&lt;3&gt; H<BR>
3: b 79<BR>
2: w 2 <BR>
1: w 9</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="Subroutines"><B><FONT SIZE=5 COLOR=#FF0000>Subroutines</FONT></B></A>
</H2>
<P>
To list all the subroutines currently in the system, use the <TT><FONT FACE="Courier">S</FONT></TT>
command. The output from the <TT><FONT FACE="Courier">S</FONT></TT>
command lists all subroutines in any package that your code uses.
For example, if you run the program in Listing 30.2 with the debugger,
you will see output as shown in Figure 30.6.
<P>
<A HREF="f30-6.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/f30-6.gif" ><B>Figure 30.6 : </B><I>Listing subroutine names.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 30.2. A sample listing.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl -d<BR>
&nbsp;2 <BR>
&nbsp;3 use VRML;<BR>
&nbsp;4 use VRML::Cube;<BR>
&nbsp;5 <BR>
&nbsp;6 my $header = VRML::new();<BR>
&nbsp;7 $header-&gt;VRML::startHeader;<BR>
&nbsp;8 <BR>
&nbsp;9 $header-&gt;VRML::startSeparator;<BR>
10 <BR>
11 my $cubeb = $header-&gt;VRML::putCube(<BR>
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'width'
=&gt; 0.5, 'height' =&gt; 0.5 , 'depth' =&gt; 0.5 ,<BR>
13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'translation'
=&gt; [1,0,0]<BR>
14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<BR>
15 my $cubed = $header-&gt;VRML::putCube(<BR>
16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'width'
=&gt; 1, 'height' =&gt; 1 , 'depth' =&gt; 1 ,<BR>
17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'translation'
=&gt; [1,1,0],<BR>
18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<BR>
19 $header-&gt;VRML::stopSeparator;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
At any time in a debug session, you can do a &quot;stack trace,&quot;
which is a listing of the calling order of the functions called
so far. Be aware that if you are modifying the argument stack
in any way, the values of the passed arguments might not be correct.
The <TT><FONT FACE="Courier">T</FONT></TT> command will do a stack
trace for you.
<H2><A NAME="Caveats"><B><FONT SIZE=5 COLOR=#FF0000>Caveats</FONT></B></A>
</H2>
<P>
First of all, there is no way to restart the debugger if there
is a problem. If you overstep something, you have to start all
over. This means getting out of the program and restarting the
debugger.
<P>
Second, the debugger itself is not completely debugged yet. If
you notice certain problems, such as your commands not being recognized,
it's probably because you typed too many characters at the prompt.
<P>
Table 30.1 lists the information about the available debugger
commands. All information in this table is gleaned from the <TT><FONT FACE="Courier">perl5db.pl</FONT></TT>
source file. Keep this table handy so that you don't have to go
to the file to see what options are available.<BR>
<P>
<CENTER><B>Table 30.1. The commands available from the debugger.</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=175><I>Command</I></TD><TD WIDTH=408><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">a [<I>ln</I>] <I>command</I></FONT></TT>
</TD><TD WIDTH=408>Sets an action to take before the line is executed.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">b</FONT></TT></TD>
<TD WIDTH=408>Sets an unconditional breakpoint at the current line.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">b [<I>ln</I>] [<I>cond</I>]</FONT></TT>
</TD><TD WIDTH=408>Sets a breakpoint if the condition is true at the specified line number.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">b <I>sname</I> [<I>cond</I>]</FONT></TT>
</TD><TD WIDTH=408>Sets a breakpoint at the first line inside the subroutine <TT><I><FONT FACE="Courier">sname()</FONT></I></TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">c</FONT></TT></TD>
<TD WIDTH=408>Continues until the next breakpoint or until the end of the program.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">c <I>line</I></FONT></TT>
</TD><TD WIDTH=408>Continues and stops at the specified line.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">d [<I>line</I>]</FONT></TT>
</TD><TD WIDTH=408>Deletes the breakpoint at a given line.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">D</FONT></TT></TD>
<TD WIDTH=408>Deletes all breakpoints.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">f <I>filename</I></FONT></TT>
</TD><TD WIDTH=408>Switches to the filename as the default.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">H -<I>number</I></FONT></TT>
</TD><TD WIDTH=408>Displays history of all commands longer than one character.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">L</FONT></TT></TD>
<TD WIDTH=408>Lists all breakpoints and actions.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">l <I>min+incr</I></FONT></TT>
</TD><TD WIDTH=408>Lists <TT><I><FONT FACE="Courier">incr+1</FONT></I></TT> lines starting at line <TT><I><FONT FACE="Courier">#min</FONT></I></TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">l <I>min-max</I></FONT></TT>
</TD><TD WIDTH=408>Lists lines from <TT><I><FONT FACE="Courier">min</FONT></I></TT> to <TT><I><FONT FACE="Courier">max</FONT></I></TT>, inclusively.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">l <I>line</I></FONT></TT>
</TD><TD WIDTH=408>Lists one line of code at a specified line.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">l</FONT></TT></TD>
<TD WIDTH=408>Lists the next 10 lines of code from the last location.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">l <I>name</I></FONT></TT>
</TD><TD WIDTH=408>Lists a subroutine by name.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">n</FONT></TT></TD>
<TD WIDTH=408>Next code at the same level. Steps over subroutine calls.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">p <I>expr</I></FONT></TT>
</TD><TD WIDTH=408>Same as <TT><FONT FACE="Courier">print DB::OUT expr</FONT></TT> in current package.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">q or ^D</FONT></TT>
</TD><TD WIDTH=408>Quits. You cannot use <TT><FONT FACE="Courier">quit</FONT></TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">r</FONT></TT></TD>
<TD WIDTH=408>Returns from current subroutine.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">s</FONT></TT></TD>
<TD WIDTH=408>Single-step over code. Steps into subroutines.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">S</FONT></TT></TD>
<TD WIDTH=408>Lists all known subroutine names in the current scope.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">t</FONT></TT></TD>
<TD WIDTH=408>Toggles <TT><FONT FACE="Courier">trace</FONT></TT> mode on and off.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">T</FONT></TT></TD>
<TD WIDTH=408>Performs a stack trace.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">V</FONT></TT> </TD>
<TD WIDTH=408>Lists all variables in all used packages.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">V <I>pkg</I></FONT></TT>
</TD><TD WIDTH=408>List all variables in a given package.</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">V <I>pkg var</I></FONT></TT>
</TD><TD WIDTH=408>Lists all variables in a package that have <TT><I><FONT FACE="Courier">var</FONT></I></TT> in them.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">w <I>line</I></FONT></TT>
</TD><TD WIDTH=408>Lists five lines before and five lines after current line.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">&lt;CR&gt;</FONT></TT>
</TD><TD WIDTH=408>Repeats last <TT><FONT FACE="Courier">n</FONT></TT> or <TT><FONT FACE="Courier">s</FONT></TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">-</FONT></TT></TD>
<TD WIDTH=408>Lists the previous window.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">/<I>regexp</I>/</FONT></TT>
</TD><TD WIDTH=408>Searches forward for a pattern using a regular expression.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">?<I>regexp</I>?</FONT></TT>
</TD><TD WIDTH=408>Searches backward for a pattern using a regular expression.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">&lt; <I>command</I></FONT></TT>
</TD><TD WIDTH=408>Defines the <TT><I><FONT FACE="Courier">command</FONT></I></TT> before the prompt.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">&gt; <I>command</I></FONT></TT>
</TD><TD WIDTH=408>Defines the <TT><I><FONT FACE="Courier">command</FONT></I></TT> after the prompt.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">! <I>number</I></FONT></TT>
</TD><TD WIDTH=408>Redoes a command (the default is the previous command).
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">! -<I>number</I></FONT></TT>
</TD><TD WIDTH=408>Redoes <TT><I><FONT FACE="Courier">number\'th</FONT></I></TT> to the last command.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">= [<I>alias value</I>]</FONT></TT>
</TD><TD WIDTH=408>Starts a command alias.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><FONT FACE="Courier">=</FONT></TT></TD>
<TD WIDTH=408>Lists all the current aliases.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=175><TT><I><FONT FACE="Courier">command</FONT></I></TT>
</TD><TD WIDTH=408>Executes as a Perl statement in the current package.
</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="CustomizingYourDebuggerEnvironment"><B><FONT SIZE=5 COLOR=#FF0000>Customizing
Your Debugger Environment</FONT></B></A></H2>
<P>
There are ways to customize your debugger environment. If you
do not like the one-character commands that come with the debugger,
you can use different aliases. There is a hash in the <TT><FONT FACE="Courier">DB::</FONT></TT>
package called <TT><FONT FACE="Courier">%alias()</FONT></TT> that
contains the command strings. You can substitute your own commands
in place of the existing ones using the <TT><FONT FACE="Courier">=</FONT></TT>
command. Since most of the time you'll want to keep your changes
consistent between debug sessions, you can edit a file called
<TT><FONT FACE="Courier">.perldb</FONT></TT> in the current working
directory and place the assignments there. Here's a sample <TT><FONT FACE="Courier">.perldb</FONT></TT>
file:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$DB::alias{'ln'} = 's/ln/p $1/';<BR>
$DB::alias{'z'} = 's/z/l/';</FONT></TT>
</BLOCKQUOTE>
<P>
These two lines will substitute the value of <TT><FONT FACE="Courier">p</FONT></TT>
for every command <TT><FONT FACE="Courier">ln</FONT></TT> you
type, and the value of <TT><FONT FACE="Courier">l</FONT></TT>
for every <TT><FONT FACE="Courier">z</FONT></TT> command. Of course,
you'll probably want to alias long commands into short one-character
sequences to save yourself some time.
<P>
Using the debugger should not be your only method for getting
bugs out of the system. The <TT><FONT FACE="Courier">-w</FONT></TT>
switch is important if you want Perl to do checking and warn you
of error conditions while executing. The types of messages generated
vary from warnings to notifications of fatal errors that can cause
the program to abort.
<H2><A NAME="ForMoreInformation"><B><FONT SIZE=5 COLOR=#FF0000>For
More Information</FONT></B></A></H2>
<P>
Reading the source file <TT><FONT FACE="Courier">perl5db.pl</FONT></TT>
gives you a few clues about how the debugger works and the commands
that are available during a debug session. Consult the <TT><FONT FACE="Courier">perldebug.html</FONT></TT>
page at <TT><FONT FACE="Courier">www.metronet.com</FONT></TT>.
This file contains the full list of all the options in the debug
environment. Review the <TT><FONT FACE="Courier">perldiag.html</FONT></TT>
page for a list of possible diagnostic values you get from using
the <TT><FONT FACE="Courier">w</FONT></TT> switch.
<H2><A NAME="Summary"><B><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></B></A>
</H2>
<P>
Nothing really beats the use of well-placed <TT><FONT FACE="Courier">print</FONT></TT>
statements to do debugging. However, Perl does offer a simple
yet powerful debugging tool with the <TT><FONT FACE="Courier">-d</FONT></TT>
option. The interactive debugger lets you step through code, into
or over subroutines, set breakpoints, execute commands, and look
at variables in a Perl program.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch29.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch29.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch31.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch31.htm"><IMG 
SRC="nc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>
