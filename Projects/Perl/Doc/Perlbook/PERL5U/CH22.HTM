<HTML>

<HEAD>
   <TITLE>Chapter 22 -- Using HTML FORMs
with Perl CGI Scripts</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT COLOR=#FF0000>Chapter 22</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Using HTML </FONT></B><TT><B><FONT FACE="Courier" COLOR=#FF0000>FORMs</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000> with Perl CGI Scripts</FONT></B></FONT></H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>

<UL>
<LI><A HREF="#InputandOutputwithCGI" >Input and Output with CGI</A>
<LI><A HREF="#WhatAreGETandPOST" >What Are GET and POST?</A>
<LI><A HREF="#HandlingHTMLFORMswithGETMethods" >Handling HTML FORMs with GET Methods</A>
<LI><A HREF="#HandlinganHTMLFORMwithPOSTMethods" >Handling an HTML FORM with POST Methods</A>
<LI><A HREF="#ReturningHTMLPages" >Returning HTML Pages</A>
<LI><A HREF="#UsingtheCollectedData" >Using the Collected Data</A>
<UL>
<LI><A HREF="#ArchivingUserResponses" >Archiving User Responses</A>
<LI><A HREF="#ForwardingUserResponses" >Forwarding User Responses</A>
</UL>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
This chapter covers the use of Perl with HTML forms. The topics
include collecting information from an HTML <TT><FONT FACE="Courier">FORM</FONT></TT>
and responding to the requested information. I cover two ways
of querying information from an HTML script: using the <TT><FONT FACE="Courier">GET</FONT></TT>
and <TT><FONT FACE="Courier">POST</FONT></TT> methods. I also
cover how to acquire and then parse data in the Common Gateway
Interface (CGI) script in order to get responses back to the browser.
The information presented in this chapter can easily be expanded
to cover a whole book. There are many different ways of handling
CGI scripts, <TT><FONT FACE="Courier">FORM</FONT></TT>s, and developing
client/server applications, and just as many texts to cover them.
A list of references is provided here if you want more information:
<P>
For more information via printed textbooks, you might want to
consult these titles:
<UL>
<LI><I>Teach Yourself Web Publishing with HTML 3.0 in a Week</I>,
Laura Lemay, Sams.net, 1-57521-064-9, 1996.
<LI><I>HTML &amp; CGI Unleashed</I>, John December and Mark Ginsberg,
Sams.net, 0-672-30745-6, 1995. 
<LI><I>Using HTML</I>, Neil Randall, Que, 0-7897-0622-9, 1995.
</UL>
<H2><A NAME="InputandOutputwithCGI"><B><FONT SIZE=5 COLOR=#FF0000>Input
and Output with CGI</FONT></B></A></H2>
<P>
If you have used a Web browser, then you have come across HTML
pages, which allow you to query databases for information. Click
a button and-voil&agrave;-you get the latest weather in Colorado.
Just enter a date and destination and you can click a button to
get the travel information you need. What's going on behind the
page? Well, the chances are very high that the information handler
behind the Web page is a Perl script. Perl's power and ease of
handling make it a good choice for setting up support code for
Web pages.
<P>
Before I begin, remember that a CGI script does not have to be
written in Perl, but the ease and convenience of handling strings
makes Perl a very comfortable choice. Because this book is about
Perl, it won't take a wild guess to figure out which language
I cover in this chapter. However, you certainly can write CGI
scripts in any language you like-tcl/Tk, C, C++, or (gasp) even
in Assembler.
<P>
I'll go over a few points about the terminology in this chapter
before I get into the code. An HTML page is picked up and displayed
by a browser on the request of a user using that browser. The
information handling scripts and executables for that page are
handled by the server to which the HTML page's Uniform Resource
Locator (URL) points. The server gets a request for action from
the browser when the user selects the URL. The request is processed
by the server using the CGI, and the results of the CGI executable
are sent back to the browser, which in turn displays them to the
user. When describing the code that handles the requests, it's
easy to use the word <I>user</I> instead of <I>browser</I>. However,
as far as the CGI script on the server is concerned, it's sending
results back to whoever or whatever called it. It's easy to get
the words mixed up, but the intent of both words is to imply the
entity that invoked the CGI script in the first place.
<P>
I introduced you briefly to CGI in <A HREF="ch20.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch20.htm" >Chapter 20</A>,
&quot;An Introduction to Web Pages and CGI.&quot; In this chapter,
I cover how the methods for CGI are implemented in HTML forms.
I use the <TT><FONT FACE="Courier">test-cgi.pl</FONT></TT> shell
script (presented earlier) as the basis for setting up shell scripts
for returning data in response to a request. Listing 22.1 presents
a Perl script to echo CGI environment variables. 
<HR>
<BLOCKQUOTE>
<B>Listing 22.1. Perl script to echo CGI environment variables.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 #<BR>
&nbsp;3 # The sample script file to echo back ENV<BR>
&nbsp;4 # variables on call from an HTML document.<BR>
&nbsp;5 #<BR>
&nbsp;6 $|=1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
Flush output immediately.<BR>
&nbsp;7 print &quot;Content-Type: text/plain\r\n&quot;;<BR>
&nbsp;8 print &quot;Yet Another CGI/1.0 Test Script\r\n&quot;;
<BR>
&nbsp;9 <BR>
10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$count = ($#ARGV + 1);<BR>
11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;Argument Count: $count&quot;;
<BR>
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach $word (@ARGV) {<BR>
13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print
&quot;\n $word&quot;;<BR>
14 <BR>
15 print &quot;\n&quot;;<BR>
16 #<BR>
17 print &quot;SERVER_SOFTWARE = $ENV{'SERVER_SOFTWARE'}\n&quot;;
<BR>
18 print &quot;SERVER_NAME = $ENV{'SERVER_NAME'}\n&quot;;<BR>
19 print &quot;GATEWAY_INTERFACE = $ENV{'GATEWAY_INTERFACE'}\n&quot;;
<BR>
20 print &quot;SERVER_PROTOCOL = $ENV{'SERVER_PROTOCOL'}\n&quot;;
<BR>
21 print &quot;SERVER_PORT = $ENV{'SERVER_PORT'}\n&quot;;<BR>
22 print &quot;SERVER_ROOT = $ENV{'SERVER_ROOT'}\n&quot;;<BR>
23 print &quot;REQUEST_METHOD = $ENV{'REQUEST_METHOD'}\n&quot;;
<BR>
24 print &quot;HTTP_AccEPT = $ENV{'HTTP_AccEPT'}\n&quot;;<BR>
25 print &quot;PATH_INFO = $ENV{'PATH_INFO'}\n&quot;;<BR>
26 print &quot;PATH = $ENV{'PATH'}\n&quot;;<BR>
27 print &quot;PATH_TRANSLATED = $ENV{'PATH_TRANSLATED'}\n&quot;;
<BR>
28 print &quot;SCRIPT_NAME = $ENV{'SCRIPT_NAME'}\n&quot;;<BR>
29 print &quot;QUERY_STRING = $ENV{'QUERY_STRING'}\n&quot;;<BR>
30 print &quot;QUERY_STRING_UNESCAPED = $ENV{'QUERY_STRING_UNESCAPED'}\n&quot;;
<BR>
31 print &quot;REMOTE_HOST = $ENV{'REMOTE_HOST'}\n&quot;;<BR>
32 print &quot;REMOTE_IDENT = $ENV{'REMOTE_IDENT'}\n&quot;;<BR>
33 print &quot;REMOTE_ADDR = $ENV{'REMOTE_ADDR'}\n&quot;;<BR>
34 print &quot;REMOTE_USER = $ENV{'REMOTE_USER'}\n&quot;;<BR>
35 print &quot;AUTH_TYPE = $ENV{'AUTH_TYPE'}\n&quot;;<BR>
36 print &quot;CONTENT_TYPE = $ENV{'CONTENT_TYPE'}\n&quot;;<BR>
37 print &quot;CONTENT_LENGTH = $ENV{'CONTENT_LENGTH'}\n&quot;;
<BR>
38 print &quot;DOCUMENT_ROOT = $ENV{'DOCUMENT_ROOT'}\n&quot;;
<BR>
39 print &quot;DOCUMENT_URI = $ENV{'DOCUMENT_URI'}\n&quot;;<BR>
40 print &quot;DOCUMENT_NAME = $ENV{'DOCUMENT_NAME'}\n&quot;;
<BR>
41 print &quot;DATE_LOCAL = $ENV{'DATE_LOCAL'}\n&quot;;<BR>
42 print &quot;DATE_GMT = $ENV{'DATE_GMT'}\n&quot;;<BR>
43 print &quot;LAST_MODIFIED = $ENV{'LAST_MODIFIED'}\n&quot;;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
I'll examine only the Perl scripting features that apply to CGI.
Basically, CGI scripts are executed by the server in response
to a request or action by the URL referenced in the HTML document
being viewed. For example, a URL refers to this document as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&lt;A<BR>
HREF=&quot;http://ikra.com/cgi-bin/test-cgi?Its+de+a+vu+all+over+again&quot;
&gt;<BR>
Click me for an echo.<BR>
&lt;/A&gt;</FONT></TT>
</BLOCKQUOTE>
<P>
The output from this script is as follows. I have truncated it
to save space.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Yet Another CGI/1.0 Test Script<BR>
<BR>
Argument Count: 6<BR>
&nbsp;Its<BR>
&nbsp;deja<BR>
&nbsp;vu<BR>
&nbsp;all<BR>
&nbsp;over<BR>
&nbsp;again<BR>
SERVER_SOFTWARE = ncSA/1.4.2<BR>
SERVER_NAME = pop.ikra.com<BR>
GATEWAY_INTERFACE = CGI/1.1<BR>
SERVER_PROTOCOL = HTTP/1.0<BR>
SERVER_PORT = 80<BR>
SERVER_ROOT =<BR>
REQUEST_METHOD = GET<BR>
HTTP_AccEPT = */*, image/gif, image/x-xbitmap, image/jpeg<BR>
PATH_INFO =<BR>
PATH = /bin:/usr/bin:/usr/ucb:/usr/bsd:/usr/local/bin<BR>
PATH_TRANSLATED =<BR>
SCRIPT_NAME = /cgi-bin/test-cgi<BR>
QUERY_STRING = Its+deja+vu+all+over+again<BR>
QUERY_STRING_UNESCAPED =<BR>
REMOTE_HOST = pop.ikra.com<BR>
REMOTE_IDENT =</FONT></TT>
</BLOCKQUOTE>
<P>
The first action is to reply to the server that text is being
sent back. This is done with the following statement:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">print &quot;Content-Type: text/plain\n\n&quot;;</FONT></TT>
</BLOCKQUOTE>
<P>
Examine this <TT><FONT FACE="Courier">test-cgi.pl</FONT></TT>
Perl script and its associated URL in more detail. Notice how
the arguments are being passed into the Perl script. Okay, so
I said <I>Its</I> instead of <I>It's</I>, because I did not want
to escape the single quote (') between the <I>t</I> and <I>s</I>.
<BLOCKQUOTE>
<TT>HREF=&quot;http://ikra.com/cgi-bin/test-cgi?Its+de+a+vu+all+over+again&quot;</FONT></TT>
</BLOCKQUOTE>
<P>
The script being referred to in this URL is the <TT><FONT FACE="Courier">test-cgi</FONT></TT>
file on the node <TT><FONT FACE="Courier">ikra.com</FONT></TT>
in the subdirectory <TT><FONT FACE="Courier">cgi-bin</FONT></TT>
of the <TT><FONT FACE="Courier">http</FONT></TT> root directory.
The arguments being passed into this script appear after the question
mark (<TT><FONT FACE="Courier">?</FONT></TT>). Each argument is
separated by a plus sign (<TT><FONT FACE="Courier">+</FONT></TT>).
<P>
The number of arguments, therefore, is six. The string is the
now famous saying that is widely attributed to Yogi Berra, &quot;It's
d&eacute;j&agrave; vu all over again.&quot; Now let's see how
the shell script handles this quip.
<P>
The first line to look at is the one in which <TT><FONT FACE="Courier">$|</FONT></TT>
is set to <TT><FONT FACE="Courier">1</FONT></TT>. The <TT><FONT FACE="Courier">$|</FONT></TT>
variable is a special variable in Perl. When the <TT><FONT FACE="Courier">$|</FONT></TT>
variable is set to a non-zero value, Perl forces a flush to the
current output channel. When you are working with CGI applications,
it's important to keep in mind that a quick response will win
you praise. Don't wait for the channel to flush input back to
the caller because the buffering on your output might cause the
client's browser to wait for input for so long that a timeout
is triggered.
<P>
The next line is absolutely necessary and should be printed back
to the browser regardless of how the shell script runs. This line
tells the client what type of data you are sending back. In this
example, plain text is sent back; it's important to let the browser
know about it. This is done by sending back the MIME content identifier:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">print &quot;Content-Type: text/plain\n\n&quot;;</FONT></TT>
</BLOCKQUOTE>
<P>
It's nice to know what the returned output is; you can print it
out with this line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">print &quot;Yet Another CGI/1.0 Test
Script\n\n&quot;;</FONT></TT>
</BLOCKQUOTE>
<P>
Next, all the arguments are printed out back to the browser with
the following lines:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$count = ($#ARGV + 1);<BR>
print &quot;Argument Count: $count&quot;;<BR>
foreach $word (@ARGV) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n $word&quot;;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The environment variable <TT><FONT FACE="Courier">QUERY_STRING</FONT></TT>
has the arguments to this shell script in the form of <TT><FONT FACE="Courier">Its+deja+vu+all+over+again</FONT></TT>.
In order to parse this string into individual arguments, you have
to split the array where there is a plus sign. This is easily
done with the following line (which is not in Listing 22.1):
<BLOCKQUOTE>
<TT><FONT FACE="Courier">@keywords = split('+', $ENV{QUERY_STRING});</FONT></TT>
</BLOCKQUOTE>
<P>
Each element of the <TT><FONT FACE="Courier">@keywords</FONT></TT>
array will be assigned an argument. That is, the array will look
like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">@keywords = (&quot;Its&quot;, &quot;deja&quot;,
&quot;vu&quot;, &quot;all&quot;, &quot;over&quot;, &quot;again&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
Now you can use these keywords to index into an external database
and return an appropriate response.
<H2><A NAME="WhatAreGETandPOST"><B><FONT SIZE=5 COLOR=#FF0000>What
Are </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">GET</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
and </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">POST</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>?</FONT></B></A>
</H2>
<P>
There are two HTTP methods for getting data to a CGI script using
an HTML page: <TT><FONT FACE="Courier">GET</FONT></TT> and <TT><FONT FACE="Courier">POST</FONT></TT>.
 The main difference between the two methods of sending data is
in the form of a query string to a CGI script. In the <TT><FONT FACE="Courier">GET</FONT></TT>
method, the query string is appended to the URL of the CGI program
that will be handling the request. Within the CGI script, the
query string will be set to the environment variable <TT><FONT FACE="Courier">QUERY_STRING</FONT></TT>.
In the case of a <TT><FONT FACE="Courier">POST</FONT></TT>, the
browser collects the information from a <TT><FONT FACE="Courier">FORM</FONT></TT>
and presents the data to the CGI script via its standard input.
The main advantage of using a <TT><FONT FACE="Courier">POST</FONT></TT>
request over a <TT><FONT FACE="Courier">GET</FONT></TT> request
is that <TT><FONT FACE="Courier">POST</FONT></TT> requests can
be longer than the maximum allowed length (usually 256) for an
environment variable. 
<P>
The <TT><FONT FACE="Courier">GET</FONT></TT> method can be used
without having to encode a <TT><FONT FACE="Courier">FORM</FONT></TT>
because all you have to do is append the query string to the calling
program's URL and send the resulting string to the CGI program.
For example, you could define an anchor tag like this: 
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&lt;A HREF=&quot;/cgi-bin/summer.pl?name=Kamran%20Husain&amp;y=3&quot;&gt;
CGI Sample&lt;/A&gt;</FONT></TT>
</BLOCKQUOTE>
<P>
This anchor tag will send a <TT><FONT FACE="Courier">GET</FONT></TT>
request to the program <TT><FONT FACE="Courier">summer.pl</FONT></TT>.
The <TT><FONT FACE="Courier">summer.pl</FONT></TT> program in
turn will get the string <TT><FONT FACE="Courier">&quot;name=Kamran%20Husain&amp;y=3&quot;</FONT></TT>
in its environment variable called <TT><FONT FACE="Courier">QUERY_STRING</FONT></TT>.
Note that the question mark (<TT><FONT FACE="Courier">?</FONT></TT>)
in the constructed query string separates the path of CGI script
from the parameters to be passed in the <TT><FONT FACE="Courier">QUERY_STRING</FONT></TT>.
<P>
Note that the <TT><FONT FACE="Courier">%20</FONT></TT> in the
name assignment corresponds to the ASCII representation for a
space, a hex 20. Spaces and special characters are not permitted
in the query string, and so they have to be converted to their
ASCII representations. Here's a Perl statement to convert a given
string into an encoded query string:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$query ~= s/(\W)/sprintf(&quot;%%%x&quot;,ord($1))/eg;
</FONT></TT>
</BLOCKQUOTE>
<P>
The substitution operator finds all the items that are not words
with the <TT><FONT FACE="Courier">\W</FONT></TT> construct. The
parentheses around the match <TT><FONT FACE="Courier">(\W) </FONT></TT>allow
this match to be referenced in the substituted string. The matched
word is then replaced by its hex equivalent by evaluating the
<TT><FONT FACE="Courier">sprintf</FONT></TT> statement, as specified
by the <TT><FONT FACE="Courier">-e</FONT></TT> flag. The <TT><FONT FACE="Courier">sprintf</FONT></TT>
command simply replaces each matched string <TT><FONT FACE="Courier">$1</FONT></TT>
with a percent sign followed by its ordinal value. The substitution
is done on the entire string by specifying the <TT><FONT FACE="Courier">-g</FONT></TT>
flag. 
<P>
So, what's going to be the major difference in the way you are
going to handle the incoming data in your Perl script? When handling
a <TT><FONT FACE="Courier">GET</FONT></TT> request, you are responding
to data in the <TT><FONT FACE="Courier">QUERY_STRING</FONT></TT>
environment variable. When handling the <TT><FONT FACE="Courier">POST</FONT></TT>
request, your Perl script will have to read from <TT><FONT FACE="Courier">STDIN</FONT></TT>,
the default input file handle. In a CGI script, the environment
variable <TT><FONT FACE="Courier">REQUEST_METHOD</FONT></TT> will
be set to either <TT><FONT FACE="Courier">GET</FONT></TT> or <TT><FONT FACE="Courier">POST</FONT></TT>
depending on how the <TT><FONT FACE="Courier">FORM</FONT></TT>
was defined. A <TT><FONT FACE="Courier">FORM</FONT></TT> can be
defined to either method in the <TT><FONT FACE="Courier">&lt;FORM&gt;</FONT></TT>
tag with the <TT><FONT FACE="Courier">METHOD</FONT></TT> attribute.
To use the <TT><FONT FACE="Courier">GET</FONT></TT> method for
a CGI script <TT><FONT FACE="Courier">handleIt.pl</FONT></TT>,
you would use the following statement: 
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&lt;FORM ACTION=&quot;/cgi-bin/handleIt.pl&quot;
METHOD=&quot;GET&quot;&gt; </FONT></TT>
</BLOCKQUOTE>
<P>
For using the <TT><FONT FACE="Courier">GET</FONT></TT> method
for the same CGI application and <TT><FONT FACE="Courier">FORM</FONT></TT>,
you would use the following statement:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&lt;FORM ACTION=&quot;/cgi-bin/handleIt.pl&quot;
METHOD=&quot;POST&quot;&gt; </FONT></TT>
</BLOCKQUOTE>
<P>
The CGI application you specify in the <TT><FONT FACE="Courier">ACTION</FONT></TT>
attribute of a <TT><FONT FACE="Courier">FORM</FONT></TT> is called
whenever a button of a <TT><FONT FACE="Courier">TYPE</FONT></TT>
attribute <TT><FONT FACE="Courier">&quot;submit&quot;</FONT></TT>
is pressed. To define a <TT><FONT FACE="Courier">&quot;submit&quot;</FONT></TT>
button on a <TT><FONT FACE="Courier">FORM</FONT></TT>, you can
use the following <TT><FONT FACE="Courier">&lt;INPUT&gt;</FONT></TT>
tag: 
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&lt;INPUT TYPE=&quot;submit&quot; VALUE=&quot;Just
do it!&quot;&gt;</FONT></TT>
</BLOCKQUOTE>
<P>
The line above will create a button on the <TT><FONT FACE="Courier">FORM</FONT></TT>
with a caption set to the string in the <TT><FONT FACE="Courier">VALUE</FONT></TT>
attribute. When this button is pressed, the browser will collect
the information from the fields in the <TT><FONT FACE="Courier">FORM</FONT></TT>
and using the method defined in the <TT><FONT FACE="Courier">METHOD</FONT></TT>
attribute of the <TT><FONT FACE="Courier">FORM</FONT></TT> make
a query string and send it to the CGI application defined in the
<TT><FONT FACE="Courier">ACTION</FONT></TT> attribute.
<P>
Hardwiring a URL with existing question marks and plus signs to
set up the input to a CGI script defeats the purpose of having
a <TT><FONT FACE="Courier">FORM</FONT></TT> in the first place.
This is where the <TT><FONT FACE="Courier">POST</FONT></TT> request
comes in to tell the browser how to make the input string for
you by using the input from a <TT><FONT FACE="Courier">FORM</FONT></TT>.
<H2><A NAME="HandlingHTMLFORMswithGETMethods"><B><FONT SIZE=5 COLOR=#FF0000>Handling
HTML </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">FORMs
</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>with </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">GET</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Methods</FONT></B></A></H2>
<P>
Data collected from an HTML form can also be sent for processing
with the <TT><FONT FACE="Courier">FORM</FONT></TT> keyword using
the <TT><FONT FACE="Courier">GET</FONT></TT> method. See the code
with the HTML page shown in Listing 22.2.
<HR>
<BLOCKQUOTE>
<B>Listing 22.2. Simple </B><TT><B><FONT FACE="Courier">FORM</FONT></B></TT><B>
input.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 &lt;html&gt;&lt;head&gt; &lt;title&gt;Welcome.&lt;/title&gt;
<BR>
&nbsp;2 &lt;/head&gt;<BR>
&nbsp;3 <BR>
&nbsp;4 &lt;body&gt;<BR>
&nbsp;5 &lt;center&gt;&lt;h1&gt;Test A Script&lt;/h1&gt;&lt;/center&gt;
<BR>
&nbsp;6 &lt;hr&gt;<BR>
&nbsp;7 &lt;p&gt;<BR>
&nbsp;8 &lt;A HREF=&quot;http://ikra.com/cgi-bin/test-cgi<BR>
&nbsp;&nbsp;&nbsp;<FONT FACE="ZAPFDINGBATS">&Acirc;</FONT>Its+deja+vu+all+over+again&quot; &gt;Click Me&lt;/A&gt;
<BR>
&nbsp;9 &lt;/p&gt;<BR>
10 &lt;p&gt;<BR>
11 &lt;FORM<BR>
12 METHOD=&quot;GET&quot; ACTION=&quot;http://ikra.com/cgi-bin/test-cgi&gt;
<BR>
13 &lt;INPUT TYPE=&quot;Submit&quot; VALUE=&quot;Just Do It&quot;&gt;
<BR>
14 &lt;/FORM&gt;<BR>
15 <BR>
16 &lt;/body&gt;&lt;/html&gt;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The rendering of this listing in Netscape is shown in Figure 22.1.
Pressing the Just Do It button returns an argument count of <TT><FONT FACE="Courier">0</FONT></TT>.
<P>
<A HREF="f22-1.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/f22-1.gif" ><B>Figure 22.1 : </B><I>A simple form.</I></A>
<P>
Accept some more input from the user to get more information about
the <TT><FONT FACE="Courier">FORM</FONT></TT>. The modified form
is shown in Figure 22.2. Listing 22.3 shows how the text area
was inserted. 
<P>
<A HREF="f22-2.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/f22-2.gif" ><B>Figure 22.2 : </B><I>Using a simple form with a text area.</I></A>
<P>
The <TT><FONT FACE="Courier">&lt;BR&gt;</FONT></TT> tag causes
a line break and forces the button onto the next line. Without
the <TT><FONT FACE="Courier">&lt;BR&gt;</FONT></TT> tag, the button
would be on the same line as the text widget (space permitting).
The following tag collects the input for the <TT><FONT FACE="Courier">FORM</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Type something here: &lt;INPUT SIZE=60
NAME=&quot;response&quot;&gt;</FONT></TT>
</BLOCKQUOTE>
<P>
The length of the string the user can type in is set to 60 characters
wide. The value sent to the shell script from this text widget
is assigned to the keyword <TT><FONT FACE="Courier">response</FONT></TT>.
Let's see how the Perl shell script is called when the button
is pressed.
<HR>
<BLOCKQUOTE>
<B>Listing 22.3. Sample form with text input.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 &lt;html&gt;&lt;head&gt;<BR>
&nbsp;2 &lt;/head&gt;<BR>
&nbsp;3 <BR>
&nbsp;4 &lt;body&gt;<BR>
&nbsp;5 &lt;center&gt;&lt;h1&gt;Test A Script&lt;/h1&gt;&lt;/center&gt;
<BR>
&nbsp;6 &lt;hr&gt;<BR>
&nbsp;7 &lt;p&gt;<BR>
&nbsp;8 &lt;A HREF=&quot;http://ikra.com/cgi-bin/test-cgi<BR>
&Acirc;Its+deja+vu+all+over+again&quot; &gt;Click Me&lt;/A&gt;
<BR>
&nbsp;9 &lt;/p&gt;<BR>
10 &lt;p&gt;<BR>
11 &lt;FORM<BR>
12&nbsp;&nbsp;METHOD=&quot;GET&quot; ACTION=&quot;http://ikra.com/cgi-bin/test-cgi&gt;
<BR>
13&nbsp;&nbsp;Type something here: &lt;INPUT SIZE=60 NAME=&quot;response&quot;&gt;
<BR>
14&nbsp;&nbsp;&lt;BR&gt;<BR>
15&nbsp;&nbsp;&lt;INPUT TYPE=&quot;Submit&quot; VALUE=&quot;Just
Do It&quot;&gt;<BR>
16&nbsp;&nbsp;&lt;/FORM&gt;<BR>
17 <BR>
18 &lt;/body&gt;&lt;/html&gt;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The output is shown in Figure 22.3. Look closely in the middle
of the figure to see the line: 
<P>
<A HREF="f22-3.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/f22-3.gif" ><B>Figure 22.3 : </B><I>The output of the request from the text area.</I></A>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&quot;response=Caution+Cape+does+not+NOT+enable+user+to+fly&quot;</FONT></TT>
</BLOCKQUOTE>
<P>
Look at the value assigned to <TT><FONT FACE="Courier">QUERY_STRING</FONT></TT>.
The &quot;<TT><FONT FACE="Courier">not+NOT</FONT></TT>&quot; is
deliberately done to catch your eye. As you can see, the string
is not easy to read. Look at the title and location of the Netscape
window in Figure 22.3. The value of <TT><FONT FACE="Courier">QUERY_STRING</FONT></TT>
is set to a format that is expected by the CGI script  at the
server.
<H2><A NAME="HandlinganHTMLFORMwithPOSTMethods"><B><FONT SIZE=5 COLOR=#FF0000>Handling
an HTML </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">FORM</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
with </FONT></B><TT><B><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">POST</FONT></B></TT><B><FONT SIZE=5 COLOR=#FF0000>
Methods</FONT></B></A></H2>
<P>
Handling the <TT><FONT FACE="Courier">POST</FONT></TT> method
is different than handling the <TT><FONT FACE="Courier">GET</FONT></TT>
method. In the <TT><FONT FACE="Courier">POST</FONT></TT> method,
you use the <TT><FONT FACE="Courier">STDIN</FONT></TT> line as
the source of your input. The length of the string being passed
into the <TT><FONT FACE="Courier">POST</FONT></TT>-handling script
is set in the <TT><FONT FACE="Courier">CONTENT_LENGTH</FONT></TT>
identifier.
<P>
To illustrate the use of <TT><FONT FACE="Courier">CONTENT_LENGTH</FONT></TT>
and <TT><FONT FACE="Courier">POST</FONT></TT> methods, you'll
work with a slightly more complicated input <TT><FONT FACE="Courier">FORM</FONT></TT>.
I'll construct the <TT><FONT FACE="Courier">FORM</FONT></TT> shown
in Figure 22.4. The HTML code for this page is shown in Listing
22.4. The Perl script behind the <TT><FONT FACE="Courier">FORM</FONT></TT>
is shown in Listing 22.5.
<P>
<A HREF="f22-4.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/f22-4.gif" ><B>Figure 22.4 : </B><I>Sample credit card application form.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 22.4. A sample credit card application form.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 &lt;html&gt;&lt;head&gt; &lt;TITLE&gt;Sample
Credit Form&lt;/TITLE&gt;<BR>
&nbsp;2 &lt;/head&gt;<BR>
&nbsp;3 <BR>
&nbsp;4 &lt;body&gt;<BR>
&nbsp;5 &lt;center&gt;&lt;h1&gt;Sample Credit Application Form&lt;/h1&gt;&lt;/center&gt;
<BR>
&nbsp;6 &lt;hr&gt;<BR>
&nbsp;7 &lt;FORM METHOD=&quot;POST&quot; ACTION=&quot;http://ikra.com/cgi-bin/credit.pl&quot;&gt;
<BR>
&nbsp;8&nbsp;&nbsp;First Name &lt;INPUT SIZE=20 NAME=&quot;fname&quot;&gt;
<BR>
&nbsp;9&nbsp;&nbsp;Last Name&nbsp;&nbsp;&lt;INPUT SIZE=20 NAME=&quot;lname&quot;&gt;
&lt;BR&gt;<BR>
10&nbsp;&nbsp;Social Security Number &lt;INPUT SIZE=12 NAME=&quot;ssn&quot;&gt;
<BR>
11&nbsp;&nbsp;Mom's Maiden Name &lt;INPUT SIZE=20 NAME=&quot;mname&quot;&gt;
&lt;BR&gt;<BR>
12 &lt;HR&gt;<BR>
13 &lt;H4&gt;Type of Cards Desired&lt;/H4&gt;<BR>
14 &lt;INPUT TYPE=&quot;CheckBox&quot; VALUE=&quot;VISA&quot;
NAME=&quot;visa&quot;&gt;VISA<BR>
15 &lt;INPUT TYPE=&quot;CheckBox&quot; VALUE=&quot;MCRD&quot;
NAME=&quot;mastercard&quot;&gt;Mastercard<BR>
16 &lt;P&gt;<BR>
17 &lt;HR&gt;<BR>
18 &lt;H4&gt;Number of Dependants&lt;/H4&gt;<BR>
19 &lt;SELECT NAME=&quot;dependants&quot; SIZE=&quot;1&quot;&gt;
<BR>
20 &lt;OPTION SELECTED&gt;1<BR>
21 &lt;OPTION&gt;2<BR>
22 &lt;OPTION&gt;3<BR>
23 &lt;OPTION&gt;4<BR>
24 &lt;OPTION&gt;5<BR>
25 &lt;OPTION&gt;6<BR>
26 &lt;/SELECT&gt;<BR>
27 &lt;HR&gt;<BR>
28 &lt;H4&gt;Yearly Income&lt;/H4&gt;<BR>
29 &lt;INPUT TYPE=&quot;Radio&quot; VALUE=&quot;1&quot; NAME=&quot;income&quot;&gt;0-10K
<BR>
30 &lt;INPUT TYPE=&quot;Radio&quot; VALUE=&quot;2&quot; NAME=&quot;income&quot;&gt;10-20K
<BR>
31 &lt;INPUT TYPE=&quot;Radio&quot; VALUE=&quot;3&quot; NAME=&quot;income&quot;&gt;20-30K
<BR>
32 &lt;INPUT TYPE=&quot;Radio&quot; VALUE=&quot;4&quot; NAME=&quot;income&quot;&gt;30-40K
<BR>
33 &lt;INPUT TYPE=&quot;Radio&quot; VALUE=&quot;5&quot; NAME=&quot;income&quot;&gt;40-50K
<BR>
34 &lt;INPUT TYPE=&quot;Radio&quot; VALUE=&quot;6&quot; NAME=&quot;income&quot;&gt;50K+
<BR>
35 &lt;HR&gt;<BR>
36&nbsp;&nbsp;&lt;INPUT TYPE=&quot;Reset&quot; VALUE=&quot;Clear
Form&quot;&gt;<BR>
37&nbsp;&nbsp;&lt;INPUT TYPE=&quot;Submit&quot; VALUE=&quot;Submit&quot;&gt;
<BR>
38&nbsp;&nbsp;&lt;/FORM&gt;<BR>
39 <BR>
40 &lt;/body&gt;&lt;/html&gt;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Here is the output from the <TT><FONT FACE="Courier">credit.pl</FONT></TT>
Perl script:
<P>
<TT><FONT FACE="Courier">=============================================</FONT></TT>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">SERVER_NAME = pop.ikra.com<BR>
REQUEST_METHOD = POST<BR>
SCRIPT_NAME = /cgi-bin/credit.pl<BR>
QUERY_STRING =<BR>
CONTENT_TYPE = application/x-www-form-urlencoded<BR>
CONTENT_LENGTH = 91<BR>
income is set to 5<BR>
ssn is set to 123-45-6789<BR>
lname is set to Doe<BR>
dependants is set to 4<BR>
mastercard is set to MCRD<BR>
mname is set to Jane Smith<BR>
fname is set to John</FONT></TT>
</BLOCKQUOTE>
<P>
In this output from the <TT><FONT FACE="Courier">POST</FONT></TT>
request, the <TT><FONT FACE="Courier">REQUEST_METHOD</FONT></TT>
is <TT><FONT FACE="Courier">POST</FONT></TT>, and the query string
is shown as empty! So where did all the user's input go? The input
has been pumped into the standard input of the Perl script. You
have to design your Perl script to pick the input from either
the <TT><FONT FACE="Courier">POST</FONT></TT> or <TT><FONT FACE="Courier">GET</FONT></TT>
requests automatically. Listing 22.5 illustrates how to process
both types of requests.
<HR>
<BLOCKQUOTE>
<B>Listing 22.5. The Perl script to handle </B><TT><B><FONT FACE="Courier">credit.html</FONT></B></TT><B>.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 #<BR>
&nbsp;3 # The sample script file to show difference in<BR>
&nbsp;4 # handling POST and GET requests.<BR>
&nbsp;5 #<BR>
&nbsp;6 #<BR>
&nbsp;7 $|=1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
Flush immediately.<BR>
&nbsp;8 print &quot;Content-Type: text/plain\n\n&quot;;<BR>
&nbsp;9 <BR>
10 <BR>
11 print &quot;\n=============================================\n&quot;;
<BR>
12 print &quot;SERVER_NAME = $ENV{'SERVER_NAME'}\n&quot;;<BR>
13 print &quot;REQUEST_METHOD = $ENV{'REQUEST_METHOD'}\n&quot;;
<BR>
14 print &quot;SCRIPT_NAME = $ENV{'SCRIPT_NAME'}\n&quot;;<BR>
15 print &quot;QUERY_STRING = $ENV{'QUERY_STRING'}\n&quot;;<BR>
16 print &quot;CONTENT_TYPE = $ENV{'CONTENT_TYPE'}\n&quot;;<BR>
17 print &quot;CONTENT_LENGTH = $ENV{'CONTENT_LENGTH'}\n&quot;;
<BR>
18 <BR>
19 if ( $ENV{'REQUEST_METHOD'} eq &quot;GET&quot; &amp;&amp;<BR>
20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ENV{'QUERY_STRING'} ne
'') {<BR>
21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$form = $ENV{'QUERY_STRING'};
<BR>
22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
23 elsif ( $ENV{'REQUEST_METHOD'} eq &quot;POST&quot; ) {<BR>
24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read(STDIN,$form, $ENV{'CONTENT_LENGTH'});
<BR>
25 } else {<BR>
26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n At least fill something!
I cannot work with empty strings&quot;;<BR>
27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit;<BR>
28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
29 <BR>
30 #<BR>
31 # Now the variable $form has your input data.<BR>
32 # Create your associative array.<BR>
33 #<BR>
34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach $pair (split('&amp;',
$form)) {<BR>
35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($pair
=~ /(.*)=(.*)/) {&nbsp;&nbsp;# found key=value;<BR>
36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;($key,$value)
= ($1,$2);&nbsp;&nbsp;&nbsp;&nbsp; # get key, value.<BR>
37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$value
=~ s/\+/ /g;&nbsp;&nbsp;# substitute spaces for + signs.<BR>
38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$value
=~ s/%(..)/pack('c',hex($1))/eg;<BR>
39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$inputs{$key}
= $value;&nbsp;&nbsp; # Create Associative Array.<BR>
40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
42&nbsp;<BR>
43 foreach $item (keys(%inputs)) {<BR>
44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;$item is set to $inputs{$item}\n&quot;;
<BR>
45 }<BR>
Lines 19 through 28 contain fragments of code that actually determine
where to pick up the input.</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Basically, this script handles the input for a <TT><FONT FACE="Courier">GET</FONT></TT>
request with non-empty input and a <TT><FONT FACE="Courier">POST</FONT></TT>
request with any input. At the end of this conditional, <TT><FONT FACE="Courier">$form</FONT></TT>
has the input string in a URL-encoded form. Obviously, this kind
of data handling is not acceptable in a real-life scenario. The
parsing of the incoming input to figure out if it's <TT><FONT FACE="Courier">POST</FONT></TT>
or <TT><FONT FACE="Courier">GET</FONT></TT> has to be done so
many times and in so many shell scripts that it's really a good
idea to simply write a subroutine that handles both types of processing.
Once you have such a subroutine defined, all you have to do is
simply include it in the rest of the CGI scripts to extract the
incoming parameters. 
<P>
In either case, the output of the Perl script is what is sent
back to the calling browser. In other words, all the words written
to <TT><FONT FACE="Courier">STDOUT</FONT></TT> (the default if
a file handle is not specified in the <TT><FONT FACE="Courier">print</FONT></TT>
statement) are sent the browser. In fact, the output is forced
to be flushed as soon as possible with the use of the <TT><FONT FACE="Courier">$|=1</FONT></TT>
command.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD ><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD >
<BLOCKQUOTE>
You have to deal with handling any errors in input. Imagine the type of input your script might receive if your user walks away from his desk and his three-year-old gets to do some typing! Always check for input into your CGI form. It's better to be safe 
than sorry.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
In Listing 22.5, lines 19 through 28 will parse the incoming parameters
into an associative array called <TT><FONT FACE="Courier">inputs</FONT></TT>.
Look at what you have parsed into the incoming <TT><FONT FACE="Courier">inputs</FONT></TT>
associative array from a test run. The output of what the values
that were entered in the form and sent to the script are set in
<TT><FONT FACE="Courier">inputs</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">%inputs{'income'} is set to 5<BR>
%inputs{'ssn'} is set to 123-45-6789<BR>
%inputs{'lname'} is set to Doe<BR>
%inputs{'dependants'} is set to 4<BR>
%inputs{'mastercard'} is set to MCRD<BR>
%inputs{'mname'} is set to Jane Smith<BR>
%inputs{'fname'} is set to John</FONT></TT>
</BLOCKQUOTE>
<P>
If you look at the HTML file that invoked this script, you'll
recognize some of the indices in the <TT><FONT FACE="Courier">%inputs</FONT></TT>
array. The keys used to index into the <TT><FONT FACE="Courier">%inputs</FONT></TT>
array were set in the HTML document. They have now been passed
into the Perl script for use. The<FONT FACE="AGaramond Bold">
</FONT><TT><FONT FACE="Courier">%inputs</FONT></TT><FONT FACE="AGaramond Bold">
</FONT>array now has all the values for you to work with.
<P>
Of course, you always have to check the incoming values to see
if they make sense. There are several ways to check the input
for your credit card application example. You could check if the
social security number has the right number of digits, if all
the fields were filled in, and so on. One possible way to check
the input is shown in Listing 22.7. Note how each variable is
tested for a range of values and to see if it's empty. In your
HTML pages and CGI scripts, you must check for missing or inconsistent
responses. Prepare for the worst-case scenario.
<P>
The tedious part is checking for all the possible responses that
your user can type in. Checking for non-zero responses, empty
strings, and out-of-range values takes time in execution and in
setting up tests. However, the time will be well spent if the
users of your page are not given <TT><FONT FACE="Courier">Server
Error</FONT></TT> messages, or, even worse, data on bad input
without even a whimper of an error message. This type of response
may lead to the user actually believing in the erroneous test
results.
<HR>
<BLOCKQUOTE>
<B>Listing 22.6. Checking for missing or inconsistent responses.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;&nbsp;2 #<BR>
&nbsp;&nbsp;3 # The sample script file to show difference in<BR>
&nbsp;&nbsp;4 # handling POST and GET requests.<BR>
&nbsp;&nbsp;5 #<BR>
&nbsp;&nbsp;6 #<BR>
&nbsp;&nbsp;7 <BR>
&nbsp;&nbsp;8 $|=1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
Flush immediately.<BR>
&nbsp;&nbsp;9 print &quot;Content-Type: text/plain\n\n&quot;;
<BR>
&nbsp;10 <BR>
&nbsp;11 print &quot;\n=============================================\n&quot;;
<BR>
&nbsp;12 print &quot;SERVER_NAME = $ENV{'SERVER_NAME'}\n&quot;;
<BR>
&nbsp;13 print &quot;REQUEST_METHOD = $ENV{'REQUEST_METHOD'}\n&quot;;
<BR>
&nbsp;14 print &quot;SCRIPT_NAME = $ENV{'SCRIPT_NAME'}\n&quot;;
<BR>
&nbsp;15 print &quot;QUERY_STRING = $ENV{'QUERY_STRING'}\n&quot;;
<BR>
&nbsp;16 print &quot;CONTENT_TYPE = $ENV{'CONTENT_TYPE'}\n&quot;;
<BR>
&nbsp;17 print &quot;CONTENT_LENGTH = $ENV{'CONTENT_LENGTH'}\n&quot;;
<BR>
&nbsp;18 print &quot;SERVER_NAME = $ENV{'SERVER_NAME'}\n&quot;;
<BR>
&nbsp;19 print &quot;\n=============================================\n&quot;;
<BR>
&nbsp;20 <BR>
&nbsp;21 $form = &amp;FormArgs;<BR>
&nbsp;22 if ($from eq &quot;0&quot; ) {<BR>
&nbsp;23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n At least
fill something! I cannot work with empty strings&quot;;<BR>
&nbsp;24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit;<BR>
&nbsp;25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;26 #<BR>
&nbsp;27 # Now the variable $form has your input data.<BR>
&nbsp;28 # Create your associative array.<BR>
&nbsp;29 #<BR>
&nbsp;30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach $pair (split('&amp;',
$form)) {<BR>
&nbsp;31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
($pair =~ /(.*)=(.*)/) {&nbsp;&nbsp;# found key=value;<BR>
&nbsp;32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;($key,$value)
= ($1,$2);&nbsp;&nbsp;&nbsp;&nbsp; # get key, value.<BR>
&nbsp;33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$value
=~ s/\+/ /g;&nbsp;&nbsp;# substitute spaces for + signs.<BR>
&nbsp;34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$value
=~ s/%(..)/pack('c',hex($1))/eg;<BR>
&nbsp;35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$inputs{$key}
= $value;&nbsp;&nbsp; # Create Associative Array.<BR>
&nbsp;36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;38 <BR>
&nbsp;39 $income = $inputs{&quot;income&quot;}; # Check if an
income value was selected.<BR>
&nbsp;40 if (($income &lt; 1) || ($income &gt; 6)) {<BR>
&nbsp;41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n Please specify
your income range&quot;;<BR>
&nbsp;42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit;<BR>
&nbsp;43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;44 <BR>
&nbsp;45 $ssn = $inputs{&quot;ssn&quot;};<BR>
&nbsp;46 <BR>
&nbsp;47 if ( $ssn =~ /[0-9]{3}-[0-9][0-9]-[0-9]{4}/)<BR>
&nbsp;48&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;49&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$snumber = $ssn;<BR>
&nbsp;50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$snumber =~ s/\-//g;<BR>
&nbsp;51&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;52 elsif ( $ssn =~ /[0-9]{9}/) {<BR>
&nbsp;53&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$snumber = $ssn;<BR>
&nbsp;54&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;55 else&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;56&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n Enter the
social security number in the form XXX-XX-XXXX&quot;;<BR>
&nbsp;57&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit;<BR>
&nbsp;58&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;59 $fname = $inputs{'fname'};<BR>
&nbsp;60 if ($fname eq &quot;&quot;) {<BR>
&nbsp;61&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n Please enter
your first name&quot;;<BR>
&nbsp;62&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit;<BR>
&nbsp;63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;64 <BR>
&nbsp;65 $lname = $inputs{'lname'};<BR>
&nbsp;66 if ($lname eq &quot;&quot;) {<BR>
&nbsp;67&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n Please enter
your last name&quot;;<BR>
&nbsp;68&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit;<BR>
&nbsp;69&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;70 <BR>
&nbsp;71 $mname = $inputs{'mname'};<BR>
&nbsp;72 if ($mname eq &quot;&quot;) {<BR>
&nbsp;73&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n Your mother's
maiden name is required&quot;;<BR>
&nbsp;74&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit;<BR>
&nbsp;75&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;76 <BR>
&nbsp;77 $dependants = $inputs{'dependants'};<BR>
&nbsp;78 if ($dependants &lt; 1) {<BR>
&nbsp;79&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n Now, now,
we have to be dependant on ourselves.&quot;;<BR>
&nbsp;80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit;<BR>
&nbsp;81&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;82 <BR>
&nbsp;83 #if ($dependants &gt; 10) {<BR>
&nbsp;84&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#print &quot;\n Would you
like me to contact the IRS for you?&quot;;<BR>
&nbsp;85&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#exit;<BR>
&nbsp;86&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#}<BR>
&nbsp;87 #<BR>
&nbsp;88 #<BR>
&nbsp;89 $visa = $inputs{'visa'};<BR>
&nbsp;90 $mastercard = $inputs{'mastercard'};<BR>
&nbsp;91 <BR>
&nbsp;92 if ($visa eq &quot;&quot; &amp;&amp;&nbsp;&nbsp;$mastercard
eq &quot;&quot;) {<BR>
&nbsp;93&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n At least
pick one card ! &quot;;<BR>
&nbsp;94&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit;<BR>
&nbsp;95&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;96 <BR>
&nbsp;97 exit;<BR>
&nbsp;98 <BR>
&nbsp;99 #------------------ explicitly bailout ----------------
<BR>
100 <BR>
101 #<BR>
102 # A simple subroutine to briefly test incoming input<BR>
103 #<BR>
104 sub FormArgs {<BR>
105 <BR>
106&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( $ENV{'REQUEST_METHOD'} eq
&quot;GET&quot; &amp;&amp;<BR>
107&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ENV{'QUERY_STRING'}
ne '') {<BR>
108&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$form = $ENV{'QUERY_STRING'};
<BR>
109&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$form; # return value is true.
<BR>
110&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
111&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elsif ( $ENV{'REQUEST_METHOD'}
eq &quot;POST&quot; &amp;&amp;<BR>
112&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ENV{'CONTENT_LENGTH'}
ne '0') {<BR>
113&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read(STDIN,$form, $ENV{'CONTENT_LENGTH'});
<BR>
114&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$form; # return value is true,
continue<BR>
115 } else {<BR>
116&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;0&quot;; # Unable to process
<BR>
117&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
118&nbsp;<BR>
119&nbsp;}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The code in line 8 makes the call to the <TT><FONT FACE="Courier">FormArgs</FONT></TT>
function which extracts all the arguments into an associative
array and returns a value of true if any arguments were extracted
or not. If no values were extracted, the code in line 22 will
bail the program out with an error message. 
<P>
The loop defined in lines 30 through 37 splits the incoming string
and places all the <TT><I><FONT FACE="Courier">variable=value</FONT></I></TT>
pairs into the <TT><FONT FACE="Courier">%inputs</FONT></TT> array.
Recall that the input string is in the form <TT><I><FONT FACE="Courier">var1=value1+subvalue1&amp;var2=value</FONT></I></TT>
and so on. Spaces are converted to + signs, each assignment is
separated from the other using an ampersand. 
<P>
The code in line 30 splits each assignment that is delimited by
ampersands. Then each element is placed in the <TT><FONT FACE="Courier">$pair</FONT></TT>
variable for use in the <TT><FONT FACE="Courier">for&#133;each</FONT></TT>
loop statements. In line 31, the element in the <TT><FONT FACE="Courier">$pair</FONT></TT>
variable is examined to see if it has the form <TT><FONT FACE="Courier">variable=value</FONT></TT>,
that is there is a word on either side of an equal sign within
the contents of the <TT><FONT FACE="Courier">$pair</FONT></TT>
variable. 
<P>
If an assignment is found, the code in line 32 extracts the name
of the variable being assigned to into the <TT><FONT FACE="Courier">$key</FONT></TT>
variable, and the value in the <TT><FONT FACE="Courier">$value</FONT></TT>
variable. The contents of the <TT><FONT FACE="Courier">$key</FONT></TT>
variable will be used to index into the <TT><FONT FACE="Courier">%inputs</FONT></TT>
array during the rest of the program. The contents of the <TT><FONT FACE="Courier">$value</FONT></TT>
variable will be that in the <TT><FONT FACE="Courier">$pair</FONT></TT>
variable. The extra plus (+) signs are replaced with spaces in
line 33. The line is terminated in line 34. Finally in line 35
we actually index into the <TT><FONT FACE="Courier">%inputs</FONT></TT>
array to assign a value using the <TT><FONT FACE="Courier">$key</FONT></TT>
value extracted in line 32. 
<P>
The rest of the lines of code (lines 38 to 71) are pretty straightforward
in the way they check for blank or incorrect input value. Of particular
interest is how the social security number is interpreted in this
script (see line 47). The number can be read in from the user
as <TT><I><FONT FACE="Courier">XXX-XX-XXXX</FONT></I></TT>, where
(<TT><I><FONT FACE="Courier">X</FONT></I></TT> is a decimal digit
from 0 to 9), or as a string of nine decimal digits <TT><I><FONT FACE="Courier">XXXXXXXXX</FONT></I></TT>.
This situation has been taken care of with the two conditions
for the regular expressions.
<P>
A social security number is quite meaningless to someone who lives
outside of the United States. When designing pages that are user
specific or where the country of origin matters, it's best to
either provide a warning or an alternative page. How would you
handle a phone number in this scenario? Phone numbers in the United
States are assigned in a different way than they are in a foreign
country. When designing HTML pages, you have to keep these sensitive
and important internationalization factors in mind.
<H2><A NAME="ReturningHTMLPages"><B><FONT SIZE=5 COLOR=#FF0000>Returning
HTML Pages</FONT></B></A></H2>
<P>
So far I have dealt only with returning messages back in the form
of text data. The beauty of CGI is the ability to send back custom
HTML pages in response to your requests. Instead of sending back
a content-type of <TT><FONT FACE="Courier">plain</FONT></TT>,
you send back a type of <TT><FONT FACE="Courier">html</FONT></TT>.
This is done with the following statement:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">print &quot;Content-type: text/html\n\n&quot;;</FONT></TT>
</BLOCKQUOTE>
<P>
It's your responsibility to make sure that your script sends back
a valid HTML page regardless of how badly the input is messed
up. The returned page should have the correct <TT><FONT FACE="Courier">&lt;HTML&gt;&lt;/HTML&gt;</FONT></TT>
tags and should be syntactically correct. Remember that the browser
will be expecting an HTML page as soon as it sees the context
type of <TT><FONT FACE="Courier">html</FONT></TT>. Don't forget
the extra empty line. Also, remember to use <TT><FONT FACE="Courier">\n\n</FONT></TT>
to terminate the string.
<P>
Refer to the code in Listing 22.7 to see how the error message
is constructed from an empty string. Basically, the very first
error that occurs is being reported (rather than flooding the
user's screen with a page full of error messages). Naturally,
this is a design decision that you have to make as you design
your HTML pages. Do you inform the user only of the first error,
or do you tell him or her about every conceivable error that has
occurred with the input? Pouring on too many error messages will
only serve to annoy or confuse the user. 
<HR>
<BLOCKQUOTE>
<B>Listing 22.7. Send back an HTML page.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;&nbsp;1 #<BR>
&nbsp;&nbsp;2 #!/usr/bin/perl # # The sample script file to show
difference in<BR>
&nbsp;&nbsp;3 # handling POST and GET requests.<BR>
&nbsp;&nbsp;4 #<BR>
&nbsp;&nbsp;5 #<BR>
&nbsp;&nbsp;6 <BR>
&nbsp;&nbsp;7 $|=1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
Flush immediately.<BR>
&nbsp;&nbsp;8 <BR>
&nbsp;&nbsp;9 ##<BR>
&nbsp;10 ## THE NEXT LINE IS DIFFERENT FROM THE PREVIOUS<BR>
&nbsp;11 ## SCRIPTS:<BR>
&nbsp;12 print &quot;Content-type: text/html\n\n&quot;;<BR>
&nbsp;13 <BR>
&nbsp;14 $form = &amp;FormArgs;<BR>
&nbsp;15 if ($from eq &quot;0&quot; ) {<BR>
&nbsp;16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n At least
fill something! I cannot work with empty strings&quot;;<BR>
&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto BAILOUT;<BR>
&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;19 #<BR>
&nbsp;20 # Now the variable $form has your input data.<BR>
&nbsp;21 # Create your associative array.<BR>
&nbsp;22 #<BR>
&nbsp;23&nbsp;&nbsp;&nbsp;&nbsp; foreach $pair (split('&amp;',
$form)) {<BR>
&nbsp;24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
($pair =~ /(.*)=(.*)/) {&nbsp;&nbsp;# found key=value;<BR>
&nbsp;25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;($key,$value)
= ($1,$2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# get key, value.<BR>
&nbsp;26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$value
=~ s/\+/ /g;&nbsp;&nbsp;# substitute spaces for + signs.<BR>
&nbsp;27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$value
=~ s/%(..)/pack('c',hex($1))/eg;<BR>
&nbsp;28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$inputs{$key}
= $value;&nbsp;&nbsp;&nbsp;# Create Associative Array.<BR>
&nbsp;29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;31 <BR>
&nbsp;32 $error = &quot;&quot;;&nbsp;&nbsp;## No errors to start
with<BR>
&nbsp;33 <BR>
&nbsp;34 $income = $inputs{&quot;income&quot;}; # Check if an
income value was selected.<BR>
&nbsp;35 if (($income &lt; 1) || ($income &gt; 6)) {<BR>
&nbsp;36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$error = &quot;Please specify
your income range&quot;;<BR>
&nbsp;37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;38 <BR>
&nbsp;39 $ssn = $inputs{&quot;ssn&quot;};<BR>
&nbsp;40 <BR>
&nbsp;41 if (error eq &quot;&quot;) {<BR>
&nbsp;42 if ($ssn =~ /[0-9]{3}-[0-9][0-9]-[0-9]{4}/)<BR>
&nbsp;43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$snumber = $ssn;<BR>
&nbsp;45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$snumber =~ s/\-//g;<BR>
&nbsp;46&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;47 elsif ( $ssn =~ /[0-9]{9}/) {<BR>
&nbsp;48&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$snumber = $ssn;<BR>
&nbsp;49&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;50 else&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
&nbsp;51&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$error = &quot;Enter the
social security number in the form XXX-XX-XXXX&quot;;<BR>
&nbsp;52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;53 }<BR>
&nbsp;54 <BR>
&nbsp;55 $fname = $inputs{'fname'};<BR>
&nbsp;56 if ($fname eq &quot;&quot;&nbsp;&nbsp;&amp;&amp; error
eq &quot;&quot;) {<BR>
&nbsp;57&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$error =&nbsp;&nbsp;&quot;Please
enter your first name&quot;;<BR>
&nbsp;58&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;59 <BR>
&nbsp;60 $lname = $inputs{'lname'};<BR>
&nbsp;61 if ($lname eq &quot;&quot; &amp;&amp; $error eq &quot;&quot;)
{<BR>
&nbsp;62&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$error =&nbsp;&nbsp;&quot;Please
enter your last name&quot;;<BR>
&nbsp;63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;64 <BR>
&nbsp;65 $mname = $inputs{'mname'};<BR>
&nbsp;66 if ($mname eq &quot;&quot; &amp;&amp; $error eq &quot;&quot;)
{<BR>
&nbsp;67&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$error = &quot;Your mother's
maiden name is required&quot;;<BR>
&nbsp;68&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;69 <BR>
&nbsp;70 $dependents = $inputs{'dependents'};<BR>
&nbsp;71 if ($dependents &lt; 1 &amp;&amp; $error eq&nbsp;&nbsp;&quot;&quot;)
{<BR>
&nbsp;72&nbsp;&nbsp;&nbsp;&nbsp; print &quot;Now, now, we have
to be dependent on ourselves.&quot;;<BR>
&nbsp;73&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto BAILOUT;<BR>
&nbsp;74&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;75 <BR>
&nbsp;76 #<BR>
&nbsp;77 #<BR>
&nbsp;78 $visa = $inputs{'visa'};<BR>
&nbsp;79 $mastercard = $inputs{'mastercard'};<BR>
&nbsp;80 <BR>
&nbsp;81 if ($error eq &quot;&quot;) {<BR>
&nbsp;82 if ($visa eq &quot;&quot; &amp;&amp;&nbsp;&nbsp;$mastercard
eq &quot;&quot;) {<BR>
&nbsp;83&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$error = &quot;At least
pick one card ! &quot;;<BR>
&nbsp;84&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;85 }<BR>
&nbsp;86 <BR>
&nbsp;87 print &lt;&lt;&quot;HTMLHEAD&quot;;<BR>
&nbsp;88 &lt;HTML&gt;&lt;TITLE&gt;This is a test&lt;/TITLE&gt;
<BR>
&nbsp;89 &lt;BODY&gt;<BR>
&nbsp;90 &lt;p&gt;<BR>
&nbsp;91 HTMLHEAD<BR>
&nbsp;92 <BR>
&nbsp;93 if ($error eq &quot;&quot;)<BR>
&nbsp;94&nbsp;&nbsp;&nbsp;&nbsp; {<BR>
&nbsp;95&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n &lt;H2&gt;Congratulations!&lt;/H2&gt;
&quot;;<BR>
&nbsp;96&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;&lt;P&gt;Your
application has been accepted&quot;;<BR>
&nbsp;97&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;&lt;P&gt;We
will be living off your interest payments shortly&quot;;<BR>
&nbsp;98&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;99 else<BR>
100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
101&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n &lt;H2&gt;Error!&lt;/H2&gt;
&quot;;<BR>
102&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n &lt;P&gt;$error&lt;P&gt;&quot;;
<BR>
103&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n &lt;P&gt;Please
correct the error and retry&quot;;<BR>
104&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
105 <BR>
106 #<BR>
107 print &lt;&lt;&quot;HTML&quot;;<BR>
108 &lt;p&gt;<BR>
109 &lt;A HREF=&quot;http://www.ikra.com/credit.html&quot;&gt;Restart&lt;/A&gt;
<BR>
110 &lt;A HREF=&quot;http://www.ikra.com/index.html&quot;&gt;Home
Page&lt;/A&gt;<BR>
111 &lt;p&gt;<BR>
112 &lt;/BODY&gt;&lt;/HTML&gt;<BR>
113 <BR>
114 HTML<BR>
115 <BR>
116 exit;<BR>
117 <BR>
118 #<BR>
119 # A simple subroutine to briefly test incoming input<BR>
120 #<BR>
121 sub FormArgs {<BR>
122 <BR>
123&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( $ENV{'REQUEST_METHOD'} eq
&quot;GET&quot; &amp;&amp;<BR>
124&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ENV{'QUERY_STRING'}
ne '') {<BR>
125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$form = $ENV{'QUERY_STRING'};
<BR>
126&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$form; # return value is true.
<BR>
127&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elsif ( $ENV{'REQUEST_METHOD'}
eq &quot;POST&quot; &amp;&amp;<BR>
129&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ENV{'CONTENT_LENGTH'}
ne '0') {<BR>
130&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read(STDIN,$form, $ENV{'CONTENT_LENGTH'});
<BR>
131&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$form; # return value is true,
continue<BR>
132 } else {<BR>
133&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;0&quot;; # Unable to process
<BR>
134&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
135 <BR>
136 }</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
This script produces the header for the HTML header and body first
with the code in lines 87 through 91. Line 87 asks Perl to print
everything until the string <TT><FONT FACE="Courier">HTMLHEAD</FONT></TT>
is found by itself on a line. Line 88 starts a new HTML page,
followed by the start of the body of the page with the <TT><FONT FACE="Courier">&lt;BODY&gt;</FONT></TT>
tag, and then a blank line with the <TT><FONT FACE="Courier">&lt;P&gt;</FONT></TT>
tag. Note that I did not use the <TT><FONT FACE="Courier">&lt;TITLE&gt;</FONT></TT>
and <TT><FONT FACE="Courier">&lt;/TITLE&gt;</FONT></TT> tag pair.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">print &lt;&lt;&quot;HTMLHEAD&quot;;&lt;HTML&gt;&lt;TITLE&gt;This
is a test&lt;/TITLE&gt;<BR>
&lt;BODY&gt;<BR>
&lt;p&gt;<BR>
HTMLHEAD</FONT></TT>
</BLOCKQUOTE>
<P>
Then, the script examines the <TT><FONT FACE="Courier">$error</FONT></TT>
string to see if it had any problems listed in it. If no problems
are seen (that is, the <TT><FONT FACE="Courier">$error</FONT></TT>
string is empty), then the script accepts this input and prints
out an acknowledgment. On the other hand, if there are some problems,
then the script prints out the value of <TT><FONT FACE="Courier">$error</FONT></TT>
to show what the errors are and print those out instead.
<P>
At this point, the script can write out HTML tags and text for
sending back the content of an HTML page to the browser. Regardless
of what the result of <TT><FONT FACE="Courier">action</FONT></TT>
is, you have to close out the HTML output with the <TT><FONT FACE="Courier">&lt;/BODY&gt;</FONT></TT>
and <TT><FONT FACE="Courier">&lt;/HTML&gt;</FONT></TT> tags. Then
you are done. The response is sent back to the browser, and you
can safely exit.
<P>
Perl gives you, as a programmer, enormous flexibility and power
to control how you handle responses and echo back messages. I
used the construct <TT><FONT FACE="Courier">print &lt;&lt; &quot;HTML&quot;</FONT></TT>.
Anything from that statement on will be printed to <TT><FONT FACE="Courier">STDOUT</FONT></TT>
(standard output of the script or until the end of file), until
either that <TT><FONT FACE="Courier">exit</FONT></TT> statement
or the word <TT><FONT FACE="Courier">HTML</FONT></TT> is found
by itself on one line.
<H2><A NAME="UsingtheCollectedData"><B><FONT SIZE=5 COLOR=#FF0000>Using
the Collected Data</FONT></B></A></H2>
<P>
So far, you've been able to collect the incoming data from the
user and verify that it is correct for the HTML <TT><FONT FACE="Courier">FORM</FONT></TT>
you are supporting. Now the question is what can you do with the
collected data? Well, basically anything you want, because it's
local to your script now. Two of the most common actions you might
want to take with this data is to archive it to disk or mail the
contents as a message to someone.
<H3><A NAME="ArchivingUserResponses"><B>Archiving User Responses</B></A>
</H3>
<P>
The archival process to store the incoming data can be done in
many different ways. You can use the incoming name and other information
to store values in a text string or a database. Using the techniques
covered in <A HREF="ch18.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch18.htm" >Chapter 18</A>, &quot;Databases
for Perl,&quot; you can construct your own database. At the very
least, you can archive the responses in a plain text file by appending
them to an existing file.
<P>
A simple solution is to use the following lines to write them
all out. It'll be one long text file. 
<BLOCKQUOTE>
<TT><FONT FACE="Courier">open (MYARchIVE,&quot;applicants&quot;,
0666) || die &quot;Cannot open Archive&quot;;<BR>
print MYARchIVE &quot;SOR&quot;;<BR>
print MYARchIVE &quot;$inputs{'income'} &quot;;<BR>
print MYARchIVE &quot;$inputs{'ssn'} &quot;;<BR>
print MYARchIVE &quot;$inputs{'lname'} &quot;;<BR>
print MYARchIVE &quot;$inputs{'dependants'}&quot;;<BR>
print MYARchIVE &quot;$inputs{'mastercard'} &quot;;<BR>
print MYARchIVE &quot;$inputs{'mname'} &quot;;<BR>
print MYARchIVE &quot;$inputs{'fname'} &quot;;<BR>
print MYARchIVE &quot;EOR&quot;;<BR>
close MYARchIVE;</FONT></TT>
</BLOCKQUOTE>
<P>
Using a crude method like this might get you by if you have only
a few applicants. The <BR>
appended, plain text file might be hard to manage and search.
This method for storing user responses certainly won't handle
multiple applications by the same individual. What you probably
want to do is to store the information in some sort of database
file. Look at <A HREF="ch18.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch18.htm" >Chapter 18</A> for information
on using free databases generated by DBM (the database management
utilities supplied with Perl) or using commercial database applications
such as Oracle, Sybase, Informix, and so on, which you can access
from within a Perl script using the DBI (database interface).
<P>
For a commercial application, you're better off using an existing
database from Oracle, dBASE, or some other commercial database
management system. With a commercial system you're able to use
the DBI to take advantage of particular features of that database.
<P>
Perl comes with several modules, including GDBM, NDBM, and SDBM.
For the purpose of illustration, they are functionally the same,
so I'll use GDBM. This will help keep the focus on how to handle
data from within a CGI script, rather than going off into a tutorial
on databases.
<P>
In this script, you'll use the <TT><FONT FACE="Courier">GDBM_File.pm</FONT></TT>
module with the following line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">use GDBM_File;</FONT></TT>
</BLOCKQUOTE>
<P>
All Perl modules end with the <TT><FONT FACE="Courier">.pm</FONT></TT>
extension; the <TT><FONT FACE="Courier">use</FONT></TT> command
does not require that this be specified. To see if you have the
module in your system, look in the <TT><FONT FACE="Courier">/usr/lib/perl5</FONT></TT>
directory for all the files ending <TT><FONT FACE="Courier">*.pm</FONT></TT>.
<P>
Next, you have to figure out how to store the users' responses
in this database. An almost-unique key for this application is
the user's <TT><FONT FACE="Courier">$ssn</FONT></TT> field. Perhaps
you can create the index by concatenation of the <TT><FONT FACE="Courier">$ssn</FONT></TT>
field with the last name (<TT><FONT FACE="Courier">$lname</FONT></TT>).
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$appIndex= $lname . $ssn;</FONT></TT>
</BLOCKQUOTE>
<P>
Using this <TT><FONT FACE="Courier">$appIndex</FONT></TT> variable,
you can index into your sample database, which is called <TT><FONT FACE="Courier">applicants.dbm</FONT></TT>.
Create this database first and then associate it with the <TT><FONT FACE="Courier">%applicants</FONT></TT>
associative array. That way, if the applicant has already applied
for credit, you can give him or her an error message or proceed
with updating his or her information. The action to take is really
up to you. The following snippet of code shows how to use DBM
to track applicants:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">dbmopen(%applicants,&quot;applicants.dbm&quot;,
0666);<BR>
if ($applicants{$appIndex} eq &quot;&quot;) {<BR>
$error = &quot;You have already applied for credit. We get back
to you&quot;;<BR>
}<BR>
else {<BR>
$applicants{$appIndex}= $form;<BR>
}<BR>
dbmclose(%applicants);</FONT></TT>
</BLOCKQUOTE>
<P>
Basically, you are saving the query string in <TT><FONT FACE="Courier">$form</FONT></TT>
for future use. Any other script reading the <TT><FONT FACE="Courier">applicants.dbm</FONT></TT>
file will have to break this string apart to get the individual
words, just like in the <TT><FONT FACE="Courier">credit.pl</FONT></TT>
script.
<H3><A NAME="ForwardingUserResponses"><B>Forwarding User Responses</B></A>
</H3>
<P>
Another alternative use of the incoming data is to mail the bulk
of the information to another user. This feature is invaluable
for firms that provide services on the Internet. For example,
you could send a mail message to the sales representative for
a mail-order firm when a <TT><FONT FACE="Courier">FORM</FONT></TT>
is filled out, or you could send the contents of a bug report
<TT><FONT FACE="Courier">FORM</FONT></TT> to a help desk representative-basically,
whenever someone fills out your <TT><FONT FACE="Courier">FORM</FONT></TT>
and you get a mail message saying that they want more information.
<P>
Now you can incorporate the mail feature in the Perl script you've
been working with. Look at the section of code you have to add
to get this &quot;mail back&quot; feature. The mail can be sent
just before you exit instead of updating your internal database.
append the following snippet of code to Listing 22.9 to add the
mailing feature to your CGI script:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$subject = &quot;Credit Application for
&quot; . $fname . &quot; &quot; . $lname;<BR>
$sendto&nbsp;&nbsp;= &quot;credit_rep@big.rich.bank.com&quot;;
<BR>
$fullname =&nbsp;&nbsp;$fname . &quot; &quot; . $lname;<BR>
$cardDesired = $mastercard . &quot; &quot; . $visa ;<BR>
#<BR>
# open pipe to send mail to .<BR>
<BR>
open (MAIL,&quot;| /usr/bin/sendmail $sendto&quot;) || die &quot;
Mail does not work!&quot;;<BR>
<BR>
select(MAIL);&nbsp;&nbsp;# Now all the output will go MAIL<BR>
<BR>
$date = `date`;<BR>
chop $date;<BR>
<BR>
print &lt;&lt; &quot;EMAIL&quot;;<BR>
Date: $date<BR>
From: $user@using.browser.com<BR>
To: $sendto<BR>
Subject: $subject<BR>
<BR>
Name = $fullname<BR>
Card Desired = $cardDesired<BR>
<BR>
Number of Dependents = $dependents<BR>
Income Level = $income<BR>
Date of application = $date<BR>
<BR>
Please contact them at your convenience,<BR>
Sincerely<BR>
Your Dearly Beloved Web Server<BR>
EMAIL<BR>
<BR>
#<BR>
# Do other processing here.<BR>
# Print out to MAIL if you have to.<BR>
#<BR>
<BR>
close(MAIL);&nbsp;&nbsp;# send mail<BR>
<BR>
#<BR>
# ... continue processing if you have to or exit.<BR>
#<BR>
exit(0);</FONT></TT>
</BLOCKQUOTE>
<P>
There are a few points to note concerning the script shown above.
First, a UNIX pipe is opened to the <TT><FONT FACE="Courier">sendmail</FONT></TT>
program. The <TT><FONT FACE="Courier">|</FONT></TT> character
in the filename argument tells Perl to open a pipe, not a regular
file. Refer to <A HREF="ch14.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch14.htm" >Chapter 14</A>, &quot;Signals,
Pipes, FIFOs, and Perl,&quot; for more information. Now all the
text sent to the <TT><FONT FACE="Courier">MAIL</FONT></TT> handle
will be sent to the program at the end of the pipe. In this case,
the program at the end of the pipe is the <TT><FONT FACE="Courier">sendmail</FONT></TT>
program.
<P>
The <TT><FONT FACE="Courier">select(MAIL);</FONT></TT> statement
selects <TT><FONT FACE="Courier">MAIL</FONT></TT> as the default
file handle for all the output. This is simply a convenience for
me as a script writer. If I do not do this, my <TT><FONT FACE="Courier">print</FONT></TT>
statements would all have to be of the form <TT><FONT FACE="Courier">print</FONT></TT>
<TT><FONT FACE="Courier">MAIL</FONT></TT>. If I inadvertently
forget to specify a <TT><FONT FACE="Courier">MAIL</FONT></TT>
handle in a <TT><FONT FACE="Courier">print</FONT></TT> statement,
it will be sent to <TT><FONT FACE="Courier">STDOUT</FONT></TT>
and not <TT><FONT FACE="Courier">MAIL</FONT></TT>. You can elect
not to use this method.
<P>
The statement for the <TT><FONT FACE="Courier">From</FONT></TT>
field in the mail message is hardwired to <TT><FONT FACE="Courier">From:
user@using.browser.com</FONT></TT>. You can add fields in your
HTML <TT><FONT FACE="Courier">FORM</FONT></TT> to accept a return
mail address and collect it in a field called <TT><FONT FACE="Courier">$returnAddress</FONT></TT>.
This way, the reply to this mail message is sent directly to the
user. The line of code to set the return address looks like this:
<TT><FONT FACE="Courier">From: $returnAddress</FONT></TT>.
<P>
It would be nice to show the date of the application relative
to the server. (The applicant could be on the other side of the
world for all you know.) The <TT><FONT FACE="Courier">chop</FONT></TT>
command gets rid of the carriage return at the end of the line
returned from the <TT><FONT FACE="Courier">date</FONT></TT> command.
<P>
The <TT><FONT FACE="Courier">close(MAIL)</FONT></TT> call terminates
the input to the <TT><FONT FACE="Courier">sendmail</FONT></TT>
program, which in turn sends the mail out. You can select <TT><FONT FACE="Courier">(STDIN)</FONT></TT>
again at this point or bail out.
<H2><A NAME="Summary"><B><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></B></A>
</H2>
<P>
This chapter covered how to write HTML <TT><FONT FACE="Courier">FORM</FONT></TT>
pages and how to write CGI scripts for handling input. There are
two methods used for querying information from an HTML script:
<TT><FONT FACE="Courier">GET</FONT></TT> and <TT><FONT FACE="Courier">POST</FONT></TT>.
The <TT><FONT FACE="Courier">GET</FONT></TT> method sends the
data collected from the <TT><FONT FACE="Courier">FORM</FONT></TT>
in the environment variable called <TT><FONT FACE="Courier">QUERY_STRING</FONT></TT>.
The <TT><FONT FACE="Courier">POST</FONT></TT> method sends the
data in via the standard input <TT><FONT FACE="Courier">(STDIN)</FONT></TT>
to the script, and the length of the input is set in the <TT><FONT FACE="Courier">CONTENT_LENGTH</FONT></TT>
environment variable. Spaces within a value, when passed as an
argument to the script handling the input, are shown as plus signs
(<TT><FONT FACE="Courier">+</FONT></TT>). Different assignments
to a variable are separated by ampersands (<TT><FONT FACE="Courier">&amp;</FONT></TT>).
<P>
The CGI script can process the input by verifying it for acceptable
parameters and return replies in the form of HTML pages or plain
text. The CGI script then can store the data away in a database,
mail the results to someone else, or both.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch21.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch21.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch23.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch23.htm"><IMG 
SRC="nc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>
