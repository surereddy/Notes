<HTML>

<HEAD>
   <TITLE>Chapter 10 -- Win32 Modules on Windows NT </TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT COLOR=#FF0000>Chapter 10</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Win32 Modules on Windows NT </FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#TheWin32Module" >The Win32 Module</A>
<LI><A HREF="#TheProcessModuleExtensions" >The Process Module Extensions</A>
<LI><A HREF="#TheKillMethod" >The Kill Method</A>
<UL>
<LI><A HREF="#TheResumeandSuspendMethods" >The Resume and Suspend Methods</A>
<LI><A HREF="#TheGetExitCodeFunction" >The GetExitCode() Function</A>
<LI><A HREF="#TheWaitTimeoutFunction" >The Wait($Timeout) Function</A>
<LI><A HREF="#ClassPriority" >Class Priority</A>
</UL>
<LI><A HREF="#TheWin32SemaphoreUtilities" >The Win32::Semaphore Utilities</A>
<LI><A HREF="#UsingMutexwithWin32Mutex" >Using Mutex with Win32::Mutex</A>
<LI><A HREF="#UsingWin32ChangeNotification" >Using Win32::ChangeNotification</A>
<LI><A HREF="#TheWin32EventlogModule" >The Win32::Eventlog Module</A>
<UL>
<LI><A HREF="#ReadingEvents" >Reading Events</A>
<LI><A HREF="#ReportingtheContentsofanEvent" >Reporting the Contents of an Event</A>
</UL>
<LI><A HREF="#TheWin32RegistryModule" >The Win32::Registry Module</A>
<LI><A HREF="#TheWin32NetAdminModule" >The Win32::NetAdmin Module</A>
<UL>
<LI><A HREF="#AddingaUser" >Adding a User</A>
<LI><A HREF="#CreatingorDeletingaGroup" >Creating or Deleting a Group</A>
<LI><A HREF="#CommentsAboutaGroup" >Comments About a Group</A>
<LI><A HREF="#AddingUserstoaGroup" >Adding Users to a Group</A>
<LI><A HREF="#RemovingUsersfromaGroup" >Removing Users from a Group</A>
<LI><A HREF="#CheckingGroupMembership" >Checking Group Membership</A>
<LI><A HREF="#ListingGroupMembers" >Listing Group Members</A>
</UL>
<LI><A HREF="#UsingtheWin32ServiceModule" >Using the Win32::Service Module</A>
<LI><A HREF="#UsingtheWin32NetResourceModule" >Using the Win32::NetResource Module</A>
<LI><A HREF="#HandlingInputfromMultipleSources" >Handling Input from Multiple Sources</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
In the previous chapter I covered details on getting and installing
Perl for Windows NT. In this chapter I cover the methods and functions
of some of the <TT><FONT FACE="Courier">Win32</FONT></TT> modules
that come with the NT Perl package.
<P>
Although this chapter covers details of how to make calls into
the Windows 32 bit API, I do not go into the details of how the
module itself works as it interacts with the API. Dealing with
that topic would be well beyond the scope of this book. To get
a good understanding of how to program an NT application, check
out Jason Loveman's <I>Moving to Windows NT Programming</I>, Sams
Publishing. This book may seem a bit dated at first, but it provides
an excellent tutorial on how to get going from a Windows 3.<I>x</I>
environment to NT. The other book that is a must-have is <I>The
Win32 API Desktop Reference</I> by Jim McCord, also from Sams
Publishing. This book is a comprehensive reference manual with
a bit of instruction on how to program without the benefit of
the Microsoft Foundation Classes.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD ><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD >
<BLOCKQUOTE>
Remember from the previous chapter that to execute a Perl script, you must type the <TT><FONT FACE="Courier">perl</FONT></TT> command on the prompt with the name of the Perl script:<BR>
<TT><FONT FACE="Courier">c:\dos&gt; perl myscript.pl</FONT></TT>
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="TheWin32Module"><FONT SIZE=5 COLOR=#FF0000>The Win32
Module</FONT></A></H2>
<P>
The Win32 module contains extensions for working specifically
with the Windows NT system. Here are some miscellaneous functions
that exist only under the Windows NT hierarchy-you'll find them
quite useful when writing Perl scripts under NT:
<UL>
<LI><TT><FONT FACE="Courier">Win32::GetLastError</FONT></TT>.
Returns the last error value generated by a call to a Win32 API
function.
<LI><TT><FONT FACE="Courier">Win32::PerlVersion</FONT></TT>. Returns
a string indicating the version of NT Perl.
<LI><TT><FONT FACE="Courier">Win32::LoginName</FONT></TT>. Returns
the name of the user running the current Perl process.
<LI><TT><FONT FACE="Courier">Win32::NodeName</FONT></TT>. Returns
the NT node name of the current machine.
<LI><TT><FONT FACE="Courier">Win32::DomainName</FONT></TT>. Returns
the domain name of the computer that the owner of the current
Perl process is logged into.
<LI><TT><FONT FACE="Courier">Win32::FsType</FONT></TT>. Returns
a string with the name of the underlying file system.
<LI><TT><FONT FACE="Courier">Win32::GetCwd</FONT></TT>. Returns
the current drive only. This function does not return a path.
<LI><TT><FONT FACE="Courier">Win32::GetOSVersion</FONT></TT>.
Returns an array in the form (<TT><FONT FACE="Courier">$description,
$major, $minor, $build, $id</FONT></TT>), which contains the following
items: an arbitrary descriptive string, followed by the major,
minor, and build numbers of the operating system. The <TT><FONT FACE="Courier">$id</FONT></TT>
is a digit with a code of the actual operating system. The values
of <TT><FONT FACE="Courier">$id</FONT></TT> are <TT><FONT FACE="Courier">0</FONT></TT>
for generic Win32, <TT><FONT FACE="Courier">1</FONT></TT> for
Windows 95, and <TT><FONT FACE="Courier">2</FONT></TT> for Windows
NT.
<LI><TT><FONT FACE="Courier">Win32::FormatMessage ERRORCODE</FONT></TT>.
Converts the Win32 error code to a printable string.
<LI><TT><FONT FACE="Courier">Win32::Spawn</FONT></TT>. Starts
a process. (See the following section on this module for more
information.)
<LI><TT><FONT FACE="Courier">Win32::InitiateSystemShutdown</FONT></TT>.
Starts shutdown. (See the following section on this module for
more information.)
<LI><TT><FONT FACE="Courier">Win32::AbortSystemShutdown</FONT></TT>.
Stops shutdown. (See the following section on this module for
more information.)
</UL>
<H5>Spawning Processes</H5>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">Win32::Spawn</FONT></TT> command
is used to start a process. The syntax for this command is
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Win32::Spawn( $command, $args, $pid);</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
A new process is started and runs the command in <TT><FONT FACE="Courier">$command</FONT></TT>.
Any command-line arguments passed into the process are specified
in <TT><FONT FACE="Courier">$args</FONT></TT>. The process ID
is returned in <TT><FONT FACE="Courier">$pid</FONT></TT>.
</BLOCKQUOTE>
<H5>Starting System Shutdown</H5>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">Win32::InitiateSystemShutdown</FONT></TT>
command is used to shut down a machine. The syntax for this command
is
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Win32::InitiateSystemShutdown (<BR>
&nbsp;&nbsp;&nbsp;&nbsp;$machine, $message, $timeout, $forceClose,
$reboot);</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
The machine name is specified in <TT><FONT FACE="Courier">$machine</FONT></TT>,
and a <TT><FONT FACE="Courier">NULL</FONT></TT> value identifies
the current machine. The <TT><FONT FACE="Courier">$message</FONT></TT>
value is sent to all the users logged into the machine at this
time. The <TT><FONT FACE="Courier">$timeout</FONT></TT> value
is used to notify users of imminent shutdown. The <TT><FONT FACE="Courier">$forceClose</FONT></TT>
value is set to <TT><FONT FACE="Courier">1</FONT></TT> if you
want the system to close all open files without prompting the
user. (This is useful during off times when the user might not
be at his or her desk.) The machine will reboot if <TT><FONT FACE="Courier">$reboot</FONT></TT>
is set to <TT><FONT FACE="Courier">true</FONT></TT>.
</BLOCKQUOTE>
<H5>Aborting System Shutdown</H5>
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">Win32::AbortSystemShutdown</FONT></TT>
command attempts to stop the shutdown process on a given machine.
The syntax for this command is
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Win32::AbortSystemShutdown ($machine);</FONT></TT>
</BLOCKQUOTE>
<BLOCKQUOTE>
The abort request might not always work because the <TT><FONT FACE="Courier">$timeout</FONT></TT>
may happen before you get this command going. (I could not stop
the shutdown/reboot process even with a very long timeout.) Stopping
a shutdown process in the middle may leave your system in an indeterminate
state. Once you get the ball rolling on a shutdown, let it go
through all the way. However, if you must stop an accidental shutdown
command, this command can be a valuable resource.
</BLOCKQUOTE>
<BLOCKQUOTE>
Several modules exist under the <TT><FONT FACE="Courier">Win32::
extensions</FONT></TT> to enable you to work with processes, interprocess
communications networks, and user resources. I cover these modules
as well. One thing to keep in mind is that this code is in test
mode at this time, and improvements will be made as the code develops.
Also, these extensions are almost always NT-specific and might
not work on Windows 95. This means that the code you write with
these modules will not be portable to platforms other than Windows
NT systems.
</BLOCKQUOTE>
<BLOCKQUOTE>
Listing 10.1 illustrates how to use some of the functions in the
Win32 module.
</BLOCKQUOTE>
<HR>
<BLOCKQUOTE>
<B>Listing 10.1. Using the Win32 modules.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 use Win32;<BR>
&nbsp;2<BR>
&nbsp;3 $x = Win32::PerlVersion&nbsp;&nbsp;;<BR>
&nbsp;4 print &quot; Version number =&nbsp;&nbsp;$x \n &quot;;
<BR>
&nbsp;5<BR>
&nbsp;6 $x = Win32::LoginName;<BR>
&nbsp;7<BR>
&nbsp;8 print &quot; \n Login Name $x&nbsp;&nbsp;&quot;;<BR>
&nbsp;9<BR>
10&nbsp;&nbsp;$x = Win32::NodeName;<BR>
11 print &quot; \n&nbsp;&nbsp;Node Name = $x &quot;;<BR>
12<BR>
13&nbsp;&nbsp;$x = Win32::DomainName;<BR>
14 print &quot; \n&nbsp;&nbsp;Domain Name = $x &quot;;<BR>
15<BR>
16&nbsp;&nbsp;$x = Win32::FsType;<BR>
17 print &quot; \n&nbsp;&nbsp;File system type = $x &quot;;<BR>
18<BR>
19&nbsp;&nbsp;$x = Win32::GetCwd;<BR>
20 print &quot; \n&nbsp;&nbsp;Current Drive = $x &quot;;<BR>
21<BR>
22&nbsp;&nbsp;$x = Win32::GetOSVersion;<BR>
23 print &quot; \n&nbsp;&nbsp;Current OS version = $x &quot;;
<BR>
24<BR>
25 $x = Win32::GetTickCount ;<BR>
26 print &quot; \n Tick count =&nbsp;&nbsp;$x &quot;;<BR>
27 print &quot;\n This is an NT box &quot;&nbsp;&nbsp;if ( Win32::IsWinNT);
<BR>
28 print &quot;\n This is a 95 box &quot;&nbsp;&nbsp;if ( Win32::IsWin95);</FONT></TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="TheProcessModuleExtensions"><FONT SIZE=5 COLOR=#FF0000>The
Process Module Extensions</FONT></A></H2>
<P>
The <TT><FONT FACE="Courier">Win32::Process</FONT></TT> module
extensions enable you to create different processes and start
applications using Perl scripts. The <TT><FONT FACE="Courier">Create</FONT></TT>
function lets you create a <TT><FONT FACE="Courier">Process</FONT></TT>
object that will run an application. The syntax for this call
is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Create( $pObject,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;$ApplicationName,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;$CommandLine,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;$InheritHandles,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;$CreateOptions,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;$CurrentDir)</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$pObject</FONT></TT> is the returned
reference to an object from this <TT><FONT FACE="Courier">Create</FONT></TT>
call. The <TT><FONT FACE="Courier">Create</FONT></TT> function
is the constructor for the <TT><FONT FACE="Courier">Process</FONT></TT>
class. Subsequent methods are called using this object as a reference.
<P>
<TT><FONT FACE="Courier">$ApplicationName</FONT></TT> is the full
pathname of the application you want to run in this <TT><FONT FACE="Courier">Process</FONT></TT>
object. The path can be specified using forward slashes or back
slashes. For example, to fire up <TT><FONT FACE="Courier">C:\dos\winzip.exe</FONT></TT>
on a system, you can use either one of these two pathnames:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&quot;c:/dos/winzip.exe&quot;<BR>
<BR>
&quot;c:\\dos\\winzip.exe&quot;</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$CommandLine</FONT></TT> is the list
of arguments passed at the command line to the application in
<TT><FONT FACE="Courier">$ApplicationName</FONT></TT>. The new
application will inherit any open file handles if <TT><FONT FACE="Courier">$InheritHandles</FONT></TT>
is set to <TT><FONT FACE="Courier">1</FONT></TT>. If you do not
want the called application to inherit file handles, set <TT><FONT FACE="Courier">$InheritHandles</FONT></TT>
to <TT><FONT FACE="Courier">0</FONT></TT>. The <TT><FONT FACE="Courier">$CurrentDir</FONT></TT>
variable is set to the working directory for executable programs.
<P>
The <TT><FONT FACE="Courier">$CreateOptions</FONT></TT> variable
can take a combination of the following values:<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=273><TT><FONT FACE="Courier">CREATE_DEFAULT_ERROR_MODE</FONT></TT>
</TD><TD WIDTH=317>Gives the new process the default error mode.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=273><TT><FONT FACE="Courier">CREATE_NEW_CONSOLE</FONT></TT>
</TD><TD WIDTH=317>The new process has a new console. This cannot be used with <TT><FONT FACE="Courier">DETAchED_PROCESS</FONT></TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=273><TT><FONT FACE="Courier">CREATE_NEW_PROCESS_GROUP</FONT></TT>
</TD><TD WIDTH=317>The new process is the root of a new process group.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=273><TT><FONT FACE="Courier">CREATE_SEPARATE_WOW_VDM</FONT></TT>
</TD><TD WIDTH=317>The new process runs in its own 16-bit Virtual DOS Machine (VDM).
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=273><TT><FONT FACE="Courier">CREATE_SUSPENDED</FONT></TT>
</TD><TD WIDTH=317>Starts the new process in a suspended state. The process can be forced to execute with the <TT><FONT FACE="Courier">Resume</FONT></TT> method.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=273><TT><FONT FACE="Courier">CREATE_UNICODE_ENVIRONMENT</FONT></TT>
</TD><TD WIDTH=317>The new process environment contains support for Unicode characters.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=273><TT><FONT FACE="Courier">DEBUG_PROCESS</FONT></TT>
</TD><TD WIDTH=317>The calling process is being used as a debugger, and the new process is being debugged.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=273><TT><FONT FACE="Courier">DEBUG_ONLY_THIS_PROCESS</FONT></TT>
</TD><TD WIDTH=317>The new process is not debugged, even if the calling process is running under the debugger.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=273><TT><FONT FACE="Courier">DETAchED_PROCESS</FONT></TT>
</TD><TD WIDTH=317>The new process does not have access to the console of the calling process.
</TD></TR>
</TABLE></CENTER>
<P>
<P>
Once the <TT><FONT FACE="Courier">Process</FONT></TT> object has
been created, you can apply methods to it. The following methods
exist for the <TT><FONT FACE="Courier">Win32::Process</FONT></TT>
object.
<UL>
<LI><TT><FONT FACE="Courier">Kill($ExitCode)</FONT></TT>
<LI><TT><FONT FACE="Courier">Resume()</FONT></TT>
<LI><TT><FONT FACE="Courier">Suspend()</FONT></TT>
<LI><TT><FONT FACE="Courier">GetExitCode()</FONT></TT>
<LI><TT><FONT FACE="Courier">Wait($Timeout)</FONT></TT>
</UL>
<H3><A NAME="TheKillMethod">The <TT><FONT SIZE=4 FACE="Courier">Kill</FONT></TT><FONT SIZE=4>
Method</FONT></A></H3>
<P>
This method kills the process associated with the <TT><FONT FACE="Courier">Process</FONT></TT>
object. The syntax for this method is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Kill( $ExitCode).</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">$ExitCode</FONT></TT> is the value
of the code that the process should return.
<H3><A NAME="TheResumeandSuspendMethods">The <TT><FONT SIZE=4 FACE="Courier">Resume</FONT></TT><FONT SIZE=4>
and </FONT><TT><FONT SIZE=4 FACE="Courier">Suspend</FONT></TT><FONT SIZE=4>
Methods</FONT></A></H3>
<P>
The <TT><FONT FACE="Courier">Suspend()</FONT></TT> method stops
a process from executing. To restart the thread, call the <TT><FONT FACE="Courier">Resume()</FONT></TT>
method.
<P>
The <TT><FONT FACE="Courier">Resume</FONT></TT> call can be used
to resume a process that was created with the <TT><FONT FACE="Courier">CREATE_SUSPENDED</FONT></TT>
flag.
<H3><A NAME="TheGetExitCodeFunction">The <TT><FONT SIZE=4 FACE="Courier">GetExitCode()</FONT></TT><FONT SIZE=4>
Function</FONT></A></H3>
<P>
The <TT><FONT FACE="Courier">GetExitCode()</FONT></TT> function
forces the <TT><FONT FACE="Courier">pObject</FONT></TT> to terminate
with its exit code set to the value of <TT><FONT FACE="Courier">$ExitCode</FONT></TT>.
The syntax for this function is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">GetExitCode( $ExitCode );</FONT></TT>
</BLOCKQUOTE>
<P>
You can use <TT><FONT FACE="Courier">GetExitCode</FONT></TT> to
find out how or if a process has exited.
<H3><A NAME="TheWaitTimeoutFunction">The <TT><FONT SIZE=4 FACE="Courier">Wait($Timeout)</FONT></TT><FONT SIZE=4>
Function</FONT></A></H3>
<P>
The calling process can wait for a process to terminate with the
<TT><FONT FACE="Courier">Wait</FONT></TT> function. The syntax
for this call is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Wait($Timeout)</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">$Timeout</FONT></TT> variable is
set to the number of milliseconds to wait for the process to end.
If the process wants to wait forever, use the keyword <TT><FONT FACE="Courier">INFINITE</FONT></TT>
for <TT><FONT FACE="Courier">$Timeout</FONT></TT>. The returned
value of <TT><FONT FACE="Courier">Wait()</FONT></TT> is <TT><FONT FACE="Courier">FALSE</FONT></TT>
if it times out and the error code in <TT><FONT FACE="Courier">$!</FONT></TT>
is set to <TT><FONT FACE="Courier">WAIT_FAILED</FONT></TT>. A
returned value of <TT><FONT FACE="Courier">TRUE</FONT></TT> indicates
that the process terminated before the <TT><FONT FACE="Courier">$Timeout</FONT></TT>
value.
<H3><A NAME="ClassPriority">Class Priority</A></H3>
<P>
The <TT><FONT FACE="Courier">GetPriorityClass</FONT></TT> and
<TT><FONT FACE="Courier">SetPriorityClass</FONT></TT> methods
provide control over the priority of the process. The priority
class of the process can be retrieved with a call to this method:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">GetPriorityClass($Priority )</FONT></TT>
</BLOCKQUOTE>
<P>
The returned value of <TT><FONT FACE="Courier">$Priority</FONT></TT>
is set to the priority class of the object this method is being
called on. <TT><FONT FACE="Courier">SetPriorityClass($Priority
)</FONT></TT><I> </I>is the opposite of the <TT><FONT FACE="Courier">GetPriorityClass()</FONT></TT>
function.
<P>
The <TT><FONT FACE="Courier">$Priority</FONT></TT> variable is
set to the priority to set the <TT><FONT FACE="Courier">Process</FONT></TT>
to. The value can be set to one of the following:<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=244><TT><FONT FACE="Courier">IDLE_PRIORITY_CLASS</FONT></TT>
</TD><TD WIDTH=346>Indicates a process whose threads run only when the system is idle.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=244><TT><FONT FACE="Courier">NORMAL_PRIORITY_CLASS</FONT></TT>
</TD><TD WIDTH=346>Standard process scheduling.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=244><TT><FONT FACE="Courier">HIGH_PRIORITY_CLASS</FONT></TT>
</TD><TD WIDTH=346>Runs at a higher priority level.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=244><TT><FONT FACE="Courier">REALTIME_PRIORITY_CLASS</FONT></TT>
</TD><TD WIDTH=346>Runs the process at the highest available priority. Be careful when using this value because you can lock up the machine with a runaway process.
</TD></TR>
</TABLE></CENTER>
<P>
<P>
Listing 10.2 shows you how to use the <TT><FONT FACE="Courier">Win32::Process</FONT></TT>
module.
<HR>
<BLOCKQUOTE>
<B>Listing 10.2. Using the </B><TT><B><FONT FACE="Courier">Win32::Process</FONT></B></TT><B>
module.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 use Win32;<BR>
&nbsp;2 use Win32::Process;<BR>
&nbsp;3<BR>
&nbsp;4 Win32::Process::Create($pobj,<BR>
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;c:/dos/winzip32.exe&quot;,
<BR>
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&quot;,&nbsp;&nbsp;&nbsp;#
no command line arguments<BR>
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,
<BR>
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DETAchED_PROCESS,&nbsp;&nbsp;#
run by yourself.<BR>
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;.&quot;)
|| die &quot;oops&quot;;<BR>
10<BR>
11 $pobj-&gt;SetPriorityClass(NORMAL_PRIORITY_CLASS) || die $!;
<BR>
12<BR>
13 $pobj-&gt;Wait(INFINITE) || die $!;  # wait forever</FONT></TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="TheWin32SemaphoreUtilities"><FONT SIZE=5 COLOR=#FF0000>The
</FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">Win32::Semaphore</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Utilities</FONT></A></H2>
<P>
The <TT><FONT FACE="Courier">Win32::Semaphore</FONT></TT> lets
a Perl script access the semaphore facility in Windows NT. The
<TT><FONT FACE="Courier">Create</FONT></TT> call in a <TT><FONT FACE="Courier">Semaphore</FONT></TT>
module lets you create a semaphore object. The semaphore in an
NT machine works in the same manner as in UNIX. For more information
on how to use semaphores, see <A HREF="ch13.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch13.htm" >Chapter 13</A>,
&quot;Messaging Facilities: The System V Ipc Functions.&quot;
The syntax for the <TT><FONT FACE="Courier">Create</FONT></TT>
function is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Create ($semaphoreObj,$initialCount,$maxCount,$name);</FONT></TT>
</BLOCKQUOTE>
<P>
The returned value from the <TT><FONT FACE="Courier">Create</FONT></TT>
call is placed to what the <TT><FONT FACE="Courier">$semaphoreObj</FONT></TT>
references. The <TT><FONT FACE="Courier">$initialCount</FONT></TT>
variable is used to set the initial count of the semaphore object.
The maximum count of the semaphore is set in <TT><FONT FACE="Courier">$maxCount</FONT></TT>.
The semaphore can be identified in the NT system by the value
in <TT><FONT FACE="Courier">$name</FONT></TT>.
<P>
The <TT><FONT FACE="Courier">DESTROY</FONT></TT> method removes
a semaphore object specified in the argument to itself. The syntax
is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">DESTROY( $SemaphoreObj );</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">DESTROY</FONT></TT> method is automatically
called by Perl when the <TT><FONT FACE="Courier">$SemaphoreObject</FONT></TT>
scalar goes out of scope.
<P>
The <TT><FONT FACE="Courier">Wait( $TimeOut )</FONT></TT> function
is used to wait for a timeout for the value in <TT><FONT FACE="Courier">$TimeOut</FONT></TT>.
The value in <TT><FONT FACE="Courier">$Timeout</FONT></TT> is
specified in milliseconds.
<P>
The <TT><FONT FACE="Courier">Wait</FONT></TT> method makes the
calling process wait on the semaphore. If the <TT><FONT FACE="Courier">Semaphore</FONT></TT>
is not released in <TT><FONT FACE="Courier">$TimeOut</FONT></TT>
milliseconds, the call returns, and the return value should be
checked. For no timeout value, use the predefined constant <TT><FONT FACE="Courier">INFINITE</FONT></TT>.
<P>
Once you are done with a semaphore, you should release it to let
other processes access it. To release a semaphore, you have to
make a call to
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Release( $ReleaseCount, $lastCount);</FONT></TT>
</BLOCKQUOTE>
<P>
The value in <TT><FONT FACE="Courier">$ReleaseCount</FONT></TT>
is incremented by the call to <TT><FONT FACE="Courier">Release</FONT></TT>.
The <TT><FONT FACE="Courier">Release</FONT></TT> method releases
a semaphore after it increments the count. The <TT><FONT FACE="Courier">$LastCount</FONT></TT>
variable contains the last value.
<P>
Listing 10.3 illustrates how to use the <TT><FONT FACE="Courier">Semaphore</FONT></TT>
module in NT. Note how the <TT><FONT FACE="Courier">ErrorMsg</FONT></TT>
subroutine displays the readable message from the <TT><FONT FACE="Courier">GetLastError()</FONT></TT>
call.
<HR>
<BLOCKQUOTE>
<B>Listing 10.3. Using the </B><TT><B><FONT FACE="Courier">Win32::Semaphore</FONT></B></TT><B>
object.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 use Win32::Semaphore;<BR>
&nbsp;2 use Win32;<BR>
&nbsp;3<BR>
&nbsp;4 my $sObject;<BR>
&nbsp;5<BR>
&nbsp;6 Win32::Semaphore::Create($sObject,1,1,&quot;Bile&quot;)||die
&quot;Die: $!\n&quot;;<BR>
&nbsp;7<BR>
&nbsp;8 sub ErrorMsg {<BR>
&nbsp;9 print Win32::FormatMessage( Win32::GetLastError());<BR>
10 }<BR>
11<BR>
12 &amp;ErrorMsg;&nbsp;&nbsp;&nbsp;&nbsp;# Tell me if there were
any errors. :w<BR>
13<BR>
14 #<BR>
15 # wait for semaphore.<BR>
16 #<BR>
17 if( $sObject-&gt;Wait(INFINITE)){<BR>
18&nbsp;&nbsp;&nbsp;&nbsp; #<BR>
19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Access
the shared resource here.<BR>
20&nbsp;&nbsp;&nbsp;&nbsp; # Do something here with returned value.
<BR>
21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
&amp;Access( $Shared_Resource );<BR>
22<BR>
23&nbsp;&nbsp;&nbsp;&nbsp; #<BR>
24&nbsp;&nbsp;&nbsp;&nbsp; # Don't forget to release the semaphore
<BR>
25&nbsp;&nbsp;&nbsp;&nbsp; # as quickly as possible.<BR>
26&nbsp;&nbsp;&nbsp;&nbsp; #<BR>
27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$sObject-&gt;Release(
1,$last );<BR>
28<BR>
29&nbsp;&nbsp;&nbsp;&nbsp; #<BR>
30&nbsp;&nbsp;&nbsp;&nbsp; # You can work with your copy of private
data.<BR>
31&nbsp;&nbsp;&nbsp;&nbsp; # with no need for locking.<BR>
32&nbsp;&nbsp;&nbsp;&nbsp; #<BR>
33 }<BR>
34 else {<BR>
35&nbsp;&nbsp;&nbsp;&nbsp; print&quot; Whoa! I cannot access any
semaphores!\n&quot;;<BR>
36 }</FONT></TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="UsingMutexwithWin32Mutex"><FONT SIZE=5 COLOR=#FF0000>Using
</FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">Mutex</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
with </FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">Win32::Mutex</FONT></TT></A>
</H2>
<P>
The <TT><FONT FACE="Courier">Win32::Mutex</FONT></TT> module is
used to create, destroy, and work with <TT><FONT FACE="Courier">Mutex</FONT></TT>es
in the NT system. A <TT><FONT FACE="Courier">Mutex</FONT></TT>
is used to provide mutually exclusive access to a resource. Processes
vie to own a <TT><FONT FACE="Courier">Mutex</FONT></TT>, and only
one process can own a <TT><FONT FACE="Courier">Mutex</FONT></TT>
at one time. A process controlling a <TT><FONT FACE="Courier">Mutex</FONT></TT>
can then work exclusively on a shared resource such as a file
or device. Mutexes differ from semaphores in that <TT><FONT FACE="Courier">Mutex</FONT></TT>es
are available only in kernel-mode processes and not for user-mode
processes. Refer to Jason Loveman's book,<I> Moving into Windows
NT Programming</I>, for some good examples on how to use <TT><FONT FACE="Courier">Mutex</FONT></TT>es.
<P>
To create a <TT><FONT FACE="Courier">Mutex</FONT></TT>, you have
to call the <TT><FONT FACE="Courier">Create</FONT></TT> function
for the object. The first parameter into the <TT><FONT FACE="Courier">Create</FONT></TT>
call is assigned a reference to the <TT><FONT FACE="Courier">Mutex</FONT></TT>
object. The syntax for the <TT><FONT FACE="Courier">Create</FONT></TT>
call is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Win32::Mutex::Create($mutexObject, $owner,
$mutexName )</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">$mutexObject</FONT></TT> is assigned
a reference to the new <TT><FONT FACE="Courier">Mutex</FONT></TT>
object. The value in the <TT><FONT FACE="Courier">$owner</FONT></TT>
variable can be <TT><FONT FACE="Courier">1</FONT></TT> or <TT><FONT FACE="Courier">0</FONT></TT>.
If it is <TT><FONT FACE="Courier">1</FONT></TT>, the calling process
will be assigned the initial ownership at the time of creation.
<P>
If it is <TT><FONT FACE="Courier">0</FONT></TT>, the <TT><FONT FACE="Courier">Mutex</FONT></TT>
will be created as available. The name of the <TT><FONT FACE="Courier">Mutex</FONT></TT>
will be in <TT><FONT FACE="Courier">$mutexName</FONT></TT>.
<P>
<TT><FONT FACE="Courier">Create</FONT></TT> creates a <TT><FONT FACE="Courier">Mutex</FONT></TT>
object and returns the reference in <TT><FONT FACE="Courier">$MutexObj</FONT></TT>.
If the <TT><FONT FACE="Courier">$InitialOwner</FONT></TT> flag
is set (nonzero), the process calling the <TT><FONT FACE="Courier">Create</FONT></TT>
function has immediate ownership of the <TT><FONT FACE="Courier">Mutex</FONT></TT>.
Otherwise, the <TT><FONT FACE="Courier">Mutex</FONT></TT> is available.
<TT><FONT FACE="Courier">$Name</FONT></TT> can be used by other
processes in <TT><FONT FACE="Courier">Win32::Mutex::Opencall</FONT></TT>
to create an object to reference an already created <TT><FONT FACE="Courier">Mutex</FONT></TT>.
<P>
To open a <TT><FONT FACE="Courier">Mutex</FONT></TT>, use the
<TT><FONT FACE="Courier">Open</FONT></TT> call to get the <TT><FONT FACE="Courier">Mutex</FONT></TT>
object. The syntax for the <TT><FONT FACE="Courier">Open</FONT></TT>
call is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Win32::Mutex::Open($mObject,$mutexName);</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">$mObject</FONT></TT> variable is
assigned a reference to a <TT><FONT FACE="Courier">Mutex</FONT></TT>
object with the name value in <TT><FONT FACE="Courier">$mutexName</FONT></TT>.
The <TT><FONT FACE="Courier">Mutex</FONT></TT> specified in <TT><FONT FACE="Courier">$mutexName</FONT></TT>
must already have been created or else a <TT><FONT FACE="Courier">NULL</FONT></TT>
value is returned in <TT><FONT FACE="Courier">$mObject</FONT></TT>.
<P>
The <TT><FONT FACE="Courier">Release()</FONT></TT> method on a
<TT><FONT FACE="Courier">Mutex</FONT></TT> object releases a <TT><FONT FACE="Courier">Mutex</FONT></TT>
object back to the system for use by other processes. The <TT><FONT FACE="Courier">Mutex</FONT></TT>
object is destroyed when it goes out of scope in the Perl program
because the default <TT><FONT FACE="Courier">DESTROY</FONT></TT>
method of the <TT><FONT FACE="Courier">Mutex</FONT></TT> object
frees the system resources used by the <TT><FONT FACE="Courier">Mutex</FONT></TT>.
<P>
The <TT><FONT FACE="Courier">Wait()</FONT></TT> function for the
<TT><FONT FACE="Courier">Mutex</FONT></TT> object is used to wait
for ownership of a <TT><FONT FACE="Courier">Mutex</FONT></TT>.
The syntax of this function is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Wait( $TimeOut );</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">$TimeOut</FONT></TT> variable is
specified in milliseconds. The value can be set to <TT><FONT FACE="Courier">INFINITE</FONT></TT>
for waiting indefinitely. The <TT><FONT FACE="Courier">Wait()</FONT></TT>
function returns a <TT><FONT FACE="Courier">false</FONT></TT>
value if the function timed out or returns true if the <TT><FONT FACE="Courier">Mutex</FONT></TT>
has become available.
<P>
Here's a fragment of code that shows how to use a <TT><FONT FACE="Courier">Mutex</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">#<BR>
# This is reserved for privileged users only<BR>
#<BR>
# Create a Mutex object<BR>
#<BR>
<BR>
Win32::Mutex::Create( $Mut,0, &quot;MyMutex&quot;)|| die $!;<BR>
<BR>
<BR>
#<BR>
# Use it<BR>
#<BR>
sub doPriviliged() {<BR>
local( $mObject ) = $_[0];&nbsp;&nbsp;# The first arg in method
is the object<BR>
$mObject-&gt;wait( 5000 )|| return ;&nbsp;&nbsp;&nbsp;&nbsp;#
Could not get it<BR>
<BR>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
&nbsp;&nbsp;&nbsp;&nbsp;# do your thing.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
<BR>
$mObject-&gt;Release();<BR>
}</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="UsingWin32ChangeNotification"><FONT SIZE=5 COLOR=#FF0000>Using
</FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">Win32::ChangeNotification</FONT></TT></A>
</H2>
<P>
The <TT><FONT FACE="Courier">Win32::ChangeNotification</FONT></TT>
module is used for notifying a Perl application or process when
a branch in the specific file system tree has been modified. The
module relies on the <TT><FONT FACE="Courier">FindFirst()</FONT></TT>
call in the Win32 API, and this is the way to create the object.
The syntax is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Win32::ChangeNotification::FindFirst(
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$cObject,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$pathName, $watchSubtree,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$filter);</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">$cObject</FONT></TT> variable is
set to the new <TT><FONT FACE="Courier">ChangeNotification</FONT></TT>
object created. <TT><FONT FACE="Courier">$pathName</FONT></TT>
is the path to the directory that you want to monitor. <TT><FONT FACE="Courier">$watchSubTree</FONT></TT>
function can be set to <TT><FONT FACE="Courier">0</FONT></TT>
or <TT><FONT FACE="Courier">1</FONT></TT>. If set to <TT><FONT FACE="Courier">0</FONT></TT>,
any subdirectories of the path are not modified. If set to <TT><FONT FACE="Courier">1</FONT></TT>,
the monitor process looks at the subtree, too.
<P>
The <TT><FONT FACE="Courier">$filter</FONT></TT> variable specifies
the conditions on which the program notifies. The value in <TT><FONT FACE="Courier">$filter</FONT></TT>
can be set to a value that is a combination of the following constants:
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=295><TT><FONT FACE="Courier">FILE_NOTIFY_chANGE_FILE_NAME</FONT></TT>
</TD><TD WIDTH=295>Notifies when a file in the monitored directory is renamed, created, or deleted.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT><FONT FACE="Courier">FILE_NOTIFY_chANGE_DIR_NAME</FONT></TT>
</TD><TD WIDTH=295>Notifies whether the name of the directory is changed.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT><FONT FACE="Courier">FILE_NOTIFY_chANGE_ATTRIBUTES</FONT></TT>
</TD><TD WIDTH=295>Notifies whether the attributes of the directory are changed.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT><FONT FACE="Courier">FILE_NOTIFY_chANGE_SIZE</FONT></TT>
</TD><TD WIDTH=295>Notifies whether the size of the underlying directory is actually written to disk. This notification might not happen immediately due to the way NT flushes cached writes of data to the disk.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT><FONT FACE="Courier">FILE_NOTIFY_chANGE_LAST_WRITE</FONT></TT>
</TD><TD WIDTH=295>Notifies whether the last write time of the underlying file is modified and actually written to disk. This notification might not happen immediately due to the way NT flushes cached writes of data to the disk.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=295><TT><FONT FACE="Courier">FILE_NOTIFY_chANGE_SECURITY</FONT></TT>
</TD><TD WIDTH=295>Notifies of any security descriptor changes in the directory being monitored.
</TD></TR>
</TABLE></CENTER>
<P>
<P>
Other methods for this module include the following:<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=177><TT><FONT FACE="Courier">FindNext();</FONT></TT>
</TD><TD WIDTH=413>The <TT><FONT FACE="Courier">FindNext</FONT></TT> method requests that the operating system signal the <TT><FONT FACE="Courier">change notification</FONT></TT> object the next time it detects an appropriate change.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=177><TT><FONT FACE="Courier">Close();</FONT></TT>
</TD><TD WIDTH=413>Stops the <TT><FONT FACE="Courier">notification</FONT></TT> object monitoring.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=177><TT><FONT FACE="Courier">Wait( $TimeOut);</FONT></TT>
</TD><TD WIDTH=413><TT><FONT FACE="Courier">$TimeOut</FONT></TT> is the time out in milliseconds. The <TT><FONT FACE="Courier">Wait</FONT></TT> method causes the calling process to block until notification of the change.
</TD></TR>
</TABLE></CENTER>
<P>
<P>
When the <TT><FONT FACE="Courier">ChangeNotification</FONT></TT>
object goes out of scope, the object's <TT><FONT FACE="Courier">DESTROY</FONT></TT>
method is called by Perl. The <TT><FONT FACE="Courier">DESTROY</FONT></TT>
method closes any outstanding notification.
<P>
Listing 10.4 shows how to use the <TT><FONT FACE="Courier">ChangeNotification</FONT></TT>
object.
<HR>
<BLOCKQUOTE>
<B>Listing 10.4. Using the </B><TT><B><FONT FACE="Courier">ChangeNotification</FONT></B></TT><B>
object.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 use Win32;<BR>
&nbsp;2 use Win32::ChangeNotification;<BR>
&nbsp;3<BR>
&nbsp;4 my $watch = TRUE ;<BR>
&nbsp;5 my $flags = &quot;FILE_NOTIFY_chANGE_ATTRIBUTES | FILE_NOTIFY_chANGE_SIZE&quot;
;<BR>
&nbsp;6 my $Path =&nbsp;&nbsp;&quot;D:/perl5/&quot;;<BR>
&nbsp;7<BR>
&nbsp;8 Win32::ChangeNotification::FindFirst( $pobj,<BR>
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp; $Path,<BR>
10&nbsp;&nbsp;&nbsp;&nbsp; ,1,<BR>
11&nbsp;&nbsp;&nbsp;&nbsp; $flags) || die $!;<BR>
12<BR>
13 sub ErrorMsg {<BR>
14 print Win32::FormatMessage( Win32::GetLastError());<BR>
15 }<BR>
16<BR>
17 &amp;ErrorMsg;&nbsp;&nbsp;&nbsp;&nbsp;# Tell me if there were
any errors. :w<BR>
18<BR>
19 $pobj-&gt;FindNext();<BR>
20 &amp;ErrorMsg;&nbsp;&nbsp;&nbsp;&nbsp;# Tell me if there were
any errors. :w<BR>
21 $pobj-&gt;Wait(8000);<BR>
22 print &quot;Hey! Someone's messing with drive D: \n&quot; ;
<BR>
23 $pobj-&gt;Close;</FONT></TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="TheWin32EventlogModule"><FONT SIZE=5 COLOR=#FF0000>The
</FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">Win32::Eventlog</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Module</FONT></A></H2>
<P>
The Windows NT system tracks events in the system using an event
logging facility. Perl scripts can read, modify, and extract information
from log records. This feature is a very powerful tool to use
when generating status reports about a system.
<P>
Before you use <TT><FONT FACE="Courier">Win32::Eventlog</FONT></TT>,
you have to open an event log and associate a <TT><FONT FACE="Courier">Win32::Eventlog</FONT></TT>
object with it. Here's the call to do this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Open Win32::EventLog($EventObj, $sourceName,
[$serverName]);</FONT></TT>
</BLOCKQUOTE>
<P>
On returning from this function, the <TT><FONT FACE="Courier">$EventObj</FONT></TT>
variable will be set to a reference to an <TT><FONT FACE="Courier">EventLog</FONT></TT>
object. The name of the source for the events that will be set
is <TT><FONT FACE="Courier">$sourceName</FONT></TT>. The <TT><FONT FACE="Courier">$ServerName</FONT></TT>
variable is optional and, if omitted or explicitly set to <TT><FONT FACE="Courier">NULL</FONT></TT>,
will be set to the local machine.
<P>
You can even create your own backups by using the <TT><FONT FACE="Courier">Backup</FONT></TT>
method on the <TT><FONT FACE="Courier">$EventObj</FONT></TT> object.
The file is created and the events in the current event log in
the <TT><FONT FACE="Courier">$EventObj</FONT></TT> object are
written to.
<P>
Any previously written file will be overwritten if a file with
the same name already exists. The syntax for this command is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Backup( $filename );</FONT></TT>
</BLOCKQUOTE>
<P>
where <TT><FONT FACE="Courier">$filename</FONT></TT> is the string
of the file to which to write the event log.
<H3><A NAME="ReadingEvents">Reading Events</A></H3>
<P>
To read events in a backup or event log, you have to use the <TT><FONT FACE="Courier">Read()</FONT></TT>
method on the <TT><FONT FACE="Courier">$EventObject</FONT></TT>.
The syntax for the <TT><FONT FACE="Courier">Read()</FONT></TT>
method is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Read($readFlags,$recordOffset,%EventInfo);</FONT></TT>
</BLOCKQUOTE>
<P>
The<TT><FONT FACE="Courier"> $readFlags</FONT></TT> variable is
set to specify how to read the events. The <TT><FONT FACE="Courier">$recordNumber</FONT></TT>
variable is set to the index (starting from 1, not 0). The hash
<TT><FONT FACE="Courier">%EventInfo</FONT></TT> is set to the
returned event's value. <TT><FONT FACE="Courier">$readFlag</FONT></TT>
can be set to a combination of these values:<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=253><TT><FONT FACE="Courier">EVENTLOG_FORWARDS_READ</FONT></TT>
</TD><TD WIDTH=337>Reads in forward chronological order. Cannot be used with <TT><FONT FACE="Courier">EVENTLOG_BACKWARDS_READ</FONT></TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=253><TT><FONT FACE="Courier">EVENTLOG_BACKWARDS_READ</FONT></TT>
</TD><TD WIDTH=337>Reads in reverse chronological order. Cannot be used with <TT><FONT FACE="Courier">EVENTLOG_FORWARDS_READ</FONT></TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=253><TT><FONT FACE="Courier">EVENTLOG_SEEK_READ</FONT></TT>
</TD><TD WIDTH=337>Reads from record number specified in <TT><FONT FACE="Courier">$RecordOffset</FONT></TT>. You must specify the direction in which you are to read the file by setting either <TT><FONT FACE="Courier">EVENTLOG_FORWARDS_READ</FONT></TT> or 
<TT><FONT FACE="Courier">EVENTLOG_BACKWARDS_READ</FONT></TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=253><TT><FONT FACE="Courier">EVENTLOG_SEQUENTIAL_READ</FONT></TT>
</TD><TD WIDTH=337>Reads from the next record after the previous <TT><FONT FACE="Courier">read</FONT></TT> operation.
</TD></TR>
</TABLE></CENTER>
<H3><A NAME="ReportingtheContentsofanEvent">Reporting the Contents
of an Event</A></H3>
<P>
To get a report of what you have just read, you can use the <TT><FONT FACE="Courier">Report()</FONT></TT>
method. The syntax for this call is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Report($eventType, %EventInfo );</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$eventType</FONT></TT> is the type of
event and <TT><FONT FACE="Courier">%EventInfo</FONT></TT> is the
returned value of an <TT><FONT FACE="Courier">%EVENTINFO</FONT></TT>
hash, which is usually the value returned from a <TT><FONT FACE="Courier">Read()</FONT></TT>
call. The options for <TT><FONT FACE="Courier">$eventType</FONT></TT>
are<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=289>EVENTLOG_ERROR_TYPE</TD><TD WIDTH=146>Error event
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=289>EVENTLOG_WARNING_TYPE</TD><TD WIDTH=146>Warning event
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=289>EVENTLOG_INFORMATION_TYPE</TD><TD WIDTH=146>Information event
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=289>EVENTLOG_AUDIT_SUccESS_TYPE</TD><TD WIDTH=146>Success audit event
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=289>EVENTLOG_AUDIT_FAILURE_TYPE</TD><TD WIDTH=146>Failure audit event
</TD></TR>
</TABLE></CENTER>
<P>
<TT><FONT FACE="Courier">%EventInfo</FONT></TT> hash can be parsed
with the following keys:<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">Category</FONT></TT>
</TD><TD WIDTH=391>An application-specific integer value for the type of event
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">EventID</FONT></TT>
</TD><TD WIDTH=391>A source-specific ID value of the event</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">EventRawData</FONT></TT>
</TD><TD WIDTH=391>Any application-specific raw binary data</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">Strings</FONT></TT>
</TD><TD WIDTH=391>Any application text strings</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">user</FONT></TT></TD>
<TD WIDTH=391>User name to which this event applies</TD></TR>
</TABLE></CENTER>
<P>
<P>
Three other functions also exist to get more information about
the position of events in a file. The returned values of these
functions can be used to specify what event record you are going
to process data from. Keep in mind that records are indexed by
starting at 1 and not 0.
<UL>
<LI><FONT COLOR=#000000>The</FONT> <TT><FONT FACE="Courier">GetOldest($recnum)</FONT></TT>
function sets the value of <TT><FONT FACE="Courier">$recnum</FONT></TT>,
the absolute record number of the last record in the event source.
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">GetNumber(
$NumberOfEvents )</FONT></TT> function returns the number of events.
<LI><FONT COLOR=#000000>The </FONT><TT><FONT FACE="Courier">Clear(
$filename )</FONT></TT> function clears the event log in the current
event file. If the <TT><FONT FACE="Courier">$filename</FONT></TT>
option is not given, the current event log is not written to the
file. If the <TT><FONT FACE="Courier">$filename</FONT></TT> option
is given and you have permissions to write to this directory,
the current event log is written to the file.
</UL>
<H2><A NAME="TheWin32RegistryModule"><FONT SIZE=5 COLOR=#FF0000>The
</FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">Win32::Registry</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Module</FONT></A></H2>
<P>
The <TT><FONT FACE="Courier">Win32::Registry</FONT></TT> module
lets you work with the Windows NT Registry model. The way to start
working with the model is to first create a <TT><FONT FACE="Courier">Win32::Registry</FONT></TT>
object with the <TT><FONT FACE="Courier">open()</FONT></TT> call
for a key. The syntax for the open call is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Win32::Registry::Open($RegistryObj,$key
)</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$RegistryObj</FONT></TT> returns a reference
to a reference object for the predefined key specified in <TT><FONT FACE="Courier">$key</FONT></TT>.
If the specified key does not exist, it is not created. <TT><FONT FACE="Courier">$key</FONT></TT>
can only hold any already opened key.
<P>
When the <TT><FONT FACE="Courier">Registry</FONT></TT> module
is loaded, four <TT><FONT FACE="Courier">Registry</FONT></TT>
objects are created in the <TT><FONT FACE="Courier">main:: namespace</FONT></TT>.
These predefined Registry objects can be referred to by the generic
names within Windows NT:
<UL>
<LI><TT><FONT FACE="Courier">LOCAL_MAchINE</FONT></TT>
<LI><TT><FONT FACE="Courier">USERS</FONT></TT>
<LI><TT><FONT FACE="Courier">CURRENT_USER</FONT></TT>
<LI><TT><FONT FACE="Courier">CLASSES_ROOT</FONT></TT>
</UL>
<P>
To create a new key, you have to use the <TT><FONT FACE="Courier">Create()</FONT></TT>
call. Here's the syntax for the <TT><FONT FACE="Courier">Create()</FONT></TT>
call:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">Win32::Registry::Create($RegistryObj,$key
)</FONT></TT>
</BLOCKQUOTE>
<P>
where <TT><FONT FACE="Courier">$RegistryObj</FONT></TT> returns
a reference to a <TT><FONT FACE="Courier">Registry</FONT></TT>
object. The <TT><FONT FACE="Courier">$key</FONT></TT> variable
contains the name of a key. If the key exists, then the <TT><FONT FACE="Courier">create</FONT></TT>
function will open it; otherwise, it will create a new key and
return a reference to it. The user must have the security privileges
to create a key.
<P>
Once you have a key in an object, you can get its value with the
<TT><FONT FACE="Courier">QueryValue</FONT></TT> method. The syntax
for the <TT><FONT FACE="Courier">QueryValue</FONT></TT> method
is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$regObject-&gt;QueryValue($subKey,$valueRef);</FONT></TT>
</BLOCKQUOTE>
<P>
Given the name of the subkey of the <TT><FONT FACE="Courier">regObject</FONT></TT>
in <TT><FONT FACE="Courier">$subKey</FONT></TT>, the <TT><FONT FACE="Courier">QueryValue</FONT></TT>
function sets the value of the variable at <TT><FONT FACE="Courier">$valueRef</FONT></TT>.
To get more information about a key, you can use the <TT><FONT FACE="Courier">QueryKey</FONT></TT>
method with this calling syntax:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$regObject-&gt;QueryKey ($keyClass, $numSubkeys,
$numValues);</FONT></TT>
</BLOCKQUOTE>
<P>
All three arguments to this function are set to a value when the
function returns. On returning, <TT><FONT FACE="Courier">$keyClass</FONT></TT>
is set to a string specifying the class of the key. The <TT><FONT FACE="Courier">$numSubKeys</FONT></TT>
contains the number of subkeys, and the <TT><FONT FACE="Courier">$numValues</FONT></TT>
variable contains the number of values for the current key.
<P>
Keys can have more than one value associated with them. To get
these values from a key, call the <TT><FONT FACE="Courier">GetValues()</FONT></TT>
method. The syntax for this call is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$regObject-&gt;GetValues(\%Values);</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">%Values</FONT></TT> hash is set to
the values in the <TT><FONT FACE="Courier">$regObject</FONT></TT>
key. The hash <TT><FONT FACE="Courier">%Values</FONT></TT> will
be keyed by deriving a value from the name and type of the object
to get a key of the form <TT><FONT FACE="Courier">{$name,$type,$data}</FONT></TT>.
<P>
The <TT><FONT FACE="Courier">GetKeys(\@Subkeys)</FONT></TT> function
returns a list of names of subkeys for a given key in the array
<TT><FONT FACE="Courier">@Subkeys</FONT></TT>. To get a list of
subkeys for an object, the call will be of this form:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$regObject-&gt;GetValues(\@subkeys);</FONT></TT>
</BLOCKQUOTE>
<P>
You can save the current key status (called <I>hive</I>) with
a call to the <TT><FONT FACE="Courier">Save()</FONT></TT> method
for a <TT><FONT FACE="Courier">Registry</FONT></TT> object. The
syntax for this method is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$regObject-&gt;Save( $filename);</FONT></TT>
</BLOCKQUOTE>
<P>
where <TT><FONT FACE="Courier">$filename</FONT></TT> is the name
of the file to save to.
<P>
To load the information about a subkey from a file on disk, you
can use the <TT><FONT FACE="Courier">Load</FONT></TT> method.
The syntax for this call is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$regObject-&gt;Load( $subkey, $filename);</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">$subkey</FONT></TT> is the subkey
to load the file into from the filename specified in <TT><FONT FACE="Courier">$filename</FONT></TT>.
<P>
You can delete keys or their values. The function to delete a
key is <TT><FONT FACE="Courier">DeleteKey($keyname)</FONT></TT>.
To delete a value, use <TT><FONT FACE="Courier">DeleteValue($keyname);</FONT></TT>.
Here are some examples of these functions:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$regObject-&gt;DeleteKey($keyname);<BR>
$CURRENT_USER-&gt;DeleteValue($keyname);</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="TheWin32NetAdminModule"><FONT SIZE=5 COLOR=#FF0000>The
</FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">Win32::NetAdmin</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Module</FONT></A></H2>
<P>
The <TT><FONT FACE="Courier">Win32::NetAdmin</FONT></TT> module
is useful for working with users and user groups on an NT machine.
Normally you would perform this operation at the main console
using the windowing interface in NT. However, addition and deletion
of users on multiple machines would tax the system administrator's
time too much. A Perl script can list the attributes of a user
or group and perhaps be able to do this automatically and remotely
on a network. This section covers some of the functions available
from within Perl.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD ><B>Note</B></TD></TR>
<TR VALIGN=TOP><TD >
<BLOCKQUOTE>
The <TT><FONT FACE="Courier">Win32::NetAdmin</FONT></TT> module will not load on a Windows 95 machine.
</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H3><A NAME="AddingaUser">Adding a User</A></H3>
<P>
To add a user using the <TT><FONT FACE="Courier">Win32::NetAdmin</FONT></TT>
module, you can call the <TT><FONT FACE="Courier">UserCreate()</FONT></TT>
function. The syntax for this function is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">UserCreate($server,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$userName,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$password,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$passwordAge,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$privilege,$<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;homeDir,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$comment,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$flags,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scriptPath);</FONT></TT>
</BLOCKQUOTE>
<P>
The<TT><FONT FACE="Courier"> $server</FONT></TT> variable is the
name of the server. It may be <TT><FONT FACE="Courier">NULL</FONT></TT>
to specify the local server. The <TT><FONT FACE="Courier">$userName</FONT></TT>
variable is the login name of the new user. <TT><FONT FACE="Courier">$groupName</FONT></TT>
is the name of the group. The <TT><FONT FACE="Courier">$comment</FONT></TT>
variable is a string that will have the attributes field of that
group when the function returns. The user's password and the time
before it expires is in the variables <TT><FONT FACE="Courier">$password</FONT></TT>
and <TT><FONT FACE="Courier">$PasswordAge</FONT></TT>, respectively.
The home directory of the user is set in the <TT><FONT FACE="Courier">$homeDir</FONT></TT>
argument. The comment variable contains appropriate information
about the user. The <TT><FONT FACE="Courier">$scriptPath</FONT></TT>
variable is the Uniform Naming Convention (Unc) pathname of the
login script for that user.
<P>
The <TT><FONT FACE="Courier">$privilege</FONT></TT> variable controls
the privileges of the new user. This variable can be set to one
of these values:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">USER_PRIV_MASK</FONT></TT> to set for
all users
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">USER_PRIV_GUEST</FONT></TT> to set for
all guest users
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">USER_PRIV_USER</FONT></TT> to set for
all normal users
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">USER_PRIV_ADMIN</FONT></TT> to set for
the administrative accounts
</BLOCKQUOTE>
<P>
Here are the defined values the <TT><FONT FACE="Courier">$flag</FONT></TT>
option can take:<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=292><TT><FONT FACE="Courier">UF_SCRIPT</FONT></TT> 
</TD><TD WIDTH=298>The script to execute when the user logs on.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=292><TT><FONT FACE="Courier">UF_AccOUNTDISABLE</FONT></TT>
</TD><TD WIDTH=298>Disables the account.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=292><TT><FONT FACE="Courier">UF_PASSWRD_NOTREQD</FONT></TT>
</TD><TD WIDTH=298>No password is required to create this account.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=292><TT><FONT FACE="Courier">UF_PASSWRD_CANT_chANGE</FONT></TT> 
</TD><TD WIDTH=298>The user cannot change his or her password.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=292><TT><FONT FACE="Courier">UF_LOCKOUT</FONT></TT>
</TD><TD WIDTH=298>Locks the current account out.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=292><TT><FONT FACE="Courier">UF_DONT_EXPIRE_PASSWORD</FONT></TT>
</TD><TD WIDTH=298>The password never expires on the account.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=292><TT><FONT FACE="Courier">UF_NORMAL_AccOUNT</FONT></TT>
</TD><TD WIDTH=298>This is a default account type for use with all typical users.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=292><TT><FONT FACE="Courier">UF_TEMP_DUPLICATE_AccOUNT</FONT></TT>
</TD><TD WIDTH=298>Use this account for users whose primary account is in another domain. This user has access to the current domain but is not a trusted account and is referred to as a local account.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=292><TT><FONT FACE="Courier">UF_WORKSTATION_TRUST_AccOUNT</FONT></TT>
</TD><TD WIDTH=298>Used for a computer account for a Windows NT Workstation server which is also a member of the current domain.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=292><TT><FONT FACE="Courier">UF_SERVER_TRUST_AccOUNT</FONT></TT>
</TD><TD WIDTH=298>Used for a computer account for a Windows NT backup domain controller which is also a member of the current domain.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=292><TT><FONT FACE="Courier">UF_INTERDOMAIN_TRUST_AccOUNT</FONT></TT>
</TD><TD WIDTH=298>Gives permission to trust this account.</TD>
</TR>
</TABLE></CENTER>
<P>
<P>
Please refer to the Windows NT reference manual for more information
about these flags. Most of the flags are descriptive enough to
indicate the functions they provide.
<P>
To delete a user from the system, call the <TT><FONT FACE="Courier">UserDelete($server,
$user)</FONT></TT> function. <TT><FONT FACE="Courier">$server</FONT></TT>
is the name of the server and can be <TT><FONT FACE="Courier">NULL</FONT></TT>
for the local machine. <TT><FONT FACE="Courier">$user</FONT></TT>
is the name of the user to delete. It's probably a good idea to
know the attributes of a user before you delete the account. To
get the attributes of a user, you have to use this call:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">UserGetAttributes(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$server, # The
name of the server.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$userName, # The
name of the user.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$password, # Their
password.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$passwordAge,
# The time before the password expires.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$privilege,&nbsp;&nbsp;#Their&nbsp;&nbsp;privilege.
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$homeDir, # Their
home directory.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$comment, # Any
comments about them.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$flags, # for
the account<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scriptPath );&nbsp;&nbsp;#
Pathname of login script.</FONT></TT>
</BLOCKQUOTE>
<P>
You can reset these values to different ones and modify an account's
attribute with the <TT><FONT FACE="Courier">UserSetAttributes</FONT></TT>
call. The parameters passed into the function are the same as
the <TT><FONT FACE="Courier">UserGetAttributes()</FONT></TT> function.
<P>
Listing 10.5 obtains listing information about a user.
<HR>
<BLOCKQUOTE>
<B>Listing 10.5. Using the </B><TT><B><FONT FACE="Courier">NetAdmin</FONT></B></TT><B>
module.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">use Win32::NetAdmin;<BR>
$userName = &quot;khusain&quot;;<BR>
<BR>
&nbsp;&nbsp;&nbsp;Win32::NetAdmin::UserGetAttributes('',$userName,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$Getpassword,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$GetpasswordAge,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$Getprivilege,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$GethomeDir,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$Getcomment,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$Getflags,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$Getscriptpath
) || warn();<BR>
<BR>
printf &quot;\n Attributes=%s\n%x\n%s\n%s\n%s\n%s\n%s\n%s\n&quot;,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$Getpassword,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$GetpasswordAge,
<BR>
Listing 10.5. continued <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$Getprivilege,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$GethomeDir,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$Getcomment,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$Getflags,
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$Getscriptpath
;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
To delete a user, you can use the <TT><FONT FACE="Courier">UserDelete</FONT></TT>
function. Here's the syntax:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">use Win32::NetAdmin;<BR>
Win32::NetAdmin::UserDelete($server,$username);</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="CreatingorDeletingaGroup">Creating or Deleting a
Group</A></H3>
<P>
To create a group, you can make one of these calls:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">LocalGroupCreate($server, $group, $comment);
<BR>
GroupCreate($server, $group, $comment);</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$server</FONT></TT> is the name of the
server. It may be <TT><FONT FACE="Courier">NULL</FONT></TT> to
specify the local server. <TT><FONT FACE="Courier">$groupName</FONT></TT>
is the name of the group. The <TT><FONT FACE="Courier">$comment</FONT></TT>
field is a string placed in the attributes field of that group.
<P>
To delete a group, you have to specify the name of the group in
one of the following functions:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">LocalGroupDelete($server, $group);<BR>
GroupDelete($server, $group);</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$server</FONT></TT> is the name of the
server. It may be <TT><FONT FACE="Courier">NULL</FONT></TT> to
specify the local server. The <TT><FONT FACE="Courier">$groupName</FONT></TT>
is the name of the group you are about to delete.
<H3><A NAME="CommentsAboutaGroup">Comments About a Group</A></H3>
<P>
Given a group name, you can get its attributes with a call to
one of these functions:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">LocalGroupGetAttributes($server, $groupName,
$comment);<BR>
GroupGetAttributes($server, $groupName,$comment);</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$server</FONT></TT> is the name of the
server. It may be <TT><FONT FACE="Courier">NULL</FONT></TT> to
specify the local server. <TT><FONT FACE="Courier">$groupName</FONT></TT>
is the name of the group. The <TT><FONT FACE="Courier">$comment</FONT></TT>
field is a string that will have the attributes field of that
group when the function returns.
<P>
You can set the values of these comments using the following functions:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">LocalGroupSetAttributes($server, $groupName,
$comment);<BR>
GroupSetAttributes($server, $groupName, $comment);</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="AddingUserstoaGroup">Adding Users to a Group</A>
</H3>
<P>
To add one or more users to a group, you can use one of these
two functions:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">LocalGroupAddUsers($server, $groupName,
$users);<BR>
GroupAddUsers($server, $groupName, @users);</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$server</FONT></TT> is the name of the
server. It may be <TT><FONT FACE="Courier">NULL</FONT></TT> to
specify the local server. <TT><FONT FACE="Courier">$groupName</FONT></TT>
is the name of the group. The <TT><FONT FACE="Courier">@user</FONT></TT>
array is a list of strings of user names to add. Each string does
not have to be case-sensitive in NT. The function returns <TT><FONT FACE="Courier">true</FONT></TT>
if all the users were added and <TT><FONT FACE="Courier">false</FONT></TT>
if there was an error. To add just one user name, make a list
with one item in it.
<H3><A NAME="RemovingUsersfromaGroup">Removing Users from a Group</A>
</H3>
<P>
To remove one or more users from a group, you can use one of two
functions:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">LocalGroupDelUsers($server, $groupName,
@users);<BR>
GroupDelUsers($server, $groupName, @users);</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$server</FONT></TT> is the name of the
server. It may be <TT><FONT FACE="Courier">NULL</FONT></TT> to
specify the local server. <TT><FONT FACE="Courier">$groupName</FONT></TT>
is the name of the group. <TT><FONT FACE="Courier">@user</FONT></TT>
is a list of strings of user names to remove. Each string does
not have to be case sensitive in NT. The function returns <TT><FONT FACE="Courier">true</FONT></TT>
if all the users were removed and <TT><FONT FACE="Courier">false</FONT></TT>
if there was an error. To delete just one user, make a list with
one item in it.
<H3><A NAME="CheckingGroupMembership">Checking Group Membership</A>
</H3>
<P>
To check if a user belongs to a group, you can use one of two
functions:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">LocalGroupIsMember($server, $groupName,$user);
<BR>
GroupIsMember($server, $groupName, $user);</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$server</FONT></TT> is the name of the
server. It may be <TT><FONT FACE="Courier">NULL</FONT></TT> to
specify the local server. <TT><FONT FACE="Courier">$groupName</FONT></TT>
is the name of the group. <TT><FONT FACE="Courier">$user</FONT></TT>
is the string of the user name to check. The string does not have
to be case-sensitive in NT. Each function returns <TT><FONT FACE="Courier">true</FONT></TT>
if the user is part of the group and <TT><FONT FACE="Courier">false</FONT></TT>
if the user is not part of the group.
<H3><A NAME="ListingGroupMembers">Listing Group Members</A></H3>
<P>
There are two functions to list the members in a given group:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">LocalGroupGetMembers($server, $groupName,
\@userArray)<BR>
GroupGetMembers($server, $groupName,\@userArray)</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$server</FONT></TT> is the name of the
server. It may be <TT><FONT FACE="Courier">NULL</FONT></TT> to
specify the local server. <TT><FONT FACE="Courier">$groupName</FONT></TT>
is the name of the group. The local members of this group are
those that are local to this host. The <TT><FONT FACE="Courier">userArray</FONT></TT>
is a reference to an array of user names. The function will fill
the <TT><FONT FACE="Courier">$userArray</FONT></TT> with the members
of <TT><FONT FACE="Courier">$groupName</FONT></TT>.
<P>
The <TT><FONT FACE="Courier">GetDomainController()</FONT></TT>
function returns the name of the server's domain controller. The
syntax for this call is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">GetDomainController($server,$domain,$returnedName);</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$server</FONT></TT> is the name of the
server. It may be <TT><FONT FACE="Courier">NULL</FONT></TT> to
specify the local server. <TT><FONT FACE="Courier">$domain</FONT></TT>
is the name of the domain you are querying. <TT><FONT FACE="Courier">$returnedName</FONT></TT>
is the name of the controller as a string.
<H2><A NAME="UsingtheWin32ServiceModule"><FONT SIZE=5 COLOR=#FF0000>Using
the </FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">Win32::Service</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Module</FONT></A></H2>
<P>
The <TT><FONT FACE="Courier">Win32::Service</FONT></TT> module
is used to start and stop services on an NT system. You should
be a privileged user (such as Administrator) for the functions
in this module to work.
<P>
The <TT><FONT FACE="Courier">Win32::Service::StartService()</FONT></TT>
function starts a named service on a host. The syntax for this
function is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">StartService($hostname, $servicename
);</FONT></TT>
</BLOCKQUOTE>
<P>
The name of the host at which to start the service is specified
in <TT><FONT FACE="Courier">$hostname</FONT></TT>. The value can
be set to <TT><FONT FACE="Courier">NULL</FONT></TT> for the local
host. Be careful how you specify the host name, because any name
resolution will generate a call to the DNS name server. If the
name server relies on the service you just happen to be starting,
whoops, your program may hang for a long time. <TT><FONT FACE="Courier">$servicename</FONT></TT>
is a string specifying the name of the NT service to start. This
service you are attempting to start must be registered with the
NT Service Control Manager.
<P>
To stop a service, you can call the <TT><FONT FACE="Courier">StopService()</FONT></TT>
command. This command uses a syntax similar to <TT><FONT FACE="Courier">StartService</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">StopService($hostname, $servicename )</FONT></TT>
</BLOCKQUOTE>
<P>
The name of the host and service to stop are specified in the
same manner as the <TT><FONT FACE="Courier">StartService</FONT></TT>
function.
<P>
You can get the status of a service on a host by calling the <TT><FONT FACE="Courier">GetStatus()</FONT></TT>
function. The syntax for this call is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">GetStatus($hostname, $servicename, $status
);</FONT></TT>
</BLOCKQUOTE>
<P>
The name of the host at which to start the service is specified
in <TT><FONT FACE="Courier">$hostname</FONT></TT>. The value can
be set to <TT><FONT FACE="Courier">NULL</FONT></TT> for the local
host. The name of the service is specified in <TT><FONT FACE="Courier">$serviceName</FONT></TT>.
The returned value of the status is a hash set in <TT><FONT FACE="Courier">$status</FONT></TT>
when the function returns. The keys of this hash are<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=188>'ServiceType'</TD><TD WIDTH=402>which can be one of these values: SERVICE_WIN32_OWN_PROCESS, SERVICE_WIN32_SHARE_PROCESS, SERVICE_KERNEL_DRIVER, or SERVICE_FILE_SYSTEM_DRIVER.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=188>'CurrentState'</TD><TD WIDTH=402>which can be one of these values: SERVICE_STOPPED, SERVICE_START_PENDING, SERVICE_STOP_PENDING, SERVICE_RUNNING, SERVICE_CONTINUE_RUNNING, SERVICE_PAUSE_PENDING, or SERVICE_PAUSED.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=188>'ControlsAccepted'</TD><TD WIDTH=402>The types of control codes the service can accept.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=188>'Win32ExitCode'</TD><TD WIDTH=402>The error code the service will return when it stops or starts.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=188>'ServiceSpecificExitCode'</TD><TD WIDTH=402>Any special codes returned if Win32ExitCode has a value of ERROR_SERVICE_SPECIFIC_ERROR.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=188>'CheckPoint'</TD><TD WIDTH=402>A value that is incremented at regular intervals as a service runs. This may always return a value of 0.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=188>'WaitHint'</TD><TD WIDTH=402>An estimate in milliseconds of time left until completion of the current state.
</TD></TR>
</TABLE></CENTER>
<P>
<P>
For more information on the values of these items, check out the
members of the <TT><FONT FACE="Courier">SERVICE_STATUS</FONT></TT>
struct in the Windows NT reference manual.
<P>
A service can be paused and restarted using these functions:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">PauseService($hostname ,$servicename
);<BR>
ResumeService($hostname ,$servicename);</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">$hostname</FONT></TT> and <TT><FONT FACE="Courier">$servicename</FONT></TT>
values are set the same as with other related functions.
<P>
To get a list of all the services available on a host, you can
use the <TT><FONT FACE="Courier">EnumServices()</FONT></TT> function.
The syntax for this function is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">EnumServices($hostname,\@list);</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">$hostname</FONT></TT> is specified
the same as it is for <TT><FONT FACE="Courier">StartService</FONT></TT>.
The <TT><FONT FACE="Courier">$list</FONT></TT> variable should
be a reference to a list of service names:
<BLOCKQUOTE>
<TT><FONT FACE="Courier"># Print out all services on this host
<BR>
<BR>
&nbsp;&nbsp;&nbsp;use Win32::Service;<BR>
#<BR>
# Get a list of available services.<BR>
#<BR>
&nbsp;&nbsp;&nbsp;Win32::Service::EnumServices(NULL,\@list );
<BR>
<BR>
print &quot;\n The services on this system are:&quot;;<BR>
$i =0;<BR>
foreach $Service (@list){<BR>
&nbsp;&nbsp;&nbsp;&nbsp;print &quot;$i++ :&nbsp;&nbsp;$service
\n&quot;;<BR>
&nbsp;&nbsp;&nbsp;}</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="UsingtheWin32NetResourceModule"><FONT SIZE=5 COLOR=#FF0000>Using
the </FONT><TT><FONT SIZE=5 COLOR=#FF0000 FACE="Courier">Win32::NetResource</FONT></TT><FONT SIZE=5 COLOR=#FF0000>
Module</FONT></A></H2>
<P>
The <TT><FONT FACE="Courier">Win32::NetResource</FONT></TT> module
is used to work with network resource objects in the NT system.
Using these functions, you can get and set network resources while
logged in as the administrator.
<P>
Use the <TT><FONT FACE="Courier">GetSharedResources</FONT></TT>
function to get a list of shared resources. The syntax of this
function is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">GetSharedResources(\@Resources,$dwType);</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">$dwType</FONT></TT> word specifies
the type of resource to get. It can take one of these values:
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=199>RESOURCETYPE_ANY</TD><TD WIDTH=221>All resources
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199>RESOURCETYPE_DISK</TD><TD WIDTH=221>Resources for use with disk
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=199>RESOURCETYPE_PRINT</TD><TD WIDTH=221>Resources for use with printing
</TD></TR>
</TABLE></CENTER>
<P>
<TT><FONT FACE="Courier">@Resources</FONT></TT> is a list of references
to hashes. Each hash in the list is of the type <TT><FONT FACE="Courier">%NETRESOURCE</FONT></TT>.
Each <TT><FONT FACE="Courier">%NETRESOURCE</FONT></TT> item has
the following keys:<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=148><TT><FONT FACE="Courier">'Scope'</FONT></TT>
</TD><TD WIDTH=313>The scope of the item</TD></TR>
<TR VALIGN=TOP><TD WIDTH=148><TT><FONT FACE="Courier">'Type'</FONT></TT>
</TD><TD WIDTH=313>The type of resource</TD></TR>
<TR VALIGN=TOP><TD WIDTH=148><TT><FONT FACE="Courier">'DisplayType'</FONT></TT>
</TD><TD WIDTH=313>The display type of the resource</TD></TR>
<TR VALIGN=TOP><TD WIDTH=148><TT><FONT FACE="Courier">'Usage'</FONT></TT>
</TD><TD WIDTH=313>Specifies how the resource is used</TD></TR>
<TR VALIGN=TOP><TD WIDTH=148><TT><FONT FACE="Courier">'LocalName'</FONT></TT>
</TD><TD WIDTH=313>The name of the local device for this resource
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=148><TT><FONT FACE="Courier">'RemoteName'</FONT></TT>
</TD><TD WIDTH=313>The network name of the resource (if any)</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=148><TT><FONT FACE="Courier">'Comment'</FONT></TT>
</TD><TD WIDTH=313>Free form text</TD></TR>
<TR VALIGN=TOP><TD WIDTH=148><TT><FONT FACE="Courier">'Provider'</FONT></TT>
</TD><TD WIDTH=313>The name of the vendor-providing resource</TD>
</TR>
</TABLE></CENTER>
<P>
<P>
The first item in the <TT><FONT FACE="Courier">%NETSOURCE</FONT></TT>
hash is the scope of what the resource affects. The scope of a
resource can be one of the following values:<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=205><TT><FONT FACE="Courier">RESOURCE_CONNECTED</FONT></TT>
</TD><TD WIDTH=261>Connected resources only</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT><FONT FACE="Courier">RESOURCE_REMEMBERED</FONT></TT>
</TD><TD WIDTH=261>Resources reconnected at each login</TD></TR>
<TR VALIGN=TOP><TD WIDTH=205><TT><FONT FACE="Courier">RESOURCE_GLOBALNET</FONT></TT>
</TD><TD WIDTH=261>Resources available to entire network</TD>
</TR>
</TABLE></CENTER>
<P>
<P>
The type of resource is the same as specified in <TT><FONT FACE="Courier">$dwType</FONT></TT>.
The display type item in <TT><FONT FACE="Courier">%NETSOURCE</FONT></TT>
is the third item in the hash. It contains more information about
how the object is displayed in NT. Here are the possible values:
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=286>RESOURCEDISPLAYTYPE_DOMAIN</TD><TD WIDTH=239>Display as domain
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=286>RESOURCEDISPLAYTYPE_SERVER</TD><TD WIDTH=239>Display as server
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=286>RESOURCEDISPLAYTYPE_SHARE</TD><TD WIDTH=239>Display as sharepoint
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=286>RESOURCEUSAGE_CONNECTABLE</TD><TD WIDTH=239>Connected to a local device
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=286>RESOURCEUSAGE_CONTAINER</TD><TD WIDTH=239>Resource contains more resources
</TD></TR>
</TABLE></CENTER>
<P>
<P>
To make a new connection, you can use the <TT><FONT FACE="Courier">AddConnection</FONT></TT>
function. The syntax for this function is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">AddConnection($resource,$Password,$UserName,$Flags)</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$resource</FONT></TT> is a reference
to a <TT><FONT FACE="Courier">%NETRESOURCE</FONT></TT> hash with
the connection to make. The user name and password are provided
by the user making the connection to the resources. <TT><FONT FACE="Courier">$Flag</FONT></TT>
is set to <TT><FONT FACE="Courier">1</FONT></TT> if the connection
has to be recorded on disk for all future logins.
<P>
To break off the connection, use the <TT><FONT FACE="Courier">CancelConnection</FONT></TT>
function call. The syntax for this function call is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">CancelConnection($Name,$Connection,$Force);</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$Name</FONT></TT> is set to the name
of the local device the resource is connected to. <TT><FONT FACE="Courier">$Connection</FONT></TT>
is set to the type of connection: <TT><FONT FACE="Courier">1</FONT></TT>
for persistent connections and <TT><FONT FACE="Courier">0</FONT></TT>
for nonpersistent connections. If <TT><FONT FACE="Courier">$Force</FONT></TT>
is set to <TT><FONT FACE="Courier">1</FONT></TT>, the connection
is broken regardless of any errors that may require a delay.
<P>
To see if there were any errors after a command, you can call
the <TT><FONT FACE="Courier">WNetGetLastError()</FONT></TT> function.
The syntax for this function is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">WNetGetLastError($ErrorCode,$Description,$Name);</FONT></TT>
</BLOCKQUOTE>
<P>
All three arguments into this function call return a piece of
information about the last error. <TT><FONT FACE="Courier">$ErrorCode</FONT></TT>
is set to the error code number, <TT><FONT FACE="Courier">$Description</FONT></TT>
contains a description of the error, and <TT><FONT FACE="Courier">$Name</FONT></TT>
is set to the name of the error. This function gets the Extended
Network Error. This is only applicable if <TT><FONT FACE="Courier">Win32::GetLastError()</FONT></TT>
returns <TT><FONT FACE="Courier">ERROR_EXTENDED_ERROR</FONT></TT>.
<P>
The <TT><FONT FACE="Courier">GetError</FONT></TT> method returns
the last error for a <TT><FONT FACE="Courier">Win32::NetResource</FONT></TT>
call. The syntax for this function is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">GetError( $ErrorCode );</FONT></TT>
</BLOCKQUOTE>
<P>
The Unc name for a local path can be derived from a local path
with the <TT><FONT FACE="Courier">GetUncName()</FONT></TT> function.
The syntax for this function is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">GetUncName( $UncName, $LocalPath );</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$UncName</FONT></TT> is set to the Unc
name of the network connection. <TT><FONT FACE="Courier">$LocalPath</FONT></TT>
is the local path.
<P>
To add a new share object, call the <TT><FONT FACE="Courier">NetShareAdd</FONT></TT>
function. The syntax for this function is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">NetShareAdd(\%SHARE,$parm_err,$servername
)</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">%SHARE_INFO</FONT></TT> is a hash describing
the share. The <TT><FONT FACE="Courier">ShareInfo</FONT></TT>
hash is used to pass information to the <TT><FONT FACE="Courier">NetResource</FONT></TT>
functions about the share objects. The keys for this hash are
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">'netname'</FONT></TT>
</TD><TD WIDTH=222>The name of the share</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">'type'</FONT></TT>
</TD><TD WIDTH=222>The type of share</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">'remark'</FONT></TT>
</TD><TD WIDTH=222>A string comment</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">'permissions'</FONT></TT>
</TD><TD WIDTH=222>Permissions values</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">'maxusers'</FONT></TT>
</TD><TD WIDTH=222>The maximum number of users</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">'current-users'</FONT></TT>
</TD><TD WIDTH=222>The current number of users</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">'path'</FONT></TT>
</TD><TD WIDTH=222>The path of the share</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">'passwd'</FONT></TT>
</TD><TD WIDTH=222>A password if one is required</TD></TR>
</TABLE></CENTER>
<P>
<P>
The <TT><FONT FACE="Courier">$parm_err</FONT></TT> variable is
set upon returning from the function to an error value, if any.
<TT><FONT FACE="Courier">$servername</FONT></TT> is the name of
the server. To offer a disk resource for sharing on the network,
call the <TT><FONT FACE="Courier">NetShareCheck()</FONT></TT>
function. The syntax for this function is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">NetShareCheck($device,$type,$servername)</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">$device</FONT></TT> is the name of the
device to be checked for shared access. The type of share is returned
in <TT><FONT FACE="Courier">$type</FONT></TT>. The value in <TT><FONT FACE="Courier">$type</FONT></TT>
is only valid if the function returns a nonzero value. <TT><FONT FACE="Courier">$servername</FONT></TT>
is the name of the server.
<P>
Use the <TT><FONT FACE="Courier">NetShareDel</FONT></TT> function
to remove a share from a machine's list of shares. The syntax
for this function is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">NetShareDel( $netname, $servername );</FONT></TT>
</BLOCKQUOTE>
<P>
The name of the share to delete is <TT><FONT FACE="Courier">$netname</FONT></TT>,
and the machine offering the share is listed in <TT><FONT FACE="Courier">$servername</FONT></TT>.
<P>
To get the <TT><FONT FACE="Courier">%SHARE_INFO</FONT></TT> information
structure, you can use the <TT><FONT FACE="Courier">NetShareGetInfo()</FONT></TT>
function. The syntax of this function is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">NetShareGetInfo( $netname, \%SHARE,$servername);</FONT></TT>
</BLOCKQUOTE>
<P>
The name of the share to get information for is named in <TT><FONT FACE="Courier">$netname</FONT></TT>,
and the machine offering the share is listed in <TT><FONT FACE="Courier">$servername</FONT></TT>.
The <TT><FONT FACE="Courier">\%SHARE</FONT></TT> is a reference
to the <TT><FONT FACE="Courier">SHARE_INFO</FONT></TT> hash describing
the share.
<P>
Once you have the information, you can set its values with the
<TT><FONT FACE="Courier">NetShareSetInfo()</FONT></TT> function.
The syntax is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">NetShareSetInfo( $netname,\%SHARE,$parm_err,$servername);</FONT></TT>
</BLOCKQUOTE>
<P>
The name of the share to get information for is named in <TT><FONT FACE="Courier">$netname</FONT></TT>,
and the machine offering the share is listed in <TT><FONT FACE="Courier">$servername</FONT></TT>.
The <TT><FONT FACE="Courier">\%SHARE</FONT></TT> is a reference
to the <TT><FONT FACE="Courier">SHARE_INFO</FONT></TT> hash describing
the share.
<H2><A NAME="HandlingInputfromMultipleSources"><FONT SIZE=5 COLOR=#FF0000>Handling
Input from Multiple Sources</FONT></A></H2>
<P>
The <TT><FONT FACE="Courier">Win32::Ipc</FONT></TT> module is
useful when waiting for input from different types of input. In
Perl on a UNIX system, you can wait on multiple sources using
the <TT><FONT FACE="Courier">select(2)</FONT></TT> call, but the
<TT><FONT FACE="Courier">select()</FONT></TT> operation excludes
semaphores and messages. On an NT system you can use the <TT><FONT FACE="Courier">Win32::Ipc</FONT></TT>
module to wait on sources such as a <TT><FONT FACE="Courier">Mutex</FONT></TT>,
<TT><FONT FACE="Courier">ChangeNotification</FONT></TT>, <TT><FONT FACE="Courier">Semaphore</FONT></TT>,
or even another process. The syntax for this call is
<BLOCKQUOTE>
<TT><FONT FACE="Courier">WaitForMultipleObjects(@list , $WaitAll
,$TimeOut );</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">@list</FONT></TT> is a list of objects
to wait for. The <TT><FONT FACE="Courier">$WaitAll</FONT></TT>
variable is set to <TT><FONT FACE="Courier">1</FONT></TT> if the
function has to return when all the objects have input. If <TT><FONT FACE="Courier">$WaitAll</FONT></TT>
is set to <TT><FONT FACE="Courier">0</FONT></TT>, the function
returns when there is input for the first available object. The
timeout value is given as milliseconds in <TT><FONT FACE="Courier">$TimeOut</FONT></TT>.
<P>
Here's an example of how to wait for more than one input. There
are two semaphores and one <TT><FONT FACE="Courier">Mutex</FONT></TT>
to wait for in Listing 10.6.
<HR>
<BLOCKQUOTE>
<B>Listing 10.6. Handling input from more than one source.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 use Win32::Mutex;<BR>
&nbsp;2 use Win32::Semaphore;<BR>
&nbsp;3 #&nbsp;&nbsp;Create all the objects here:<BR>
&nbsp;4 Win32::Semaphore::Create($sem, 1,1,&quot;MySemaphore&quot;)||die
$!;<BR>
&nbsp;5 Win32::Semaphore::Create($com, 1,1,&quot;ComPort1&quot;)||die
$!;<BR>
&nbsp;6 Win32::Mutex::Create( $mut,0,&quot;MyMutex&quot;) ||die
$!;<BR>
&nbsp;7 #<BR>
&nbsp;8 # note: the WaitForMultipleObjects call is inherited,
and<BR>
&nbsp;9 #<BR>
10<BR>
11 Win32::Semaphore::WaitForMultipleObjects(($sem,$mut,$com),
<BR>
12&nbsp;&nbsp;&nbsp;&nbsp; 1, INFINITE )<BR>
13&nbsp;&nbsp;&nbsp;&nbsp; || die $!;</FONT></TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
This chapter has provided enough information on how to use <TT><FONT FACE="Courier">Win32::</FONT></TT>
and its extension modules to access Windows NT system facilities.
Some of these functions may change over time and as development
progresses. However, you have enough information now to write
system administration applications with the Win32 version of Perl
for NT.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch9.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch9.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch11.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch11.htm"><IMG 
SRC="nc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>
