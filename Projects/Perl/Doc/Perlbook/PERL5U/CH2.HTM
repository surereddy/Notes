<HTML>

<HEAD>
   <TITLE>Chapter 2 -- A Brief Introduction to Perl</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT COLOR=#FF0000>Chapter 2</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>A Brief Introduction to Perl</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#RunningPerl" >Running Perl</A>
<LI><A HREF="#VariablesinPerl" >Variables in Perl</A>
<UL>
<LI><A HREF="#SpecialVariables" >Special Variables</A>
<LI><A HREF="#CodeBlocks" >Code Blocks</A>
<LI><A HREF="#QuotingRules" >Quoting Rules</A>
</UL>
<LI><A HREF="#ArraysandAssociativeArrays" >Arrays and Associative Arrays</A>
<UL>
<LI><A HREF="#WhatAreAssociativeArrays" >What Are Associative Arrays?</A>
</UL>
<LI><A HREF="#ArrayOperations" >Array Operations</A>
<LI><A HREF="#FileHandlesandOperators" >File Handles and Operators</A>
<LI><A HREF="#WorkingwithPatterns" >Working with Patterns</A>
<LI><A HREF="#Subroutines" >Subroutines</A>
<LI><A HREF="#AFinalNote" >A Final Note</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
This chapter offers a very brief introduction to Perl programming
and syntax. If this is the first time you are working with Perl,
do not despair at the barrage of information in this chapter.
As you progress through the book, any new or elaborate syntax
will be explained. This chapter is intended as an introduction
to Perl, not a complete tutorial-you'll learn more about the advanced
features of Perl in the subsequent chapters. If you are already
familiar with Perl, you might want to glance through this chapter
to get a quick overview of the syntax and reserved words.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD ><B>Note </B></TD></TR>
<TR VALIGN=TOP><TD >
<BLOCKQUOTE>
Please refer to the inside front cover for a quick reference of all the special variables in Perl. </BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="RunningPerl"><FONT SIZE=5 COLOR=#FF0000>Running Perl</FONT></A>
</H2>
<P>
Perl is a program just like any other program on your system,
only it's more powerful than most other programs! To run Perl,
you can simply type <TT><B><FONT FACE="Courier">perl</FONT></B></TT>
at the prompt and then type your code. In almost all cases, you'll
want to keep your Perl code in files just like shell scripts.
A Perl program is referred to as a script.
<P>
Normally, the Perl program on your machine will be located in
the <TT><FONT FACE="Courier">/usr/bin</FONT></TT>, <TT><FONT FACE="Courier">/usr/bin/perl5</FONT></TT>,
or <TT><FONT FACE="Courier">/usr/local/bin/perl5</FONT></TT> directory.
Use a <TT><FONT FACE="Courier">find</FONT></TT> command to see
whether you can locate Perl on your system. If you are certain
that you do not have Perl on your system, turn to <A HREF="ch24.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch24.htm" >Chapter 24</A>,
&quot;Building and Installing the Perl 5 Interpreter,&quot; for
information on how to install Perl on your machine. Perl scripts
are of the following form:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">#!/usr/bin/perl <BR>
... <I>insert code here</I> ...<BR>
# comments are text after the # mark.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
comments can begin anywhere on a line.</FONT></TT>
</BLOCKQUOTE>
<P>
Here's a simple Perl script:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">#/usr/bin/perl<BR>
print &quot;\n Whoa! That was good!\n&quot;;</FONT></TT>
</BLOCKQUOTE>
<P>
If the path to the Perl program on your system is different, you'll
have to use that pathname instead of <TT><FONT FACE="Courier">/usr/bin/perl</FONT></TT>.
You also can specify programs on the command line with the <TT><FONT FACE="Courier">-e</FONT></TT>
switch to Perl. For example, entering the following command at
the prompt will print <TT><FONT FACE="Courier">Howdy!</FONT></TT>.
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$ perl -e  'print &quot;Howdy !\n&quot;;'</FONT></TT>
</BLOCKQUOTE>
<P>
In all but the shortest of Perl programs, you'll use a file to
store your Perl code as a script. Using a script file offers you
the ease of not having to type all the commands interactively
and thus not being able to correct typing errors easily. Also,
a script file provides a written record of what commands to use
to accomplish a certain task.
<P>
To fire off a command on all lines in the input, use <TT><FONT FACE="Courier">-n</FONT></TT>
option. Thus, the line
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$perl -n 's/old/new/g' test.txt</FONT></TT>
</BLOCKQUOTE>
<P>
runs the command to substitute all strings <TT><FONT FACE="Courier">old</FONT></TT>
with <TT><FONT FACE="Courier">new</FONT></TT> on each line from
the file <TT><FONT FACE="Courier">test.txt</FONT></TT>. If you
use the <TT><FONT FACE="Courier">-p</FONT></TT> option, it prints
each line as it is read in. The <TT><FONT FACE="Courier">-v</FONT></TT>
option prints the version number of Perl you are running. This
book is written for Perl 5.002.
<P>
Now, let's begin the introduction to the Perl language.
<H2><A NAME="VariablesinPerl"><FONT SIZE=5 COLOR=#FF0000>Variables
in Perl</FONT></A></H2>
<P>
Perl has three basic types of variables: scalars, arrays, and
associative arrays. A <I>scalar </I>variable is anything that
can hold one number (either as a floating point number or as an
integer) or a string. An <I>array</I> stores many scalars in a
sequence, where each scalar can be indexed using a number starting
with 0 on up. An <I>associative array</I> is like an array in
that it stores strings in sequence but uses another string as
an index to address individual items instead of a number. I cover
how to use these three types of variables in this chapter.
<P>
The syntax for a scalar variable is <TT><FONT FACE="Courier">$variable_name</FONT></TT>.
A variable name is set up and addressed in the same way as Bourne
shell variables. To assign values to a scalar, you use statements
like these:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$name = &quot;Kamran&quot;;<BR>
$number= 100;<BR>
$phone_Number = '555-1232';</FONT></TT>
</BLOCKQUOTE>
<P>
A variable in Perl is evaluated at runtime to derive a value that
is one of the following: a string, a number, or a pointer to scalar.
(To see the use of pointers and references, refer to <A HREF="ch3.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch3.htm" >Chapter 3</A>,
&quot;References.&quot;)
<P>
To print out the value of a variable, you use a <TT><FONT FACE="Courier">print</FONT></TT>
statement. Therefore, to print the value of <TT><FONT FACE="Courier">$name</FONT></TT>,
you would make the following call:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">print $name;</FONT></TT>
</BLOCKQUOTE>
<P>
The value of <TT><FONT FACE="Courier">$name</FONT></TT> is printed
to the screen. Perl scripts &quot;expect&quot; input from a standard
input (the keyboard) and to write to the standard output. Of course,
you can also use the <TT><FONT FACE="Courier">print</FONT></TT>
statement to print the values of special variables that are built
into Perl.
<H3><A NAME="SpecialVariables">Special Variables</A></H3>
<P>
Table 2.1 lists the special variables in Perl. The first column
contains the variable, and the second contains a verbose name
that you can use to make the code readable. The third column in
the table describes the contents of each variable. 
<P>
You can use the verbose names (in column 2) by including the following
line in the beginning of your code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">use English; </FONT></TT>
</BLOCKQUOTE>
<P>
This statement will let you use the <TT><FONT FACE="Courier">English.pm</FONT></TT>
module in your code. (I cover the use of modules in <A HREF="ch4.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch4.htm" >Chapter 4</A>,
&quot;Introduction to Perl Modules.&quot;) Not all Perl variables
have an equivalent name in the <TT><FONT FACE="Courier">English.pm</FONT></TT>
module. The entry &quot;n/a&quot; in the second column indicates
that there is not an English name for the variable. <BR>
<P>
<CENTER><B>Table 2.1. Special variables in Perl. </B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=100><I>Variable</I></TD><TD WIDTH=245><I>English Name</I>
</TD><TD WIDTH=245><I>Description</I></TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$_</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$ARG</FONT></TT></TD><TD WIDTH=245>The default input and output pattern searching space
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$1-$9</FONT></TT></TD>
<TD WIDTH=245>n/a</TD><TD WIDTH=245>The subpattern from the last set of parentheses in a pattern match
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$&amp;</FONT></TT>
</TD><TD WIDTH=245><TT><FONT FACE="Courier">$MATch</FONT></TT>
</TD><TD WIDTH=245>The last pattern matched (RO)</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$`</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$PREMATch</FONT></TT></TD>
<TD WIDTH=245>The string preceding a pattern match (RO)</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$&#180;</FONT></TT>
</TD><TD WIDTH=245><TT><FONT FACE="Courier">$POSTMATch</FONT></TT>
</TD><TD WIDTH=245>The string following a pattern match (RO)</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$+</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$LAST_PAREN_MATch</FONT></TT>
</TD><TD WIDTH=245>The last bracket matched in a pattern (RO)
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$*</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$MULTILINE_MATchING</FONT></TT>
</TD><TD WIDTH=245>Set to <TT><FONT FACE="Courier">1</FONT></TT> to enable multi-line matching; set to <TT><FONT FACE="Courier">0</FONT></TT> by default
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$.</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$INPUT_LINE_NUMBER</FONT></TT>
</TD><TD WIDTH=245>The current input line number; reset on <TT><FONT FACE="Courier">close()</FONT></TT> call only
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$/</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$INPUT_RECORD_SEPARATOR</FONT></TT>
</TD><TD WIDTH=245>The newline by default</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$|</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$AUTO_FLUSH</FONT></TT>
</TD><TD WIDTH=245>If set to <TT><FONT FACE="Courier">1</FONT></TT>, forces a flush on every <TT><FONT FACE="Courier">write</FONT></TT> or <TT><FONT FACE="Courier">print</FONT></TT>; <TT><FONT FACE="Courier">0</FONT></TT> by default
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$,</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$OUTPUT_FIELD_SEPARATOR</FONT></TT>
</TD><TD WIDTH=245>Specifies what is printed between fields</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$\</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$INPUT_RECORD_SEPARATOR</FONT></TT>
</TD><TD WIDTH=245>The output record separator for the print operator
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$&quot;</FONT></TT>
</TD><TD WIDTH=245><TT><FONT FACE="Courier">$LIST_SEPARATOR</FONT></TT>
</TD><TD WIDTH=245>The separator for elements within a list</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$;</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$SUBSCRIPT_SEPARATOR</FONT></TT>
</TD><TD WIDTH=245>The character for multidimensional array emulation
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$#</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$FORMAT</FONT></TT></TD>
<TD WIDTH=245>Output format for printed numbers</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$%</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$FORMAT_PAGE_NUMBER</FONT></TT>
</TD><TD WIDTH=245>The current page number</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$=</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$FORMAT_LINES_PER_PAGE</FONT></TT>
</TD><TD WIDTH=245>The number of lines per page</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$-</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$FORMAT_LINES_LEFT</FONT></TT>
</TD><TD WIDTH=245>The number of lines still left to draw on the page
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$~</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$FORMAT_NAME</FONT></TT>
</TD><TD WIDTH=245>The name of the current format being used</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$^</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$FORMAT_TOP_NAME</FONT></TT>
</TD><TD WIDTH=245>The name of the current top-of-page format
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$:</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$FORMAT_LINE_BREAK_chARACTERS</FONT></TT>
</TD><TD WIDTH=245>The set of characters after which a string can be broken up to fill with continuation characters
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$^L</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$FORMAT_FORMFEED</FONT></TT>
</TD><TD WIDTH=245>The default form feed operator</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$^A</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$AccUMULATOR</FONT></TT>
</TD><TD WIDTH=245>The current format line accumulator for <TT><FONT FACE="Courier">format()</FONT></TT> lines
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$?</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$chILD_ERROR</FONT></TT>
</TD><TD WIDTH=245>The status from the last tilde command</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$!</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$ERRNO</FONT></TT></TD>
<TD WIDTH=245>The last <TT><FONT FACE="Courier">errno</FONT></TT> value
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$@</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$EVAL_ERROR</FONT></TT>
</TD><TD WIDTH=245>The Perl error message from the last <TT><FONT FACE="Courier">eval</FONT></TT> statement
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$$</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$PROCESS_ID</FONT></TT>
</TD><TD WIDTH=245>The process number of this Perl script</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$&lt;</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$REAL_USER_ID</FONT></TT>
</TD><TD WIDTH=245>The real UID of this process</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$&gt;</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$EFFECTIVE_USER_ID</FONT></TT>
</TD><TD WIDTH=245>The effective UID of this process </TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$(</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$REAL_GROUP_ID</FONT></TT>
</TD><TD WIDTH=245>The real group GID of this process</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$)</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$EFFECTIVE_GROUP_ID</FONT></TT>
</TD><TD WIDTH=245>The effective GID of this process</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$0</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$PROGRAM_NAME</FONT></TT>
</TD><TD WIDTH=245>The name of the program in <TT><FONT FACE="Courier">$ARGV[0]</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$[</FONT></TT></TD>
<TD WIDTH=245>n/a</TD><TD WIDTH=245>Index of the first element in the array
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$]</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$PERL_VERSION</FONT></TT>
</TD><TD WIDTH=245>The Perl version string</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$^D</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$DEBUGGING</FONT></TT>
</TD><TD WIDTH=245>The current value of the debugging flag</TD>
</TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$^F</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$SYSTEM_FD_MAX</FONT></TT>
</TD><TD WIDTH=245>The maximum file descriptors in the system (RO)
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$^I</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$INPLACE_EDIT</FONT></TT>
</TD><TD WIDTH=245>The in-place edit extension</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$^P</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$PERLDB</FONT></TT></TD>
<TD WIDTH=245>The value of the internal debugger flag</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$^T</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$BASETIME</FONT></TT></TD>
<TD WIDTH=245>The time at which the debugged script started running
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$^W</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$WARNING</FONT></TT></TD>
<TD WIDTH=245>The value of the <TT><FONT FACE="Courier">-w</FONT></TT> switch
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$^X</FONT></TT></TD>
<TD WIDTH=245><TT><FONT FACE="Courier">$EXECUTABLE_NAME</FONT></TT>
</TD><TD WIDTH=245>The name of the program in <TT><FONT FACE="Courier">$ARGV[0]</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$ARGV</FONT></TT></TD>
<TD WIDTH=245>n/a</TD><TD WIDTH=245>The name of the current file while reading from the <TT><FONT FACE="Courier">&lt;&gt;</FONT></TT> in a <TT><FONT FACE="Courier">while</FONT></TT> loop
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">$VERSION</FONT></TT>
</TD><TD WIDTH=245>n/a</TD><TD WIDTH=245>The version number of the Perl interpreter
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">%ENV</FONT></TT></TD>
<TD WIDTH=245>n/a</TD><TD WIDTH=245>The hash of the environment variables for the process 
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">%Inc</FONT></TT></TD>
<TD WIDTH=245>n/a</TD><TD WIDTH=245>The hash of filenames that have been included in the current file
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">%SIG</FONT></TT></TD>
<TD WIDTH=245>n/a</TD><TD WIDTH=245>The hash of all signal handlers for the current process
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">@ARGV</FONT></TT></TD>
<TD WIDTH=245>n/a</TD><TD WIDTH=245>The command-line arguments for the script
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">@EXPORT</FONT></TT>
</TD><TD WIDTH=245>n/a</TD><TD WIDTH=245>The names of all exported functions in a module
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">@F</FONT></TT></TD>
<TD WIDTH=245>n/a</TD><TD WIDTH=245>The command-line options used for the current program
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">@Inc</FONT></TT></TD>
<TD WIDTH=245>n/a</TD><TD WIDTH=245>The pathnames of places to look in for all included files
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=100><TT><FONT FACE="Courier">@ISA</FONT></TT></TD>
<TD WIDTH=245>n/a</TD><TD WIDTH=245>The names of all modules to search for when looking for a module
</TD></TR>
</TABLE></CENTER>
<P>
<P>
Don't worry if you do not recognize some of these strange characters.
I will be covering them all in the course of this book. 
<P>
Now let's see how you can use these built-in variables as well
as your own variables in code.
<H3><A NAME="CodeBlocks">Code Blocks</A></H3>
<P>
Variables and assignment statements exist in code blocks. Each
code block is a section of code between two curly braces. Recognizing
code blocks matters when you are concerned about the scope of
influence of code on the value of a variable. (More on scope in
a moment.) Code blocks are simply assignment statements enclosed
between curly braces. Normally, you see code blocks in loop constructs
and conditionals. It's syntactically correct to use statements
like this in Perl programs:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">{<BR>
<I>print something;<BR>
print more of something; <BR>
more statements;<BR>
</I>}</FONT></TT>
</BLOCKQUOTE>
<P>
This coding style is rare and is usually done only if the programmer
explicitly wants to keep some special variables within the curly
braces. Usually, most of the application's code will be in one
type of block, either a subroutine, loop, or conditional, with
only the lines not in such blocks being those that are global
to the rest of the components of the program. 
<P>
Here are some examples of code blocks available in Perl:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">{<BR>
# a simple code block with statements in here. <BR>
}<BR>
<BR>
while(<I>condition</I>) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;... <I>execute code here while condition
is true</I>;<BR>
}<BR>
<BR>
until(condition) {&nbsp;&nbsp;# opposite of while statement.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;... <I>execute code here while condition
is false</I>;<BR>
}<BR>
<BR>
do {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;... <I>do this at least once</I> ...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;... <I>stop if condition is false</I>
...<BR>
} while(condition);<BR>
<BR>
do {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;... <I>do this at least once</I> ...<BR>
&nbsp;&nbsp;&nbsp;&nbsp;... <I>stop if condition is true</I> ...
<BR>
} until(condition);<BR>
<BR>
if (condition1) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<I>condition1_code true</I>;<BR>
} else {<BR>
...&nbsp;&nbsp;&nbsp;&nbsp;<I>no condition1 up to conditionN&nbsp;&nbsp;is
true</I>;<BR>
}<BR>
<BR>
if (condition1) {<BR>
...&nbsp;&nbsp;&nbsp;&nbsp;<I>condition1_code true</I>;<BR>
} elsif (condition2) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<I>condition1_code true</I>;<BR>
....<BR>
} elsif (conditionN) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;<I>conditionN_code true</I>;<BR>
} else {<BR>
...&nbsp;&nbsp;&nbsp;&nbsp;<I>no condition from 1 up to N&nbsp;&nbsp;is
true</I>;<BR>
}<BR>
<BR>
unless (condition1) { # opposite of &quot;if&quot; statement.
<BR>
...&nbsp;&nbsp;&nbsp;&nbsp;<I>do this if condition is false</I>;
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The condition in these blocks of code is anything from a Perl
variable to an expression that returns either a <TT><FONT FACE="Courier">true</FONT></TT>
or <TT><FONT FACE="Courier">false</FONT></TT> value. A <TT><FONT FACE="Courier">true</FONT></TT>
value is a non-zero value or a non-empty string.
<P>
Code blocks can be declared within code blocks to create levels
of code blocks. Variables declared in one code block are usually
global to the rest of the program. To keep the scope of the variable
limited to the code block in which it is declared, use the <TT><FONT FACE="Courier">my
$variableName</FONT></TT> syntax. If you declare with <TT><FONT FACE="Courier">local
$variableName</FONT></TT> syntax, the <TT><FONT FACE="Courier">$variableName</FONT></TT>
will be available to all lower levels but not outside the code
block.
<P>
Figure 2.1 illustrates how the scoping rules work in Perl. The
main block declares two variables, <TT><FONT FACE="Courier">$x</FONT></TT>
and <TT><FONT FACE="Courier">$y</FONT></TT>. There are two blocks
of code between curly braces, block A and block B. The variable
<TT><FONT FACE="Courier">$x</FONT></TT> is not available to either
of these blocks, but <TT><FONT FACE="Courier">$y</FONT></TT> will
be available. 
<P>
<A HREF="f2-1.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/f2-1.gif" ><B>Figure 2.1 : </B><I>Scoping rules in Perl </I></A>
<P>
Because block A is declared in the main block, the code in it
will be able to access <TT><FONT FACE="Courier">$y</FONT></TT>
but not <TT><FONT FACE="Courier">$x</FONT></TT> because <TT><FONT FACE="Courier">$x</FONT></TT>
is declared as <TT><FONT FACE="Courier">&quot;my&quot;</FONT></TT>.
The variable <TT><FONT FACE="Courier">$f</FONT></TT> will not
be available to other blocks of code even if they are declared
within block A. The variable <TT><FONT FACE="Courier">$g</FONT></TT>
is not declared as <TT><FONT FACE="Courier">&quot;local&quot;</FONT></TT>
or <TT><FONT FACE="Courier">&quot;my&quot;</FONT></TT>, so it's
not visible to the main module nor to block B. 
<P>
The code in block B declares two variables, <TT><FONT FACE="Courier">$k</FONT></TT>
and <TT><FONT FACE="Courier">$m</FONT></TT>. The variable <TT><FONT FACE="Courier">$k</FONT></TT>
can be assigned the value of <TT><FONT FACE="Courier">$g</FONT></TT>,
provided that the code in block A is called before the code in
block B. If the code in block B is called before the code in block
A, the variable <TT><FONT FACE="Courier">$g</FONT></TT> will not
be declared, and a value of <TT><FONT FACE="Courier">'undef'</FONT></TT>
will be assigned to <TT><FONT FACE="Courier">$k</FONT></TT>. Also,
<TT><FONT FACE="Courier">$m</FONT></TT> cannot use the value of
<TT><FONT FACE="Courier">$f</FONT></TT> because <TT><FONT FACE="Courier">$f</FONT></TT>
is declared in block A as a <TT><FONT FACE="Courier">&quot;my&quot;</FONT></TT>
variable. The values of <TT><FONT FACE="Courier">$y</FONT></TT>
and <TT><FONT FACE="Courier">$g</FONT></TT> are available to code
in block B. 
<P>
Finally, another code block (call it C) could be assigned in block
B. Block C is not shown in the figure. All variables in this new
block C that are declared as neither <TT><FONT FACE="Courier">&quot;my&quot;</FONT></TT>
nor <TT><FONT FACE="Courier">&quot;local&quot;</FONT></TT> would
be available to blocks A and B and the main program. Code in block
C would not be able to access variables <TT><FONT FACE="Courier">$f</FONT></TT>,
<TT><FONT FACE="Courier">$k</FONT></TT>, and <TT><FONT FACE="Courier">$m</FONT></TT>
because they are declared as <TT><FONT FACE="Courier">&quot;my&quot;</FONT></TT>.
The variable <TT><FONT FACE="Courier">$g</FONT></TT> would not
be available to code in block B or C because it is local to block
A.
<P>
Keep in mind that variables in code blocks are also declared at
the first time they are assigned a value. This creation includes
arrays and strings. Variables are then evaluated by the parser
when they appear in code, and even in strings. There are times
when you do not want the variable to be evaluated. This is the
time when you should be aware of quoting rules in Perl.
<H3><A NAME="QuotingRules">Quoting Rules</A></H3>
<P>
Three different types of quotes can be used in Perl. Double quotes
(<TT><FONT FACE="Courier">&quot;</FONT></TT>) are used to enclose
strings. Any scalars in double-quoted strings are evaluated by
Perl. To force Perl not to evaluate anything in a quote, you'll
have to use single quotes (<TT><FONT FACE="Courier">'</FONT></TT>).
Anything that looks like code and is not quoted is interpreted
as code by the Perl interpreter, which attempts to evaluate the
code as an expression or a set of executable code statements.
Finally, to run some values in a shell program and get its return
value back, use the back quote (<TT><FONT FACE="Courier">`</FONT></TT>)
symbol. See the Perl script in Listing 2.1 for an example.
<HR>
<BLOCKQUOTE>
<B>Listing 2.1. Quoting in a Perl script.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">1 #!/usr/bin/perl<BR>
2 $folks=&quot;100&quot;;<BR>
3 print &quot;\$folks = $folks \n&quot;;<BR>
4 print '\$folks = $folks \n';<BR>
5 print &quot;\n\n BEEP! \a&nbsp;&nbsp;\LSOME BLANK \ELINES HERE
\n\n&quot;;<BR>
6 $date = `date +%D`;<BR>
7 print &quot;Today is [$date] \n&quot;;<BR>
8 chop $date;<BR>
9 print &quot;Date after chopping off carriage return: [&quot;.$date.&quot;]\n&quot;;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The output from the code in Listing 2.1 is as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$folks = 100<BR>
\$folks = $folks \n<BR>
<BR>
 BEEP!&nbsp;&nbsp;some blank LINES HERE<BR>
<BR>
Today is [03/29/96<BR>
]<BR>
Date after chopping off carriage return: [03/29/96]</FONT></TT>
</BLOCKQUOTE>
<P>
Let's go over the code shown in Listing 2.1. First of all, note
that the actual listing did not have line numbers. The line numbers
in this and subsequent scripts are used to identify specific lines
of code.
<P>
Line 1 is the mandatory first line of the Perl script. Change
the path shown in Listing 2.1 to where your Perl interpreter is
located if the script does not run. Be sure to make a similar
change to the rest of the source listings in this book.
<P>
Line 2 assigns a string value to the<B> </B><TT><FONT FACE="Courier">$folks</FONT></TT>
variable. Note that you did not have to declare the variable <TT><FONT FACE="Courier">$folks</FONT></TT>
because it was created when used for the first time.
<P>
Line 3 prints the value of <TT><FONT FACE="Courier">$folks</FONT></TT>
in between double quotes. The <TT><FONT FACE="Courier">$</FONT></TT>
sign in <TT><FONT FACE="Courier">$folks</FONT></TT> has to be
escaped with a backslash to prevent Perl from evaluating the value
of <TT><FONT FACE="Courier">$folks</FONT></TT> instead of printing
the following line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$folks = 100</FONT></TT>
</BLOCKQUOTE>
<P>
In line 4, Perl does not evaluate anything between the single
quotes. Therefore, the entire contents of the line are left untouched
and printed here:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">\$folks = $folks \n</FONT></TT>
</BLOCKQUOTE>
<P>
Perl has several special characters to format text data for you.
Line 5 prints multiple blank lines with the <TT><FONT FACE="Courier">\n</FONT></TT>
character and beeps at the terminal. Notice how the words <TT><FONT FACE="Courier">SOME
BLANK</FONT></TT> are printed in lowercase letters. This is because
they are encased between the <TT><FONT FACE="Courier">\L</FONT></TT>
and <TT><FONT FACE="Courier">\E</FONT></TT> special characters,
which force all characters to be lowercase. Some of these special
characters are listed in Table 2.2.<BR>
<BLOCKQUOTE>
<CENTER><B>Table 2.2. Special characters in Perl.</B></CENTER>
</BLOCKQUOTE>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=83><I>Character</I></TD><TD WIDTH=401><I>Meaning</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\\</FONT></TT> </TD>
<TD WIDTH=401>Backslash.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\0ooo</FONT></TT></TD>
<TD WIDTH=401>Octal number in <TT><FONT FACE="Courier">ooo</FONT></TT> (for example, <TT><FONT FACE="Courier">\0213</FONT></TT>).
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\a</FONT></TT> </TD>
<TD WIDTH=401>Beep.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\b</FONT></TT> </TD>
<TD WIDTH=401>Backspace.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\c</FONT></TT></TD>
<TD WIDTH=401>Inserts the next character literally (for example, <TT><FONT FACE="Courier">\$</FONT></TT> puts <TT><FONT FACE="Courier">$</FONT></TT>).
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\cC</FONT></TT></TD>
<TD WIDTH=401>Inserts control character <TT><FONT FACE="Courier">C</FONT></TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\l</FONT></TT> </TD>
<TD WIDTH=401>Next character is lowercase.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\L</FONT></TT> <TT><FONT FACE="Courier">\E</FONT></TT> 
</TD><TD WIDTH=401>All characters between <TT><FONT FACE="Courier">\L</FONT></TT> and <TT><FONT FACE="Courier">\E</FONT></TT> are lowercase.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\n</FONT></TT> </TD>
<TD WIDTH=401>New line (line feed).</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\r</FONT></TT> </TD>
<TD WIDTH=401>Carriage return (MS-DOS).</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\t</FONT></TT> </TD>
<TD WIDTH=401>Tab.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\u</FONT></TT> </TD>
<TD WIDTH=401>Next character is uppercase.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\U</FONT></TT> <TT><FONT FACE="Courier">\E</FONT></TT> 
</TD><TD WIDTH=401>All characters between <TT><FONT FACE="Courier">\U</FONT></TT> and <TT><FONT FACE="Courier">\E</FONT></TT> are uppercase.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=83><TT><FONT FACE="Courier">\x##</FONT></TT> </TD>
<TD WIDTH=401>Hex number in <TT><FONT FACE="Courier">##</FONT></TT> (for example, <TT><FONT FACE="Courier">\x1d</FONT></TT>).
</TD></TR>
</TABLE></CENTER>
<P>
<P>
In line 6, the script uses the back quotes (<TT><FONT FACE="Courier">`</FONT></TT>)
to execute a command and return the results in the <TT><FONT FACE="Courier">$date</FONT></TT>
variable. The string in between the two back quotes is what you
would type at the command line, with one exception: if you use
Perl variables in the command line for the back quotes, Perl evaluates
these variables before passing them off to the shell for execution.
For example, line 6 could be rewritten as this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$parm = &quot;+%D&quot;;<BR>
$date = `$date $parm`;</FONT></TT>
</BLOCKQUOTE>
<P>
The returned value in <TT><FONT FACE="Courier">$date</FONT></TT>
is printed out in line 7. Note that there is an extra carriage
return in the text for data. To remove it, use the <TT><FONT FACE="Courier">chop</FONT></TT>
command as shown in line 8.
<P>
Then in line 9 the <TT><FONT FACE="Courier">$date</FONT></TT>
output is shown to print correctly. Note how the period (<TT><FONT FACE="Courier">.</FONT></TT>)
is used to concatenate three strings together for the output.
<P>
It's easy to construct strings in Perl with the period (<TT><FONT FACE="Courier">.</FONT></TT>)
operator. Given two strings, <TT><FONT FACE="Courier">$first</FONT></TT>
and <TT><FONT FACE="Courier">$last</FONT></TT>, you can construct
the string <TT><FONT FACE="Courier">$fullname</FONT></TT> like
this to get <TT><FONT FACE="Courier">&quot;Jim Smith&quot;</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$first = &quot;Jim&quot;;<BR>
$last = &quot;Smith&quot;;<BR>
$fullname = $first . &quot; &quot; . $last;</FONT></TT>
</BLOCKQUOTE>
<P>
Numbers in Perl are stored as floating-point numbers; even variables
used as integers are really stored as floating point numbers.
There are a set of operations you can do with numbers. These operations
are listed in Table 2.3. The table also lists Boolean operators.
<BR>
<P>
<CENTER><B>Table 2.3. Numeric operations with Perl.</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=167><I>Operation</I></TD><TD WIDTH=405><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">$r = $x + $y</FONT></TT> 
</TD><TD WIDTH=405>Adds <TT><FONT FACE="Courier">$x</FONT></TT> to <TT><FONT FACE="Courier">$y</FONT></TT> and assigns the result to <TT><FONT FACE="Courier">$r</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">$r = $x - $y</FONT></TT> 
</TD><TD WIDTH=405>Subtracts <TT><FONT FACE="Courier">$y</FONT></TT> from <TT><FONT FACE="Courier">$x</FONT></TT> and assigns the result to <TT><FONT FACE="Courier">$r</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">$r = $x * $y </FONT></TT>
</TD><TD WIDTH=405>Multiplies <TT><FONT FACE="Courier">$y</FONT></TT> and <TT><FONT FACE="Courier">$x</FONT></TT> and assigns the result to <TT><FONT FACE="Courier">$r</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">$r = $x / $y </FONT></TT>
</TD><TD WIDTH=405>Divides <TT><FONT FACE="Courier">$x</FONT></TT> by <TT><FONT FACE="Courier">$y</FONT></TT> and assigns the result to <TT><FONT FACE="Courier">$r</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">$r = $x % $y </FONT></TT>
</TD><TD WIDTH=405>Modulo; divides <TT><FONT FACE="Courier">$x</FONT></TT> by <TT><FONT FACE="Courier">$y</FONT></TT> and assigns the remainder to <TT><FONT FACE="Courier">$r</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">$r = $x ** $y </FONT></TT>
</TD><TD WIDTH=405>Raises <TT><FONT FACE="Courier">$x</FONT></TT> to the power of <TT><FONT FACE="Courier">$y</FONT></TT> and assigns the result to <TT><FONT FACE="Courier">$r</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">$r = $x &lt;&lt; $n</FONT></TT>
</TD><TD WIDTH=405>Shifts bits in <TT><FONT FACE="Courier">$x</FONT></TT> left <TT><FONT FACE="Courier">$n</FONT></TT> times and assigns to <TT><FONT FACE="Courier">$r</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">$r = $x &gt;&gt; $n</FONT></TT>
</TD><TD WIDTH=405>Shifts bits in <TT><FONT FACE="Courier">$x</FONT></TT> right <TT><FONT FACE="Courier">$n</FONT></TT> times and assigns to <TT><FONT FACE="Courier">$r</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">$r = ++$x </FONT></TT>
</TD><TD WIDTH=405>Increments <TT><FONT FACE="Courier">$x</FONT></TT> and assigns <TT><FONT FACE="Courier">$x</FONT></TT> to <TT><FONT FACE="Courier">$r</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">$r = $x++ </FONT></TT>
</TD><TD WIDTH=405>Assigns <TT><FONT FACE="Courier">$x</FONT></TT> to <TT><FONT FACE="Courier">$r</FONT></TT> and then increments <TT><FONT FACE="Courier">$x</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">$r += $x;</FONT></TT>
</TD><TD WIDTH=405>Adds <TT><FONT FACE="Courier">$x</FONT></TT> to <TT><FONT FACE="Courier">$r</FONT></TT> and then assigns to <TT><FONT FACE="Courier">$r</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">$r = --$x </FONT></TT>
</TD><TD WIDTH=405>Decrements <TT><FONT FACE="Courier">$x</FONT></TT> and assigns <TT><FONT FACE="Courier">$x</FONT></TT> to <TT><FONT FACE="Courier">$r</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">$r = $x-- </FONT></TT>
</TD><TD WIDTH=405>Assigns <TT><FONT FACE="Courier">$x</FONT></TT> to <TT><FONT FACE="Courier">$r</FONT></TT> and then decrements <TT><FONT FACE="Courier">$x</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">$r -= $x;</FONT></TT>
</TD><TD WIDTH=405>Subtracts <TT><FONT FACE="Courier">$x</FONT></TT> from <TT><FONT FACE="Courier">$r</FONT></TT> and then assigns to <TT><FONT FACE="Courier">$r</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">$r /= $x;</FONT></TT>
</TD><TD WIDTH=405>Divides <TT><FONT FACE="Courier">$r</FONT></TT> by <TT><FONT FACE="Courier">$x</FONT></TT> and then assigns to <TT><FONT FACE="Courier">$r</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">$r *= $x;</FONT></TT>
</TD><TD WIDTH=405>Multiplies <TT><FONT FACE="Courier">$r</FONT></TT> by <TT><FONT FACE="Courier">$x</FONT></TT> and then assigns to <TT><FONT FACE="Courier">$r</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">$r = $x &lt;=&gt; $y </FONT></TT>
</TD><TD WIDTH=405><TT><FONT FACE="Courier">$r</FONT></TT> is <TT><FONT FACE="Courier">1</FONT></TT> if <TT><FONT FACE="Courier">$x &gt; $y</FONT></TT>; <TT><FONT FACE="Courier">0</FONT></TT> if <TT><FONT FACE="Courier">$x == $y</FONT></TT>; -<TT><FONT 
FACE="Courier">1</FONT></TT> if <TT><FONT FACE="Courier">$x &lt; $y</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">$r = $x || $y</FONT></TT>
</TD><TD WIDTH=405><TT><FONT FACE="Courier">$r</FONT></TT> is the logical <TT><FONT FACE="Courier">OR</FONT></TT> of variables <TT><FONT FACE="Courier">$x</FONT></TT> and <TT><FONT FACE="Courier">$y</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">$r = $x &amp;&amp; $y</FONT></TT>
</TD><TD WIDTH=405><TT><FONT FACE="Courier">$r</FONT></TT> is the logical <TT><FONT FACE="Courier">AND</FONT></TT> of variables <TT><FONT FACE="Courier">$x</FONT></TT> and <TT><FONT FACE="Courier">$y</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=167><TT><FONT FACE="Courier">$r = ! $x </FONT></TT>
</TD><TD WIDTH=405><TT><FONT FACE="Courier">$r</FONT></TT> is the opposite Boolean value of <TT><FONT FACE="Courier">$x</FONT></TT>
</TD></TR>
</TABLE></CENTER>
<P>
<P>
You can compare values of variables to check results of operations.
Table 2.4 lists the comparison operators for numbers and strings.
<BR>
<P>
<CENTER><B>Table 2.4. Comparison operations with Perl.</B></CENTER>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=138><I>Operation</I></TD><TD WIDTH=416><I>Description</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">$x == $y</FONT></TT> 
</TD><TD WIDTH=416><TT><FONT FACE="Courier">True</FONT></TT> if <TT><FONT FACE="Courier">$x</FONT></TT> is equal to <TT><FONT FACE="Courier">$y</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">$x != $y</FONT></TT> 
</TD><TD WIDTH=416><TT><FONT FACE="Courier">True</FONT></TT> if <TT><FONT FACE="Courier">$x</FONT></TT> is not equal to <TT><FONT FACE="Courier">$y</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">$x &lt; $y</FONT></TT> 
</TD><TD WIDTH=416><TT><FONT FACE="Courier">True</FONT></TT> if <TT><FONT FACE="Courier">$x</FONT></TT> is less than <TT><FONT FACE="Courier">$y</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">$x &lt;= $y</FONT></TT> 
</TD><TD WIDTH=416><TT><FONT FACE="Courier">True</FONT></TT> if <TT><FONT FACE="Courier">$x</FONT></TT> is less than or equal to <TT><FONT FACE="Courier">$y</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">$x &gt; $y</FONT></TT> 
</TD><TD WIDTH=416><TT><FONT FACE="Courier">True</FONT></TT> if <TT><FONT FACE="Courier">$x</FONT></TT> is greater than <TT><FONT FACE="Courier">$y</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">$x &gt;= $y</FONT></TT> 
</TD><TD WIDTH=416><TT><FONT FACE="Courier">True</FONT></TT> if <TT><FONT FACE="Courier">$x</FONT></TT> is greater than or equal to <TT><FONT FACE="Courier">$y</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">$x eq $y</FONT></TT> 
</TD><TD WIDTH=416><TT><FONT FACE="Courier">True</FONT></TT> if string <TT><FONT FACE="Courier">$x</FONT></TT> is equal to string <TT><FONT FACE="Courier">$y</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">$x ne $y</FONT></TT> 
</TD><TD WIDTH=416><TT><FONT FACE="Courier">True</FONT></TT> if string <TT><FONT FACE="Courier">$x</FONT></TT> is not equal to string <TT><FONT FACE="Courier">$y</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">$x lt $y</FONT></TT> 
</TD><TD WIDTH=416><TT><FONT FACE="Courier">True</FONT></TT> if string <TT><FONT FACE="Courier">$x</FONT></TT> is less than string <TT><FONT FACE="Courier">$y</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">$x le $y</FONT></TT> 
</TD><TD WIDTH=416><TT><FONT FACE="Courier">True</FONT></TT> if string <TT><FONT FACE="Courier">$x</FONT></TT> is less than or equal to string <TT><FONT FACE="Courier">$y</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">$x gt $y</FONT></TT> 
</TD><TD WIDTH=416><TT><FONT FACE="Courier">True</FONT></TT> if string <TT><FONT FACE="Courier">$x</FONT></TT> is greater than string <TT><FONT FACE="Courier">$y</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">$x ge $y</FONT></TT> 
</TD><TD WIDTH=416><TT><FONT FACE="Courier">True</FONT></TT> if string <TT><FONT FACE="Courier">$x</FONT></TT> is greater than or equal to string <TT><FONT FACE="Courier">$y</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">$x x $y</FONT></TT> 
</TD><TD WIDTH=416>Repeats <TT><FONT FACE="Courier">$x</FONT></TT>, <TT><FONT FACE="Courier">$y</FONT></TT> times
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">$x . $y</FONT></TT> 
</TD><TD WIDTH=416>Returns the concatenated value of <TT><FONT FACE="Courier">$x</FONT></TT> and <TT><FONT FACE="Courier">$y</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">$x cmp $y</FONT></TT> 
</TD><TD WIDTH=416>Returns <TT><FONT FACE="Courier">1</FONT></TT> if <TT><FONT FACE="Courier">$x gt $y</FONT></TT>; <TT><FONT FACE="Courier">0</FONT></TT> if <TT><FONT FACE="Courier">$x eq $y</FONT></TT>; <TT><FONT FACE="Courier">-1</FONT></TT> if 
<TT><FONT FACE="Courier">$x lt $y</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=138><TT><FONT FACE="Courier">$w ? $x : $y</FONT></TT>
</TD><TD WIDTH=416>Returns <TT><FONT FACE="Courier">$x</FONT></TT> if <TT><FONT FACE="Courier">$w</FONT></TT> is <TT><FONT FACE="Courier">true</FONT></TT>; <TT><FONT FACE="Courier">$y</FONT></TT> if <TT><FONT FACE="Courier">$w</FONT></TT> is <TT><FONT 
FACE="Courier">false</FONT></TT>
</TD></TR>
</TABLE></CENTER>
<P>
<H2><A NAME="ArraysandAssociativeArrays"><FONT SIZE=5 COLOR=#FF0000>Arrays
and Associative Arrays</FONT></A></H2>
<P>
Perl has arrays to let you group items using a single variable
name. Perl offers two types of arrays: those whose items are indexed
by number (arrays) and those whose items are indexed by a string
(associative arrays). An index into an array is referred to as
the <I>subscript</I> of the array.<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD ><B>Tip</B></TD></TR>
<TR VALIGN=TOP><TD >
<BLOCKQUOTE>
An associative array is referred to as &quot;hash&quot; because of the way it's stored internally in Perl.</BLOCKQUOTE>

</TD></TR>
</TABLE></CENTER>
<P>
<P>
Arrays are referred to with the <TT><FONT FACE="Courier">@</FONT></TT>
symbol. Individual items in an array are derived with a <TT><FONT FACE="Courier">$</FONT></TT>
and the subscript. Therefore, the first item in an array <TT><FONT FACE="Courier">@count</FONT></TT>
would be <TT><FONT FACE="Courier">$count[0]</FONT></TT>, the second
item would be <TT><FONT FACE="Courier">$count[1]</FONT></TT>,
and so on. See Listing 2.2 for usage of arrays.
<HR>
<BLOCKQUOTE>
<B>Listing 2.2. Using arrays.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 #<BR>
&nbsp;3 # An example to show how arrays work in Perl<BR>
&nbsp;4 #<BR>
&nbsp;5 @amounts = (10,24,39);<BR>
&nbsp;6 @parts = ('computer', 'rat', &quot;kbd&quot;);<BR>
&nbsp;7<BR>
&nbsp;8 $a = 1; $b = 2; $c = '3';<BR>
&nbsp;9 @count = ($a, $b, $c);<BR>
10<BR>
11 @empty = ();<BR>
12<BR>
13 @spare = @parts;<BR>
14<BR>
15 print '@amounts = ';<BR>
16 print &quot;@amounts \n&quot;;<BR>
17<BR>
18 print '@parts = ';<BR>
19 print &quot;@parts \n&quot;;<BR>
20<BR>
21 print '@count = ';<BR>
22 print &quot;@count \n&quot;;<BR>
23<BR>
24 print '@empty = ';<BR>
25 print &quot;@empty \n&quot;;<BR>
26<BR>
27 print '@spare = ';<BR>
28 print &quot;@spare \n&quot;;<BR>
29<BR>
30<BR>
31 #<BR>
32 # Accessing individual items in an array<BR>
33 #<BR>
34 print '$amounts[0] = ';<BR>
35 print &quot;$amounts[0] \n&quot;;<BR>
36 print '$amounts[1] = ';<BR>
37 print &quot;$amounts[1] \n&quot;;<BR>
38 print '$amounts[2] = ';<BR>
39 print &quot;$amounts[2] \n&quot;;<BR>
40 print '$amounts[3] = ';<BR>
41 print &quot;$amounts[3] \n&quot;;<BR>
42<BR>
43 print &quot;Items in \@amounts&nbsp;&nbsp;= $#amounts \n&quot;;
<BR>
44 $size = @amounts; print &quot;Size of Amount&nbsp;&nbsp;= $size\n&quot;;
<BR>
45 print &quot;Item 0 in \@amounts = $amounts[$[]\n&quot;;<BR>
46</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Here's the output from Listing 2.2:<BR>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">@amounts = 10 24 39<BR>
@parts = computer rat kbd<BR>
@count = 1 2 3<BR>
@empty =<BR>
@spare = computer rat kbd<BR>
$amounts[0] = 10<BR>
$amounts[1] = 24<BR>
$amounts[2] = 39<BR>
$amounts[3] =<BR>
Items in @amounts&nbsp;&nbsp;= 2<BR>
Size of Amount&nbsp;&nbsp;= 3<BR>
Item 0 in @amounts = 10</FONT></TT>
</BLOCKQUOTE>
<P>
In line 5, three integer values are assigned to the <TT><FONT FACE="Courier">@amounts</FONT></TT>
array. In line 6, three strings are assigned to the <TT><FONT FACE="Courier">@parts</FONT></TT>
array. In line 8, the script assigns both string and numeric values
to variables and then assigns the values of the variables to the
<TT><FONT FACE="Courier">@count</FONT></TT> array. An empty array
is created in line 11. In line 12, the <TT><FONT FACE="Courier">@spare</FONT></TT>
array is assigned the same values as those in <TT><FONT FACE="Courier">@parts</FONT></TT>.
<P>
Lines 15 through 28 print out the first five lines of the output.
In lines 34 to 41, the script addresses individual items of the
<TT><FONT FACE="Courier">@amounts</FONT></TT> array. Note that
<TT><FONT FACE="Courier">$amounts[3]</FONT></TT> does not exist;
therefore, it is printed as an empty item.
<P>
The <TT><FONT FACE="Courier">@#array</FONT></TT> syntax is used
in line 43 to print the last index in an array, so the script
prints <TT><FONT FACE="Courier">2</FONT></TT>. The size of the
amounts array is (<TT><FONT FACE="Courier">$#amounts</FONT></TT>
+ 1). If an array is assigned to a scalar, as shown in line 44,
the size of the array is assigned to the scalar.
<P>
Line 45 shows the use of a special Perl variable, <TT><FONT FACE="Courier">$[</FONT></TT>,
which is the base subscript (<TT><FONT FACE="Courier">0</FONT></TT>)
of an array.
<H3><A NAME="WhatAreAssociativeArrays">What Are Associative Arrays?</A>
</H3>
<P>
An associative array is really an array with two items per index.
The first item at each index is called a key and the other item
is called a value. You index into an associative array using keys
to get values. An associative array name is preceded with a percent
(<TT><FONT FACE="Courier">%</FONT></TT>) sign and indexed items
are enclosed within curly braces (<TT><FONT FACE="Courier">{}</FONT></TT>).
See Listing 2.3 for some sample uses of associative arrays.
<HR>
<BLOCKQUOTE>
<B>Listing 2.3. Using associative arrays.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 #<BR>
&nbsp;3 # Associative Arrays.<BR>
&nbsp;4 #<BR>
&nbsp;5<BR>
&nbsp;6 %subscripts = (<BR>
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'bmp', 'Bitmap',<BR>
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;cpp&quot;, &quot;C++
Source&quot;,<BR>
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;txt&quot;, 'Text
file' );<BR>
10<BR>
11 $bm = 'asc';<BR>
12 $subscripts{$bm} = 'Ascii File';<BR>
13<BR>
14 print &quot;\n =========== Raw dump of hash&nbsp;&nbsp;=========
\n&quot;;<BR>
15 print %subscripts;<BR>
16<BR>
17 print &quot;\n =========== using foreach&nbsp;&nbsp;=========
\n&quot;;<BR>
18 foreach $key (keys (%subscripts)) {<BR>
19&nbsp;&nbsp;&nbsp;&nbsp; $value = $subscripts{$key};<BR>
20&nbsp;&nbsp;&nbsp;&nbsp; print &quot;Key = $key, Value = $value
\n&quot;;<BR>
21&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
22<BR>
23 print &quot;\n === using foreach with sort ========= \n&quot;;
<BR>
24 foreach $key (sort keys (%subscripts)) {<BR>
25&nbsp;&nbsp;&nbsp;&nbsp; $value = $subscripts{$key};<BR>
26&nbsp;&nbsp;&nbsp;&nbsp; print &quot;Key = $key, Value = $value
\n&quot;;<BR>
27&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
28<BR>
29 print &quot;\n =========== using each()&nbsp;&nbsp;=========
\n&quot;;<BR>
30 while (($key,$value) = each(%subscripts)) {<BR>
31&nbsp;&nbsp;&nbsp;&nbsp; print &quot;Key = $key, Value = $value
\n&quot;;<BR>
32&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
33</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Here's the output from Listing 2.3:
<BLOCKQUOTE>
<TT><FONT FACE="Courier"> =========== Raw dump of hash&nbsp;&nbsp;=========
<BR>
txtText filecppC++ SourceascAscii FilebmpBitmap<BR>
 =========== using foreach&nbsp;&nbsp;=========<BR>
Key = txt, Value = Text file<BR>
Key = cpp, Value = C++ Source<BR>
Key = asc, Value = Ascii File<BR>
Key = bmp, Value = Bitmap<BR>
<BR>
 === using foreach with sort =========<BR>
Key = asc, Value = Ascii File<BR>
Key = bmp, Value = Bitmap<BR>
Key = cpp, Value = C++ Source<BR>
Key = txt, Value = Text file<BR>
<BR>
 =========== using each()&nbsp;&nbsp;=========<BR>
Key = txt, Value = Text file<BR>
Key = cpp, Value = C++ Source<BR>
Key = asc, Value = Ascii File<BR>
Key = bmp, Value = Bitmap</FONT></TT>
</BLOCKQUOTE>
<P>
An associative array called <TT><FONT FACE="Courier">%subscripts</FONT></TT>
is created in line 6 to line 9. Three items of (<TT><FONT FACE="Courier">key</FONT></TT>,<TT><FONT FACE="Courier">value</FONT></TT>)
pairs are added to <TT><FONT FACE="Courier">%subscripts</FONT></TT>
as a list. At line 11, a new item is added to the <TT><FONT FACE="Courier">%subscript</FONT></TT>
array by assigning <TT><FONT FACE="Courier">$bm</FONT></TT> to
a key and then using <TT><FONT FACE="Courier">$bm</FONT></TT>
as the index. We could have just as easily added the string 'Ascii
File' with this hard-coded statement:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$subscripts{'asc'} = 'Ascii File';</FONT></TT>
</BLOCKQUOTE>
<P>
Items in an associative array are referred to as items stored
in a <I>hash</I>, because this is the way items are stored internally.
Look at the output from line 15, which dumps out the associative
array items.
<P>
In line 17, the script uses a <TT><FONT FACE="Courier">foreach</FONT></TT>
statement to loop over the keys in the <TT><FONT FACE="Courier">%subscripts</FONT></TT>
array. The <TT><FONT FACE="Courier">keys()</FONT></TT> function
returns a list of keys for a given hash. The value of the item
at <TT><FONT FACE="Courier">$subscripts{$key}</FONT></TT> is assigned
to <TT><FONT FACE="Courier">$value</FONT></TT> at line 19. You
could combine lines 18 and 19 into one statement like this without
loss of meaning:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">print &quot;Key = $key, Value = $subscripts{$key}
\n&quot;;</FONT></TT>
</BLOCKQUOTE>
<P>
Using the keys alone did not list the contents of the <TT><FONT FACE="Courier">%subscripts</FONT></TT>
hash in the order we want. To sort the output, you should sort
the keys into the hash. This is shown in line 24. The <TT><FONT FACE="Courier">sort()</FONT></TT>
function takes a list of items and returns a text-sorted version.
The <TT><FONT FACE="Courier">foreach</FONT></TT> function takes
the output from the <TT><FONT FACE="Courier">sort()</FONT></TT>
function applied to the value returned by the <TT><FONT FACE="Courier">keys()</FONT></TT>
function. To sort in decreasing order, you can apply the <TT><FONT FACE="Courier">reverse</FONT></TT>
function to the returned value of <TT><FONT FACE="Courier">sort()</FONT></TT>
to get this line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">for $i (reverse sort (keys %@array))
{</FONT></TT>
</BLOCKQUOTE>
<P>
It's more efficient to use the <TT><FONT FACE="Courier">each()</FONT></TT>
function when working with associative arrays because only one
lookup is required per item to get both the key and its value.
See Line 30 where the (<TT><FONT FACE="Courier">$key</FONT></TT>,<TT><FONT FACE="Courier">$value</FONT></TT>)
pairs are assigned to the returned values by the <TT><FONT FACE="Courier">each()</FONT></TT>
command. The variable <TT><FONT FACE="Courier">$key</FONT></TT>
is assigned to the first item, and the variable <TT><FONT FACE="Courier">$value</FONT></TT>
is assigned to the second item that is returned from the <TT><FONT FACE="Courier">each()</FONT></TT>
function call.
<P>
The code in line 30 is important and deserves some explaining.
First of all, the <TT><FONT FACE="Courier">while()</FONT></TT>
loop is used here. The format for a <TT><FONT FACE="Courier">while</FONT></TT>
loop is defined as this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">while( conditionIsTrue) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;codeInLOOP<BR>
}<BR>
<BR>
codeOutOfLOOP</FONT></TT>
</BLOCKQUOTE>
<P>
If the condition in the <TT><FONT FACE="Courier">while</FONT></TT>
loop is a nonzero number, a nonempty string, or a nonempty list,
the code in the area <TT><FONT FACE="Courier">codeInLOOP</FONT></TT>
is executed. Otherwise, the next statement outside the loop (that
is, after the curly brace) is executed.
<P>
Second, look at how the list (<TT><FONT FACE="Courier">$key</FONT></TT>,<TT><FONT FACE="Courier">$value</FONT></TT>)
is mapped onto the list returned by the <TT><FONT FACE="Courier">each()</FONT></TT>
function. The first item of the returned list is assigned to <TT><FONT FACE="Courier">$key</FONT></TT>,
the next item to<TT><FONT FACE="Courier"> $value</FONT></TT>.
This is part of the array-slicing operations available in Perl.
<H2><A NAME="ArrayOperations"><FONT SIZE=5 COLOR=#FF0000>Array
Operations</FONT></A></H2>
<P>
When working with arrays in Perl, you are really working with
lists. You can add or remove items from the front or back of the
list. Items in the middle of the list can be indexed using subscripts
or keys. Sublists can be created by extracting items from lists,
and lists can be concatenated to create one or more new lists.
<P>
Let's view some examples of how they fit together. See Listing
2.4, which uses some of these concepts.
<HR>
<BLOCKQUOTE>
<B>Listing 2.4. Array operations.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 #<BR>
&nbsp;3 # Array operations<BR>
&nbsp;4 #<BR>
&nbsp;5<BR>
&nbsp;6 $a = 'RFI';<BR>
&nbsp;7 $b = 'UPS';<BR>
&nbsp;8 $c = 'SPIKE';<BR>
&nbsp;9<BR>
10 @words = ('DC','AC','EMI','SURGE');<BR>
11<BR>
12 $count = @words;&nbsp;&nbsp;# Get the count<BR>
13<BR>
14 #<BR>
15 # Using the for operator on a list<BR>
16 #<BR>
17 print &quot;\n \@words = &quot;;<BR>
18 for $i (@words) {<BR>
19&nbsp;&nbsp;&nbsp;&nbsp; print &quot;[$i] &quot;;<BR>
20&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
21<BR>
22 print &quot;\n&quot;;<BR>
23 #<BR>
24 # Using the for loop for indexing<BR>
25 #<BR>
26 for ($i=0;$i&lt;$count;$i++) {<BR>
27&nbsp;&nbsp;&nbsp;&nbsp; print &quot;\n Words[$i] : $words[$i];&quot;;
<BR>
28&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
29 #<BR>
30 # print 40 equal signs<BR>
31 #<BR>
32 print &quot;\n&quot;;<BR>
33 print &quot;=&quot; x 40;<BR>
34 print &quot;\n&quot;;<BR>
35 #<BR>
36 # Extracting items into scalars<BR>
37 #<BR>
38 ($x,$y) = @words;<BR>
39 print &quot;x = $x, y = $y \n&quot;;<BR>
40 ($w,$x,$y,$z) = @words;<BR>
41 print &quot;w = $x, x = $x, y = $y, z = $z\n&quot;;<BR>
42<BR>
43 ($anew[0], $anew[3], $anew[9], $anew[5]) = @words;<BR>
44<BR>
45 $temp = @anew;<BR>
46<BR>
47 #<BR>
48 # print 40 equal signs<BR>
49 #<BR>
50 print &quot;=&quot; x 40;<BR>
51 print &quot;\n&quot;;<BR>
52<BR>
53 print &quot;Number of elements in anew = &quot;. $temp, &quot;\n&quot;;
<BR>
54 print &quot;Last index in anew = &quot;. $#anew, &quot;\n&quot;;
<BR>
55 print &quot;The newly created Anew arrary is: &quot;;<BR>
56 $j = 0;<BR>
57 for $i (@anew) {<BR>
58&nbsp;&nbsp;&nbsp;&nbsp; print &quot;\n \$anew[$j] = is $i &quot;;
<BR>
59&nbsp;&nbsp;&nbsp;&nbsp; $j++;<BR>
60&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
61 print &quot;\n&quot;;<BR>
62<BR>
63</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Here's the output from Listing 2.4:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;@words = [DC] [AC] [EMI] [SURGE]
<BR>
<BR>
&nbsp;Words[0] : DC;<BR>
&nbsp;Words[1] : AC;<BR>
&nbsp;Words[2] : EMI;<BR>
&nbsp;Words[3] : SURGE;<BR>
========================================<BR>
x = DC, y = AC<BR>
w = AC, x = AC, y = EMI z = SURGE<BR>
========================================<BR>
Number of elements in anew = 10<BR>
Last index in anew = 9<BR>
The newly created Anew arrary is:<BR>
&nbsp;$anew[0] = is DC<BR>
&nbsp;$anew[1] = is<BR>
&nbsp;$anew[2] = is<BR>
&nbsp;$anew[3] = is AC<BR>
&nbsp;$anew[4] = is<BR>
&nbsp;$anew[5] = is SURGE<BR>
&nbsp;$anew[6] = is<BR>
&nbsp;$anew[7] = is<BR>
&nbsp;$anew[8] = is<BR>
&nbsp;$anew[9] = is EMI</FONT></TT>
</BLOCKQUOTE>
<P>
Lines 6, 7, and 8 assign values to scalars <TT><FONT FACE="Courier">$a</FONT></TT>,
<TT><FONT FACE="Courier">$b</FONT></TT>, and <TT><FONT FACE="Courier">$c</FONT></TT>,
respectively. In line 10, four values are assigned to the <TT><FONT FACE="Courier">@words</FONT></TT>
array. At line 12, you get a count of the number of elements in
the array.
<P>
The <TT><FONT FACE="Courier">for()</FONT></TT> loop statement
is used to cycle through each element in the list. Perl takes
each item in the <TT><FONT FACE="Courier">@words</FONT></TT> array,
assigns it to <TT><FONT FACE="Courier">$i</FONT></TT>, and then
executes the statements in the block of code between the curly
braces. You could rewrite line 17 as the following and get the
same result:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">for $i ('DC','AC','EMI','SURGE') {</FONT></TT>
</BLOCKQUOTE>
<P>
In the example in Listing 2.4, the value of each item is printed
with square brackets around it. Line 22 simply prints a new line.
<P>
Now look at line 26, where the <TT><FONT FACE="Courier">for</FONT></TT>
loop is defined. The syntax in the <TT><FONT FACE="Courier">for</FONT></TT>
loop will be very familiar to C programmers:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">for (startingCondition; endingCondition;
at_end_of_every_loop) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;execute_statements_in_this_block;
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}</FONT></TT>
</BLOCKQUOTE>
<P>
In line 26, <TT><FONT FACE="Courier">$i</FONT></TT> is set to
zero when the <TT><FONT FACE="Courier">for</FONT></TT> loop is
started. Before Perl executes the next statement within the block,
it checks to see whether <TT><FONT FACE="Courier">$i</FONT></TT>
is less than <TT><FONT FACE="Courier">$count</FONT></TT>. If <TT><FONT FACE="Courier">$i</FONT></TT>
is less than <TT><FONT FACE="Courier">$count</FONT></TT>, the
<TT><FONT FACE="Courier">print</FONT></TT> statement is executed.
If <TT><FONT FACE="Courier">$i</FONT></TT> is greater than or
equal to <TT><FONT FACE="Courier">$count</FONT></TT>, the next
statement following the ending curly brace is executed. After
executing the last statement in a <TT><FONT FACE="Courier">for</FONT></TT>
loop code block (see line 28), Perl increments the value of <TT><FONT FACE="Courier">$i</FONT></TT>
with the statement for the end of loop: <TT><FONT FACE="Courier">$i++</FONT></TT>.
So <TT><FONT FACE="Courier">$i</FONT></TT> is incremented. Perl
goes back to the top of the loop to test for the ending condition
to see what to do next.
<P>
In lines 32 through 34, an output-delimiting line is printed with
40 equal signs. The <TT><FONT FACE="Courier">x</FONT></TT> operator
in line 33 causes = to be repeated by the number following it.
Another way to print a somewhat fancier line would be to use the
following in lines 32 through 34:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">32 print &quot;[\n&quot;;<BR>
33 print &quot;-=&quot; x 20;<BR>
34 print &quot;]\n&quot;;</FONT></TT>
</BLOCKQUOTE>
<P>
Next, in line 38 the first two items in <TT><FONT FACE="Courier">@words</FONT></TT>
are assigned to variables <TT><FONT FACE="Courier">$x</FONT></TT>
and <TT><FONT FACE="Courier">$y</FONT></TT>, respectively. The
rest of the items in <TT><FONT FACE="Courier">@words</FONT></TT>
are not used. In line 40, four items from <TT><FONT FACE="Courier">@words</FONT></TT>
are assigned to four variables. The mapping of items from <TT><FONT FACE="Courier">@words</FONT></TT>
to variables is done on a one-to-one basis, based on the type
of parameter on the left side of the equal sign.
<P>
Had I used the following line in place of line 40, I would get
the value of <TT><FONT FACE="Courier">$words[0]</FONT></TT> in
<TT><FONT FACE="Courier">$x</FONT></TT> and the rest of <TT><FONT FACE="Courier">@words</FONT></TT>
in <TT><FONT FACE="Courier">@sublist</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">($x,@sublist) = @words;</FONT></TT>
</BLOCKQUOTE>
<P>
In line 43 a new array, <TT><FONT FACE="Courier">@anew</FONT></TT>,
is created and assigned values from the <TT><FONT FACE="Courier">@words</FONT></TT>
array, but not on a one-to-one basis. In fact, you'll see that
the <TT><FONT FACE="Courier">@anew</FONT></TT> array is not even
the same size as <TT><FONT FACE="Courier">@words</FONT></TT>.
Perl automatically resizes the <TT><FONT FACE="Courier">@anew</FONT></TT>
array to be at least as large the largest index. In this case,
because <TT><FONT FACE="Courier">$anew[9]</FONT></TT> is being
assigned a value, <TT><FONT FACE="Courier">@anew</FONT></TT> will
be at least 10 items long to cover items from <TT><FONT FACE="Courier">0</FONT></TT>
to <TT><FONT FACE="Courier">9</FONT></TT>.
<P>
In lines 53 and 54, the script prints out the value of the number
of elements in the array and the highest valid index in the array.
Lines 57 through 60 print out the value of each item in the <TT><FONT FACE="Courier">anew</FONT></TT>
area. Notice that items in the <TT><FONT FACE="Courier">@anew</FONT></TT>
array are not assigned any values.
<P>
You can create other lists from lists, as well. See the example
in Listing 2.5.
<HR>
<BLOCKQUOTE>
<B>Listing 2.5. Creating sublists.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 #<BR>
&nbsp;3 # Array operations<BR>
&nbsp;4 #<BR>
&nbsp;5<BR>
&nbsp;6 $a = 'RFI';<BR>
&nbsp;7 $b = 'UPS';<BR>
&nbsp;8 $c = 'SPIKE';<BR>
&nbsp;9<BR>
10 @words = ('DC','AC','EMI','SURGE');<BR>
11<BR>
12 $count = @words;&nbsp;&nbsp;# Get the count<BR>
13 #<BR>
14 # Using the for operator on a list<BR>
15 #<BR>
16 print &quot;\n \@words = &quot;;<BR>
17 for $i (@words) {<BR>
18&nbsp;&nbsp;&nbsp;&nbsp; print &quot;[$i] &quot;;<BR>
19&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
20<BR>
21 print &quot;\n&quot;;<BR>
22 print &quot;=&quot; x 40;<BR>
23 print &quot;\n&quot;;<BR>
24<BR>
25 #<BR>
26 # Concatenate lists together<BR>
27 #<BR>
28 @more = ($c,@words,$a,$b);<BR>
29 print &quot;\n&nbsp;&nbsp;Putting a list together: &quot;;
<BR>
30 $j = 0;<BR>
31 for $i (@more) {<BR>
32&nbsp;&nbsp;&nbsp;&nbsp; print &quot;\n \$more[$j] = is $i &quot;;
<BR>
33&nbsp;&nbsp;&nbsp;&nbsp; $j++;<BR>
34&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
35 print &quot;\n&quot;;<BR>
36<BR>
37 @more = (@words,($a,$b,$c));<BR>
38 $j = 0;<BR>
39 for $i (@more) {<BR>
40&nbsp;&nbsp;&nbsp;&nbsp; print &quot;\n \$more[$j] = is $i &quot;;
<BR>
41&nbsp;&nbsp;&nbsp;&nbsp; $j++;<BR>
42&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
43 print &quot;\n&quot;;<BR>
44<BR>
45<BR>
46 $fourth = ($a x 4);<BR>
47 print &quot; $fourth\n&quot;;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Here's the output from Listing 2.5:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;@words = [DC] [AC] [EMI] [SURGE]
<BR>
========================================<BR>
<BR>
&nbsp;&nbsp;Putting a list together:<BR>
&nbsp;$more[0] = is SPIKE<BR>
&nbsp;$more[1] = is DC<BR>
&nbsp;$more[2] = is AC<BR>
&nbsp;$more[3] = is EMI<BR>
&nbsp;$more[4] = is SURGE<BR>
&nbsp;$more[5] = is RFI<BR>
&nbsp;$more[6] = is UPS<BR>
<BR>
&nbsp;$more[0] = is DC<BR>
&nbsp;$more[1] = is AC<BR>
&nbsp;$more[2] = is EMI<BR>
&nbsp;$more[3] = is SURGE<BR>
&nbsp;$more[4] = is RFI<BR>
&nbsp;$more[5] = is UPS<BR>
&nbsp;$more[6] = is SPIKE<BR>
<BR>
&nbsp;RFIRFIRFIRFI</FONT></TT>
</BLOCKQUOTE>
<P>
In Listing 2.5, one list is created from another list. In Line
10, the script creates and fills the <TT><FONT FACE="Courier">@words</FONT></TT>
array. In Lines 16 through 19, the script prints the array. Lines
21 through 23 are repeated again (which we will convert into a
subroutine soon).
<P>
At line 28, the <TT><FONT FACE="Courier">@more</FONT></TT> array
is created by placing together the value of <TT><FONT FACE="Courier">$c</FONT></TT>,
all the items in the entire <TT><FONT FACE="Courier">@words</FONT></TT>
array, followed by the values <TT><FONT FACE="Courier">$a</FONT></TT>
and <TT><FONT FACE="Courier">$b</FONT></TT>. The size of the <TT><FONT FACE="Courier">@more</FONT></TT>
array will therefore be <TT><FONT FACE="Courier">6</FONT></TT>.
The items in the <TT><FONT FACE="Courier">@more</FONT></TT> array
are printed in lines 31 through 35.
<P>
The code at line 37 creates another <TT><FONT FACE="Courier">@more</FONT></TT>
array with a different ordering. The previously created <TT><FONT FACE="Courier">@more</FONT></TT>
array is freed back to the memory pool. The newly ordered <TT><FONT FACE="Courier">@more</FONT></TT>
list is printed from lines 40 through 43.
<P>
The script then uses the <TT><FONT FACE="Courier">x</FONT></TT>
operator in line 46 to create another item by concatenating four
copies of <TT><FONT FACE="Courier">$a</FONT></TT> into the variable
<TT><FONT FACE="Courier">$fourth</FONT></TT>.
<P>
I have covered how to add items to arrays but not how to remove
them. To remove an item from an array, use the <TT><FONT FACE="Courier">delete</FONT></TT>
command on an array item. For example, to delete <TT><FONT FACE="Courier">$more[2]</FONT></TT>,
you would use the command:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">delete $more[2];</FONT></TT>
</BLOCKQUOTE>
<P>
If you are like me, you probably do want to type the same lines
of code again and again. For example, the code in lines 21 through
23 of Listing 2.5 could be made into a function that looks like
this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub printLine {<BR>
&nbsp;&nbsp;print &quot;\n&quot;;<BR>
&nbsp;&nbsp;print &quot;=&quot; x 40;<BR>
&nbsp;&nbsp;print &quot;\n&quot;;<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
Now when you want print the lines, call the subroutine with this
line of code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&amp;printLine;</FONT></TT>
</BLOCKQUOTE>
<P>
I cover other aspects of subroutines in the section &quot;Subroutines&quot;
of this chapter, and a bit more in <A HREF="ch3.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch3.htm" >Chapter 3</A>.
<P>
Now let's get back to some of the things you can do with arrays
using the functions supplied with Perl. See Listing 2.6 for a
script that uses the array functions I discuss here.
<HR>
<BLOCKQUOTE>
<B>Listing 2.6. Using array functions.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 #<BR>
&nbsp;3 # Functions for Arrays<BR>
&nbsp;4 #<BR>
&nbsp;5 sub printLine {<BR>
&nbsp;6 print &quot;\n&quot;; print &quot;=&quot; x 60; print
&quot;\n&quot;;<BR>
&nbsp;7 }<BR>
&nbsp;8<BR>
&nbsp;9 $quote= 'Listen to me slowly';<BR>
10<BR>
11 #<BR>
12 # USING THE SPLIT function<BR>
13 #<BR>
14 @words = split(' ',$quote);<BR>
15<BR>
16 #<BR>
17 # Using the for operator on a list<BR>
18 #<BR>
19 &amp;printLine;<BR>
20 print &quot;The quote from Sam Goldwyn: $quote &quot;;<BR>
21 &amp;printLine;<BR>
22 print &quot;The words \@words = &quot;;<BR>
23 for $i (@words) {<BR>
24&nbsp;&nbsp;&nbsp;&nbsp; print &quot;[$i] &quot;;<BR>
25&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
26<BR>
27 #<BR>
28 # chOP<BR>
29 #<BR>
30 &amp;printLine;<BR>
31 chop(@words);<BR>
32 print &quot;The chopped words \@words = &quot;;<BR>
33 for $i (@words) {<BR>
34&nbsp;&nbsp;&nbsp;&nbsp; print &quot;[$i] &quot;;<BR>
35&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
36 print &quot;\n .. restore&quot;;<BR>
37 #<BR>
38 # Restore!<BR>
39 #<BR>
40 @words = split(' ',$quote);<BR>
41<BR>
42 #<BR>
43 # Using PUSH<BR>
44 #<BR>
45 @temp = push(@words,&quot;please&quot;);<BR>
46 &amp;printLine;<BR>
47 print &quot;After pushing \@words = &quot;;<BR>
48 for $i (@words) {<BR>
49&nbsp;&nbsp;&nbsp;&nbsp; print &quot;[$i] &quot;;<BR>
50&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
51<BR>
52 #<BR>
53 # USING POP<BR>
54 #<BR>
55 $temp = pop(@words);&nbsp;&nbsp;# Take the 'please' off<BR>
56 $temp = pop(@words);&nbsp;&nbsp;# Take the 'slowly' off<BR>
57 &amp;printLine;<BR>
58 print &quot;Popping twice \@words = &quot;;<BR>
59 for $i (@words) {<BR>
60&nbsp;&nbsp;&nbsp;&nbsp; print &quot;[$i] &quot;;<BR>
61&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
62 #<BR>
63 # SHIFT from the front of the array.<BR>
64 #<BR>
65 $temp = shift @words;<BR>
66 &amp;printLine;<BR>
67 print &quot;Shift $temp off, \@words= &quot;;<BR>
68 for $i (@words) {<BR>
69&nbsp;&nbsp;&nbsp;&nbsp; print &quot;[$i] &quot;;<BR>
70&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
71 #<BR>
72 # Restore words<BR>
73 #<BR>
74 @words = ();<BR>
75 @words = split(' ',$quote);<BR>
76 &amp;printLine;<BR>
77 print &quot;Restore words&quot;;<BR>
78 #<BR>
79 # SPLICE FUncTION<BR>
80 #<BR>
81 @two = splice(@words,1,2);<BR>
82 print &quot;\n Words after splice = &quot;;<BR>
83 for $i (@words) {<BR>
84&nbsp;&nbsp;&nbsp;&nbsp; print &quot; [$i]&quot;;<BR>
85&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
86 print &quot;\n Returned from splice = &quot;;<BR>
87 for $i (@two) {<BR>
88&nbsp;&nbsp;&nbsp;&nbsp; print &quot; [$i]&quot;;<BR>
89&nbsp;&nbsp;&nbsp;&nbsp; }<BR>
90 &amp;printLine;<BR>
91<BR>
92 #<BR>
93 # Using the join function<BR>
94 #<BR>
95 $joined = join(&quot;:&quot;,@words,@two);<BR>
96 print &quot;\n Returned from join = $joined &quot;;<BR>
97 &amp;printLine;</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The <TT><FONT FACE="Courier">split()</FONT></TT> function is used
in line 14 to split the items in the string <TT><FONT FACE="Courier">$quote</FONT></TT>
into the <TT><FONT FACE="Courier">@words</FONT></TT> array.
<P>
Next, the script uses <TT><FONT FACE="Courier">chop()</FONT></TT>
on a list. This function removes a character from a string. When
applied to an array, <TT><FONT FACE="Courier">chop()</FONT></TT>
removes a character from each item on the list. See lines 31 through
35.
<P>
You can add or delete items from an array using the <TT><FONT FACE="Courier">pop(@Array)</FONT></TT>
or <TT><FONT FACE="Courier">push(@Array)</FONT></TT> functions.
The <TT><FONT FACE="Courier">pop()</FONT></TT> function removes
the last item from a list and returns it as a scalar. Look at
the <TT><FONT FACE="Courier">push(ARRAY,LIST);</FONT></TT><I>
</I>call to add items to a list. The <TT><FONT FACE="Courier">push()</FONT></TT>
function takes an array as the first parameter and treats the
rest of the parameters as items to place at the end of the array.
At line 45, the <TT><FONT FACE="Courier">push()</FONT></TT> function
pushes the word <TT><FONT FACE="Courier">please</FONT></TT> into
the back of the <TT><FONT FACE="Courier">@words</FONT></TT> array.
In lines 55 and 56, two words are popped off the <TT><FONT FACE="Courier">@words</FONT></TT>
list. The size of the array <TT><FONT FACE="Courier">@words</FONT></TT>
changes with each command.
<P>
Let's look at how the <TT><FONT FACE="Courier">shift()</FONT></TT>
function is used in line 67. The <TT><FONT FACE="Courier">shift(ARRAY)</FONT></TT>
function returns the first element of an array. The size of the
array is decreased by 1. You can use <TT><FONT FACE="Courier">shift()</FONT></TT>
in one of three ways:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">shift (@mine); # return first item of
@mine<BR>
shift @mine; # return first item of @mine<BR>
shift; # return first item in @ARGV</FONT></TT>
</BLOCKQUOTE>
<P>
The special variable <TT><FONT FACE="Courier">@ARGV</FONT></TT>
is the argument vector for your Perl program. The number of elements
in <TT><FONT FACE="Courier">@ARGV</FONT></TT> is easily found
by assigning a scalar to <TT><FONT FACE="Courier">$ARGC</FONT></TT>
that is equal to <TT><FONT FACE="Courier">@#ARGV</FONT></TT> before
any operations are applied to <TT><FONT FACE="Courier">@ARGV</FONT></TT>.
<P>
Then, after restoring <TT><FONT FACE="Courier">@words</FONT></TT>
to its original value, the script uses the <TT><FONT FACE="Courier">splice()</FONT></TT>
function to remove items from the <TT><FONT FACE="Courier">@words</FONT></TT>
array. The <TT><FONT FACE="Courier">splice()</FONT></TT> function
is a very important function and is really the key behind the
<TT><FONT FACE="Courier">pop()</FONT></TT>, <TT><FONT FACE="Courier">push()</FONT></TT>,
and <TT><FONT FACE="Courier">shift()</FONT></TT> functions. Here's
the syntax for the <TT><FONT FACE="Courier">splice()</FONT></TT>
function:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">splice(@array,$offset,$length,$list)</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">splice()</FONT></TT> function returns
the items removed in the form of a list. It replaces the <TT><FONT FACE="Courier">$length</FONT></TT>
items in <TT><FONT FACE="Courier">@array</FONT></TT> starting
from <TT><FONT FACE="Courier">$offset</FONT></TT> with the contents
of <TT><FONT FACE="Courier">$list</FONT></TT>. If you leave out
the <TT><FONT FACE="Courier">$list</FONT></TT> parameter and just
use <TT><FONT FACE="Courier">splice(@array,$offset,$length)</FONT></TT>,
nothing is inserted in the original array. Any removed items are
returned from <TT><FONT FACE="Courier">splice()</FONT></TT>. If
you leave out the <TT><FONT FACE="Courier">$length</FONT></TT>
parameter to <TT><FONT FACE="Courier">splice()</FONT></TT> and
use it as <TT><FONT FACE="Courier">splice(@array,$offset)</FONT></TT>,
the value of <TT><FONT FACE="Courier">$length</FONT></TT> is used
to determine the number of the <TT><FONT FACE="Courier">@array</FONT></TT>
to use starting from the offset.
<H2><A NAME="FileHandlesandOperators"><FONT SIZE=5 COLOR=#FF0000>File
Handles and Operators</FONT></A></H2>
<P>
Now that I have covered basic array and numeric operations, let's
cover some of the input/output operations where files are concerned.
A Perl program has three file handles when it starts up: <TT><FONT FACE="Courier">STDIN</FONT></TT>
(for standard input), <TT><FONT FACE="Courier">STDOUT</FONT></TT>
(for standard output), and <TT><FONT FACE="Courier">STDERR</FONT></TT>
(for standard error message output). Note the use of capitals
and the lack of a dollar (<TT><FONT FACE="Courier">$</FONT></TT>)
sign to signify that these are file handles. For a C/C++ programmer,
the three handles are akin to <TT><FONT FACE="Courier">stdin</FONT></TT>,
<TT><FONT FACE="Courier">stdout</FONT></TT>, and <TT><FONT FACE="Courier">stderr</FONT></TT>.
<P>
To open a file for I/O you have to use the <TT><FONT FACE="Courier">open</FONT></TT>
statement. Here's the syntax for the <TT><FONT FACE="Courier">open</FONT></TT>
call:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">open(HANDLE, $filename);</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">HANDLE</FONT></TT> is then used for all
the operations on a file. To close a file, you use the function
<TT><FONT FACE="Courier">close HANDLE;</FONT></TT>.
<P>
For writing text to a file given a handle, you can use the <TT><FONT FACE="Courier">print()</FONT></TT>
statement to write to the file:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">print HANDLE $output;</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">HANDLE</FONT></TT> defaults to <TT><FONT FACE="Courier">STDIN</FONT></TT>
if no handle is specified. To read one line from the file given
a <TT><FONT FACE="Courier">HANDLE</FONT></TT>, you use the <TT><FONT FACE="Courier">&lt;&gt;</FONT></TT>
operators:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$line = &lt;HANDLE&gt;</FONT></TT>
</BLOCKQUOTE>
<P>
In this code, <TT><FONT FACE="Courier">$line</FONT></TT> will
be assigned all the input until a carriage return or <TT><FONT FACE="Courier">eof</FONT></TT>.
When writing interactive scripts, you normally use the <TT><FONT FACE="Courier">chop()</FONT></TT>
function to remove the end-of-line character. To read from the
standard input into a variable <TT><FONT FACE="Courier">$response</FONT></TT>,
you use these statements in sequence:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$response = &lt;STDIN&gt;;<BR>
chop $response; # remove offensive carriage return.</FONT></TT>
</BLOCKQUOTE>
<P>
You can perform binary read and write operations on a file using
the <TT><FONT FACE="Courier">read()</FONT></TT> and <TT><FONT FACE="Courier">write()</FONT></TT>
functions. Here's the syntax for each type of function:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">read(HANDLE,$buffer,$length[,$offset]);
<BR>
write(HANDLE,$buffer,$length[,$offset]);</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">read</FONT></TT> function is used
to read from <TT><FONT FACE="Courier">HANDLE</FONT></TT> into
<TT><FONT FACE="Courier">$buffer</FONT></TT>, up to <TT><FONT FACE="Courier">$length</FONT></TT>
bytes from the <TT><FONT FACE="Courier">$offset</FONT></TT> in
bytes from the start of the file. The <TT><FONT FACE="Courier">$offset</FONT></TT>
is optional, and <TT><FONT FACE="Courier">read()</FONT></TT> defaults
reading to the current location in the file if <TT><FONT FACE="Courier">$offset</FONT></TT>
is left out. The location in the file to read from is advanced
<TT><FONT FACE="Courier">$length</FONT></TT> bytes. To check if
you have reached the end of the file, use the command:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">eof(HANDLE);</FONT></TT>
</BLOCKQUOTE>
<P>
A nonzero value returned signifies the end of the file; a zero
returned indicates that there is more to read in the file.
<P>
The <TT><FONT FACE="Courier">write</FONT></TT> function is used
to write the contents of <TT><FONT FACE="Courier">$buffer</FONT></TT>
to <TT><FONT FACE="Courier">HANDLE</FONT></TT>. The number of
bytes to write is set in <TT><FONT FACE="Courier">$length</FONT></TT>.
The location to write<TT><FONT FACE="Courier"> </FONT></TT>at
the handle is set in the variable <TT><FONT FACE="Courier">$offset</FONT></TT>
as the number of bytes from the start of the file. The <TT><FONT FACE="Courier">$offset</FONT></TT>
is optional, and <TT><FONT FACE="Courier">write()</FONT></TT>
defaults writing to the current location in the file if <TT><FONT FACE="Courier">$offset</FONT></TT>
is left out. The location in the file written to is advanced <TT><FONT FACE="Courier">$length</FONT></TT>
bytes. 
<P>
You can move to a position in the file using the <TT><FONT FACE="Courier">seek()</FONT></TT>
function:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">seek(HANDLE,$offset,$base)</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">$offset</FONT></TT> is from the location
specified in <TT><FONT FACE="Courier">$base</FONT></TT>. The <TT><FONT FACE="Courier">seek</FONT></TT>
function behaves exactly like the C function call in that if <TT><FONT FACE="Courier">$base</FONT></TT>
is <TT><FONT FACE="Courier">0</FONT></TT>, the <TT><FONT FACE="Courier">$offset</FONT></TT>
is from the start of the file. If <TT><FONT FACE="Courier">$base</FONT></TT>
is set to <TT><FONT FACE="Courier">1</FONT></TT>, the program
uses the current location of the file pointer. If <TT><FONT FACE="Courier">$base</FONT></TT>
is <TT><FONT FACE="Courier">$2</FONT></TT>, the program uses an
offset from the end of the file where the value of <TT><FONT FACE="Courier">$offset</FONT></TT>
is negative.
<P>
There can be errors associated with opening files. It's a good
idea to see what the errors are before proceeding further in a
program. To print error messages before a script crashes, the
<TT><FONT FACE="Courier">die</FONT></TT> function is used. A call
to open a file called <TT><FONT FACE="Courier">test.data</FONT></TT>
would like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">open(TESTFILE,&quot;test.data&quot;)
|| die &quot;\n $0 Cannot open $! \n&quot;;</FONT></TT>
</BLOCKQUOTE>
<P>
This line literally reads <TT><FONT FACE="Courier">Open test.data
for input or die if you cannot open it</FONT></TT>. The <TT><FONT FACE="Courier">$0</FONT></TT>
is the Perl special variable for the process name, and the special
variable <TT><FONT FACE="Courier">$!</FONT></TT> is set to a string
corresponding to the value of the system variable, <TT><FONT FACE="Courier">errno</FONT></TT>.
<P>
The syntax in the string used for the filename also signifies
the type of operation you intend to perform with the file. Table
2.5 shows some of the ways you can open a file.<BR>
<BLOCKQUOTE>
<CENTER><B>Table 2.5. File open types.</B></CENTER>
</BLOCKQUOTE>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=129><I>File</I></TD><TD WIDTH=461><I>Action</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=129><TT><FONT FACE="Courier">test.data</FONT></TT>
</TD><TD WIDTH=461>Opens <TT><FONT FACE="Courier">test.data</FONT></TT> for reading. The file must exist.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=129><TT><FONT FACE="Courier">&gt;test.data</FONT></TT>
</TD><TD WIDTH=461>Opens <TT><FONT FACE="Courier">test.data</FONT></TT> for writing. Creates the file if it does not exist and destroys any previous file called <TT><FONT FACE="Courier">test.data</FONT></TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=129><TT><FONT FACE="Courier">&gt;&gt;test.data</FONT></TT>
</TD><TD WIDTH=461>Opens <TT><FONT FACE="Courier">test.data</FONT></TT> for writing. Creates the file if it does not exist and appends to any existing file called <TT><FONT FACE="Courier">test.data</FONT></TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=129><TT><FONT FACE="Courier">+&gt;test.data</FONT></TT>
</TD><TD WIDTH=461>Opens <TT><FONT FACE="Courier">test.data</FONT></TT> for reading and writing. Creates the file if it does not exist.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=129><TT><FONT FACE="Courier">| cmd</FONT></TT></TD>
<TD WIDTH=461>Opens a pipe to write to. (<A HREF="ch14.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch14.htm" >Chapter 14</A>, &quot;Signals, Pipes, FIFOs, and Perl,&quot; covers pipes.)
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=129><TT><FONT FACE="Courier">cm |</FONT></TT></TD>
<TD WIDTH=461>Opens a pipe to read from.</TD></TR>
</TABLE></CENTER>
<P>
<P>
When working with multiple files, you can have more than one unique
handle to write to or read from. Use the <TT><FONT FACE="Courier">select
HANDLE;</FONT></TT> call to set the default file handle to use
with <TT><FONT FACE="Courier">print</FONT></TT> statements. For
example, suppose you have two file handles, <TT><FONT FACE="Courier">LARRY</FONT></TT>
and <TT><FONT FACE="Courier">CURLY</FONT></TT>; here's how to
switch between handles:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">select LARRY;<BR>
print &quot;Whatsssa matter?\n&quot;; # write to LARRY<BR>
select CURLY;<BR>
print &quot;Whoop, whoop, whoop!&quot;; # write to CURLY<BR>
select LARRY;<BR>
print &quot;I oughta.... &quot;; # write to LARRY again</FONT></TT>
</BLOCKQUOTE>
<P>
Of course, by explicitly stating the handle name you could get
the same result with these three lines of code:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">print LARRY &quot;Whatsssa matter?\n&quot;;
# write to LARRY<BR>
print CURLY &quot;Whoop, whoop, whoop!&quot;; # write to CURLY
<BR>
print LARRY &quot;I oughta.... &quot;; # write to LARRY again</FONT></TT>
</BLOCKQUOTE>
<P>
This is a very brief introduction to using file handles in Perl.
I cover the use of file handles throughout the rest of this book,
so don't worry if this pace of information is too quick. You'll
see plenty of examples throughout the book.
<P>
You can also check for the status of a file given a filename.
The available tests are listed in the source test file shown in
Listing 2.7.
<HR>
<BLOCKQUOTE>
<B>Listing 2.7. Testing file parameters.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 <BR>
&nbsp;3 $name = &quot;test.txt&quot;;<BR>
&nbsp;4 print &quot;\nTesting flags for $name \n&quot;;<BR>
&nbsp;5 print &quot;\n========== Effective User ID tests &quot;;
<BR>
&nbsp;6 print &quot;\n is readable&quot; if ( -r $name);<BR>
&nbsp;7 print &quot;\n is writable&quot; if ( -w $name);<BR>
&nbsp;8 print &quot;\n is executable&quot; if ( -x $name);<BR>
&nbsp;9 print &quot;\n is owned &quot; if ( -o $name);<BR>
10 print &quot;\n========== Real User ID tests &quot;;<BR>
11 print &quot;\n is readable&quot; if ( -R $name);<BR>
12 print &quot;\n is writable&quot; if ( -W $name);<BR>
13 print &quot;\n is executable&quot; if ( -X $name);<BR>
14 print &quot;\n is owned by &quot; if ( -O $name);<BR>
15 <BR>
16 print &quot;\n========== Reality Checks &quot;;<BR>
17 print &quot;\n exists &quot; if ( -e $name);<BR>
18 print &quot;\n has zero size &quot; if ( -z $name);<BR>
19 print &quot;\n has some bytes in it &quot; if ( -s $name);
<BR>
20 <BR>
21 print &quot;\n is a file &quot; if (-f $name);<BR>
22 print &quot;\n is a directory &quot; if (-d $name);<BR>
23 print &quot;\n is a link &quot; if (-l $name);<BR>
24 print &quot;\n is a socket &quot; if (-S $name);<BR>
25 print &quot;\n is a pipe &quot; if (-p $name);<BR>
26 <BR>
27 print &quot;\n is a block device &quot; if (-b $name);<BR>
28 print &quot;\n is a character device &quot; if (-c $name);
<BR>
29 <BR>
30 print &quot;\n has setuid bit set &quot; if (-u $name);<BR>
31 print &quot;\n has sticky bit set &quot; if (-k $name);<BR>
32 print &quot;\n has gid bit set &quot; if (-g $name);<BR>
33 <BR>
34 print &quot;\n is open to terminal &quot; if (-t $name);<BR>
35 print &quot;\n is a Binary file &quot; if (-B $name);<BR>
36 print &quot;\n is a Text file &quot; if (-T $name);<BR>
37 <BR>
38 printf &quot;\n&quot;;</FONT></TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="WorkingwithPatterns"><FONT SIZE=5 COLOR=#FF0000>Working
with Patterns</FONT></A></H2>
<P>
Perl has a very powerful regular expression parser as well as
a powerful string search-and-replace function. To search for a
substring, you use the following syntax (normally within an <TT><FONT FACE="Courier">if</FONT></TT>
block):
<BLOCKQUOTE>
<TT><FONT FACE="Courier">if ($a =~ /&quot;menu&quot;/) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n Found menu in $a! \n&quot;;
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The value in <TT><FONT FACE="Courier">$a</FONT></TT> is the number
of matched strings. To search in a case-insensitive manner, use
an <TT><FONT FACE="Courier">i</FONT></TT> at the end of the search
statement, like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">if ($a =~ /&quot;mEnU&quot;/i) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n Found menu in $a! \n&quot;;
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
You can even search for items in an array. For example, if <TT><FONT FACE="Courier">$a</FONT></TT>
was an array <TT><FONT FACE="Courier">@a</FONT></TT>, the returned
value from the search operation is an array with all the matched
strings. If you do not specify the <TT><FONT FACE="Courier">@a
=~</FONT></TT> portion, Perl uses the <TT><FONT FACE="Courier">$_</FONT></TT>
default name space to search on.
<P>
To search and replace strings, use the following syntax:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$expr =~ s/&quot;old&quot;/&quot;new&quot;/gie</FONT></TT>
</BLOCKQUOTE>
<P>
The <TT><FONT FACE="Courier">g</FONT></TT>, <TT><FONT FACE="Courier">i</FONT></TT>,
and <TT><FONT FACE="Courier">e</FONT></TT> are optional parameters.
If <TT><FONT FACE="Courier">g</FONT></TT> is not specified, only
the first match to the <TT><FONT FACE="Courier">old</FONT></TT>
string will be replaced with <TT><FONT FACE="Courier">new</FONT></TT>.
The <TT><FONT FACE="Courier">i</FONT></TT> flag specifies a case-insensitive
search, and <TT><FONT FACE="Courier">e</FONT></TT> forces Perl
to use the <TT><FONT FACE="Courier">new</FONT></TT> string as
a Perl expression. Therefore, in the following example, the value
of <TT><FONT FACE="Courier">$a</FONT></TT> will be <TT><FONT FACE="Courier">&quot;HIGHWAY&quot;</FONT></TT>:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$a = &quot;DRIVEWAY&quot;;<BR>
$a =~ s/&quot;DRIVE&quot;/&quot;HIGH&quot;/<BR>
print $a;</FONT></TT>
</BLOCKQUOTE>
<P>
Perl has a <TT><FONT FACE="Courier">grep()</FONT></TT> function
that is very similar the <TT><FONT FACE="Courier">grep</FONT></TT>
function in UNIX. Perl's <TT><FONT FACE="Courier">grep</FONT></TT>
function takes a regular expression and a list. The return value
from <TT><FONT FACE="Courier">grep</FONT></TT> can be handled
one of two ways: if assigned to a scalar, it's the number of matches
found, or if assigned to a list, it's a sublist of all the items
found via <TT><FONT FACE="Courier">grep</FONT></TT>.
<P>
Please check the <TT><FONT FACE="Courier">man</FONT></TT> pages
for using <TT><FONT FACE="Courier">grep</FONT></TT>. Some of the
main types of predefined patterns are shown in the following list:
<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=61><I>Code </I></TD><TD WIDTH=253><I>Pattern</I>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61><TT><FONT FACE="Courier">*</FONT></TT></TD><TD WIDTH=253>Zero or more of the previous pattern
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61><TT><FONT FACE="Courier">+</FONT></TT></TD><TD WIDTH=253>One or more of the previous pattern
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61><TT><FONT FACE="Courier">.</FONT></TT></TD><TD WIDTH=253>Any character
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61><TT><FONT FACE="Courier">?</FONT></TT></TD><TD WIDTH=253>Zero or one of the previous pattern
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61><TT><FONT FACE="Courier">\0</FONT></TT></TD>
<TD WIDTH=253>Null</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61><TT><FONT FACE="Courier">\000</FONT></TT></TD>
<TD WIDTH=253>Octal</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61><TT><FONT FACE="Courier">\cX</FONT></TT></TD>
<TD WIDTH=253>ASCII control character</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61><TT><FONT FACE="Courier">\d</FONT></TT></TD>
<TD WIDTH=253>Digits [0-9]</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61><TT><FONT FACE="Courier">\D</FONT></TT></TD>
<TD WIDTH=253>Anything but digits</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61><TT><FONT FACE="Courier">\f</FONT></TT></TD>
<TD WIDTH=253>Formfeed</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61><TT><FONT FACE="Courier">\n</FONT></TT></TD>
<TD WIDTH=253>Newline</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61><TT><FONT FACE="Courier">\r</FONT></TT></TD>
<TD WIDTH=253>Carriage return</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61><TT><FONT FACE="Courier">\s</FONT></TT></TD>
<TD WIDTH=253>Space or tab or return or newline</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61><TT><FONT FACE="Courier">\S</FONT></TT></TD>
<TD WIDTH=253>Anything but <TT><FONT FACE="Courier">\s</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61><TT><FONT FACE="Courier">\t</FONT></TT></TD>
<TD WIDTH=253>Tab</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61><TT><FONT FACE="Courier">\w</FONT></TT></TD>
<TD WIDTH=253>[0-9a-zA-Z]</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61><TT><FONT FACE="Courier">\W</FONT></TT></TD>
<TD WIDTH=253>Anything but <TT><FONT FACE="Courier">\w</FONT></TT>
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=61><TT><FONT FACE="Courier">\X00</FONT></TT></TD>
<TD WIDTH=253>Hex</TD></TR>
</TABLE></CENTER>
<P>
<P>
Perl uses a special variable called <TT><FONT FACE="Courier">$_</FONT></TT>.
This is the default variable to use in Perl if you do not explicitly
specify a variable name and Perl expects a variable. For example,
in the <TT><FONT FACE="Courier">grep()</FONT></TT> function, if
you omit <TT><FONT FACE="Courier">LIST</FONT></TT>, <TT><FONT FACE="Courier">grep()</FONT></TT>
will use the string in the variable <TT><FONT FACE="Courier">$_</FONT></TT>.
The <TT><FONT FACE="Courier">$_</FONT></TT> variable is Perl's
default string in which to search, assign input, or read for data
for a number.
<H2><A NAME="Subroutines"><FONT SIZE=5 COLOR=#FF0000>Subroutines</FONT></A>
</H2>
<P>
Perl 5 supports subroutines and functions with the <TT><FONT FACE="Courier">sub</FONT></TT>
command. You can use pointers to subroutines, too. Here's the
syntax for subroutines:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub Name {<BR>
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The ending curly brace does not require a semicolon to terminate
it. If you are using a reference to a subroutine, it can be declared
without a <TT><FONT FACE="Courier">Name</FONT></TT>, as shown
here:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$ptr = sub {<BR>
<BR>
};</FONT></TT>
</BLOCKQUOTE>
<P>
Note the use of the semicolon to terminate the end of the subroutine.
To call this function, you use the following line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&amp;\$ptr(argument list);</FONT></TT>
</BLOCKQUOTE>
<P>
Parameters to subroutines are passed in the <TT><FONT FACE="Courier">@_</FONT></TT>
array. To get the individual items in the array, you can use <TT><FONT FACE="Courier">$_[0]</FONT></TT>,
<TT><FONT FACE="Courier">$_[1]</FONT></TT>, and so on. You can
define your own local variables with the <TT><FONT FACE="Courier">local</FONT></TT>
keyword. Here's an example:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub sample {<BR>
local ($a, $b, @c, $x) = @_<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&amp;lowerFunc();<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
In this subroutine, you'll find that <TT><FONT FACE="Courier">$a
= $_[0]</FONT></TT>, <TT><FONT FACE="Courier">$b = $_[1]</FONT></TT>,
and <TT><FONT FACE="Courier">@c</FONT></TT> point to the rest
of the arguments as one list with <TT><FONT FACE="Courier">$x</FONT></TT>
empty. Generally, an array is the last assignment in such an assignment
because it chews up all your parameters.
<P>
The <TT><FONT FACE="Courier">local</FONT></TT> variables will
all be available for use in the <TT><FONT FACE="Courier">lowerFunc()</FONT></TT>
function. To hide <TT><FONT FACE="Courier">$a</FONT></TT>, <TT><FONT FACE="Courier">$b</FONT></TT>,
<TT><FONT FACE="Courier">@c</FONT></TT>, and <TT><FONT FACE="Courier">$x</FONT></TT>
from <TT><FONT FACE="Courier">lowerFunc</FONT></TT>, use the <TT><FONT FACE="Courier">my</FONT></TT>
keyword like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">my ($a, $b, @c, $x) = @_</FONT></TT>
</BLOCKQUOTE>
<P>
Remember, <TT><FONT FACE="Courier">$x</FONT></TT> is empty. Now,
the code in <TT><FONT FACE="Courier">lowerFunc()</FONT></TT> is
not be able to access <TT><FONT FACE="Courier">$a</FONT></TT>,
<TT><FONT FACE="Courier">$b</FONT></TT>, <TT><FONT FACE="Courier">@c</FONT></TT>,
or <TT><FONT FACE="Courier">$x</FONT></TT>.
<P>
Parameters in Perl can be in form, from the looks of it. Since
Perl 5.002, you can define <BR>
prototypes for subroutine arguments with the following syntax:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub&nbsp;&nbsp;&nbsp;Name (parameters)
{<BR>
<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
If the parameters are not what the function expects, Perl bails
out with an error. The parameter format is as follows: <TT><FONT FACE="Courier">$</FONT></TT>
for a scalar, <TT><FONT FACE="Courier">@</FONT></TT> for an array,
<TT><FONT FACE="Courier">%</FONT></TT> for a hash, <TT><FONT FACE="Courier">&amp;</FONT></TT>
for a reference to a subroutine, and <TT><FONT FACE="Courier">*</FONT></TT>
for anything. Therefore, if you want your function to accept only
three scalars, you would declare it as this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub func1($$$) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;my ($x,$y,$z) = @_;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;code here<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
To pass the value of an array by reference (by pointer), you would
use a backslash (<TT><FONT FACE="Courier">\</FONT></TT>). If you
pass two arrays without the backslash specifier, the contents
of the two arrays will be concatenated into one long array in
<TT><FONT FACE="Courier">@_</FONT></TT>. The function prototype
to pass three arrays, a hash, and the rest in an array, would
look like this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub func2(\@\@\@\%@)</FONT></TT>
</BLOCKQUOTE>
<P>
The returned value from a subroutine is always the value of the
last expression executed in the statement. The value can be a
scalar, array, hash, or reference to an array.
<H2><A NAME="AFinalNote"><FONT SIZE=5 COLOR=#FF0000>A Final Note</FONT></A>
</H2>
<P>
The Perl distribution comes with two programs: <TT><FONT FACE="Courier">a2p</FONT></TT>
to convert awk programs to Perl, and <TT><FONT FACE="Courier">s2p</FONT></TT>
to convert sed programs to Perl. It's often convenient to write
a sed script or an awk program to do a certain task. To see how
to do the same thing in Perl, run the <TT><FONT FACE="Courier">a2p</FONT></TT>
or <TT><FONT FACE="Courier">s2p</FONT></TT> program. For example,
to convert <TT><FONT FACE="Courier">mine.awk</FONT></TT> to <TT><FONT FACE="Courier">mine.pl</FONT></TT>,
you use the following command:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$ a2p mine.awk &gt; mine.pl</FONT></TT>
</BLOCKQUOTE>
<H2><A NAME="Summary"><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></A>
</H2>
<P>
This chapter has been a whirlwind introduction to Perl. I must
admit that this chapter does not cover <I>every</I> aspect of
Perl programming basics. As you progress through the book, you'll
learn more ways to do things than are described here. Even if
you are new to Perl, you should not have any problems understanding
how to use Perl because the programming paradigms in Perl are
not that different from any other programming language.
<P>
For more information, consult the following books:
<UL>
<LI><I>Teach Yourself Perl 5 in 21 Days</I>, Dave Till, 0-672-30894-0,
Sams Publishing, 1995.
<LI><I>Learning Perl</I>, Randall Schwartz, 1-56592-042-2, O'Reilly
&amp; Associates, 1993.
<LI><I>Programming Perl</I>, Larry Wall and Randall Schwartz,
0-937175-64-1, O'Reilly &amp; Associates, 1990.
</UL>
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch1.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch1.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch3.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch3.htm"><IMG 
SRC="nc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>

