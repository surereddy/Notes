<HTML>

<HEAD>
   <TITLE>Chapter 29 -- Practical Scripts While Using
Perl</TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0b5aGold (WinNT; I) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#CE2910">
<H1><FONT COLOR=#FF0000>Chapter 29</FONT></H1>
<H1><B><FONT SIZE=5 COLOR=#FF0000>Practical Scripts While Using
Perl</FONT></B>
</H1>
<P>
<HR WIDTH="100%"></P>
<P>
<H3 ALIGN=CENTER><FONT COLOR="#000000"><FONT SIZE=+2>CONTENTS<A NAME="CONTENTS"></A>
</FONT></FONT></H3>
<UL>
<LI><A HREF="#StatisticalApplications" >Statistical Applications</A>
<LI><A HREF="#UsingPerlforSimpleStatisticalRoutin" >Using Perl for Simple Statistical Routines</A>
<UL>
<LI><A HREF="#DotandCrossProductsofVectors" >Dot and Cross Products of Vectors</A>
<LI><A HREF="#AddingorSubtractingVectors" >Adding or Subtracting Vectors</A>
</UL>
<LI><A HREF="#UsingMatrices" >Using Matrices</A>
<UL>
<LI><A HREF="#ReadingtheImage" >Reading the Image</A>
<LI><A HREF="#GettingaHistogram" >Getting a Histogram</A>
</UL>
<LI><A HREF="#TheFilter" >The Filter</A>
<LI><A HREF="#AnAddedTouch" >An Added Touch</A>
<LI><A HREF="#APartingNote" >A Parting Note</A>
<LI><A HREF="#Summary" >Summary</A>
</UL>
<HR>
<P>
Perl is a powerful language for prototyping applications. This
chapter introduces you to implementing some practical algorithms
using Perl as the base language. Once you have tested your algorithm
you can use another faster language, but during testing the Perl
interpreter will provide a quick turnaround for testing and debugging.
<H2><A NAME="StatisticalApplications"><B><FONT SIZE=5 COLOR=#FF0000>Statistical
Applications</FONT></B></A></H2>
<P>
Perl programs can call the standard math library functions to
give you greater computing power. The following functions are
available to you as standard calls. All values of these functions
are sent and returned as radians:<P>
<CENTER>
<TABLE BORDERCOLOR=#000000 BORDER=1 WIDTH=80%>
<TR VALIGN=TOP><TD WIDTH=118><TT><FONT FACE="Courier">Atan2($y,$x);</FONT></TT>
</TD><TD WIDTH=472>Returns the arc tangent in radians of the value of <TT><FONT FACE="Courier">$y/$x</FONT></TT>. The value returned is always between <TT><FONT FACE="Courier">PI</FONT></TT> and <TT><FONT FACE="Courier">-PI</FONT></TT>. There is no 
<TT><FONT FACE="Courier">atan()</FONT></TT> function because of the floating-point error problem.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=118><TT><FONT FACE="Courier">cos($x);</FONT></TT>
</TD><TD WIDTH=472>Returns cosine of <TT><FONT FACE="Courier">$x</FONT></TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=118><TT><FONT FACE="Courier">sin($x);</FONT></TT>
</TD><TD WIDTH=472>Returns sine of <TT><FONT FACE="Courier">$x</FONT></TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=118><TT><FONT FACE="Courier">sqrt($x);</FONT></TT>
</TD><TD WIDTH=472>Returns the square root of <TT><FONT FACE="Courier">$x</FONT></TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=118><TT><FONT FACE="Courier">log($x);</FONT></TT>
</TD><TD WIDTH=472>Returns the natural log of <TT><FONT FACE="Courier">$x</FONT></TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=118><TT><FONT FACE="Courier">exp($x);</FONT></TT>
</TD><TD WIDTH=472>Returns e to the power of <TT><FONT FACE="Courier">$x</FONT></TT>.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=118><TT><FONT FACE="Courier">srand($x);</FONT></TT>
</TD><TD WIDTH=472>Seeds the random number generator.</TD></TR>
<TR VALIGN=TOP><TD WIDTH=118><TT><FONT FACE="Courier">rand($x);</FONT></TT>
</TD><TD WIDTH=472>Generates a random number based on the seed.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=118><TT><FONT FACE="Courier">time;</FONT></TT></TD>
<TD WIDTH=472>Returns the number of seconds since Jan. 1, 1970.
</TD></TR>
<TR VALIGN=TOP><TD WIDTH=118><TT><FONT FACE="Courier">int($x);</FONT></TT>
</TD><TD WIDTH=472>Returns the integer portion of <TT><FONT FACE="Courier">$x</FONT></TT>. To get the fraction portion, use <TT><FONT FACE="Courier">$x - int($x);</FONT></TT>.
</TD></TR>
</THTTP/1.0 500 Cache Detected Error
Content-Type: text/html
Content-Length: 773
Date: Fri, 02 Apr 1999 05:38:44 GMT
Expires: Fri, 02 Apr 1999 05:43:44 GMT
Last-Modified: Fri, 02 Apr 1999 05:38:44 GMT

<HTML><BODY BGCOLOR=#FFFFFF TEXT=#000000>
<TITLE>ERROR: The requested URL could not be retrieved</TITLE>
<H2>ERROR: The requested URL could not be retrieved</H2>
<HR>
<P>
While trying to retrieve the URL:
<A HREF="http://wangcj.163.net/books/perl5u/ch29.htm">http://wangcj.163.net/books/perl5u/ch29.htm</A>
<P>
The following error was encountered:
<UL>
<LI><STRONG>ERROR 301 -- Read timeout</STRONG>
</UL>
<P>This means that:
<PRE>
    The Network/Remote site may be down.  Try again later.
</PRE>
<P> <HR>
</BODY>
<ADDRESS>
<a href="http://www.netapp.com"><img src="http://prefetch-atm:8080/disk_objects/graphics/logo.gif" alt="Network Appliance"></a> Web-Caching powered by Network Appliance.<br>
Generated by netcache/3.1.1d-Solaris@prefetch-atm:8080
</ADDRESS></HTML>

sp;&nbsp;# Declare as taking two scalars
<BR>
13 sub toRect($$);&nbsp;&nbsp;&nbsp;&nbsp;# Declare as taking
two scalars<BR>
14<BR>
15 *PI&nbsp;&nbsp;= \3.1415926;<BR>
16 *PIBY2 = $PI / 2;<BR>
17 *TODEG = \57.2958;<BR>
18 *TORAD = \0.01745;<BR>
19<BR>
20 GetOptions('x=i', 'y=i');<BR>
21<BR>
22 $x = $opt_x;<BR>
23 $y = $opt_y;<BR>
24<BR>
25 ($r,$theta) = &amp;toPolar($x,$y);<BR>
26<BR>
27 printf &quot;The polar coordinates for %6.3f,%6.3f are \n&quot;,
$x,$y;<BR>
28 printf &quot;&nbsp;&nbsp;&nbsp;&nbsp;r = %6.3f and theta %6.3f
or %6.3f degrees\n&quot;,<BR>
29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$r,$theta,
$theta * $TODEG;<BR>
30<BR>
31 ($x1,$y1) = toRect($r,$theta);<BR>
32<BR>
33 printf &quot;Compare x,y (%6.3f,%6.3f) with&nbsp;&nbsp;&quot;,
$x, $y, $x1, $y1;<BR>
34 printf &quot; x1,y1 (%6.3f,%6.3f) \n&quot;, $x, $y, $x1, $y1;
<BR>
35<BR>
36<BR>
37 sub toPolar {&nbsp;&nbsp;&nbsp;# ($$);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
Declare as taking two scalars<BR>
38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my ($x,$y) = @_;<BR>
39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $r;<BR>
40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $t;<BR>
41<BR>
42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$r = sqrt( $x * $x + $y
+ $y ) ;<BR>
43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$t = atan2($y,$x);<BR>
44<BR>
45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return($r,$t);<BR>
46<BR>
47 }<BR>
48 sub toRect&nbsp;&nbsp;{&nbsp;&nbsp;#($$);&nbsp;&nbsp; # Declare
as taking two scalars<BR>
49&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my ($r,$t) = @_;<BR>
50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $x;<BR>
51&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $y;<BR>
52<BR>
53&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$x = $r * cos($t);<BR>
54&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$y = $r * sin($t);<BR>
55<BR>
56&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return($x,$y);<BR>
57 }<BR>
58</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
At line 37, the subroutine <TT><FONT FACE="Courier">toPolar</FONT></TT>
uses a prototype to specify two input parameters using the <TT><FONT FACE="Courier">($$)</FONT></TT>
construct. Similarly, the <TT><FONT FACE="Courier">toRect</FONT></TT>
function also takes two parameters with the <TT><FONT FACE="Courier">($$)</FONT></TT>
prototype. Both functions return two items each. The constants
declared in lines 17 and 18 are not used in this program but are
included only for reference or future use should you need them.
<H2><A NAME="UsingPerlforSimpleStatisticalRoutin"><B><FONT SIZE=5 COLOR=#FF0000>Using
Perl for Simple Statistical Routines</FONT></B></A></H2>
<P>
Let's add some more functionality to what you have just developed
in the code in Listing 29.1. Let's start by adding some simple
statistical routines.
<P>
Perhaps the most common function to perform on a list of numeric
values is to calculate the average and standard deviation. Listing
29.2 presents a function that returns these values given an array
of items.
<HR>
<BLOCKQUOTE>
<B>Listing 29.2. Calculating the average and standard deviation.
<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2<BR>
&nbsp;3<BR>
&nbsp;4 #<BR>
&nbsp;5 # Simple statistical functions in Perl<BR>
&nbsp;6 #<BR>
&nbsp;7<BR>
&nbsp;8 use Getopt::Long;<BR>
&nbsp;9<BR>
10 #----------------------------------------------------------------
<BR>
11 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Declare
any subroutines here<BR>
12 #----------------------------------------------------------------
<BR>
13 sub stats(\@);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Declare as taking
reference to array.<BR>
14<BR>
15<BR>
16 GetOptions('file=s');<BR>
17 open (DATA,&quot;$opt_file&quot;) || die &quot;Cannot open
$opt_file \n&quot;;<BR>
18<BR>
19 $i = 0;<BR>
20 while ($line = &lt;DATA&gt;)<BR>
21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>
22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chop $line;<BR>
23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;($date,$hi[$i],$lo[$i],$day[$i])
= split(' ',$line);<BR>
24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$i++;<BR>
25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
26<BR>
27 ($ave,$max,$min,$std) = &amp;stats(\@day);<BR>
28<BR>
29 printf &quot; Average = %6.2lf \n&quot;, $ave;<BR>
30 printf &quot; Maximum = %6.2lf \n&quot;, $max;<BR>
31 printf &quot; Minimum = %6.2lf \n&quot;, $min;<BR>
32 printf &quot; Std Dev = %6.2lf \n&quot;, $std;<BR>
33<BR>
34 close DATA;<BR>
35<BR>
36<BR>
37 #<BR>
38 # Compute simple stats on incoming stream.<BR>
39 #<BR>
40<BR>
41 sub stats {<BR>
42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Allow passing of array
either by reference or<BR>
44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# by its values.<BR>
45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
46&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $a = ref($_[0]) ? $_[0]
: \@_;<BR>
47&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $count = $#{$a} + 1;
<BR>
48<BR>
49&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Bail out in case of erroneous
data.<BR>
51&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(-1,-1,-1,-1) if ($count
&lt; 2);<BR>
53<BR>
54&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;$count items
\n&quot;;<BR>
55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $i;<BR>
56<BR>
57&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
58&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Initialize local variables.
The assignment to 0<BR>
59&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# is unnecessary for all
scalars except $max and $min<BR>
60&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# since Perl will initialize
them to zero for you.<BR>
61&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
62&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $min = $$a[0];<BR>
63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $max = $$a[0];<BR>
64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $sum = 0;<BR>
65&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $sum2 = 0;<BR>
66&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $ave = 0;<BR>
67&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $std = 0;<BR>
68<BR>
69&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
70&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Get the required statistics
<BR>
71&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
72&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for $i (@$a) {<BR>
73&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$sum
+= $i;<BR>
74&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$sum2
+= ($i * $i);<BR>
75&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$max
= $i if ($max &lt; $i);<BR>
76&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$min
= $i if ($min &gt; $i);<BR>
77&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
78&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ave = $sum/$count;<BR>
79&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$std = (($sum2 - $sum *
$ave)/($count - 1));<BR>
80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
81&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return the list of values
back from function.<BR>
82&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<BR>
83&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ($ave,$max,$min,$std);
<BR>
84 }</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Look at line 23 in Listing 29.2. The data is stripped off into
columns for you to work with. The format of the data file has
the list of data points for each item in separate columns.
<P>
Also note that we are forcing the user to type in <TT><FONT FACE="Courier">file=<I>something</I></FONT></TT>
for this program to work. If you never intend on passing any parameters
to this program via the use of options, then it's better to use
<TT><FONT FACE="Courier">ARGV[1]</FONT></TT>. However, you will
have to take care of things like missing or malformed strings
in <TT><FONT FACE="Courier">ARGV[1]</FONT></TT>.
<P>
The <TT><FONT FACE="Courier">stats</FONT></TT> subroutine is also
defined via a prototype in line 13. Prototypes are discussed in
<A HREF="ch2.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch2.htm" >Chapter 2</A>, &quot;A Brief Introduction to
Perl.&quot; The <TT><FONT FACE="Courier">stats</FONT></TT> subroutine
is shown to take only one parameter, which is a pointer to an
array.
<P>
Note how the input parameter to the <TT><FONT FACE="Courier">stats</FONT></TT>
function is derived using the <TT><FONT FACE="Courier">ref()</FONT></TT>
function call in line 46. If the passed parameter is a reference,
then the function uses the first argument; otherwise, <TT><FONT FACE="Courier">$a</FONT></TT>
is assigned to the entire incoming argument list:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">my $a = ref($_[0]) ? $_[0] : \@_;</FONT></TT>
</BLOCKQUOTE>
<P>
The math operations are performed in lines 72 to 79. The results
of these calculations are returned in line 83. Listing 29.1 and
Listing 29.2 should be enough to get you started on creating more
complicated functions. For example, let's add two routines for
performing vector calculations.
<H3><A NAME="DotandCrossProductsofVectors"><B>Dot and Cross Products
of Vectors</B></A></H3>
<P>
Two subroutines that perform the cross and dot products of two
vectors are shown in Listing 29.3. A cross product of a vector
of length <TT><FONT FACE="Courier">n</FONT></TT> and a vector
of length <TT><FONT FACE="Courier">m</FONT></TT> will return a
matrix of size <TT><FONT FACE="Courier">m</FONT></TT> <FONT FACE="Symbol">&#165;</FONT>
<TT><FONT FACE="Courier">n</FONT></TT>, whereas a dot product
of two vectors of the same size (i.e., <TT><FONT FACE="Courier">m</FONT></TT>
= <TT><FONT FACE="Courier">n</FONT></TT>) will return a scalar
value.
<HR>
<BLOCKQUOTE>
<B>Listing 29.3. Vector functions.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2<BR>
&nbsp;3 #<BR>
&nbsp;4 # Simple statistical functions in Perl<BR>
&nbsp;5 #<BR>
&nbsp;6<BR>
&nbsp;7<BR>
&nbsp;8 #----------------------------------------------------------------
<BR>
&nbsp;9 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Declare
any subroutines here<BR>
10 #----------------------------------------------------------------
<BR>
11 sub xProduct(\@\@\@);&nbsp;&nbsp;&nbsp;# Declare as taking
two pointers to arrays<BR>
12 sub dProduct(\@\@);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Declare
as taking two pointers to arrays<BR>
13<BR>
14 @one = ( 2, 4, 3);<BR>
15 @two = ( 4, -1, 7);<BR>
16 @result = ();<BR>
17<BR>
18 $r = &amp;dProduct(\@one,\@two);<BR>
19<BR>
20 print &quot;\n Dot Product = $r \n&quot;;<BR>
21<BR>
22 &amp;xProduct(\@one,\@two,\@result);<BR>
23<BR>
24 print &quot;\n Cross Product = \n&quot;;<BR>
25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ($i=0;$i&lt;3;$i++)
{<BR>
26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
($j=0;$j&lt; 3;$j++) {<BR>
27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;&nbsp;&quot;
%4d&quot;, $result[$i][$j];<BR>
28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n&quot;;<BR>
30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
31<BR>
32 exit (0);<BR>
33 # ------------------------------------------------<BR>
34 #&nbsp;&nbsp;Returns dot product of two vectors.<BR>
35 #&nbsp;&nbsp;Takes two pointers to arrays as input<BR>
36 #&nbsp;&nbsp;Returns a scalar.<BR>
37 sub dProduct {&nbsp;&nbsp;#<BR>
38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my ($x,$y) = @_;<BR>
39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $sum;<BR>
40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $ct1 = $#{$x} + 1;&nbsp;&nbsp;
# items in $x<BR>
41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $ct2 = $#{$y} + 1;&nbsp;&nbsp;
# items in $y<BR>
42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return undef if ($ct1 !=
$ct2) ;<BR>
43<BR>
44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ($i=0;$i&lt;$ct1;$i++)
{<BR>
45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$sum += $$x[$i] * $$y[$i];
<BR>
46&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
47&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return $sum;<BR>
48 }<BR>
49 # ------------------------------------------------<BR>
50 # Returns a cross product of two vectors.<BR>
51 # Takes two pointers to arrays as input<BR>
52 # Returns a two-dimensional array.<BR>
53 sub xProduct {<BR>
54&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my ($x,$y) = @_;<BR>
55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $i, $j, @array;<BR>
56&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $ct1 = $#{$x} + 1;&nbsp;&nbsp;&nbsp;#
items in $x<BR>
57&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $ct2 = $#{$y} + 1;&nbsp;&nbsp;&nbsp;#
items in $y<BR>
58&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $result = \@arrau;<BR>
59&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ($i=0;$i&lt;$ct1;$i++)
{<BR>
60&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
($j=0;$j&lt;$ct2;$j++) {<BR>
61&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$result[$i][$j]
= $$x[$i] * $$y[$i];<BR>
62&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
print &quot; $i, $j, $$result[$i][$j] \n&quot;;<BR>
63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
64&nbsp;&nbsp;return ($result);&nbsp;&nbsp;&nbsp;return result.
<BR>
65 }</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
Notice how the subroutines for the two functions are declared
at lines 11 and 12. At line 18, the script calls <TT><FONT FACE="Courier">dProduct</FONT></TT>
to return the dot product of the two vectors. The return value
from the <TT><FONT FACE="Courier">dProduct</FONT></TT> function
can also be <TT><FONT FACE="Courier">undef</FONT></TT> if the
vectors are not the same size.
<P>
At line 22, you get the resulting cross product matrix of multiplying
the two vectors together. The size of the matrix is M<FONT FACE="Symbol">&#165;</FONT>N,
where M is the size of the first vector and N is the size of the
second vector passed into <TT><FONT FACE="Courier">xProduct()</FONT></TT>.
<P>
To return an entire result of a calculation instead of having
to pass the <TT><FONT FACE="Courier">@result</FONT></TT> array,
you can rewrite the cross product function as shown in Listing
29.4. Line 9 now declares only two pointers to arrays into <TT><FONT FACE="Courier">xProduct</FONT></TT>.
The array in <TT><FONT FACE="Courier">xProduct</FONT></TT> is
referred to by reference as well at line 53. The reference, <TT><FONT FACE="Courier">$result</FONT></TT>,
is returned to the caller in line 64. Note the <TT><FONT FACE="Courier">@array</FONT></TT>,
even though declared as a <TT><FONT FACE="Courier">my</FONT></TT>
variable, is not destroyed because the reference to it in <TT><FONT FACE="Courier">$result</FONT></TT>
is returned by the <TT><FONT FACE="Courier">xProduct</FONT></TT>
function. As long as the returned reference to the calling program
continues to be used, the space allocated for the <TT><FONT FACE="Courier">@array</FONT></TT>
will not be destroyed.
<H3><A NAME="AddingorSubtractingVectors"><B>Adding or Subtracting
Vectors</B></A></H3>
<P>
It's quite straightforward to include the two functions to add
and subtract two vectors. These two subroutines are defined in
Listing 29.4 at lines 65 and 87, respectively.
<P>
The number of elements in each array passed into the functions
is kept in variables <TT><FONT FACE="Courier">$ct1</FONT></TT>
and <TT><FONT FACE="Courier">$ct2</FONT></TT> (see lines 105 and
106). The counts are used in loops elsewhere in the code.
<HR>
<BLOCKQUOTE>
<B>Listing 29.4. Calculations returning an array.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;&nbsp;2<BR>
&nbsp;&nbsp;3 #---------------------------------------------------------------
<BR>
&nbsp;&nbsp;4 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector
Arithmetic Routines for use in Perl.<BR>
&nbsp;&nbsp;5 #&nbsp;&nbsp;Copy these freely with NO RESTRICTIONS
AND NO WARRANTY!<BR>
&nbsp;&nbsp;6 #----------------------------------------------------------------
<BR>
&nbsp;&nbsp;7 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Declare
thy subroutines here<BR>
&nbsp;&nbsp;8 #----------------------------------------------------------------
<BR>
&nbsp;&nbsp;9 sub xProduct(\@\@);&nbsp;&nbsp;# Declare as taking
two pointers to arrays<BR>
&nbsp;10 sub dProduct(\@\@);&nbsp;&nbsp;# Declare as taking two
pointers to arrays<BR>
&nbsp;11 sub vAdd(\@\@);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
Declare as taking two pointers to arrays<BR>
&nbsp;12 sub vSubtract(\@\@); # Declare as taking two pointers
to arrays<BR>
&nbsp;13<BR>
&nbsp;14 # -------------------------------------------------------------------
<BR>
&nbsp;15 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test
with these vectors<BR>
&nbsp;16 # -------------------------------------------------------------------
<BR>
&nbsp;17 @one = ( 2, 4, 3);<BR>
&nbsp;18 @two = ( 4, -1, 7);<BR>
&nbsp;19 @result = ();<BR>
&nbsp;20<BR>
&nbsp;21 print &quot;\n Vector 1 = &quot;;<BR>
&nbsp;22 for (@one) { printf &quot; %4d&quot;, $_; }<BR>
&nbsp;23<BR>
&nbsp;24 print &quot;\n Vector 2 = &quot;;<BR>
&nbsp;25 for (@two) { printf &quot; %4d&quot;, $_; }<BR>
&nbsp;26<BR>
&nbsp;27<BR>
&nbsp;28 # -------------------------------------------------------------------
<BR>
&nbsp;29 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test
Dot Product<BR>
&nbsp;30 # -------------------------------------------------------------------
<BR>
&nbsp;31 $r = &amp;dProduct(@one,@two);<BR>
&nbsp;32 print &quot;\n Dot Product = $r \n&quot;;<BR>
&nbsp;33<BR>
&nbsp;34 # -------------------------------------------------------------------
<BR>
&nbsp;35 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test
Addition<BR>
&nbsp;36 # -------------------------------------------------------------------
<BR>
&nbsp;37 @result = &amp;vAdd(\@one,\@two);<BR>
&nbsp;38 print &quot;\n Added = &quot;;<BR>
&nbsp;39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (@result) { printf
&quot; %4d&quot;, $_; }<BR>
&nbsp;40<BR>
&nbsp;41 # -------------------------------------------------------------------
<BR>
&nbsp;42 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test
Subtraction<BR>
&nbsp;43 # -------------------------------------------------------------------
<BR>
&nbsp;44 @result = &amp;vSubtract(\@one,\@two);<BR>
&nbsp;45 print &quot;\n Subtract&nbsp;&nbsp;= &quot;;<BR>
&nbsp;46&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (@result) { printf
&quot; %4d&quot;, $_; }<BR>
&nbsp;47<BR>
&nbsp;48 # -------------------------------------------------------------------
<BR>
&nbsp;49 #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test
Cross Product<BR>
&nbsp;50 # -------------------------------------------------------------------
<BR>
&nbsp;51 @result = &amp;xProduct(\@one,\@two);<BR>
&nbsp;52<BR>
&nbsp;53 print &quot;\n Cross Product = \n&quot;;<BR>
&nbsp;54&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ($i=0;$i&lt;3;$i++)
{<BR>
&nbsp;55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
($j=0;$j&lt; 3;$j++) {<BR>
&nbsp;56&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;&nbsp;&quot;
%4d&quot;, $result[$i][$j];<BR>
&nbsp;57&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<BR>
&nbsp;58&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print &quot;\n&quot;;
<BR>
&nbsp;59&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;60<BR>
&nbsp;61 exit (0);<BR>
&nbsp;62<BR>
&nbsp;63 # -------------------------------------------------------------------
<BR>
&nbsp;64 # Returns a vector that is the result of subtracting
one vector from<BR>
&nbsp;65 # another. Both vectors have to be the same size.<BR>
&nbsp;66 # -------------------------------------------------------------------
<BR>
&nbsp;67 sub vAdd {&nbsp;&nbsp;# (\@\@); Declare as taking two
pointers to arrays<BR>
&nbsp;68&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my ($x,$y) = @_;<BR>
&nbsp;69&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $ct1 = $#{$x} +
1;&nbsp;&nbsp; # items in $x<BR>
&nbsp;70&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $ct2 = $#{$y} +
1;&nbsp;&nbsp; # items in $y<BR>
&nbsp;71&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return undef if ($ct1
!= $ct2) ;<BR>
&nbsp;72&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $i;<BR>
&nbsp;73&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my @answer;<BR>
&nbsp;74<BR>
&nbsp;75&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ($i=0;$i&lt;$ct1;$i++)
{<BR>
&nbsp;76&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$answer[$i]
= $$x[$i] + $$y[$i];<BR>
&nbsp;77&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;78&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return @answer;<BR>
&nbsp;79 }<BR>
&nbsp;80<BR>
&nbsp;81 # -------------------------------------------------------------------
<BR>
&nbsp;82 # Returns a vector that is the result of subtracting
one vector from<BR>
&nbsp;83 # another. Both vectors have to be the same size.<BR>
&nbsp;84 # -------------------------------------------------------------------
<BR>
&nbsp;85 sub vSubtract {&nbsp;&nbsp;# (\@\@); Declare as taking
two pointers to arrays<BR>
&nbsp;86&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my ($x,$y) = @_;<BR>
&nbsp;87&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $ct1 = $#{$x} +
1;&nbsp;&nbsp;&nbsp;# items in $x<BR>
&nbsp;88&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $ct2 = $#{$y} +
1;&nbsp;&nbsp;&nbsp;# items in $y<BR>
&nbsp;89&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return undef if ($ct1
!= $ct2) ;<BR>
&nbsp;90&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $i;<BR>
&nbsp;91&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my @answer;<BR>
&nbsp;92<BR>
&nbsp;93&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ($i=0;$i&lt;$ct1;$i++)
{<BR>
&nbsp;94&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$answer[$i]
= $$x[$i] - $$y[$i];<BR>
&nbsp;95&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;96&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return @answer;<BR>
&nbsp;97 }<BR>
&nbsp;98<BR>
&nbsp;99 # -------------------------------------------------------------------
<BR>
100 # Returns a scalar that is a dot product of two vectors.<BR>
101 # -------------------------------------------------------------------
<BR>
102 sub dProduct {&nbsp;&nbsp;# (\@\@); Declare as taking two
pointers to arrays<BR>
103&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my ($x,$y) = @_;<BR>
104&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $sum;<BR>
105&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $ct1 = $#{$x} + 1;&nbsp;&nbsp;&nbsp;#
items in $x<BR>
106&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $ct2 = $#{$y} + 1;&nbsp;&nbsp;&nbsp;#
items in $y<BR>
107&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return undef if ($ct1 !=
$ct2) ;<BR>
108<BR>
109&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ($i=0;$i&lt;$ct1;$i++)
{<BR>
110&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$sum += $$x[$i] * $$y[$i];
<BR>
111&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
112&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return $sum;<BR>
113 }<BR>
114<BR>
115 # ------------------------------------------------------------
<BR>
116 # Returns an array that is the cross product of two vectors.
<BR>
117 # ------------------------------------------------------------
<BR>
118 sub xProduct {&nbsp;&nbsp;# (\@\@); Declare as taking two
pointers to arrays<BR>
119&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my ($x,$y) = @_;<BR>
120&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my @array;<BR>
121&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $result = \@array;<BR>
122&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $i, $j;<BR>
123&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $ct1 = $#{$x} + 1;&nbsp;&nbsp;&nbsp;#
items in $x<BR>
124&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $ct2 = $#{$y} + 1;&nbsp;&nbsp;&nbsp;#
items in $y<BR>
125<BR>
126&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ($i=0;$i&lt;$ct1;$i++)
{<BR>
127&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
($j=0;$j&lt;$ct2;$j++) {<BR>
128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$result[$i][$j]
= $$x[$i] * $$y[$i];<BR>
129&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#
print &quot; $i, $j, $$result[$i][$j] \n&quot;;<BR>
130&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
131&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
132&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return @array;<BR>
133 }</FONT></TT>
</BLOCKQUOTE>
<HR>
<H2><A NAME="UsingMatrices"><B><FONT SIZE=5 COLOR=#FF0000>Using
Matrices</FONT></B></A></H2>
<P>
Just like with vectors, you can use Perl references on matrices.
As an example of developing code for a prototype, this section
covers the following items:
<UL>
<LI><FONT COLOR=#000000>Reading an ASCII PBM file</FONT>
<LI><FONT COLOR=#000000>Collecting histogram information to show
work with matrices in Perl</FONT>
<LI><FONT COLOR=#000000>Applying a 3</FONT><FONT FACE="Symbol">&#165;</FONT>3
convolution smoothing filter on the image
<LI><FONT COLOR=#000000>Writing a resulting ASCII PBM file</FONT>
</UL>
<P>
This section covers the image shown in Figure 29.1. The image
is a black-and-white cartoon, but the techniques you'll learn
here can be applied to color images as well. Listing 29.5 contains
the complete code for developing the images shown in Figures 29.2
and 29.3.
<P>
<A HREF="f29-1.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/f29-1.gif" ><B>Figure 29.1 : </B><I>The unfiltered image.</I></A>
<HR>
<BLOCKQUOTE>
<B>Listing 29.5. The complete listing for reading and writing
PBM files.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;&nbsp;2<BR>
&nbsp;&nbsp;3 #-------------------------------------------------------
<BR>
&nbsp;&nbsp;4 #&nbsp;&nbsp;&nbsp;&nbsp;Read and write ASCII PPM
files<BR>
&nbsp;&nbsp;5 #-------------------------------------------------------
<BR>
&nbsp;&nbsp;6 # Author: Kamran Husain&nbsp;&nbsp;4.4.96<BR>
&nbsp;&nbsp;7 # NO WARRANTIES WHATSOEVER APPLY HERE!! Copy freely,
use<BR>
&nbsp;&nbsp;8 # at will, with no restrictions.<BR>
&nbsp;&nbsp;9 #-------------------------------------------------------
<BR>
&nbsp;10 use Getopt::Long;<BR>
&nbsp;11 GetOptions('out=s');<BR>
&nbsp;12<BR>
&nbsp;13 open (TEXT,&quot;pirate.ppm&quot;) || die &quot;\n Cannot
open $!\n&quot;;<BR>
&nbsp;14 @image = ();<BR>
&nbsp;15 @hist = ();<BR>
&nbsp;16 ($wd, $ht, @image) =&nbsp;&nbsp;&amp;readImage;<BR>
&nbsp;17 close &lt;TEXT&gt;;<BR>
&nbsp;18<BR>
&nbsp;19 print &quot;@image &quot;;<BR>
&nbsp;20 @hist = &amp;getHistogram($ht,$wd,@image);<BR>
&nbsp;21<BR>
&nbsp;22 $ctr = 0;<BR>
&nbsp;23 $hi = $#hist + 1;<BR>
&nbsp;24<BR>
&nbsp;25 # ------------------------------------------------------
<BR>
&nbsp;26 # Display histogram of image in memory<BR>
&nbsp;27 # ------------------------------------------------------
<BR>
&nbsp;28 print &quot;Histogram of image\n&quot;;<BR>
&nbsp;29 for ($i = 0; $i &lt; $hi; $i++) {<BR>
&nbsp;30 if ($hist[$i] != 0) {<BR>
&nbsp;31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf &quot;[%3d]
= %5d &quot;, $i, $hist[$i] ; $ctr++;<BR>
&nbsp;32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
($ctr &gt;= 5) {<BR>
&nbsp;33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ctr
= 0;<BR>
&nbsp;34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print
&quot;\n&quot;<BR>
&nbsp;35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;37 }<BR>
&nbsp;38<BR>
&nbsp;39 # ------------------------------------------------------
<BR>
&nbsp;40 #&nbsp;&nbsp;&nbsp;Write to disk as unfiltered.<BR>
&nbsp;41 # ------------------------------------------------------
<BR>
&nbsp;42 @convolve = ( 0.1, 0.1, 0.1,<BR>
&nbsp;43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.1, 0.1,
0.1,<BR>
&nbsp;44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.1, 0.1,
0.1);<BR>
&nbsp;45 print &quot;\n Filter 1 applied&quot;;<BR>
&nbsp;46 &amp;applyFilter3($wd,$ht,\@convolve,\@image);<BR>
&nbsp;47 &amp;dumpImage ('filt1.ppm', $wd, $ht);<BR>
&nbsp;48<BR>
&nbsp;49 @convolve = ( 0.1, 0.0, 0.1,<BR>
&nbsp;50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.5,
0.0,<BR>
&nbsp;51&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.1, 0.0,
0.1);<BR>
&nbsp;52 print &quot;\n Filter 2 applied&quot;;<BR>
&nbsp;53 &amp;applyFilter3($wd,$ht,\@convolve,\@image);<BR>
&nbsp;54<BR>
&nbsp;55 &amp;dumpImage ('filt2.ppm', $wd, $ht);<BR>
&nbsp;56<BR>
&nbsp;57 exit(0);<BR>
&nbsp;58<BR>
&nbsp;59 # ------------------------------------------------------
<BR>
&nbsp;60 #&nbsp;&nbsp;&nbsp;&nbsp;Dump PPM file to disk given
file name,<BR>
&nbsp;61 #&nbsp;&nbsp;&nbsp;&nbsp;ht and width of image<BR>
&nbsp;62 # ------------------------------------------------------
<BR>
&nbsp;63 sub dumpImage {<BR>
&nbsp;64<BR>
&nbsp;65&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $fname = shift
@_;<BR>
&nbsp;66&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $wd = shift @_;
<BR>
&nbsp;67&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $ht = shift @_;
<BR>
&nbsp;68&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $i,$j,$k,$v;<BR>
&nbsp;69<BR>
&nbsp;70 print &quot;\n Writing file $fname $wd by $ht&quot;;
<BR>
&nbsp;71<BR>
&nbsp;72 open (OUTPUT,&quot;&gt;$fname&quot;) || die &quot;Cannot
open $fname $! &quot;;<BR>
&nbsp;73 select OUTPUT;<BR>
&nbsp;74 print &quot;P3\n&quot;;<BR>
&nbsp;75 print &quot;# Test output\n&quot;;<BR>
&nbsp;76 print &quot;$wd $ht\n&quot;;<BR>
&nbsp;77 print &quot;255\n&quot;;<BR>
&nbsp;78<BR>
&nbsp;79 $count = 0;<BR>
&nbsp;80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for($i=0;$i&lt;$ht;$i++)
{<BR>
&nbsp;81&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for($j=0;$j&lt;$wd;$j++)
{<BR>
&nbsp;82&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$v
= $$image[$i][$j];<BR>
&nbsp;83&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf
&quot;%3d %3d %3d &quot;, $v,$v,$v;<BR>
&nbsp;84&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$count++;
<BR>
&nbsp;85&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(($count % 5) == 0) {<BR>
&nbsp;86&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$count
= 0;<BR>
&nbsp;87&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print
&quot;\n&quot;;}<BR>
&nbsp;88&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
&nbsp;89&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;90 close OUTPUT;<BR>
&nbsp;91 select STDOUT;<BR>
&nbsp;92 }<BR>
&nbsp;93<BR>
&nbsp;94<BR>
&nbsp;95 # ------------------------------------------------------
<BR>
&nbsp;96 #&nbsp;&nbsp;&nbsp;&nbsp;Read PPM file from disk given
file name,<BR>
&nbsp;97 #&nbsp;&nbsp;&nbsp;&nbsp;Return b/w version back along
with ht and width of<BR>
&nbsp;98 #&nbsp;&nbsp;&nbsp;&nbsp;image.<BR>
&nbsp;99 # ------------------------------------------------------
<BR>
100 sub readImage { # (\@) for image data;<BR>
101&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my @image;<BR>
102&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $result = \@image;<BR>
103&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $format = &lt;TEXT&gt;;
<BR>
104&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $comment = &lt;TEXT&gt;;
<BR>
105&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$a = &lt;TEXT&gt;;<BR>
106&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chop $a;<BR>
107&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local ($cols, $rows) =
split(' ',$a);<BR>
108&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local $colors = &lt;TEXT&gt;;
<BR>
109&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $row = 0;<BR>
110&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $col = 0;<BR>
111&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $a;<BR>
112<BR>
113&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$rows = int($rows);<BR>
114&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$cols = int($cols);<BR>
115<BR>
116&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while ($a = &lt;TEXT&gt;)
{<BR>
117&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chop $a;<BR>
118&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@words = split(' ',$a);
<BR>
119&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$count = $#words;<BR>
120<BR>
121&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (@words) {<BR>
122&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;($r,$g,$b)
= splice(@words,0,3);<BR>
123&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$image[$row][$col]
= ($r+$g+$b)/3;<BR>
124&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$col++;
<BR>
125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ($col
&gt;= $cols) { $row++; $col = 0 }<BR>
126&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
127&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
128&nbsp;&nbsp;&nbsp;&nbsp;return ($cols,$rows,@image);<BR>
129&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
130<BR>
131<BR>
132 # ------------------------------------------------------<BR>
133 #&nbsp;&nbsp;&nbsp;&nbsp;Calculate histogram of up to 256
colors in<BR>
134 #&nbsp;&nbsp;&nbsp;&nbsp;the passed image bytes.<BR>
135 # ------------------------------------------------------<BR>
136 sub getHistogram {<BR>
137&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my ($rows,$cols,$img) =
@_;<BR>
138&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my @image = @$img;<BR>
139&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my @refered = ();<BR>
140&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $hst = \@refered;<BR>
141<BR>
142&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $i,$j,$k;<BR>
143<BR>
144&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for($i=0;$i&lt;$rows;$i++)
{<BR>
145&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for($j=0;$j&lt;$cols;$j++) {<BR>
146&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$k
= $$image[$i][$j];<BR>
147&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$hst[$k]
+= 1;<BR>
148&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
149&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
150&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (@refered);<BR>
151 }<BR>
152<BR>
153<BR>
154 # ------------------------------------------------------<BR>
155 #&nbsp;&nbsp;&nbsp;&nbsp;Apply 3x3 filter to the image<BR>
156 #&nbsp;&nbsp;&nbsp;&nbsp;Return resulting image.<BR>
157 # ------------------------------------------------------<BR>
158 sub applyFilter3 {<BR>
159&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my ($rows,$cols,$convolve,$img)
= @_;<BR>
160&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my @fir = @$convolve;<BR>
161&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my @image = @$img;<BR>
162&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my $i,$j,$k,$v;<BR>
163<BR>
164&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\n
Filter: $rows X $cols &quot;;<BR>
165&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for ($i=0; $i&lt;9;$i++)
{<BR>
166&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&nbsp;&nbsp;&nbsp;&quot;\[
$fir[$i] \]&quot;;<BR>
167&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
168&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for($i=1;$i&lt;$rows -1;$i++)
{<BR>
169&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for($j=1;$j&lt;$cols
- 1;$j++) {<BR>
170&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$k
=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$image[$i-1][$j-1] * $fir[0] +
<BR>
171&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$image[$i][$j-1]&nbsp;&nbsp;&nbsp;*
$fir[1] +<BR>
172&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$image[$i+1][$j-1]
* $fir[2] +<BR>
173&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$image[$i-1][$j]&nbsp;&nbsp;&nbsp;*
$fir[3] +<BR>
174&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$image[$i][$j]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
$fir[4] +<BR>
175&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$image[$i+1][$j]&nbsp;&nbsp;&nbsp;*
$fir[5] +<BR>
176&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$image[$i-1][$j+1]&nbsp;*
$fir[6] +<BR>
177&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$image[$i][$j+1]&nbsp;&nbsp;&nbsp;*
$fir[7] +<BR>
178&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$image[$i+1][$j+1]
* $fir[8];<BR>
179&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$image[$i][$j]
= int($k);<BR>
180&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>
181&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
182 }</FONT></TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME="ReadingtheImage"><B>Reading the Image</B></A></H3>
<P>
The format chosen for this example is the ASCII version of the
portable bitmap (PBM) file type PPM. There are two reasons for
choosing this format. First, it's simple to work with compared
to the more complicated GIF, pcX, and JPEG formats. The idea here
is to show how to use Perl to prototype algorithms, not discuss
graphics file formats. Second, the PBM utilities have some filters
and lots of conversion utilities for converting an image to a
format other than PBM if necessary. The downside of the ASCII
depiction is the slow speed in reading ASCII and the large amount
of disk space required for the image.
<P>
Obviously, after you prototype your algorithm, you'll want to
code the reading and writing of PBM files in a compiled and optimized
language such as C.
<P>
Following is the header for the image shown in Figures 29.1, 29.2,
and 29.3:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">P3<BR>
# CREATOR: XV Version 3.10  Rev: 12/16/94<BR>
99 77<BR>
255<BR>
252 252 252 252 252 252 252 252 252 252 252 252 252 252 252<BR>
252 252 252 252 252 252 252 252 252 252 252 252 252 252 252<BR>
252 252 252 252 252 252 252 252 252 252 252 252 252 252 252<BR>
252 252 252 252 252 252 252 252 252 252 252 252 252 252 252<BR>
252 252 252 252 252 252 252 252 252 252 252 252 252 252 252<BR>
252 252 252 252 252 252 252 252 252 252 252 252 252 252 252</FONT></TT>
</BLOCKQUOTE>
<P>
<TT><FONT FACE="Courier">P3</FONT></TT> is required for this image
file. The comment line concerning <TT><FONT FACE="Courier">CREATOR</FONT></TT>
is optional, but you will have to compensate for its existence.
<TT><FONT FACE="Courier">99</FONT></TT> refers to the number of
columns in the image, <TT><FONT FACE="Courier">77</FONT></TT>
refers to the number of rows of pixels, and <TT><FONT FACE="Courier">255</FONT></TT>
refers to the highest color.
<P>
What follows next is the red/green/blue (RGB) content of each
pixel in the image. All images used in this chapter have 256 gray
levels, so the RGB values are all equal. There must be 99<FONT FACE="Symbol">&#165;</FONT>77<FONT FACE="Symbol">&#165;</FONT>3
distinct RGB values.
<P>
The code for reading these pixel RGB values knows when to start
a new row by reading the number of values per row and then incrementing
the row when it reaches the columns per row. Thus, the program
reads in three values at a time and then assigns each value to
an <TT><FONT FACE="Courier">$$image</FONT></TT> array. Here's
the fragment of code to do this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">while ($a = &lt;TEXT&gt;) {<BR>
chop $a;<BR>
@words = split(' ',$a);<BR>
$count = $#words;<BR>
<BR>
while (@words) {<BR>
&nbsp;&nbsp;&nbsp;($r,$g,$b) = splice(@words,0,3);<BR>
&nbsp;&nbsp;&nbsp;$$image[$row][$col] = ($r+$g+$b)/3;<BR>
&nbsp;&nbsp;&nbsp;$col++;<BR>
&nbsp;&nbsp;&nbsp;if ($col &gt;= $cols) { $row++; $col = 0 }<BR>
&nbsp;&nbsp;&nbsp;}<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The RGB values in this example are all equal, but this cannot
be guaranteed because you may be working with a color image. You
take the average of the RGB intensities to determine the average
intensity of a pixel by using the following line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">$$image[$row][$col] = ($r+$g+$b)/3;</FONT></TT>
</BLOCKQUOTE>
<P>
instead of assuming grayscale images only and then using only
one value. I do take the liberty of allocating room (by default)
to 97<FONT FACE="Symbol">&#165;</FONT>88 because grayscale images
are used instead of color maps to get the average intensity of
a pixel.
<P>
The processing algorithm requires the dimensions of the file and
the data. These values are returned in the following line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">return ($cols,$rows,@image);</FONT></TT>
</BLOCKQUOTE>
<H3><A NAME="GettingaHistogram"><B>Getting a Histogram</B></A>
</H3>
<P>
After the image has been read from disk into memory, you can run
some programs on it. The histogram routine to run on the image
is as follows:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">sub getHistogram {<BR>
my ($rows,$cols,$img) = @_;<BR>
my @image = @$img;<BR>
my @refered = ();<BR>
my $hst = \@refered;<BR>
<BR>
my $i,$j,$k;<BR>
<BR>
for($i=0;$i&lt;$rows;$i++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for($j=0;$j&lt;$cols;$j++) {<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$k
= $$image[$i][$j];<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$$hst[$k]
+= 1;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
return (@refered);<BR>
}</FONT></TT>
</BLOCKQUOTE>
<P>
The reference to the <TT><FONT FACE="Courier">@hst</FONT></TT>
array in the <TT><FONT FACE="Courier">getHistogram</FONT></TT>
subroutine is called to store the accumulated values per pixel
in the image.
<H2><A NAME="TheFilter"><B><FONT SIZE=5 COLOR=#FF0000>The Filter</FONT></B></A>
</H2>
<P>
A simple 3<FONT FACE="Symbol">&#165;</FONT>3 matrix convolution
filter is used in this section. Two filters are shown in Listing
29.5. The first filter is a uniform gain filter, and the second
is for using a type of Gaussian filter. You can modify this code
to use your own filter.
<P>
The filter is applied with a call to <TT><FONT FACE="Courier">applyFilter3</FONT></TT>.
In line 159, we pick up the <TT><FONT FACE="Courier">$convolve</FONT></TT>
filter and the pointer to the <TT><FONT FACE="Courier">$img</FONT></TT>.
The <TT><FONT FACE="Courier">convolve</FONT></TT> filter is passed
to an array with nine elements: The first three elements are in
the row above the pixel, followed by three more at the center
of row, and then three immediately below the current row. The
filter is shown at line 42 as this:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">@convolve = ( 0.1, 0.1, 0.1,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;0.1, 0.1, 0.1,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;0.1, 0.1, 0.1);<BR>
The second filter is shown at line 49 as this:<BR>
@convolve = ( 0.1, 0.0, 0.1,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0, 0.5, 0.0,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.1, 0.0, 0.1);</FONT></TT>
</BLOCKQUOTE>
<P>
The following lines are where the filter is applied and the results
are written to disk:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">print &quot;\n Filter 2 applied&quot;;
<BR>
&amp;applyFilter3($wd,$ht,\@convolve,\@image);<BR>
dumpImage (&quot;filt1.ppm&quot;);</FONT></TT>
</BLOCKQUOTE>
<P>
The output of these filters is shown in Figures 29.2 and 29.3.
The way the convolution matrix is applied to the image is shown
in lines 168 to 179 in Listing 29.5.
<P>
<A HREF="f29-2.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/f29-2.gif" ><B>Figure 29.2 : </B><I>The filtered image using the first filter.</I></A>
<P>
<A HREF="f29-3.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/f29-3.gif" ><B>Figure 29.3 : </B><I>The filtered image using the second filter.</I></A>
<P>
Note that a band is left around the image so as not to overrun
the extents of the image array. When prototyping for eventual
use in a formal language, keep the restrictions of the formal
language in mind.
<P>
Finally, the image is written to disk with the <TT><FONT FACE="Courier">dumpImage</FONT></TT>
subroutine (shown in line 63). The calls to dump the image are
shown in lines 43 and 55.
<H2><A NAME="AnAddedTouch"><B><FONT SIZE=5 COLOR=#FF0000>An Added
Touch</FONT></B></A></H2>
<P>
To see the histograms in three dimensions, you can use the <TT><FONT FACE="Courier">VRML.pm</FONT></TT>
module developed earlier in this book to generate a display. By
applying different filters and then generating 3D histograms of
the resulting image, you can get a pictorial view of how each
filter affects the output. The following lines of code are for
a subroutine, <TT><FONT FACE="Courier">show3Dhistogram</FONT></TT>,
to create VRML cubes from the histogram array. Add this subroutine
to the end of the file shown in Listing 29.5:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 use VRML;<BR>
&nbsp;2 use VRML::Cube;<BR>
&nbsp;3 use VRML::Cylinder;<BR>
&nbsp;4<BR>
&nbsp;5 sub show3Dhistogram {<BR>
&nbsp;6 open (VRMLFILE,&quot;&gt;vrml1.wrl&quot;) || die &quot;\n
Cannot open $!\n&quot;;<BR>
&nbsp;7 $oldfile = select VRMLFILE;<BR>
&nbsp;8 my $header = VRML::new();<BR>
&nbsp;9 $header-&gt;VRML::startHeader;<BR>
10 $header-&gt;VRML::startSeparator;<BR>
11 $width = 0.01;<BR>
12 my @cyl;<BR>
13 $hi = $#hist + 1;<BR>
14 for ($i = 0; $i &lt; $hi; $i++) {<BR>
15 $v = $hist[$i] / 100;<BR>
16&nbsp;&nbsp;&nbsp;if ($v &gt; 0) {<BR>
17&nbsp;&nbsp;&nbsp;$x = ($i * $width) % 16 ;<BR>
18&nbsp;&nbsp;&nbsp;$y = ($i * $width) / 16 ;<BR>
19&nbsp;&nbsp;&nbsp;$t = $header-&gt;VRML::putCube(<BR>
20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'width' =&gt;
$width, 'height' =&gt; $v, 'depth' =&gt; $width,<BR>
21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'translation'
=&gt; [$x,$y,0],<BR>
22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'ambientColor'
=&gt; [$v,$v,$v]<BR>
23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<BR>
24&nbsp;&nbsp;&nbsp;}<BR>
25 }<BR>
26 $header-&gt;VRML::stopSeparator;<BR>
27 close VRMLFILE;<BR>
28&nbsp;&nbsp;select $oldfile;<BR>
29 }</FONT></TT>
</BLOCKQUOTE>
<P>
Note that in line 7, we take care to store away the file handle
of the current output file when we set the default file handle
to <TT><FONT FACE="Courier">VRMLFILE</FONT></TT> with the <TT><FONT FACE="Courier">select</FONT></TT>
call. The <TT><FONT FACE="Courier">for</FONT></TT> loop in line
14 steps through the entire <TT><FONT FACE="Courier">hist</FONT></TT>
array and generates code to print a cube. Lines 19 through 23
are the statements for generating VRML code for a cube. Line 26
terminates the VRML output. The file handle is used to close the
VRML output file in line 27. After the VRML output file is closed,
we reset the default file handle (in line 28) to whatever it was
prior to the <TT><FONT FACE="Courier">select</FONT></TT> call.
<H2><A NAME="APartingNote"><B><FONT SIZE=5 COLOR=#FF0000>A Parting
Note</FONT></B></A></H2>
<P>
The number of routines in this chapter (and other chapters, for
that matter) make it hard for me to look them up by name. You
can use the following script to quickly get listings of all the
subroutine functions you want in a bunch of source code files.
See Listing 29.6.
<HR>
<BLOCKQUOTE>
<B>Listing 29.6. Printing the subroutines in source files.<BR>
</B>
</BLOCKQUOTE>
<BLOCKQUOTE>
<TT><FONT FACE="Courier">&nbsp;1 #!/usr/bin/perl<BR>
&nbsp;2 #<BR>
&nbsp;3 # Display all the subroutines in the files on the command
line<BR>
&nbsp;4 #<BR>
&nbsp;5 while (&lt;&gt;) {<BR>
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chop;<BR>
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (/^\s*sub\s+(\w+(?:[:`]+))?(\w+)/)
{<BR>
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$name = $2;<BR>
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print $ARGV, &quot;:Line
$.&nbsp;&nbsp;:&quot;, &quot;$name\n&quot;;<BR>
10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close(ARGV) if eof();&nbsp;&nbsp;&nbsp;&nbsp;#
reset line numbers<BR>
11&nbsp;&nbsp;&nbsp;&nbsp;}<BR>
12&nbsp;}</FONT></TT>
</BLOCKQUOTE>
<HR>
<P>
The key line to look at is the search pattern defined in line
7:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">/^\s*sub\s+(\w+(?:[:`]+))?(\w+)/</FONT></TT>
</BLOCKQUOTE>
<P>
Basically, the first part <TT><FONT FACE="Courier">\s*sub\s*</FONT></TT>
looks for all whitespaces (tabs and spaces) before and after the
string sub. Then it looks for an <TT><FONT FACE="Courier">(</FONT></TT>
open parenthesis, followed by a word as specified by <TT><FONT FACE="Courier">\w</FONT></TT>.
If the word that matches the <TT><FONT FACE="Courier">\w</FONT></TT>
is followed by <TT><FONT FACE="Courier">::</FONT></TT> or a single
quote <TT><FONT FACE="Courier">`</FONT></TT>, then it's considered
a class specification and accepted as such since the second question
mark <TT><FONT FACE="Courier">?</FONT></TT> allows for more than
one occurrence of such words. Note that we did not look for an
open curly brace for the subroutine code on the same line as the
subroutine declaration since the open curly brace may be on the
next line following the subroutine declaration.
<P>
The program shown in Listing 29.6 is not foolproof because it
looks for a very specific pattern in defining subroutines. However,
it will catch most subroutine definitions. The output from this
script gives you a listing of all subroutines declared in a file.
It even attempts to print subroutines in <TT><FONT FACE="Courier">*.pm</FONT></TT>
files. Actually, this script can write out a tags file by replacing
the <TT><FONT FACE="Courier">print</FONT></TT> line with the following
line:
<BLOCKQUOTE>
<TT><FONT FACE="Courier">print &quot;$name\t$ARGV\t\/^$_\/\n&quot;</FONT></TT>
</BLOCKQUOTE>
<P>
Hope this will help you keep your functions in order! ;-)
<H2><A NAME="Summary"><B><FONT SIZE=5 COLOR=#FF0000>Summary</FONT></B></A>
</H2>
<P>
This chapter is designed to show you how to use the techniques
you learned in the previous chapters of this book by developing
prototyping algorithms using Perl. The built-in mathematical and
array functions of Perl can be assets when used for developing
algorithms. In this chapter we worked on a filtering algorithm
for an image, as well as reading and archiving to disk. You even
can use previously developed modules and available tools to see
how your prototypes work.
<P>
<HR WIDTH="100%"></P>

<CENTER><P><A HREF="ch28.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch28.htm"><IMG SRC="pc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/pc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="#CONTENTS"><IMG SRC="cc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/cc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="index.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/index.htm"><IMG SRC="hb.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/hb.gif" BORDER=0 HEIGHT=88 WIDTH=140></A><A HREF="ch30.htm" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/ch30.htm"><IMG 
SRC="nc.gif" tppabs="http://www.mcp.com/818726400/0-672/0-672-30891-6/nc.gif" BORDER=0 HEIGHT=88 WIDTH=140></A></P></CENTER>

<P>
<HR WIDTH="100%"></P>

</BODY>
</HTML>
